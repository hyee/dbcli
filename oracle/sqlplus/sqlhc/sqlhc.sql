SPO sqlhc.log
SET DEF ^
SET TERM OFF ECHO ON AUTOP OFF VER OFF SERVEROUT ON SIZE 1000000 LONG 2000000 LONGC 2000;
REM
--REM $Header: 1366133.1 sqlhc.sql 12.1.08 2014/04/18 carlos.sierra mauro.pagano $
REM PSR: $Header: 1366133.1 sqlhc.sql 12.1.09.PSRv10.20 2021/05/27 pushkar.upakare $
REM
REM Copyright (c) 2000-2013, Oracle Corporation. All rights reserved.
REM
REM AUTHOR
REM   carlos.sierra@oracle.com
REM   mauro.pagano@oracle.com
REM
REM SCRIPT
REM   sqlhc.sql SQL Health-Check (extract mode)
REM
REM DESCRIPTION
REM   Produces an HTML report with a list of observations based on
REM   health-checks performed in and around a SQL statement that
REM   may be performing poorly.
REM
REM   Inputs a memory-resident SQL_ID.
REM
REM   In addition to the health_check report, it generates some
REM   additional diagnostics files regarding SQL performance.
REM
REM   This script does not install any objects in the database.
REM   It does not perform any DDL commands.
REM   It only performs DML commands against the PLAN_TABLE then it
REM   rolls back those temporary inserts.
REM   It can be used in Dataguard or any read-only database.
REM
REM PRE-REQUISITES
REM   1. Execute as SYS or user with DBA role or user with access
REM      to data dictionary views.
REM   2. The SQL for which this script is executed must be
REM      memory-resident.
REM
REM PARAMETERS
REM   1. Oracle Pack license (Tuning or Diagnostics or None) T|D|N
REM   2. SQL_ID of interest.
REM
REM EXECUTION
REM   1. Start SQL*Plus connecting as SYS or user with DBA role or
REM      user with access to data dictionary views.
REM   2. Execute script sqlhc.sql passing values for parameters.
REM
REM EXAMPLE
REM   # sqlplus / as sysdba
REM   SQL> START [path]sqlhc.sql [T|D|N|L] [SQL_ID]
REM   SQL> START sqlhc.sql T 51x6yr9ym5hdc
REM
REM NOTES
REM   1. For possible errors see sqlhc.log.
REM   2. If site has both Tuning and Diagnostics licenses then
REM      specified T (Oracle Tuning pack includes Oracle Diagnostics)
REM   3. On a read-only instance, the "Observations" section with the
REM      results of the health-checks will be missing.
REM
REM uday enabled shared cursors
REM
DEF health_checks = 'Y';
DEF shared_cursor = 'Y';
DEF sql_monitor_reports = '12';
REM
DEF script = 'sqlhc';
DEF method = 'SQLHC';
DEF mos_doc = '1366133.1';
DEF doc_ver = '12.1.08.PSRv10.20';
DEF doc_date = '2021/05/26';
-- sqldx_output: HTML/CSV/BOTH/NONE
-- uday disabled sqldx
DEF sqldx_output = 'NONE';

/**************************************************************************************************/

EXEC DBMS_APPLICATION_INFO.SET_MODULE(module_name => '^^method. ^^doc_ver.', action_name => '^^script..sql');
EXEC DBMS_APPLICATION_INFO.SET_CLIENT_INFO(client_info => '^^method.');
VAR health_checks CHAR(1);
EXEC :health_checks := '^^health_checks.';
VAR shared_cursor CHAR(1);
EXEC :shared_cursor := '^^shared_cursor.';
SET TERM ON ECHO OFF;
PRO
PRO Parameter 1:
PRO Oracle Pack License (Tuning, Diagnostics or None) [T|D|N] (required)
PRO
DEF input_license = '^1';
DEF days = '15';
PRO
SET TERM OFF;
COL license NEW_V license FOR A1;

SELECT UPPER(SUBSTR(TRIM('^^input_license.'), 1, 1)) license FROM DUAL;

VAR license CHAR(1);
EXEC :license := '^^license.';

VAR L_SQLHC_MIN NUMBER;
COL unique_id NEW_V unique_id FOR A15;
col sqlhcstart NEW_V sqlhcstart
SELECT TO_CHAR(SYSDATE, 'YYYYMMDD_HH24MISS') unique_id, to_char(systimestamp, 'DD-Mon-RR HH24:MI:SS.FF') sqlhcstart FROM DUAL;
-- SELECT TO_CHAR(SYSDATE, 'YYYYMMDD_HH24MISS') unique_id FROM DUAL;

SET TERM ON LIN 100 TRIMS ON FEED OFF;
var Fusion_PDB     varchar2(128);
var is_multitenant varchar2(4);
var con_id         number;
var con_name       varchar2(128);
var pdb_name       varchar2(128);

declare
  dbname       varchar(25);
  inst_number  number;
  inst_name    varchar(25);
  cdbid        number;
begin
  -- get the current db/instance information
  select d.con_dbid, d.name, sys_context('USERENV', 'CON_ID'), sys_context('USERENV', 'CON_NAME'), upper(d.CDB)
        ,i.instance_number, i.instance_name
  into   cdbid, dbname, :con_id, :con_name, :is_multitenant, inst_number, inst_name
  from   v$database d,
         v$instance i;
    -- display the info
    dbms_output.put_line('~~~~~~~~~~~~~~~~');
    dbms_output.put_line('Current Instance');
    dbms_output.put_line('~~~~~~~~~~~~~~~~');
    dbms_output.put_line(rpad('DB Id', 15) ||' '||rpad('DB Name', 15) ||' '||
                         rpad('Inst Num', 15) ||' '|| rpad('Instance', 15) ||' '||
                         --rpad('MultiTenant',11)||' '|| 
                         rpad('Container Id', 15) ||' '||
                         rpad('Container Name', 15));
    dbms_output.put_line(rpad('-',15,'-') ||' '|| rpad('-',15,'-') ||' '|| 
                         rpad('-',15,'-') ||' '|| rpad('-',15,'-') ||' '||
                         --rpad('-',11,'-') ||' '||
                         rpad('-',15,'-') ||' '|| rpad('-',15,'-'));
    dbms_output.put_line(rpad(cdbid, 15) ||' '|| 
                         rpad(dbname, 15) || ' ' || 
                         rpad(inst_number,15) ||' '||
                         rpad(inst_name, 15) ||' '|| 
                         --rpad(:is_multitenant, 11) ||' '||
                         rpad(:con_id,15) ||' '|| rpad(:con_name,15));
    dbms_output.put_line(chr(10));
    if :is_multitenant <> 'YES' then
      :Fusion_PDB := :con_name;
    end if;
end;
/

begin   
  -- show PDB info (highlight supposedly FUSION FA PDB)
  --if :is_multitenant = 'YES' and :con_id <> 0 then
  if :is_multitenant = 'YES' then
    -- you are in CDB
    dbms_output.put_line('~~~~~~~~~~~~~~~~');    
    dbms_output.put_line('*Available PDBs*');
    dbms_output.put_line('~~~~~~~~~~~~~~~~');        
    dbms_output.put_line(rpad('PDB NAME', 15)||' '||rpad('FA PDB?', 35));
    dbms_output.put_line(rpad('-',15,'-')||' '||rpad('-',35,'-'));
    -- get the PDBs
    for pdb_rec in (select PDB_NAME from dba_pdbs order by 1)
    loop
      if regexp_count(pdb_rec.PDB_NAME,'_F$',1,'i') > 0 then
      --if regexp_count(pdb_rec.PDB_NAME,'1$',1,'i') > 0 then
        dbms_output.put_line(rpad(pdb_rec.PDB_NAME, 15)||' ' ||rpad('YES [** per the naming convention]', 35));
        :Fusion_PDB := pdb_rec.PDB_NAME;    
        exit;    
      else
        dbms_output.put_line(rpad(pdb_rec.PDB_NAME, 15)||' ' ||rpad('NO', 35));
        :Fusion_PDB := pdb_rec.PDB_NAME;    
      end if;           
    end loop;
    dbms_output.put_line(rpad('-',15,'-')||' '||rpad('-',35,'-'));    
  else
    :Fusion_PDB := :con_name;
  end if;
end;
/
 
pro
set term off
column Fusion_PDB new_value Fusion_PDB noprint;
select :Fusion_PDB Fusion_PDB from dual;

spool ask_container.sql
begin
  if :is_multitenant = 'YES' and :con_id = 1 then
    dbms_output.put_line('pro Please input the container in which you wish to run SQLHC');
    dbms_output.put_line('pro Press enter if you want container to be "^^Fusion_PDB."');
    dbms_output.put_line('Accept pdb_name char default ''^^Fusion_PDB.'' prompt ''Enter Container Name: ''');
    dbms_output.put_line('pro');
  else
    dbms_output.put_line('def pdb_name=''^^Fusion_PDB.''');
  end if;
end;
/
SPO sqlhc.log APP;
set term on
@ask_container.sql

set term off  
spool ask_container1.sql
begin
  if :is_multitenant = 'YES' and :con_id = 1 then
    dbms_output.put_line('exec :pdb_name:=''^^pdb_name.''');
  end if;
end;
/
SPO sqlhc.log APP;
@ask_container1.sql

set term on
begin
  if upper(:pdb_name)='CDB$ROOT' then
    dbms_output.put_line('>>>>>>>>>>>>>> IMPORTANT <<<<<<<<<<<<<<<');
    dbms_output.put_line('YOU ARE CREATING SQL PATCH IN A CDB$ROOT');
    dbms_output.put_line('>>>>>>>>>>>>>>>>>>>><<<<<<<<<<<<<<<<<<<<');
    --RAISE PROGRAM_ERROR;
  end if;
  
  if :is_multitenant = 'YES' and :con_id = 1 then
    execute immediate 'alter session set container='||:pdb_name;
    dbms_output.put_line('>>>>>>>>>> YOU ARE CONNECTED TO A CDB: Setting container to an entered value => '||:pdb_name||' <<<<<<<<<<');
    -- this dbms output will NOT be shown if the switching to PDB (bug 30484412 logged against RDBMS)
  else
    --dbms_output.put_line('>>>>>>>>>> Setting container to an entered value => '||:Fusion_PDB.||' <<<<<<<<<<');
    NULL;
  end if;
exception
  when program_error then
    --dbms_output.put_line('You can''t run SQLHC in '||:pdb_name);
    RAISE_APPLICATION_ERROR(-20100, 'You can''t create SQLHC from '||:pdb_name);
  when others then
    --dbms_output.put_line(SQLERRM||chr(10)||'>>>>>>>>>> Can''t continue with the container=>'||:pdb_name||' <<<<<<<<<<');
    RAISE_APPLICATION_ERROR(-20101, SQLERRM||chr(10)||'>>>>>>>>>> Can''t continue with the container=>'||:pdb_name||' <<<<<<<<<<');
end;
/

select sys_context('USERENV', 'CON_NAME') Fusion_PDB from dual;
pro Proceeding with "^^Fusion_PDB."

SET SERVEROUT ON SIZE 1000000
WHENEVER SQLERROR EXIT SQL.SQLCODE;

BEGIN
  IF '^^license.' IS NULL OR '^^license.' NOT IN ('T', 'D', 'N', 'L') THEN
    RAISE_APPLICATION_ERROR(-20100, 'Oracle Pack License (Tuning, Diagnostics, None, Lite) must be specified as "T" or "D" or "N" or "L".');
  END IF;

  --IF regexp_count(USER,'FUSION_READ_ONLY',1,'i')>0 then
  --  return;
  --END IF;
  
  IF regexp_count(USER,'(SYS|DBSNMP)',1,'i')=0 then 
    RAISE_APPLICATION_ERROR(-20100, 'Connected as '||USER||CHR(10)||'********** Connect as SYS or SYSTEM to retry, preferrably from a DB host, as recommended!');
  END IF;
END;
/

set term off FEED on;
VAR request_retval NUMBER;
VAR lockhandle     VARCHAR2(128)
DECLARE 
  l_str varchar2(200);
BEGIN
  begin
    /* Pushkar - Request a lock so that other SQLHCs cannot run */  
    l_str := q'[begin dbms_lock.allocate_unique(lockname => 'IS_SQLHC_RUNNING', lockhandle => :1, expiration_secs => 100); end;]';
    execute immediate l_str using OUT :lockhandle;
    
    l_str := q'[begin :1 := dbms_lock.request (lockhandle => :2, timeout => 0); end;]';
    execute immediate l_str using OUT :request_retval, IN :lockhandle;
  exception 
    when others then dbms_output.put_line(SQLERRM); 
     -- dbms lock privs?    
    :request_retval := -9;
  end;
END;
/

set term on
BEGIN
  IF :request_retval in (0,4,-9) THEN
     -- got lock. Move forward.
     NULL;
  ELSE
     --NULL;
     RAISE_APPLICATION_ERROR(-20100, 'Another SQLHC is being run!'||CHR(10)|| '********** Try running after some time [lockhandle=>'||:lockhandle||')]!!');
  END IF;	 
END;
/

set term off
WHENEVER SQLERROR CONTINUE;

PRO
PRO Parameter 2:
PRO SQL_ID of the SQL to be analyzed (required)
PRO
DEF input_sql_id = '^2';
DEF input_parameter = '^^input_sql_id.';
PRO

PRO Values passed:
PRO License: "^^input_license."
PRO SQL_ID : "^^input_sql_id."
PRO
--SET TERM OFF;

-- get dbid
COL dbid NEW_V dbid;
SELECT dbid FROM v$database;

COL sql_id NEW_V sql_id FOR A13;

SELECT sql_id
  FROM gv$sqlarea
 WHERE sql_id = TRIM('^^input_sql_id.')
 UNION
SELECT sql_id
  FROM dba_hist_sqltext
 WHERE :license IN ('T', 'D', 'L')
   AND dbid = ^^dbid.
   AND sql_id = TRIM('^^input_sql_id.');

VAR sql_id VARCHAR2(13);
EXEC :sql_id := '^^sql_id.';

var diff varchar2(10);
col diff new_value diff for A5 noprint
var start_time varchar2(50);

SET TERM ON;
WHENEVER SQLERROR EXIT SQL.SQLCODE;

BEGIN
  IF '^^sql_id.' IS NULL THEN
    IF :license IN ('T', 'D', 'L') THEN
      RAISE_APPLICATION_ERROR(-20200, 'SQL_ID "^^input_sql_id." not found in memory nor in AWR.');
    ELSE
      RAISE_APPLICATION_ERROR(-20200, 'SQL_ID "^^input_sql_id." not found in memory.');
    END IF;
  END IF;
END;
/

WHENEVER SQLERROR CONTINUE;
SET ECHO ON TIMI ON;

/**************************************************************************************************
 *
 * begin_common: from begin_common to end_common sqlhc.sql and sqlhcxec.sql are identical
 *
 **************************************************************************************************/
SELECT 'BEGIN: '||TO_CHAR(SYSDATE, 'YYYY-MM-DD/HH24:MI:SS') FROM dual;

DEF doc_link = 'https://support.oracle.com/CSP/main/article?cmd=show&type=NOT&id=';
DEF bug_link = 'https://support.oracle.com/CSP/main/article?cmd=show&type=BUG&id=';

-- tracing script in case it takes long to execute so we can diagnose it
ALTER SESSION SET MAX_DUMP_FILE_SIZE = '1G';
ALTER SESSION SET TRACEFILE_IDENTIFIER = "^^script._^^unique_id.";
--ALTER SESSION SET STATISTICS_LEVEL = 'ALL';
-- ALTER SESSION SET EVENTS '10046 TRACE NAME CONTEXT FOREVER, LEVEL 12';

-- adding to prevent slow access to ASH with non default NLS settings
ALTER SESSION SET NLS_SORT = 'BINARY';
ALTER SESSION SET NLS_COMP = 'BINARY';

Prompt ---;
Prompt ignore below error if DB version is 11g
Prompt ---;
alter session set "_optimizer_adaptive_plans"=false;

/**************************************************************************************************/

col instances new_value instances
select count(*) instances from gv$instance;

col instance_number new_value current_instance  
select instance_number from v$instance;

-- check for LITE mode, and # of instances if NOT a LITE mode
begin
  if upper(:license)='L' then
    -- LITE mode 
    dbms_output.put_line('!!!!!!!!!!!!!!!!!!        Executing the LITE version of SQLHC        !!!!!!!!!!!!!!!!!!');
  else
    if ^^instances. > 2 then
      -- switching to LITE mode
      dbms_output.put_line('As # of Instances '|| ^^instances. ||' > 2 ...');
      dbms_output.put_line('!!!!!!!!!!!!!!!!!!        Switching to LITE mode        !!!!!!!!!!!!!!!!!!');
      :license := 'L';
    end if;
   end if;
end;
/

SELECT :license license FROM DUAL;

/* -----------------------------------
 *
 * Pushkar: PII related info below
 * Add new tables in pii_tables (change the size of the variable if required)
 * ** don't capture min/max values, histogram values, binds
 * ----------------------------------- */
var pii_tables varchar2(2000)
var pii_used number
exec :pii_tables := 'per_addresses_f,per_addresses_f_,per_drivers_licenses,per_drivers_licenses_,per_email_addresses,per_email_addresses_,per_national_identifiers,per_national_identifiers_,per_passports,per_passports_,per_phones,per_phones_,per_visas_permits_f,per_visas_permits_f_';

def pii_1 = 'per_addresses_f_,per_drivers_licenses_,per_email_addresses_,per_national_identifiers_,per_passports_,per_phones_,per_visas_permits_f_';

PRO Continuing execution with changed license="^^license." from input being "^^input_license."

/* -------------------------
 *
 * get sql_text
 *
 * ------------------------- */

VAR sql_text CLOB;
EXEC :sql_text := NULL;

-- get sql_text from memory
DECLARE
  l_sql_text VARCHAR2(32767);
BEGIN -- 10g see bug 5017909
  DBMS_OUTPUT.PUT_LINE('getting sql_text from memory');
  FOR i IN (SELECT DISTINCT piece, sql_text
              FROM gv$sqltext_with_newlines
             WHERE sql_id = '^^sql_id.'
             ORDER BY 1, 2)
  LOOP
    IF :sql_text IS NULL THEN
      DBMS_LOB.CREATETEMPORARY(:sql_text, TRUE);
      DBMS_LOB.OPEN(:sql_text, DBMS_LOB.LOB_READWRITE);
    END IF;
    l_sql_text := REPLACE(i.sql_text, CHR(00), ' ');
    l_sql_text := regexp_replace(i.sql_text, '<([a-z0-9]+?)','< \1',1,0,'i');
    DBMS_LOB.WRITEAPPEND(:sql_text, LENGTH(l_sql_text), l_sql_text);
  END LOOP;
  IF :sql_text IS NOT NULL THEN
    DBMS_LOB.CLOSE(:sql_text);
  END IF;
EXCEPTION
  WHEN OTHERS THEN
    DBMS_OUTPUT.PUT_LINE('getting sql_text from memory: '||SQLERRM);
    :sql_text := NULL;
END;
/

-- get sql_text from awr
BEGIN
  IF :license IN ('T', 'D', 'L') AND (:sql_text IS NULL OR NVL(DBMS_LOB.GETLENGTH(:sql_text), 0) = 0) THEN
    DBMS_OUTPUT.PUT_LINE('getting sql_text from awr');
    SELECT regexp_replace(REPLACE(sql_text, CHR(00), ' '), '<([a-z0-9]+?)','< \1',1,0,'i')
      INTO :sql_text
      FROM dba_hist_sqltext
     WHERE :license IN ('T', 'D', 'L')
       AND dbid = ^^dbid.
       AND sql_id = '^^sql_id.'
       AND sql_text IS NOT NULL
       AND ROWNUM = 1;
  END IF;
EXCEPTION
  WHEN OTHERS THEN
    DBMS_OUTPUT.PUT_LINE('getting sql_text from awr: '||SQLERRM);
    :sql_text := NULL;
END;
/

set pagesize 1000
col :sql_text format A150 wor
SELECT :sql_text FROM DUAL;

/* -------------------------
 *
 * get several values
 *
 * ------------------------- */
--PSRv10 start

COL release_name NEW_V fa_release FOR A20;
var fa_release varchar2(50)
exec :fa_release := 'n/a';
declare
 l_fa varchar2(1);
begin
  SELECT 'Y' 
    INTO l_fa
    FROM dba_tab_columns
   WHERE table_name = 'AD_PRODUCT_GROUPS'
     AND column_name = 'RELEASE_NAME'
     AND data_type = 'VARCHAR2'
     AND owner = 'FUSION'
  ;

  IF l_fa = 'Y' THEN
    execute immediate 'select release_name from fusion.AD_PRODUCT_GROUPS' into :fa_release;
  END IF;
exception when others then
  :fa_release := 'n/a';
end;
/
select :fa_release fa_release from dual;

col service new_value service_name
col source new_value sql_source

  select service, 
         case when program_id <> 0 then 
                 (select owner||'.'||object_name||'  Line#: '|| program_line# from dba_objects o where o.object_id = s.program_id)
              else ''
         end source
    from gv$sql s
   where sql_id = :sql_id
     and rownum = 1
;

col service new_value service_name
col ash_plsql_entry new_value ash_plsql_entry
col ash_plsql_object new_value ash_plsql_object
col source_batch_ui new_value source_batch_ui

select case when '^^service_name' is null then 
                (select name from v$services s where s.name_hash = ash.service_hash) 
            else '^^service_name'
       end service,
       case when plsql_entry_object_id is not null then
           (select object_name||'.'||procedure_name from dba_procedures where object_id = plsql_entry_object_id 
               and SUBPROGRAM_ID = plsql_entry_subprogram_id and rownum=1) 
            else ''
       end ash_plsql_entry,
       case when plsql_entry_object_id is not null then 
             (select object_name||'.'||procedure_name from dba_procedures where object_id = plsql_object_id 
                 and SUBPROGRAM_ID = plsql_subprogram_id and rownum=1) 
            else ''
       end ash_plsql_object,
       (select distinct case when consumer_group = 'FUSIONAPPS_ONLINE_GROUP' then 'UI'
                    when consumer_group = 'FUSIONAPPS_BATCH_GROUP'  then 'Batch'
                    when consumer_group = 'FUSIONAPPS_DIAG_GROUP'   then 'Diag (RO/ERO)'
                    else consumer_group 
               end
          from DBA_RSRC_CONSUMER_GROUPS cg
         where cg.consumer_group_id = ash.consumer_group_id) source_batch_ui
  from gv$ACTIVE_SESSION_HISTORY ash
 where sql_id = :sql_id
   and rownum = 1
;

col service new_value service_name
col ash_plsql_entry new_value ash_plsql_entry
col ash_plsql_object new_value ash_plsql_object
col source_batch_ui new_value source_batch_ui

select case when '^^service_name' is null then 
                (select name from v$services s where s.name_hash = ash.service_hash) 
            else '^^service_name'
       end service,
       case when '^^ash_plsql_entry' is not null then
               '^^ash_plsql_entry'
            when '^^ash_plsql_entry' is null and plsql_entry_object_id is not null then 
               (select owner||'.'||object_name||'.'||procedure_name from dba_procedures where object_id = plsql_entry_object_id 
                   and SUBPROGRAM_ID = plsql_entry_subprogram_id and rownum=1) 
            else ''
       end ash_plsql_entry,
       case when '^^ash_plsql_object' is not null then
               '^^ash_plsql_object'
            when '^^ash_plsql_object' is null and plsql_entry_object_id is not null then 
               (select owner||'.'||object_name||'.'||procedure_name from dba_procedures where object_id = plsql_object_id 
                   and SUBPROGRAM_ID = plsql_subprogram_id and rownum=1) 
            else ''
       end ash_plsql_object,
       (select distinct case when consumer_group = 'FUSIONAPPS_ONLINE_GROUP' then 'UI'
                    when consumer_group = 'FUSIONAPPS_BATCH_GROUP'  then 'Batch'
                    when consumer_group = 'FUSIONAPPS_DIAG_GROUP'   then 'Diag (RO/ERO)'
                    else consumer_group 
               end
          from DBA_RSRC_CONSUMER_GROUPS cg
         where cg.consumer_group_id = ash.consumer_group_id) source_batch_ui
from dba_hist_active_sess_history ash, dba_hist_snapshot ss
 where 1=1
   and ss.dbid = (select dbid from v$database)
   and (:license IN ('T', 'D') or (:license = 'L' and ss.begin_interval_time > systimestamp - interval '^^days.' day))
   and ash.dbid = ss.dbid
   and ash.snap_id = ss.snap_id
   and ash.instance_number = ss.instance_number
   and sql_id = :sql_id
   and '^^service_name' is null
   and rownum = 1
;

--col pod_size new_value pod_size

--select regexp_substr(l.dimension_parameter, '[^:]+', 1, 3) pod_size
--  from sys.v$lcm_audit l
-- where action in ('AUDIT', 'UPDATE') 
--   and status not like '%ERRORS%' 
-- order by audit_date desc fetch first 1 row only
--;

col pod_size  NEW_V pod_size  FOR A32;
var pod_size varchar2(32)
exec :pod_size := 'n/a';
begin
    execute immediate 'select regexp_substr(l.dimension_parameter, ''[^:]+'', 1, 3) pod_size
                       from sys.v$lcm_audit l
                       where action in (''AUDIT'', ''UPDATE'')
                       and status not like ''%ERRORS%''
                       order by audit_date desc fetch first 1 row only' into :pod_size;
exception when others then
  :pod_size := 'n/a';
end;
/
select :pod_size pod_size from dual;

exec dbms_output.put_line('POD size : ' || :pod_size)

-- get job_queue_processes
COL jobqp NEW_V jobqp FOR A17;
SELECT value jobqp FROM v$system_parameter2 WHERE LOWER(name) = 'job_queue_processes';

--PSRv10 Stop

-- signature (force=false)
VAR signature NUMBER;
BEGIN
  IF :license = 'T' THEN
    :signature := DBMS_SQLTUNE.SQLTEXT_TO_SIGNATURE(:sql_text, FALSE);
  ELSE
    :signature := -1;
  END IF;
END;
/
COL signature NEW_V signature FOR A20;
SELECT TO_CHAR(:signature) signature FROM DUAL;

-- signature (force=true)
VAR signaturef NUMBER;
BEGIN
  IF :license = 'T' THEN
    :signaturef := DBMS_SQLTUNE.SQLTEXT_TO_SIGNATURE(:sql_text, TRUE);
  ELSE
    :signaturef := -1;
  END IF;
END;
/
COL signaturef NEW_V signaturef FOR A20;
SELECT TO_CHAR(:signaturef) signaturef FROM DUAL;

-- get database name (up to 10, stop before first '.', no special characters)
COL database_name_short NEW_V database_name_short FOR A10;
SELECT SUBSTR(SYS_CONTEXT('USERENV', 'DB_NAME'), 1, 10) database_name_short FROM DUAL;
SELECT SUBSTR('^^database_name_short.', 1, INSTR('^^database_name_short..', '.') - 1) database_name_short FROM DUAL;
SELECT TRANSLATE('^^database_name_short.',
'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789 ''`~!@#$%^*()-_=+[]{}\|;:",.<>/?'||CHR(0)||CHR(9)||CHR(10)||CHR(13)||CHR(38),
'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789') database_name_short FROM DUAL;

-- get host name (up to 30, stop before first '.', no special characters)
COL host_name_short NEW_V host_name_short FOR A30;
SELECT SUBSTR(SYS_CONTEXT('USERENV', 'SERVER_HOST'), 1, 30) host_name_short FROM DUAL;
SELECT SUBSTR('^^host_name_short.', 1, INSTR('^^host_name_short..', '.') - 1) host_name_short FROM DUAL;
SELECT TRANSLATE('^^host_name_short.',
'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789 ''`~!@#$%^*()-_=+[]{}\|;:",.<>/?'||CHR(0)||CHR(9)||CHR(10)||CHR(13)||CHR(38),
'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789') host_name_short FROM DUAL;

-- get rdbms version
COL rdbms_version NEW_V rdbms_version FOR A17;
SELECT version rdbms_version FROM v$instance;

-- get Database Version
DECLARE 
   vdbversion number(4);
   vrdbmsversion varchar2(20);
BEGIN 

        EXECUTE IMMEDIATE 'SELECT substr(banner, instr(banner,''Database'',1,1)+9,2) from v$version FETCH FIRST 1 ROW ONLY' into vdbversion;
  	IF vdbversion > 12 THEN 
  	  EXECUTE IMMEDIATE 'SELECT substr(banner_full, instr(banner_full,''Version'',1,1)+8,12) from v$version' into vrdbmsversion ;
	ELSE
  	  SELECT substr(banner, instr(banner,'Release',1,1)+8,10) into vrdbmsversion from v$version FETCH FIRST 1 ROW ONLY;
        END IF;
	DBMS_OUTPUT.PUT_LINE('RDBMS Version: ' || vrdbmsversion  );

END; 
/



-- get platform
COL platform NEW_V platform FOR A80;
SELECT UPPER(TRIM(REPLACE(REPLACE(product, 'TNS for '), ':' ))) platform FROM product_component_version WHERE product LIKE 'TNS for%' AND ROWNUM = 1;

-- get instance
COL instance_number NEW_V instance_number FOR A10;
SELECT TO_CHAR(instance_number) instance_number FROM v$instance;

-- YYYYMMDD_HH24MISS
COL time_stamp NEW_V time_stamp FOR A15;
SELECT TO_CHAR(SYSDATE, 'YYYYMMDD_HH24MISS') time_stamp FROM DUAL;

-- YYYY-MM-DD/HH24:MI:SS
COL time_stamp2 NEW_V time_stamp2 FOR A20;
SELECT TO_CHAR(SYSDATE, 'YYYY-MM-DD/HH24:MI:SS') time_stamp2 FROM DUAL;

-- Pushkar when did the EBR upgrade happen
COL ebr_date      NEW_V ebr_date             ;
SELECT TO_CHAR(created,'YYYY-MM-DD/HH24:MI:SS') ebr_date 
FROM dba_objects 
WHERE object_name='fre_ebr_programs' and object_type='TABLE';

-- get db_block_size
COL sys_db_block_size NEW_V sys_db_block_size FOR A17;
SELECT value sys_db_block_size FROM v$system_parameter2 WHERE LOWER(name) = 'db_block_size';

-- get cpu_count
COL sys_cpu NEW_V sys_cpu FOR A17;
SELECT value sys_cpu FROM v$system_parameter2 WHERE LOWER(name) = 'cpu_count';

-- get ofe
COL sys_ofe NEW_V sys_ofe FOR A17;
SELECT value sys_ofe FROM v$system_parameter2 WHERE LOWER(name) = 'optimizer_features_enable';

-- get ds
COL sys_ds NEW_V sys_ds FOR A10;
SELECT value sys_ds FROM v$system_parameter2 WHERE LOWER(name) = 'optimizer_dynamic_sampling';

-- Exadata?
COL exadata NEW_V exadata FOR A1;
SELECT 'Y' exadata FROM v$cell_state WHERE ROWNUM = 1;

-- get user
COL sessionuser NEW_V sessionuser FOR A50;
SELECT TO_CHAR(SYS_CONTEXT('USERENV','SESSION_USER')) sessionuser FROM dual;

-- get num_cpu
COL num_cpus NEW_V num_cpus FOR A10
SELECT TO_CHAR(value) num_cpus FROM v$osstat WHERE stat_name = 'NUM_CPUS';


-- get num_cores
COL num_cores NEW_V num_cores FOR A10
SELECT TO_CHAR(value) num_cores FROM v$osstat WHERE stat_name = 'NUM_CPU_CORES';

-- get num_cpu
COL num_sockets NEW_V num_sockets FOR A10
SELECT TO_CHAR(value) num_sockets FROM v$osstat WHERE stat_name = 'NUM_CPU_SOCKETS';

/* -------------------------
 *
 * application vendor
 *
 * ------------------------- */

-- ebs
COL is_ebs NEW_V is_ebs FOR A1;
COL ebs_owner NEW_V ebs_owner FOR A30;
SELECT 'Y' is_ebs, owner ebs_owner
  FROM dba_tab_columns
 WHERE table_name = 'FND_PRODUCT_GROUPS'
   AND column_name = 'RELEASE_NAME'
   AND data_type = 'VARCHAR2'
   AND ROWNUM = 1;

-- siebel
COL is_siebel NEW_V is_siebel FOR A1;
COL siebel_owner NEW_V siebel_owner FOR A30;
SELECT 'Y' is_siebel, owner siebel_owner
  FROM dba_tab_columns
 WHERE '^^is_ebs.' IS NULL
   AND table_name = 'S_REPOSITORY'
   AND column_name = 'ROW_ID'
   AND data_type = 'VARCHAR2'
   AND ROWNUM = 1;

-- psft
COL is_psft NEW_V is_psft FOR A1;
COL psft_owner NEW_V psft_owner FOR A30;
SELECT 'Y' is_psft, owner psft_owner
  FROM dba_tab_columns
 WHERE '^^is_ebs.' IS NULL
   AND '^^is_siebel.' IS NULL
   AND table_name = 'PSSTATUS'
   AND column_name = 'TOOLSREL'
   AND data_type = 'VARCHAR2'
   AND ROWNUM = 1;

/* -------------------------
 *
 * find tables and indexes
 *
 * ------------------------- */

-- this script uses the gtt plan_table as a temporary staging place to store results of health-checks
/* Pushkar */
DELETE plan_table where STATEMENT_ID = :sql_id;
commit;

INSERT INTO plan_table(STATEMENT_ID, object_owner, object_type, object_name, cardinality, cost, optimizer, object_alias, operation, options, io_cost, bytes)
  WITH  
    object AS (
       SELECT /*+ MATERIALIZE */
              object_owner owner, object_name name, object_type
         FROM gv$sql_plan
        WHERE inst_id IN (SELECT inst_id FROM gv$instance)
          AND sql_id = :sql_id
          AND object_owner IS NOT NULL
          AND object_name IS NOT NULL
          AND not (object_type = 'TABLE (TEMP)' and object_name like 'SYS_TEMP%') --Uday.v6
        UNION
       SELECT object_owner owner, object_name name, object_type
         FROM dba_hist_sql_plan
        WHERE :license IN ('T', 'D')
          AND dbid = ^^dbid.
          AND sql_id = :sql_id
          AND object_owner IS NOT NULL
          AND object_name IS NOT NULL
          AND not (object_type = 'TABLE (TEMP)' and object_name like 'SYS_TEMP%') --Uday.v6
    )
    , plan_tables AS (
         SELECT /*+ MATERIALIZE */
                'TABLE' object_type, o.owner object_owner, o.name object_name
           FROM object o
          WHERE (o.object_type like 'TABLE%' OR o.object_type like 'MAT_VIEW%')
          UNION
         SELECT 'TABLE' object_type, i.table_owner object_owner, i.table_name object_name
           FROM dba_indexes i,
                object o
          WHERE o.object_type like 'INDEX%'  --Uday.v6
            AND i.owner = o.owner
            AND i.index_name = o.name
    )
         -- (object_owner, object type,    object_name,  cardinality, cost,         
  -- psrv9: added distinct. Some scenarios getting duplicate tables. 
  select distinct :sql_id, t.owner, pt.object_type, t.table_name, t.num_rows,  t.sample_size, 
         -- OPTIMIZER
         TO_CHAR(t.last_analyzed, 'YYYY-MM-DD/HH24:MI:SS') last_analyzed, 
         -- object_alias, operation,   options, io_cost,  bytes
         temporary,       partitioned, degree,  t.blocks, t.avg_row_len
    from plan_tables pt, dba_tables t
   where t.table_name = pt.object_name
     and t.owner = pt.object_owner
  ;

/* -------------------------
 *
 * record type enumerator
 *
 * ------------------------- */

-- constants
VAR E_GLOBAL     NUMBER;
VAR E_EBS        NUMBER;
VAR E_SIEBEL     NUMBER;
VAR E_PSFT       NUMBER;
VAR E_TABLE      NUMBER;
VAR E_INDEX      NUMBER;
VAR E_1COL_INDEX NUMBER;
VAR E_TABLE_PART NUMBER;
VAR E_INDEX_PART NUMBER;
VAR E_TABLE_COL  NUMBER;

EXEC :E_GLOBAL     := 01;
EXEC :E_EBS        := 02;
EXEC :E_SIEBEL     := 03;
EXEC :E_PSFT       := 04;
EXEC :E_TABLE      := 05;
EXEC :E_INDEX      := 06;
EXEC :E_1COL_INDEX := 07;
EXEC :E_TABLE_PART := 08;
EXEC :E_INDEX_PART := 09;
EXEC :E_TABLE_COL  := 10;

/**************************************************************************************************/
-- setup to produce reports
SET ECHO OFF FEED OFF VER OFF SHOW OFF HEA OFF LIN 2000 NEWP NONE PAGES 0 LONG 2000000 LONGC 2000 SQLC MIX TAB ON TRIMS ON TRIM ON TI OFF TIMI OFF ARRAY 100 NUMF "" SQLP SQL> SUF sql BLO . RECSEP OFF APPI OFF AUTOT OFF;

/**************************************************************************************************/

COL files_prefix NEW_V files_prefix FOR A40;
--SELECT '^^script._^^database_name_short._^^host_name_short._^^rdbms_version._^^sql_id._^^time_stamp.' files_prefix FROM DUAL
SELECT '^^script._^^time_stamp._^^sql_id._^^license.' files_prefix FROM DUAL;
COL sqldx_prefix NEW_V sqldx_prefix FOR A40;
SELECT '^^files_prefix._8_sqldx' sqldx_prefix FROM DUAL;

rem select STATEMENT_ID, object_type, object_owner, object_name from plan_table;
rem pause;

/**************************************************************************************************
 *
 * health-check report
 *
 **************************************************************************************************/

/* -------------------------
 *
 * heading
 *
 * ------------------------- */
SPO ^^files_prefix._1_health_check.html;

PRO <html>
PRO <!-- $Header: ^^mos_doc. ^^script..sql ^^doc_ver. ^^doc_date. carlos.sierra $ -->
PRO <!-- Copyright (c) 2000-2012, Oracle Corporation. All rights reserved. -->
PRO <!-- Author: carlos.sierra@oracle.com -->
PRO
PRO <head>
PRO <title>^^files_prefix._1_health_check.html</title>
PRO

PRO <style type="text/css">
PRO body {font:10pt Arial,Helvetica,Verdana,Geneva,sans-serif; color:black; background:white;}
PRO a {font-weight:bold; color:#663300;}
PRO pre {font:8pt Monaco,"Courier New",Courier,monospace;} /* for code */
PRO h1 {font-size:16pt; font-weight:bold; color:#336699;}
PRO h2 {font-size:14pt; font-weight:bold; color:#336699;}
PRO h3 {font-size:12pt; font-weight:bold; color:#336699;}
PRO li {font-size:10pt; font-weight:bold; color:#336699; padding:0.1em 0 0 0;}
PRO table {font-size:8pt; color:black; background:white;}
PRO th {font-weight:bold; background:#cccc99; color:#336699; vertical-align:bottom; padding-left:3pt; padding-right:3pt; padding-top:1pt; padding-bottom:1pt; position:sticky; top:0;}
PRO td {text-align:left; background:#fcfcf0; vertical-align:top; padding-left:3pt; padding-right:3pt; padding-top:1pt; padding-bottom:1pt;}
PRO td.c {text-align:center;} /* center */
PRO td.l {text-align:left;} /* left (default) */
PRO td.r {text-align:right;} /* right */
PRO font.n {font-size:8pt; font-style:italic; color:#336699;} /* table footnote in blue */
PRO font.f {font-size:8pt; color:#999999;} /* footnote in gray */
PRO td.red {font-weight:bold; color:#336699;}
PRO #summary1 {font-weight: bold; font-size: 16pt; color:#336699;}
PRO #summary2 {font-weight: bold; font-size: 14pt; color:#336699;}
PRO #summary3 {font-weight: bold; font-size: 12pt; color:#336699;}
PRO summary:hover {background-color: #FFFF99;}
PRO .button  {cursor: pointer;}
PRO .button1 {border-radius: 8px; background-color: #FFFF99; color: black;}
PRO .button1:hover {background-color: #4CAF50;color: white;}
PRO red {font-weight:bold; color:#ff0000;}
PRO </style>
PRO

PRO </head>
PRO <body>
PRO <h1><a target="MOS" href="^^doc_link.^^mos_doc.">^^mos_doc.</a> ^^method.
PRO ^^doc_ver. Report: ^^files_prefix._1_health_check.html</h1>
PRO

PRO <pre>
PRO License    : ^^input_license.
PRO Input      : ^^input_parameter.
PRO SIGNATURE  : ^^signature.
PRO SIGNATUREF : ^^signaturef.
PRO RDBMS      : ^^rdbms_version.
PRO Platform   : ^^platform.
PRO Database   : ^^database_name_short.
PRO DBID       : ^^dbid.
PRO Host       : ^^host_name_short.
PRO Instance   : ^^instance_number.
PRO CPU_Count  : ^^sys_cpu.
PRO Num CPUs   : ^^num_cpus.
PRO Num Cores  : ^^num_cores.
PRO Num Sockets: ^^num_sockets.
PRO Block Size : ^^sys_db_block_size.
PRO OFE        : ^^sys_ofe.
PRO DYN_SAMP   : ^^sys_ds.
PRO EBS        : "^^is_ebs."
PRO SIEBEL     : "^^is_siebel."
PRO PSFT       : "^^is_psft."
PRO Date       : ^^time_stamp2.
PRO User       : ^^sessionuser.
PRO </pre><!--Pushkar-->
PRO 
PRO <RED>... REMOVED from version 10.16 ...</RED>
PRO 
PRO </body>
PRO </html>

SPO OFF;

/**************************************************************************************************/

SPO sqlhc.log append
PRO SQL Shared Cursor related SQLs generation
SELECT '<!-- '||TO_CHAR(SYSDATE, 'YYYY-MM-DD/HH24:MI:SS')||' -->' FROM dual;
SPO OFF;
/* -------------------------
 *
 * gv$sql_shared_cursor cursor_sum
 * Uday: modified to use UNPIVOT to improve performance
 *
 * ------------------------- */
--uday SELECT (CASE WHEN ROWNUM = 1 THEN 'WITH sc AS (SELECT /*+ MATERIALIZE */ /* gv$sql_shared_cursor cursor_sum */ * FROM gv$sql_shared_cursor WHERE :shared_cursor = ''Y'' AND sql_id = ''^^sql_id.'')' ELSE 'UNION ALL' END)||CHR(10)||
--uday        'SELECT '''||v.column_name||''' reason, inst_id, COUNT(*) cursors FROM sc WHERE '||v.column_name||' = ''Y'' GROUP BY inst_id' line
--uday   FROM (
--uday SELECT /*+ NO_MERGE */
--uday        column_name
--uday   FROM dba_tab_cols
--uday  WHERE :shared_cursor = 'Y'
--uday    AND owner = 'SYS'
--uday    AND table_name = 'GV_$SQL_SHARED_CURSOR'
--uday    AND data_type = 'VARCHAR2'
--uday    AND data_length = 1
--uday  ORDER BY
--uday        column_name ) v
--
--
SPO sql_shared_cursor_sum_^^sql_id..sql;
PRO SELECT /* ^^script..sql Cursor Sharing as per Reason */
PRO        CHR(10)||'<tr>'||CHR(10)||
PRO        '<td class="r">'||ROWNUM||'</td>'||CHR(10)||
PRO        '<td>'||v2.reason||'</td>'||CHR(10)||
PRO        '<td class="c">'||v2.inst_id||'</td>'||CHR(10)||
PRO        '<td class="r">'||v2.cursors||'</td>'||CHR(10)||
PRO        '</tr>'
PRO   FROM (
select 'WITH v0 AS (' || chr(10) ||
       '   SELECT * ' || chr(10) ||
       q'[     FROM   gv$sql_shared_cursor where :shared_cursor = 'Y' AND sql_id = '^^sql_id.']' || chr(10) ||
       ')' || chr(10) ||
       ', v1 as (' || chr(10) ||
       '   SELECT inst_id, reason_type , result' || chr(10) ||
       '     FROM   v0' || chr(10) ||
       '   unpivot (result FOR reason_type IN' || chr(10) ||
       '             (' || chr(10) ||
       '               ' || 
       listagg(column_name, ', ') within group(order by column_name) || chr(10) || 
       '             )'|| chr(10) || 
       '           )'|| chr(10) || 
       q'[     where result='Y']'|| chr(10) || 
       ')'|| chr(10) || 
       'select reason_type as reason, inst_id, count(*) cursors '|| chr(10) || 
       '  from v1'|| chr(10) || 
       ' group by inst_id, reason_type'|| chr(10) || 
       ' order by inst_id, reason_type) v2;'       
  from dba_tab_columns 
 where owner = 'SYS'
   AND table_name = 'GV_$SQL_SHARED_CURSOR'
   AND data_type = 'VARCHAR2'
   AND data_length = 1
 group by table_name
;


SELECT 'SELECT ''reason'' reason, 0 inst_id, 0 cursors FROM DUAL WHERE 1 = 0' FROM dual WHERE :shared_cursor <> 'Y';
-- PRO ORDER BY reason, inst_id ) v2;;
SPO OFF;

SPO sqlhc.log append
PRO SQL Shared Cursor related SQLs generation: sql_shared_cursor_sum*.sql created
SELECT '<!-- '||TO_CHAR(SYSDATE, 'YYYY-MM-DD/HH24:MI:SS')||' -->' FROM dual;
SPO OFF;
/* -------------------------
 *
 * gv$sql_shared_cursor cursor_col
 *
 * ------------------------- */
SPO sql_shared_cursor_col_^^sql_id..sql
select 'WITH v1 AS (' || chr(10) ||
       '   SELECT * ' || chr(10) ||
       q'[     FROM   gv$sql_shared_cursor where :shared_cursor = 'Y' AND sql_id = '^^sql_id.']' || chr(10) ||
       ')' || chr(10) ||
       ', v2 as (' || chr(10) ||
       '   SELECT inst_id, reason_type , result' || chr(10) ||
       '     FROM   v1' || chr(10) ||
       '   unpivot (result FOR reason_type IN' || chr(10) ||
       '             (' || chr(10) ||
       '               ' ||
       listagg(column_name, ', ') within group(order by column_name) || chr(10) ||
       '             )'|| chr(10) ||
       '           )'|| chr(10) ||
       q'[     where result='Y']'|| chr(10) ||
       ')'|| chr(10) ||
       q'[select distinct ', RPAD(' || reason_type || ', 30) "' || reason_type || '"' COLUMN_NAME]' || chr(10) ||
       '  from v2'
  from dba_tab_columns
 where owner = 'SYS'
   AND table_name = 'GV_$SQL_SHARED_CURSOR'
   AND data_type = 'VARCHAR2'
   AND data_length = 1
 group by table_name
;

--uday SELECT (CASE WHEN ROWNUM = 1 THEN 'WITH sc AS (SELECT /*+ MATERIALIZE */ /* gv$sql_shared_cursor cursor_col */ * FROM gv$sql_shared_cursor WHERE :shared_cursor = ''Y'' AND sql_id = ''^^sql_id.'')' ELSE 'UNION ALL' END)||CHR(10)||
--uday        'SELECT '', RPAD('||LOWER(v.column_name)||', 30) "'||v.column_name||'"'' column_name FROM sc WHERE '||v.column_name||' = ''Y'' AND ROWNUM = 1' line
--uday   FROM (
--uday SELECT /*+ NO_MERGE */
--uday        column_name
--uday   FROM dba_tab_cols
--uday  WHERE :shared_cursor = 'Y'
--uday    AND owner = 'SYS'
--uday    AND table_name = 'GV_$SQL_SHARED_CURSOR'
--uday    AND data_type = 'VARCHAR2'
--uday    AND data_length = 1
--uday  ORDER BY
--uday        column_name ) v
SELECT 'SELECT * FROM DUAL WHERE 1 = 0' FROM dual WHERE :shared_cursor <> 'Y';
PRO ;;
SPO OFF;

SPO sqlhc.log append
PRO SQL Shared Cursor related SQLs generation: sql_shared_cursor_col*.sql created
SELECT '<!-- '||TO_CHAR(SYSDATE, 'YYYY-MM-DD/HH24:MI:SS')||' -->' FROM dual;
SPO OFF;
/* -------------------------
 *
 * gv$sql_shared_cursor cursor_cur
 *
 * ------------------------- */
SPO sql_shared_cursor_cur_^^sql_id..sql
PRO SELECT /* ^^script..sql Cursor Sharing List */
PRO ROWNUM "#", v.* FROM (
PRO SELECT /*+ NO_MERGE */
PRO inst_id
PRO , child_number
@sql_shared_cursor_col_^^sql_id..sql
SELECT ', reason' FROM DUAL WHERE '^^rdbms_version.' >= '11.2%';
PRO FROM gv$sql_shared_cursor
PRO WHERE :shared_cursor = 'Y'
PRO AND sql_id = '^^sql_id.'
PRO ORDER BY 1, 2) v;;
SPO OFF;

SPO sqlhc.log append
PRO SQL Shared Cursor related SQLs generation: sql_shared_cursor_cur*.sql created
SELECT '<!-- '||TO_CHAR(SYSDATE, 'YYYY-MM-DD/HH24:MI:SS')||' -->' FROM dual;
SPO OFF;
/**************************************************************************************************/

/**************************************************************************************************
 *
 * diagnostics report
 *
 **************************************************************************************************/

/* -------------------------
 *
 * heading
 *
 * ------------------------- */
rem select STATEMENT_ID, object_type, object_owner, object_name from plan_table;
rem pause;
SPO ^^files_prefix._2_diagnostics.html;

PRO <html>
PRO <!-- $Header: ^^mos_doc. ^^script..sql ^^doc_ver. ^^doc_date. carlos.sierra $ -->
PRO <!-- Copyright (c) 2000-2012, Oracle Corporation. All rights reserved. -->
PRO <!-- Author: carlos.sierra@oracle.com -->
PRO
PRO <head>
PRO <title>^^files_prefix._2_diagnostics.html</title>
PRO

PRO <style type="text/css">
PRO body {font:10pt Arial,Helvetica,Verdana,Geneva,sans-serif; color:black; background:white;}
PRO a {font-weight:bold; color:#663300;}
PRO pre {font:8pt Monaco,"Courier New",Courier,monospace;} /* for code */
PRO h1 {font-size:16pt; font-weight:bold; color:#336699;}
PRO h2 {font-size:14pt; font-weight:bold; color:#336699;}
PRO h3 {font-size:12pt; font-weight:bold; color:#336699;}
PRO h4 {font-size:12pt; font-weight:bold; color:#336699;}
PRO li {font-size:10pt; font-weight:bold; color:#336699; padding:0.1em 0 0 0;}
PRO table {font-size:8pt; color:black; background:white;}
PRO th {font-weight:bold; background:#cccc99; color:#336699; vertical-align:bottom; padding-left:3pt; padding-right:3pt; padding-top:1pt; padding-bottom:1pt; position:sticky; top:0;}
PRO tr.bg {background:#B3F3B3;}
rem PRO td {text-align:left; background:#fcfcf0; vertical-align:top; padding-left:3pt; padding-right:3pt; padding-top:1pt; padding-bottom:1pt;}
PRO td {text-align:left; vertical-align:top; padding-left:3pt; padding-right:3pt; padding-top:1pt; padding-bottom:1pt;}
PRO td.c {text-align:center;} /* center */
PRO td.l {text-align:left;} /* left (default) */
PRO td.r {text-align:right;} /* right */
PRO td.bg_c{text-align:center;background:#DCEEB0;}
PRO tr:not(.tr):hover {background-color: #CCFFCC;}
PRO font.n {font-size:8pt; font-style:italic; color:#336699;} /* table footnote in blue */
PRO font.f {font-size:8pt; color:#999999;} /* footnote in gray */
PRO #summary1 {font-weight: bold; font-size: 16pt; color:#336699;}
PRO #summary2 {font-weight: bold; font-size: 14pt; color:#336699;}
PRO #summary3 {font-weight: bold; font-size: 12pt; color:#336699;}
PRO summary:hover {background-color: #FFFF99;}
PRO .button  {cursor: pointer;}
PRO .button1 {border-radius: 8px; background-color: #FFFF99; color: black;}
PRO .button1:hover {background-color: #4CAF50;color: white;}
PRO </style>
PRO

PRO </head>
PRO <body>
PRO <table style="width:100%"><tr><td style="text-align:right; background-color:#ffffff"><a href='#/' id='expAll' class='exp'>Collapse All</a></td></tr></table>
PRO <script>
PRO // Reference the toggle link
PRO var xa = document.getElementById('expAll')
PRO
PRO // Register link on click event
PRO xa.addEventListener('click', function(e) {
PRO
PRO e.target.classList.toggle('exp')
PRO e.target.classList.toggle('col')
PRO 
PRO // Collect all <details> into a NodeList
PRO var details = document.querySelectorAll('details')
PRO 
PRO Array.from(details).forEach(function(obj, idx) {
PRO
PRO if (e.target.classList.contains('exp')) {
PRO   obj.open = true
PRO   xa.innerHTML = "Collapse All"
PRO // Otherwise make it false
PRO } else {
PRO   obj.open = false
PRO   xa.innerHTML = "Expand All"
PRO }
PRO 
PRO })
PRO }, false)
PRO </script>

PRO <h1><a target="MOS" href="^^doc_link.^^mos_doc.">^^mos_doc.</a> ^^method.
PRO ^^doc_ver. Report: ^^files_prefix._2_diagnostics.html</h1>
PRO

/* psrv9
PRO <pre>
PRO License    : ^^input_license.
PRO Input      : ^^input_parameter.
PRO SIGNATURE  : ^^signature.
PRO SIGNATUREF : ^^signaturef.
PRO RDBMS      : ^^rdbms_version.
PRO Platform   : ^^platform.
PRO Database   : ^^database_name_short.
PRO DBID       : ^^dbid.
PRO Host       : ^^host_name_short.
PRO Instance   : ^^instance_number.
PRO CPU_Count  : ^^sys_cpu.
PRO Num CPUs   : ^^num_cpus.
PRO Num Cores  : ^^num_cores.
PRO Num Sockets: ^^num_sockets.
PRO Block Size : ^^sys_db_block_size.
PRO OFE        : ^^sys_ofe.
PRO DYN_SAMP   : ^^sys_ds.
PRO EBS        : "^^is_ebs."
PRO SIEBEL     : "^^is_siebel."
PRO PSFT       : "^^is_psft."
PRO Date       : ^^time_stamp2.
PRO User       : ^^sessionuser.
PRO </pre>

PRO <ul>
PRO <li><a href="#text">SQL Text</a></li>
PRO <li><a href="#spm">SQL Plan Baselines (DBA_SQL_PLAN_BASELINES)</a></li>
PRO <li><a href="#prof">SQL Profiles (DBA_SQL_PROFILES)</a></li>
PRO <li><a href="#patch">SQL Patches (DBA_SQL_PATCHES)</a></li>
PRO <li><a href="#share_r">Cursor Sharing and Reason</a></li>
PRO <li><a href="#share_l">Cursor Sharing List</a></li>
PRO <li><a href="#mem_plans_sum">Current Plans Summary (GV$SQL)</a></li>
PRO <li><a href="#mem_stats">Current SQL Statistics (GV$SQL)</a></li>
PRO <li><a href="#awr_plans_sum">Historical Plans Summary (DBA_HIST_SQLSTAT)</a></li>
PRO <li><a href="#awr_stats_d">Historical SQL Statistics - Delta (DBA_HIST_SQLSTAT)</a></li>
PRO <li><a href="#awr_stats_t">Historical SQL Statistics - Total (DBA_HIST_SQLSTAT)</a></li>
PRO <li><a href="#ash_plan">Active Session History by Plan (GV$ACTIVE_SESSION_HISTORY)</a></li>
PRO <li><a href="#ash_line">Active Session History by Plan Line (GV$ACTIVE_SESSION_HISTORY)</a></li>
PRO <li><a href="#awr_plan">AWR Active Session History by Plan (DBA_HIST_ACTIVE_SESS_HISTORY)</a></li>
PRO <li><a href="#awr_line">AWR Active Session History by Plan Line (DBA_HIST_ACTIVE_SESS_HISTORY)</a></li>
-- PRO <li><a href="#dbms_stats_sys_prefs">DBMS_STATS System Preferences</a></li> --Uday.v6.Aug2016
PRO <li><a href="#tables">Tables</a></li>
PRO <li><a href="#dbms_stats_tab_prefs">DBMS_STATS Table Preferences</a></li>
PRO <li><a href="#tbl_cols">Table Columns</a></li>
PRO <li><a href="#tbl_parts">Table Partitions</a></li>
PRO <li><a href="#tbl_constr">Table Constraints</a></li>
PRO <li><a href="#tbl_stat_ver">Tables Statistics Versions</a></li>
PRO <li><a href="#tbl_modifications">Table Modifications</a></li>
PRO <li><a href="#indexes">Indexes</a></li>
PRO <li><a href="#idx_text">Text Indexes</a></li>
PRO <li><a href="#idx_cols">Index Columns</a></li>
PRO <li><a href="#ind_parts">Index Partitions</a></li>
PRO <li><a href="#idx_stat_ver">Indexes Statistics Versions</a></li>
PRO <li><a href="#sys_params">System Parameters with Non-Default or Modified Values</a></li>
PRO <li><a href="#inst_params">Instance Parameters</a></li>
PRO <li><a href="#vpd_policies">VPD Policies</a></li>
PRO <li><a href="#sql_undo_usage">SQL Undo Usage</a></li>
PRO <li><a href="#sql_stats_hard_parse_time">SQL Statistics based on Last Hard Parse Time</a></li>
PRO <li><a href="#sql_obj_dependency">SQL Object Dependency</a></li>
PRO <li><a href="#sql_views_dependency">View/Synonym Dependency Hierarchy</a></li>
PRO <li><a href="#metadata">Metadata</a></li>
PRO </ul>
psrv9*/ 

PRO <a name="toc"></a>
PRO <table border="0">
PRO  <tr class="tr">
PRO   <!-- Column 1 -->
PRO   <td class="lw">
PRO    <h4>Global</h4>
PRO     <ul>
PRO     <li><a href="#text">SQL Text</a></li>
PRO     <li><a href="#sys_params">Parameters (Non-Default Values)</a></li>
PRO     <li><a href="#inst_params">Instance Parameters</a></li>
PRO     </ul>
--PSRv10- moved to Plans section PRO    <h4>Plan Control</h4>
--PSRv10- moved to Plans section PRO     <ul>
--PSRv10- moved to Plans section PRO     <li><a href="#spm">SQL Plan Baselines</a></li>
--PSRv10- moved to Plans section PRO     <li><a href="#prof">SQL Profiles</a></li>
--PSRv10- moved to Plans section PRO     <li><a href="#patch">SQL Patches</a></li>
--PSRv10- moved to Plans section PRO     <!-- <li> <a href="#directives">SQL Plan Directives</a></li> -->
--PSRv10- moved to Plans section PRO    </ul>
--PSRv10- moved to Plans section PRO    
PRO    <h4>Cursor Sharing and Binds</h4>
PRO     <ul>
PRO     <li><a href="#share_r">Cursor Sharing and Reason</a></li>
PRO     <li><a href="#share_l">Cursor Sharing List</a></li>        
PRO     <li>Peeked & Captured Binds<br>(see file: *_13_all_bind_values.txt)</li> 
PRO     </ul>
PRO    </td>
PRO    
PRO    <!-- Column 2 -->
PRO    
PRO    <td class="lw">&nbsp;&nbsp;&nbsp;&nbsp;</td><td class="lw">
PRO    <h4>Plans</h4>
PRO     <ul>
PRO     <li><a href="#planControl">Plan Control</a> (<a href="#planControlHints">Hints</a>)</li>
PRO     <li><a href="#monitored_execs">Monitored Execs</a></li>
PRO     <li><a href="#mem_plans_sum">In Memory Plans Summary</a></li>
PRO     <li><a href="#mem_stats">In Memory SQL Statistics</a></li>
PRO     <li><a href="#reoptimization_hints">Reoptimization Hints</a></li>
PRO     <li><a href="#awr_plans_sum">Historical Plans Summary</a></li>
PRO     <li><a href="#awr_stats_d">Historical SQL Statistics - Delta</a></li>
PRO     <li><a href="#awr_stats_t">Historical SQL Statistics - Total</a></li>
PRO     <li><a href="#spd">SQL Plan Directives</a></li>
PRO    </ul>
PRO    
PRO    <h4>Active Session History (ASH)</h4>
PRO     <ul>
PRO     <li><a href="#ash_plan">In Memory ASH by Plan</a></li>
PRO     <li><a href="#ash_line">In Memory ASH by Plan Line</a></li>
PRO     <li><a href="#awr_plan">AWR ASH by Plan</a></li>
PRO     <li><a href="#awr_line">AWR ASH by Plan Line</a></li>
PRO     </ul>
PRO    </td>
PRO    
PRO    <!-- Column 3 -->
PRO    
PRO    <td class="lw">&nbsp;&nbsp;&nbsp;&nbsp;</td><td class="lw">
PRO    
PRO    <h4>Tables and Indexes</h4>
PRO     <ul>
PRO      <li><a href="#tables">Tables</a>
PRO       <ul>
PRO        <li><a href="#tbl_modifications">Table Modifications</a></li>
PRO        <li><a href="#tbl_stat_ver">Tables Statistics Versions</a></li>
PRO        <li><a href="#bootstrap_joblog">Bootstrap Stats Log</a></li>
PRO        <li><a href="#tbl_cols">Table Columns</a></li>
PRO        <li><a href="#extensions">Table Extensions</a></li>
PRO        <li><a href="#dbms_stats_tab_prefs">DBMS_STATS Table Preferences</a></li>
PRO        <li><a href="#tbl_parts">Table Partitions</a></li>
PRO        <li><a href="#tbl_constr">Table Constraints</a></li>
PRO       </ul>
PRO      </li>
PRO     <li><a href="#indexes">Indexes</a></li>
PRO       <ul>
PRO        <li><a href="#idx_text">Text Indexes</a></li>
PRO        <li><a href="#idx_stat_ver">Indexes Statistics Versions</a></li>
PRO        <li><a href="#idx_cols">Index Columns</a></li>
PRO        <li><a href="#ind_parts">Index Partitions</a></li>
PRO       </ul>
PRO      </li>
PRO     </ul>
PRO    
PRO    <h4>Miscellanious</h4>
PRO     <ul>
PRO      <li><a href="#vpd_policies">VPD Policies</a></li>
PRO      <li><a href="#sql_undo_usage">SQL Undo Usage</a></li>
PRO      <li><a href="#sql_stats_hard_parse_time">SQL Statistics based on Last Hard Parse Time</a></li>
PRO      <li><a href="#sql_obj_dependency">SQL Object Dependency</a></li>
PRO      <li><a href="#sql_views_dependency">View/Synonym Dependency Hierarchy</a></li>
PRO      <li><a href="#metadata">Metadata </a> (<a href="#index_metadata">Index</a> and <a href="#view_metadata">View</a>)</li>
PRO      <li><a href="#indexcontention">Index Contention</a></li>
PRO     </ul>
PRO    </td>
PRO    
PRO    <!-- Column 4 -->
PRO    
--PRO    <td class="lw">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td>
PRO    <td class="lw">&nbsp;&nbsp;&nbsp;&nbsp;</td>
PRO    <td class="lw">
PRO    <pre>
PRO    SQL_ID     : ^^input_parameter.
PRO    SIGNATURE  : ^^signature.
PRO    SIGNATUREF : ^^signaturef.
-- PSRv10 source
PRO    UI/Batch/..: ^^source_batch_ui.
PRO    Source(Mem): ^^sql_source.
PRO    Source(ASH): 
PRO    Obj   : ^^ash_plsql_entry.
PRO    SubObj: ^^ash_plsql_object.
PRO    
--PRO    RDBMS      : ^^rdbms_version.

-- get Database Version
-- added by Vivek Jha on 4/28/21
DECLARE 
   vdbversion number(4);
   vrdbmsversion varchar2(12);
BEGIN 

        EXECUTE IMMEDIATE 'SELECT substr(banner, instr(banner,''Database'',1,1)+9,2) from v$version FETCH FIRST 1 ROW ONLY' into vdbversion;
  	IF vdbversion > 12 THEN 
  	  EXECUTE IMMEDIATE 'SELECT substr(banner_full, instr(banner_full,''Version'',1,1)+8,12) from v$version' into vrdbmsversion ;
	ELSE
  	  SELECT substr(banner, instr(banner,'Release',1,1)+8,10) into vrdbmsversion from v$version FETCH FIRST 1 ROW ONLY;
        END IF;
	DBMS_OUTPUT.PUT_LINE('RDBMS      : ' || vrdbmsversion  );

END; 
/


PRO    DBID       : ^^dbid.
PRO    Database   : ^^database_name_short.
PRO    Inst#      : ^^current_instance.
PRO    #Instances : ^^instances.
-- PSRv10 service
PRO    Service    : ^^service_name.
PRO    
PRO    Platform   : ^^platform.
PRO    Host       : ^^host_name_short.
PRO    
PRO    Block Size : ^^sys_db_block_size.
PRO    OFE        : ^^sys_ofe.
PRO    DYN_SAMP   : ^^sys_ds.
PRO    
PRO    Date       : ^^time_stamp2.
PRO
PRO    EBR upgrade: ^^ebr_date.
PRO 
PRO    User       : ^^sessionuser.
PRO    License    : ^^input_license.
PRO    </pre>
PRO    </td>
PRO   
PRO    
PRO    <!-- Column 5 -->
PRO    
--PRO    <td class="lw">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td>
PRO    <td class="lw">&nbsp;&nbsp;&nbsp;&nbsp;</td>
PRO    <td class="lw">
PRO    <pre>
-- PSRv10 FA Release
--PRO    FA Release : ^^fa_release.
exec dbms_output.put_line('FA Release : ' || :fa_release)
--PRO    POD Size   : ^^pod_size.
exec dbms_output.put_line('POD size   : ' || :pod_size)
PRO    CPU_Count  : ^^sys_cpu.
PRO    Job Queues : ^^jobqp.
PRO    
PRO    Num CPUs   : ^^num_cpus.
PRO    Num Cores  : ^^num_cores.
PRO    Num Sockets: ^^num_sockets.
PRO    
PRO    </pre>
PRO    </td>
PRO   
PRO   </tr>
PRO </table>
/* -------------------------
 *
 * invalid parameters check -- PSRv10
 *
 * ------------------------- */
 
exec :start_time := to_char(sysdate,'dd-mon-rr hh24:mi:ss');

with recos as 
(
 select '14545269' name, '0' value from dual
 union all
 select '14764840', '1' value from dual
 union all
 select '6708183', '1' value from dual
 union all
 select '17799716', '1' value from dual
 union all
 select '19710102', '1' value from dual
 union all
 select '18134680', '1' value from dual
 union all
 select '18115594', '1' value from dual
 union all
 select '9633142', '1' value from dual
 union all
 select '20355502', '0' value from dual
 union all
 select '_sql_plan_directive_mgmt_control', '0' value from dual
 union all
 select '_optimizer_dsdir_usage_control', '0' value from dual
 union all
 select '_optimizer_use_feedback', 'FALSE' value from dual
)
, actuals as
(
  select to_char(bugno) name, to_char(value) value 
    from v$system_fix_control 
   where bugno in (14545269, 14764840, 6708183, 17799716, 19710102, 18134680, 18115594, 9633142, 20355502) 
  union all
  select name, value
    from v$parameter
   where name in ('_sql_plan_directive_mgmt_control', '_optimizer_dsdir_usage_control', '_optimizer_use_feedback')
)
, invalidp as
(
  select recos.name, recos.value recommended_value, act.value actual_value, row_number() over(order by recos.name) rn
         --, case when then '<font color="red">***NOT a recommended value***</font>' end comment
    from recos, actuals act
   where recos.name = act.name(+)
     and recos.value <> act.value
     -- and 1=2
   order by recos.name
)
select 
       CHR(10)||'<details open><br/><summary id="summary2"><font color="red">Invalid Parameter Settings:</font></summary>'||CHR(10)||
       q'{
           <table>
           <tr>
           <th>#</th>
           <th>name</th>
           <th>Recommended<br>Value</th>
           <th>Actual<br>Value</th>
           </tr>
         }'
  from invalidp
 where rownum = 1
union all
select 
       CHR(10)||'<tr>'||CHR(10)||
       '<td class="r">'||ROWNUM||'</td>'||CHR(10)||
       '<td >'|| name               ||'</td>'||CHR(10)||
       '<td >'|| recommended_value  ||'</td>'||CHR(10)||
       '<td >'|| actual_value       ||'</td>'||CHR(10)||
       '</tr>'
  from invalidp
union all
select 
       q'{
           </table>
         }' || chr(10)
  from invalidp
 where rownum = 1
;

select round((sysdate-to_date(:start_time,'dd-mon-rr hh24:mi:ss'))*86400) diff from dual;
PRO <table style="width:100%"><tr><td style="text-align:right; background-color:#ffffff">Time taken: ^^diff. seconds</td></tr></table>
PRO </details><!--Pushkar-->
exec :start_time := to_char(sysdate,'dd-mon-rr hh24:mi:ss');
/* -------------------------
 *
 * sql_text
 *
 * ------------------------- */
PRO <script language="JavaScript" type="text/JavaScript">
PRO function openInNewWindow(url)
PRO {
PRO   window.open(url,"_blank");
PRO }
PRO </script>
PRO <a name="text"></a><details open><br/><summary id="summary2">SQL Text</summary>
PRO <FORM><BUTTON class="button button1" onclick="openInNewWindow(&quot;https://apex.oraclecorp.com/pls/apex/f?p=28906&quot;)">Analyze SQL Text via PSR Tool [use Upload SQL Button]</BUTTON></FORM> 
PRO
PRO <pre>

DECLARE
  l_sql_text CLOB := :sql_text;
  l_pos NUMBER;
BEGIN
  WHILE NVL(LENGTH(l_sql_text), 0) > 0
  LOOP
    l_pos := INSTR(l_sql_text, CHR(10));
    IF l_pos > 0 THEN
      DBMS_OUTPUT.PUT_LINE(SUBSTR(l_sql_text, 1, l_pos - 1));
      l_sql_text := SUBSTR(l_sql_text, l_pos + 1);
    ELSE
      DBMS_OUTPUT.PUT_LINE(l_sql_text);
      l_sql_text := NULL;
    END IF;
  END LOOP;
END;
/

PRO </pre>

select round((sysdate-to_date(:start_time,'dd-mon-rr hh24:mi:ss'))*86400) diff from dual;
PRO <table style="width:100%"><tr><td style="text-align:right; background-color:#ffffff">Time taken: ^^diff. seconds</td></tr></table>
PRO </details><!--Pushkar-->
exec :start_time := to_char(sysdate,'dd-mon-rr hh24:mi:ss');

/* -------------------------
 *
 * PL/SQL child queries
 *
 * ------------------------- */

var in_ash_memory varchar2(1);
exec :in_ash_memory := NULL;

-- Get sql id from ASH

declare 
  v_sql_opname gv$active_session_history.sql_opname%type;
begin

  select sql_opname
  into v_sql_opname  
  from gv$active_session_history
  where sql_id = '^^sql_id.'
  and rownum = 1;

  if v_sql_opname = 'PL/SQL EXECUTE'
  then
    :in_ash_memory := 'Y';
--    dbms_output.put_line('SQL ID IS A PL/SQL CALL IN ASH MEMORY');
  end if;

exception 
    when others then
     null;
end;
/

-- Get sql id from historical ASH

declare 
  v_sql_opname dba_hist_active_sess_history.sql_opname%type;
begin
  if :in_ash_memory IS NULL 
  then
    select sql_opname
    into v_sql_opname  
    from dba_hist_active_sess_history
    where sql_id = '^^sql_id.'
    and rownum = 1;

    if v_sql_opname = 'PL/SQL EXECUTE'
    then
      :in_ash_memory := 'N';
--      dbms_output.put_line('SQL ID IS A PL/SQL CALL IN HISTORICAL ASH');
      null;
    end if;
  end if;

exception 
    when others then
    null;
end;
/

begin
  if :in_ash_memory = 'Y'
  then
    dbms_output.put_line(CHR(10)||'<details open><br/><summary id="summary2">PL/SQL Child SQLs From In Memory ASH:</summary>'||CHR(10));
  elsif :in_ash_memory = 'N'
  then
    dbms_output.put_line(CHR(10)||'<details open><br/><summary id="summary2">PL/SQL Child SQLs From Historical ASH (AWR):</summary>'||CHR(10));
  end if;
end;
/

begin
  if :in_ash_memory is not null
  then
    dbms_output.put_line('EXEC ELAPSED TIME is only shown if executions = 1');
    dbms_output.put_line('<table>');
    dbms_output.put_line('<tr>');
    dbms_output.put_line('<th>#</th>');
    dbms_output.put_line('<th>SQL ID</th>');
    dbms_output.put_line('<th>PLAN HASH VALUE</th>');
    dbms_output.put_line('<th>EXECUTIONS</th>');
    dbms_output.put_line('<th>SQL OPNAME</th>');
    dbms_output.put_line('<th>SQL FIRST SAMPLE</th>');
    dbms_output.put_line('<th>SQL LAST SAMPLE</th>');
    dbms_output.put_line('<th>EXEC ELAPSED TIME</th>');
    dbms_output.put_line('<th>ECID COUNT</th>');
    dbms_output.put_line('<th>SESSION COUNT</th>');
    dbms_output.put_line('<th>SAMPLE COUNT</th>');
    dbms_output.put_line('<th>% OF TOTAL TIME</th>');
    dbms_output.put_line('</tr>');
  end if;
end;
/

WITH IN_ASH AS
(
    SELECT
           CHR(10)||'<tr>'||CHR(10)||
           '<td class="r">'||ROWNUM||'</td>'||CHR(10)||
           '<td class="r">'||sql_id      ||'</td>'||CHR(10)||
           '<td class="r">'||phv         ||'</td>'||CHR(10)||
           '<td class="r">'||execs       ||'</td>'||CHR(10)||
           '<td class="r">'||sql_opname  ||'</td>'||CHR(10)||
           '<td class="r">'||sql_first_sample  ||'</td>'||CHR(10)||
           '<td class="r">'||sql_last_sample  ||'</td>'||CHR(10)||
           '<td class="r">'||elatime_allexecs  ||'</td>'||CHR(10)||
           '<td class="r">'||ecid_count  ||'</td>'||CHR(10)||
           '<td class="r">'||sesscnt  ||'</td>'||CHR(10)||
           '<td class="r">'||cnt  ||'</td>'||CHR(10)||
           '<td class="r">'||pct         ||'</td>'||CHR(10)||
           '</tr>'
    FROM (
             select sql_id,
                    phv,
                    execs,
                    sql_opname,
                    sql_first_sample,
                    sql_last_sample,
                    elatime_allexecs,
                    ecid_count,
                    sesscnt,
                    cnt,
                    pct
             from
             (
                 select sql_id,
                        phv,
                        execs,
                        sql_opname,
                        sql_first_sample,
                        sql_last_sample,
                        decode(execs,1,regexp_replace(to_char(elatime_allexecs),'^\+[0]+'),'N/A') as elatime_allexecs,
                        ecid_count,
                        sesscnt,
                        cnt,
                        round(cnt/sum(cnt) over () * 100,2) as pct
                 from
                 (
                     select nvl(sql_id,'NULL') sql_id,
                            sql_plan_hash_value phv,
                            count(distinct sql_exec_id || '-' || sql_exec_start) execs,
                            count(*) cnt,
                            sql_opname,
                            min(sample_time) sql_first_sample,
                            max(sample_time) sql_last_sample,
                            max(sample_time)-min(sample_time) elatime_allexecs,
                           count(distinct ECID) ecid_count,
                           count(distinct session_id||'/'||session_serial#||'/'|| inst_id) sesscnt
                     from gv$active_session_history
                     where top_level_sql_id = '^^sql_id.'
                     and :in_ash_memory = 'Y'
                     group by nvl(sql_id,'NULL'), sql_plan_hash_value, sql_opname
                 )
                 order by pct desc
            )
            where pct >= 5
         ) v
    ),
    IN_AWR AS
    (
    SELECT
           CHR(10)||'<tr>'||CHR(10)||
           '<td class="r">'||ROWNUM||'</td>'||CHR(10)||
           '<td class="r">'||sql_id      ||'</td>'||CHR(10)||
           '<td class="r">'||phv         ||'</td>'||CHR(10)||
           '<td class="r">'||execs       ||'</td>'||CHR(10)||
           '<td class="r">'||sql_opname  ||'</td>'||CHR(10)||
           '<td class="r">'||sql_first_sample  ||'</td>'||CHR(10)||
           '<td class="r">'||sql_last_sample  ||'</td>'||CHR(10)||
           '<td class="r">'||elatime_allexecs  ||'</td>'||CHR(10)||
           '<td class="r">'||ecid_count  ||'</td>'||CHR(10)||
           '<td class="r">'||sesscnt  ||'</td>'||CHR(10)||
           '<td class="r">'||cnt  ||'</td>'||CHR(10)||
           '<td class="r">'||pct         ||'</td>'||CHR(10)||
           '</tr>'
    FROM (
             select sql_id,
                    phv,
                    execs,
                    sql_opname,
                    sql_first_sample,
                    sql_last_sample,
                    elatime_allexecs,
                    ecid_count,
                    sesscnt,
                    cnt,
                    pct
             from
             (
                 select sql_id,
                        phv,
                        execs,
                        sql_opname,
                        sql_first_sample,
                        sql_last_sample,
                        decode(execs,1,regexp_replace(to_char(elatime_allexecs),'^\+[0]+'),'N/A') as elatime_allexecs,
                        ecid_count,
                        sesscnt,
                        cnt,
                        round(cnt/sum(cnt) over () * 100,2) as pct
                 from
                 (
                     select nvl(sql_id,'NULL') sql_id,
                            sql_plan_hash_value phv,
                            count(distinct sql_exec_id || '-' || sql_exec_start) execs,
                            count(*) cnt,
                            sql_opname,
                            min(sample_time) sql_first_sample,
                            max(sample_time) sql_last_sample,
                            max(sample_time)-min(sample_time) elatime_allexecs,
                           count(distinct ECID) ecid_count,
                           count(distinct session_id||'/'||session_serial#||'/'|| instance_number) sesscnt
                     from dba_hist_active_sess_history
                     where top_level_sql_id = '^^sql_id.'
                     and :in_ash_memory = 'N'
                     group by nvl(sql_id,'NULL'), sql_plan_hash_value, sql_opname
                 )
                 order by pct desc
           )
           where pct >= 5
         ) v
    )
SELECT * FROM IN_ASH
UNION ALL
SELECT * FROM IN_AWR
;

begin
  if :in_ash_memory is not null
  then
    dbms_output.put_line('<tr>');
    dbms_output.put_line('<th>#</th>');
    dbms_output.put_line('<th>SQL ID</th>');
    dbms_output.put_line('<th>PLAN HASH VALUE</th>');
    dbms_output.put_line('<th>EXECUTIONS</th>');
    dbms_output.put_line('<th>SQL OPNAME</th>');
    dbms_output.put_line('<th>SQL FIRST SAMPLE</th>');
    dbms_output.put_line('<th>SQL LAST SAMPLE</th>');
    dbms_output.put_line('<th>EXEC ELAPSED TIME</th>');
    dbms_output.put_line('<th>ECID COUNT</th>');
    dbms_output.put_line('<th>SESSION COUNT</th>');
    dbms_output.put_line('<th>SAMPLE COUNT</th>');
    dbms_output.put_line('<th>% OF TOTAL TIME</th>');
    dbms_output.put_line('</tr>');
    dbms_output.put_line('</table>'); -- Pushkar
  end if;
end;
/

begin
  if :in_ash_memory in ('N','Y')
  then
    dbms_output.put_line(CHR(10)||'<table style="width:100%"><tr><td style="text-align:right; background-color:#ffffff">Time taken: '||round((sysdate-to_date(:start_time,'dd-mon-rr hh24:mi:ss'))*86400)||' seconds</td></tr></table></details>'||CHR(10));
  end if;
end;
/
REM special case -- Pushkar

exec :start_time := to_char(sysdate,'dd-mon-rr hh24:mi:ss');

/* -------------------------
 *
 * Plan Control Objects
 *
 * ------------------------- */
PRO <a name="planControl"></a><details open><br/><summary id="summary2">Plan Control Objects (DBA_SQL_PLAN_BASELINES/DBA_SQL_PROFILES/DBA_SQL_PATCHES)</summary>
PRO
SELECT '<!-- '||TO_CHAR(SYSDATE, 'YYYY-MM-DD/HH24:MI:SS')||' -->' FROM dual;
PRO <!-- Please Wait -->

COL signature FOR 99999999999999999999;

PRO
PRO <table>
PRO
PRO <tr>
PRO <th>#</th>
PRO <th>Plan Control<br>Object</th>
PRO <th>Hints</th>
PRO <th>Name</th>
PRO <th>Origin</th>
PRO <th>Signature</th>
PRO <th>Created</th>
PRO <th>Last<br>Modified</th>
PRO <th>Description</th>
PRO <th>Enabled</th>
PRO <th>Type</th>
PRO <th>Force<br>Matching</th>
PRO <th>Category</th>
PRO <th>Last<br>Executed</th>
PRO <th>Accepted</th>
PRO <th>Reproduced</th>
PRO <th>Auto<br>Purge</th>
PRO <th>Adaptive</th>
PRO <th>Optimizer<br>Cost</th>
PRO <th>Executions</th>
PRO <th>Elapsed<br>Time</th>
PRO <th>CPU<br>Time</th>
PRO <th>Buffer<br>Gets</th>
PRO <th>Disk<br>Reads</th>
PRO <th>Direct Writes</th>
PRO <th>Rows Processed</th>
PRO <th>Fetches</th>
PRO <th>EndOf<br>FetchCount</th>
PRO <th>SQL Handle</th>
PRO </tr>
PRO

SELECT 
       CHR(10)||'<tr>'||CHR(10)||
       '<td class="r">'||ROWNUM||'</td>'||CHR(10)||
       '<td >'||plan_control        ||'</td>'||CHR(10)||
       '<td class="c"><a href="#' || name || '">Hints</a></td>'||CHR(10)||
       '<td >'||name                ||'</td>'||CHR(10)||
       '<td >'||origin              ||'</td>'||CHR(10)||
       '<td >'||SIGNATURE           ||'</td>'||CHR(10)||
       '<td >'||CREATED             ||'</td>'||CHR(10)||
       '<td >'||LAST_MODIFIED       ||'</td>'||CHR(10)||
       '<td >'||DESCRIPTION         ||'</td>'||CHR(10)||
       '<td >'||ENABLED             ||'</td>'||CHR(10)||
       '<td >'||type                ||'</td>'||CHR(10)||
       '<td >'||FORCE_MATCHING      ||'</td>'||CHR(10)||
       '<td >'||category            ||'</td>'||CHR(10)||
       '<td >'||last_executed       ||'</td>'||CHR(10)||
       '<td >'||ACCEPTED            ||'</td>'||CHR(10)||
       '<td >'||REPRODUCED          ||'</td>'||CHR(10)||
       '<td >'||AUTOPURGE           ||'</td>'||CHR(10)||
       '<td >'||ADAPTIVE            ||'</td>'||CHR(10)||
       '<td >'||OPTIMIZER_COST      ||'</td>'||CHR(10)||
       '<td >'||EXECUTIONS          ||'</td>'||CHR(10)||
       '<td >'||ELAPSED_TIME        ||'</td>'||CHR(10)||
       '<td >'||CPU_TIME            ||'</td>'||CHR(10)||
       '<td >'||BUFFER_GETS         ||'</td>'||CHR(10)||
       '<td >'||DISK_READS          ||'</td>'||CHR(10)||
       '<td >'||DIRECT_WRITES       ||'</td>'||CHR(10)||
       '<td >'||ROWS_PROCESSED      ||'</td>'||CHR(10)||
       '<td >'||FETCHES             ||'</td>'||CHR(10)||
       '<td >'||END_OF_FETCH_COUNT  ||'</td>'||CHR(10)||
       '<td >'||SQL_HANDLE          ||'</td>'||CHR(10)||
       '</tr>'
  FROM (
        SELECT /*+ NO_MERGE */ 
               'Baseline' Plan_control,
               PLAN_NAME name,
               origin,
               SIGNATURE, 
               to_char(CREATED, 'YYYY-MM-DD/HH24:MI:SS') CREATED,
               to_char(LAST_MODIFIED, 'YYYY-MM-DD/HH24:MI:SS') LAST_MODIFIED,
               DESCRIPTION,
               ENABLED,
               decode(FIXED, 'YES', 'Fixed', 'Not Fixed') type,
               'n/a' FORCE_MATCHING,
               'n/a' category,
               to_char(LAST_EXECUTED, 'YYYY-MM-DD/HH24:MI:SS') last_executed,
               ACCEPTED,
               REPRODUCED,
               AUTOPURGE,
               ADAPTIVE,
               to_char(OPTIMIZER_COST) OPTIMIZER_COST,
               to_char(EXECUTIONS) EXECUTIONS,
               to_char(ELAPSED_TIME) ELAPSED_TIME,
               to_char(CPU_TIME) CPU_TIME,
               to_char(BUFFER_GETS) BUFFER_GETS,
               to_char(DISK_READS) DISK_READS,
               to_char(DIRECT_WRITES) DIRECT_WRITES,
               to_char(ROWS_PROCESSED) ROWS_PROCESSED,
               to_char(FETCHES) FETCHES,
               to_char(END_OF_FETCH_COUNT) END_OF_FETCH_COUNT,  
               SQL_HANDLE
          FROM dba_sql_plan_baselines 
         WHERE signature IN (^^signature., ^^signaturef.) 
        UNION ALL
         SELECT /*+ NO_MERGE */  
               'SQL Profile' Plan_control,
                NAME,
                'n/a' origin,                
                SIGNATURE,
                to_char(CREATED, 'YYYY-MM-DD/HH24:MI:SS') CREATED,
                to_char(LAST_MODIFIED, 'YYYY-MM-DD/HH24:MI:SS') LAST_MODIFIED,
                DESCRIPTION,
                STATUS,
                TYPE,
                FORCE_MATCHING,
                CATEGORY,
                'n/a' LAST_EXECUTED,
                'n/a' ACCEPTED,
                'n/a' REPRODUCED,
                'n/a' AUTOPURGE,
                'n/a' ADAPTIVE,
                'n/a' OPTIMIZER_COST,
                'n/a' EXECUTIONS,
                'n/a' ELAPSED_TIME,
                'n/a' CPU_TIME,
                'n/a' BUFFER_GETS,
                'n/a' DISK_READS,
                'n/a' DIRECT_WRITES,
                'n/a' ROWS_PROCESSED,
                'n/a' FETCHES,
                'n/a' END_OF_FETCH_COUNT,
                'n/a' SQL_HANDLE
           FROM dba_sql_profiles 
          WHERE signature IN (^^signature., ^^signaturef.) 
        UNION ALL
         SELECT /*+ NO_MERGE */
               'SQL Patch' Plan_control,
                NAME,
                'n/a' origin,
                SIGNATURE,
                to_char(CREATED, 'YYYY-MM-DD/HH24:MI:SS') CREATED,
                to_char(LAST_MODIFIED, 'YYYY-MM-DD/HH24:MI:SS') LAST_MODIFIED,
                DESCRIPTION,
                STATUS,
                'n/a' TYPE,
                FORCE_MATCHING,
                CATEGORY,
                'n/a' LAST_EXECUTED,
                'n/a' ACCEPTED,
                'n/a' REPRODUCED,
                'n/a' AUTOPURGE,
                'n/a' ADAPTIVE,
                'n/a' OPTIMIZER_COST,
                'n/a' EXECUTIONS,
                'n/a' ELAPSED_TIME,
                'n/a' CPU_TIME,
                'n/a' BUFFER_GETS,
                'n/a' DISK_READS,
                'n/a' DIRECT_WRITES,
                'n/a' ROWS_PROCESSED,
                'n/a' FETCHES,
                'n/a' END_OF_FETCH_COUNT,
                'n/a' SQL_HANDLE
          FROM dba_sql_patches
         WHERE signature IN (^^signature., ^^signaturef.)
         ORDER BY created desc, plan_control, name
        ) v
;


PRO <tr>
PRO <th>#</th>
PRO <th>Plan Control<br>Object</th>
PRO <th>Hints</th>
PRO <th>Name</th>
PRO <th>Origin</th>
PRO <th>Signature</th>
PRO <th>Created</th>
PRO <th>Last<br>Modified</th>
PRO <th>Description</th>
PRO <th>Enabled</th>
PRO <th>Type</th>
PRO <th>Force<br>Matching</th>
PRO <th>Category</th>
PRO <th>Last<br>Executed</th>
PRO <th>Accepted</th>
PRO <th>Reproduced</th>
PRO <th>Auto<br>Purge</th>
PRO <th>Adaptive</th>
PRO <th>Optimizer<br>Cost</th>
PRO <th>Executions</th>
PRO <th>Elapsed<br>Time</th>
PRO <th>CPU<br>Time</th>
PRO <th>Buffer<br>Gets</th>
PRO <th>Disk<br>Reads</th>
PRO <th>Direct Writes</th>
PRO <th>Rows Processed</th>
PRO <th>Fetches</th>
PRO <th>EndOf<br>FetchCount</th>
PRO <th>SQL Handle</th>
PRO
PRO </table>

select round((sysdate-to_date(:start_time,'dd-mon-rr hh24:mi:ss'))*86400) diff from dual;
PRO <table style="width:100%"><tr><td style="text-align:right; background-color:#ffffff">Time taken: ^^diff. seconds</td></tr></table>
PRO </details><!--Pushkar-->
exec :start_time := to_char(sysdate,'dd-mon-rr hh24:mi:ss');

--PSRv10 Replaced with PlanControl section /* -------------------------
--PSRv10 Replaced with PlanControl section  *
--PSRv10 Replaced with PlanControl section  * dba_sql_plan_baselines
--PSRv10 Replaced with PlanControl section  *
--PSRv10 Replaced with PlanControl section  * ------------------------- */
--PSRv10 Replaced with PlanControl section PRO <a name="spm"></a><br/><summary id="summary2">SQL Plan Baselines (DBA_SQL_PLAN_BASELINES)</summary>
--PSRv10 Replaced with PlanControl section PRO
--PSRv10 Replaced with PlanControl section PRO Available on 11g or higher. If this section is empty that means there are no plans in plan history for this SQL.
--PSRv10 Replaced with PlanControl section PRO
--PSRv10 Replaced with PlanControl section SELECT '<!-- '||TO_CHAR(SYSDATE, 'YYYY-MM-DD/HH24:MI:SS')||' -->' FROM dual;
--PSRv10 Replaced with PlanControl section PRO <!-- Please Wait -->
--PSRv10 Replaced with PlanControl section 
--PSRv10 Replaced with PlanControl section SET HEA ON PAGES 50 MARK HTML ON TABLE "" SPOOL OFF;
--PSRv10 Replaced with PlanControl section COL signature FOR 99999999999999999999;
--PSRv10 Replaced with PlanControl section SELECT ROWNUM "#", v.* FROM (SELECT /*+ NO_MERGE */ * FROM dba_sql_plan_baselines WHERE signature IN (^^signature., ^^signaturef.) ORDER BY created, plan_name) v;
--PSRv10 Replaced with PlanControl section SET HEA OFF PAGES 0 MARK HTML OFF;
--PSRv10 Replaced with PlanControl section 
--PSRv10 Replaced with PlanControl section /* -------------------------
--PSRv10 Replaced with PlanControl section  *
--PSRv10 Replaced with PlanControl section  * dba_sql_profiles
--PSRv10 Replaced with PlanControl section  *
--PSRv10 Replaced with PlanControl section  * ------------------------- */
--PSRv10 Replaced with PlanControl section PRO <a name="prof"></a><br/><summary id="summary2">SQL Profiles (DBA_SQL_PROFILES)</summary>
--PSRv10 Replaced with PlanControl section PRO
--PSRv10 Replaced with PlanControl section PRO Available on 10g or higher. If this section is empty that means there are no profiles for this SQL.
--PSRv10 Replaced with PlanControl section PRO
--PSRv10 Replaced with PlanControl section SELECT '<!-- '||TO_CHAR(SYSDATE, 'YYYY-MM-DD/HH24:MI:SS')||' -->' FROM dual;
--PSRv10 Replaced with PlanControl section PRO <!-- Please Wait -->
--PSRv10 Replaced with PlanControl section 
--PSRv10 Replaced with PlanControl section SET HEA ON PAGES 50 MARK HTML ON TABLE "" SPOOL OFF;
--PSRv10 Replaced with PlanControl section COL signature FOR 99999999999999999999;
--PSRv10 Replaced with PlanControl section SELECT ROWNUM "#", v.* FROM (SELECT /*+ NO_MERGE */ * FROM dba_sql_profiles WHERE signature IN (^^signature., ^^signaturef.) ORDER BY created, name) v;
--PSRv10 Replaced with PlanControl section SET HEA OFF PAGES 0 MARK HTML OFF;
--PSRv10 Replaced with PlanControl section 
--PSRv10 Replaced with PlanControl section /* -------------------------
--PSRv10 Replaced with PlanControl section  *
--PSRv10 Replaced with PlanControl section  * dba_sql_patches
--PSRv10 Replaced with PlanControl section  *
--PSRv10 Replaced with PlanControl section  * ------------------------- */
--PSRv10 Replaced with PlanControl section PRO <a name="patch"></a><br/><summary id="summary2">SQL Patches (DBA_SQL_PATCHES)</summary>
--PSRv10 Replaced with PlanControl section PRO
--PSRv10 Replaced with PlanControl section PRO Available on 11g or higher. If this section is empty that means there are no patches for this SQL.
--PSRv10 Replaced with PlanControl section PRO
--PSRv10 Replaced with PlanControl section SELECT '<!-- '||TO_CHAR(SYSDATE, 'YYYY-MM-DD/HH24:MI:SS')||' -->' FROM dual;
--PSRv10 Replaced with PlanControl section PRO <!-- Please Wait -->
--PSRv10 Replaced with PlanControl section 
--PSRv10 Replaced with PlanControl section SET HEA ON PAGES 50 MARK HTML ON TABLE "" SPOOL OFF;
--PSRv10 Replaced with PlanControl section COL signature FOR 99999999999999999999;
--PSRv10 Replaced with PlanControl section SELECT ROWNUM "#", v.* FROM (SELECT /*+ NO_MERGE */ * FROM dba_sql_patches WHERE signature IN (^^signature., ^^signaturef.) ORDER BY created, name) v;
--PSRv10 Replaced with PlanControl section SET HEA OFF PAGES 0 MARK HTML OFF;


/* -------------------------
 *
 * Monitored Execution
 * top 10 by status (desc order by sql exec start)
 * PSR v10
 *
 * ------------------------- */
PRO <a name="monitored_execs"></a><details open><br/><summary id="summary2">Monitored Executions</summary>
PRO
PRO Recent 10 executions by Status
SELECT '<!-- '||TO_CHAR(SYSDATE, 'YYYY-MM-DD/HH24:MI:SS')||' -->' FROM dual;
PRO <!-- Please Wait -->

PRO
PRO <table>
PRO
PRO <tr>
PRO <th>#</th>
PRO <th>Status</th>
PRO <th>SQL Exec Start</th>
PRO <th>SQL Exec ID</th>
PRO <th>PHV</th>
PRO <th>Last Refresh Time</th>
PRO <th>BufferGets</th>
PRO <th>Rows Proc.<br>All Lines</th>
PRO <th>Rows Selected<br>Final Result Set</th>
PRO <th>Elapsed<br>Sec</th>
PRO <th>CPU<br>Sec</th>
PRO <th>CPU<br>%</th>
PRO <th>Appl<br>Sec</th>
PRO <th>Appl<br>%</th>
PRO <th>Conc<br>Sec</th>
PRO <th>Conc<br>%</th>
PRO <th>Cluster<br>Sec</th>
PRO <th>Cluster<br>%</th>
PRO <th>IO<br>Sec</th>
PRO <th>IO<br>%</th>
PRO <th>PL/SQL<br>Sec</th>
PRO <th>PL/SQL<br>%</th>
PRO <th>Error Message</th>
PRO </tr>
PRO

SELECT 
       CHR(10)||'<tr>'||CHR(10)||
       '<td nowrap>'||ROWNUM||'</td>'||CHR(10)||
       case when status like '%ERROR%' then
         '<td style="color: red;">'||Status        ||'</td>'
            when status like '%EXECU%' then
         '<td style="color: green;">'||Status        ||'</td>'
       else
         '<td >'||Status        ||'</td>'
       end || chr(10)||
       '<td nowrap>'||sql_exec_start      ||'</td>'||CHR(10)||
       '<td class="r">'||sql_exec_id         ||'</td>'||CHR(10)||
       '<td class="r">'||phv         ||'</td>'||CHR(10)||
       '<td nowrap>'||last_refresh_time   ||'</td>'||CHR(10)||
       '<td class="r">'||buffer_gets         ||'</td>'||CHR(10)||
       '<td class="r">'||rowsp               ||'</td>'||CHR(10)||
       '<td class="r">'||rowsel              ||'</td>'||CHR(10)||
       '<td class="r">'||elapsed_sec         ||'</td>'||CHR(10)||
       '<td class="r">'||cpu_sec             ||'</td>'||CHR(10)||
       '<td class="r">'||pct_cpu             ||'</td>'||CHR(10)||
       '<td class="r">'||applwt_sec          ||'</td>'||CHR(10)||
       '<td class="r">'||pct_applwt          ||'</td>'||CHR(10)||
       '<td class="r">'||concwt_sec          ||'</td>'||CHR(10)||
       '<td class="r">'||pct_concwt          ||'</td>'||CHR(10)||
       '<td class="r">'||cluswt_sec          ||'</td>'||CHR(10)||
       '<td class="r">'||pct_cluswt          ||'</td>'||CHR(10)||
       '<td class="r">'||iowt_sec            ||'</td>'||CHR(10)||
       '<td class="r">'||pct_iowt            ||'</td>'||CHR(10)||
       '<td class="r">'||plsqlwt_sec         ||'</td>'||CHR(10)||
       '<td class="r">'||pct_plsqlwt         ||'</td>'||CHR(10)||
       '<td >'||error_message       ||'</td>'||CHR(10)||
       '</tr>'
  FROM ( 
          select status,
                 sql_exec_start,
                 sql_exec_id,
                 phv,
                 last_refresh_time,
                 buffer_gets,
                 rowsp,
                 rowsel,
                 elapsed_sec,
                 cpu_sec,
                 pct_cpu,
                 applwt_sec,
                 pct_applwt,
                 concwt_sec,
                 pct_concwt,
                 cluswt_sec,
                 pct_cluswt,
                 iowt_sec,
                 pct_iowt,
                 plsqlwt_sec,
                 pct_plsqlwt,
                 error_message
          from (
                select status,
                       to_char(sql_exec_start,'YYYY-MM-DD/HH24:MI:SS') sql_exec_start,
                       sql_exec_id,
                       sql_plan_hash_value phv,
                       to_char(last_refresh_time, 'YYYY-MM-DD/HH24:MI:SS') last_refresh_time,
                       to_char(buffer_gets,'999,999,999,999,999') buffer_gets,
                       round(elapsed_time/1000000,2) elapsed_sec,
                       round(cpu_time/1000000,2) cpu_sec,
                       round(application_wait_time/1000000,2) applwt_sec,
                       round(concurrency_wait_time/1000000,2) concwt_sec,
                       round(cluster_wait_time/1000000,2) cluswt_sec,
                       round(user_io_wait_time/1000000,2) iowt_sec,
                       round(plsql_exec_time/1000000,2) plsqlwt_sec,
                       round(100*cpu_time/elapsed_time, 2) pct_cpu,
                       round(100*application_wait_time/elapsed_time, 2) pct_applwt,
                       round(100*concurrency_wait_time/elapsed_time, 2) pct_concwt,
                       round(100*cluster_wait_time/elapsed_time, 2) pct_cluswt,
                       round(100*user_io_wait_time/elapsed_time, 2) pct_iowt,
                       round(100*plsql_exec_time/elapsed_time, 2) pct_plsqlwt,
                       (select to_char(sum(nvl(output_rows,0)),'999,999,999,999,999')
                          from gv$sql_plan_monitor pm
                          where pm.inst_id = sm.inst_id and pm.key = pm.key and pm.sql_id = sm.sql_id and pm.SQL_PLAN_HASH_VALUE = sm.SQL_PLAN_HASH_VALUE
                          and pm.sql_exec_start = sm.sql_exec_start
                          and rownum = 1
                       ) rowsp,
                       (select to_char(nvl(output_rows,0),'999,999,999,999,999')
                          from gv$sql_plan_monitor pm
                          where pm.inst_id = sm.inst_id and pm.key = pm.key and pm.sql_id = sm.sql_id and pm.SQL_PLAN_HASH_VALUE = sm.SQL_PLAN_HASH_VALUE
                          and pm.sql_exec_start = sm.sql_exec_start
                          and pm.plan_line_id = 0
                          and rownum = 1
                       ) rowsel,
                       error_message,
                       sm.inst_id||'/'||sm.sid||'/'||sm.session_serial#,
                       rank() over (partition by status order by sql_exec_start desc) rk
                  from gv$sql_monitor sm
                  where sm.sql_id = :sql_id
                  and sm.sql_exec_start is not null
               )
         where rk <= 10
         order by (case when status = 'EXECUTING' then '1' when status = 'DONE (ERROR)' then '2' else status end)
                   , sql_exec_start desc
       ) v
;
PRO
PRO <tr>
PRO <th>#</th>
PRO <th>Status</th>
PRO <th>SQL Exec Start</th>
PRO <th>SQL Exec ID</th>
PRO <th>PHV</th>
PRO <th>Last Refresh Time</th>
PRO <th>BufferGets</th>
PRO <th>Rows Proc.<br>All Lines</th>
PRO <th>Rows Selected<br>Final Result Set</th>
PRO <th>Elapsed<br>Sec</th>
PRO <th>CPU<br>Sec</th>
PRO <th>CPU<br>%</th>
PRO <th>Appl<br>Sec</th>
PRO <th>Appl<br>%</th>
PRO <th>Conc<br>Sec</th>
PRO <th>Conc<br>%</th>
PRO <th>Cluster<br>Sec</th>
PRO <th>Cluster<br>%</th>
PRO <th>IO<br>Sec</th>
PRO <th>IO<br>%</th>
PRO <th>PL/SQL<br>Sec</th>
PRO <th>PL/SQL<br>%</th>
PRO <th>Error Message</th>
PRO </tr>
PRO
PRO </table>

select round((sysdate-to_date(:start_time,'dd-mon-rr hh24:mi:ss'))*86400) diff from dual;
PRO <table style="width:100%"><tr><td style="text-align:right; background-color:#ffffff">Time taken: ^^diff. seconds</td></tr></table>
PRO </details><!--Pushkar-->
exec :start_time := to_char(sysdate,'dd-mon-rr hh24:mi:ss');
/* -------------------------
 *
 * cursor sharing reason
 *
 * ------------------------- */
PRO <a name="share_r"></a><details open><br/><summary id="summary2">Cursor Sharing and Reason (GV$SQL_SHARED_CURSOR)</summary>
PRO
PRO Collected from GV$SQL_SHARED_CURSOR.
PRO
PRO <table>
PRO
PRO <tr>
PRO <th>#</th>
PRO <th>Reason</th>
PRO <th>Inst</th>
PRO <th>Cursors</th>
PRO </tr>
PRO
SELECT '<!-- '||TO_CHAR(SYSDATE, 'YYYY-MM-DD/HH24:MI:SS')||' -->' FROM dual;
PRO <!-- Please Wait -->

@sql_shared_cursor_sum_^^sql_id..sql;

PRO
PRO <tr>
PRO <th>#</th>
PRO <th>Reason</th>
PRO <th>Inst</th>
PRO <th>Cursors</th>
PRO </tr>
PRO
PRO </table>

select round((sysdate-to_date(:start_time,'dd-mon-rr hh24:mi:ss'))*86400) diff from dual;
PRO <table style="width:100%"><tr><td style="text-align:right; background-color:#ffffff">Time taken: ^^diff. seconds</td></tr></table>
PRO </details><!--Pushkar-->
exec :start_time := to_char(sysdate,'dd-mon-rr hh24:mi:ss');
/* -------------------------
 *
 * cursor sharing list
 *
 * ------------------------- */
PRO <a name="share_l"></a><details open><br/><summary id="summary2">Cursor Sharing List (GV$SQL_SHARED_CURSOR)</summary>
PRO
PRO Collected from GV$SQL_SHARED_CURSOR.
PRO
SELECT '<!-- '||TO_CHAR(SYSDATE, 'YYYY-MM-DD/HH24:MI:SS')||' -->' FROM dual;
PRO <!-- Please Wait -->

SET HEA ON PAGES 50 MARK HTML ON TABLE "" SPOOL OFF;

@sql_shared_cursor_cur_^^sql_id..sql;

SET HEA OFF PAGES 0 MARK HTML OFF;


select round((sysdate-to_date(:start_time,'dd-mon-rr hh24:mi:ss'))*86400) diff from dual;
PRO <table style="width:100%"><tr><td style="text-align:right; background-color:#ffffff">Time taken: ^^diff. seconds</td></tr></table>
PRO </details> <!--Pushkar-->
exec :start_time := to_char(sysdate,'dd-mon-rr hh24:mi:ss');
/* -------------------------
 *
 * gv$sql plans summary
 *
 * ------------------------- */
EXEC DBMS_APPLICATION_INFO.SET_CLIENT_INFO('^^method.: Plans Summary and Plan Statistics - ' || TO_CHAR(SYSDATE, 'YYYY-MM-DD/HH24:MI:SS'));
PRO <a name="mem_plans_sum"></a><details open><br/><summary id="summary2">Current Plans Summary (GV$SQL)</summary>
PRO
PRO Execution Plans performance metrics for ^^sql_id. while still in memory. Plans ordered by average elapsed time.
PRO
PRO <table>
PRO
PRO <tr>
PRO <th>#</th>
PRO <th>Plan HV</th>
PRO <th>Avg<br>Elapsed<br>Time<br>(secs)</th>
PRO <th>Avg<br>CPU<br>Time<br>(secs)</th>
PRO <th>Avg<br>IO<br>Time<br>(secs)</th>
PRO <th>Avg<br>Conc<br>Time<br>(secs)</th>
PRO <th>Avg<br>Appl<br>Time<br>(secs)</th>
PRO <th>Avg<br>Clus<br>Time<br>(secs)</th>
PRO <th>Avg<br>PLSQL<br>Time<br>(secs)</th>
PRO <th>Avg<br>Java<br>Time<br>(secs)</th>
PRO <th>Avg<br>Buffer<br>Gets</th>
PRO <th>Avg<br>Disk<br>Reads</th>
PRO <th>Avg<br>Direct<br>Writes</th>
PRO <th>Avg<br>Rows<br>Proc</th>
PRO <th>Total<br>Execs</th>
PRO <th>Total<br>Fetch</th>
PRO <th>Total<br>Loads</th>
PRO <th>Total<br>Inval</th>
PRO <th>Total<br>Parse<br>Calls</th>
PRO <th>Total<br>Child<br>Cursors</th>
PRO <th>Min<br>Cost</th>
PRO <th>Max<br>Cost</th>
PRO <th>Min<br>Opt Env HV</th>
PRO <th>Max<br>Opt Env HV</th>
PRO <th>First Load</th>
PRO <th>Last Load</th>
PRO <th>Last Active</th>
PRO </tr>
PRO
SELECT '<!-- '||TO_CHAR(SYSDATE, 'YYYY-MM-DD/HH24:MI:SS')||' -->' FROM dual;
PRO <!-- Please Wait -->

SELECT CHR(10)||'<tr>'||CHR(10)||
       '<td class="r">'||ROWNUM||'</td>'||CHR(10)||
       '<td class="r">'||v.plan_hash_value||'</td>'||CHR(10)||
       '<td class="r">'||TO_CHAR(v.avg_elapsed_time_secs, '99999999999990D990')||'</td>'||CHR(10)||
       '<td class="r">'||TO_CHAR(v.avg_cpu_time_secs, '99999999999990D990')||'</td>'||CHR(10)||
       '<td class="r">'||TO_CHAR(v.avg_user_io_wait_time_secs, '99999999999990D990')||'</td>'||CHR(10)||
       '<td class="r">'||TO_CHAR(v.avg_concurrency_wait_time_secs, '99999999999990D990')||'</td>'||CHR(10)||
       '<td class="r">'||TO_CHAR(v.avg_application_wait_time_secs, '99999999999990D990')||'</td>'||CHR(10)||
       '<td class="r">'||TO_CHAR(v.avg_cluster_wait_time_secs, '99999999999990D990')||'</td>'||CHR(10)||
       '<td class="r">'||TO_CHAR(v.avg_plsql_exec_time_secs, '99999999999990D990')||'</td>'||CHR(10)||
       '<td class="r">'||TO_CHAR(v.avg_java_exec_time_secs, '99999999999990D990')||'</td>'||CHR(10)||
       '<td class="r">'||v.avg_buffer_gets||'</td>'||CHR(10)||
       '<td class="r">'||v.avg_disk_reads||'</td>'||CHR(10)||
       '<td class="r">'||v.avg_direct_writes||'</td>'||CHR(10)||
       '<td class="r">'||v.avg_rows_processed||'</td>'||CHR(10)||
       '<td class="r">'||v.total_executions||'</td>'||CHR(10)||
       '<td class="r">'||v.total_fetches||'</td>'||CHR(10)||
       '<td class="r">'||v.total_loads||'</td>'||CHR(10)||
       '<td class="r">'||v.total_invalidations||'</td>'||CHR(10)||
       '<td class="r">'||v.total_parse_calls||'</td>'||CHR(10)||
       '<td class="r">'||v.child_cursors||'</td>'||CHR(10)||
       '<td class="r">'||v.min_optimizer_cost||'</td>'||CHR(10)||
       '<td class="r">'||DECODE(v.min_optimizer_cost, v.max_optimizer_cost, NULL, v.max_optimizer_cost)||'</td>'||CHR(10)||
       '<td class="r">'||v.min_optimizer_env_hash_value||'</td>'||CHR(10)||
       '<td class="r">'||DECODE(v.min_optimizer_env_hash_value, v.max_optimizer_env_hash_value, NULL, v.max_optimizer_env_hash_value)||'</td>'||CHR(10)||
       '<td nowrap>'||v.first_load_time||'</td>'||CHR(10)||
       '<td nowrap>'||v.last_load_time||'</td>'||CHR(10)||
       '<td nowrap>'||TO_CHAR(v.last_active_time, 'YYYY-MM-DD/HH24:MI:SS')||'</td>'||CHR(10)||
       '</tr>'
  FROM (
SELECT /*+ NO_MERGE */
       plan_hash_value,
       ROUND((SUM(elapsed_time)/SUM(GREATEST(executions, 1))) / 1e6, 3) avg_elapsed_time_secs,
       ROUND((SUM(cpu_time)/SUM(GREATEST(executions, 1))) / 1e6, 3) avg_cpu_time_secs,
       ROUND((SUM(user_io_wait_time)/SUM(GREATEST(executions, 1))) / 1e6, 3) avg_user_io_wait_time_secs,
       ROUND((SUM(concurrency_wait_time)/SUM(GREATEST(executions, 1))) / 1e6, 3) avg_concurrency_wait_time_secs,
       ROUND((SUM(application_wait_time)/SUM(GREATEST(executions, 1))) / 1e6, 3) avg_application_wait_time_secs,
       ROUND((SUM(cluster_wait_time)/SUM(GREATEST(executions, 1))) / 1e6, 3) avg_cluster_wait_time_secs,
       ROUND((SUM(plsql_exec_time)/SUM(GREATEST(executions, 1))) / 1e6, 3) avg_plsql_exec_time_secs,
       ROUND((SUM(java_exec_time)/SUM(GREATEST(executions, 1))) / 1e6, 3) avg_java_exec_time_secs,
       ROUND(SUM(buffer_gets)/SUM(GREATEST(executions, 1))) avg_buffer_gets,
       ROUND(SUM(disk_reads)/SUM(GREATEST(executions, 1))) avg_disk_reads,
       ROUND(SUM(direct_writes)/SUM(GREATEST(executions, 1))) avg_direct_writes,
       ROUND(SUM(rows_processed)/SUM(GREATEST(executions, 1))) avg_rows_processed,
       SUM(GREATEST(executions, 1)) total_executions,
       SUM(fetches) total_fetches,
       SUM(loads) total_loads,
       SUM(invalidations) total_invalidations,
       SUM(parse_calls) total_parse_calls,
       COUNT(*) child_cursors,
       MIN(optimizer_cost) min_optimizer_cost,
       MAX(optimizer_cost) max_optimizer_cost,
       MIN(optimizer_env_hash_value) min_optimizer_env_hash_value,
       MAX(optimizer_env_hash_value) max_optimizer_env_hash_value,
       MIN(first_load_time) first_load_time,
       MAX(last_load_time) last_load_time,
       MAX(last_active_time) last_active_time
  FROM gv$sql
 WHERE sql_id = :sql_id
 GROUP BY
       plan_hash_value
 ORDER BY
       2) v;

PRO
PRO <tr>
PRO <th>#</th>
PRO <th>Plan HV</th>
PRO <th>Avg<br>Elapsed<br>Time<br>(secs)</th>
PRO <th>Avg<br>CPU<br>Time<br>(secs)</th>
PRO <th>Avg<br>IO<br>Time<br>(secs)</th>
PRO <th>Avg<br>Conc<br>Time<br>(secs)</th>
PRO <th>Avg<br>Appl<br>Time<br>(secs)</th>
PRO <th>Avg<br>Clus<br>Time<br>(secs)</th>
PRO <th>Avg<br>PLSQL<br>Time<br>(secs)</th>
PRO <th>Avg<br>Java<br>Time<br>(secs)</th>
PRO <th>Avg<br>Buffer<br>Gets</th>
PRO <th>Avg<br>Disk<br>Reads</th>
PRO <th>Avg<br>Direct<br>Writes</th>
PRO <th>Avg<br>Rows<br>Proc</th>
PRO <th>Total<br>Execs</th>
PRO <th>Total<br>Fetch</th>
PRO <th>Total<br>Loads</th>
PRO <th>Total<br>Inval</th>
PRO <th>Total<br>Parse<br>Calls</th>
PRO <th>Total<br>Child<br>Cursors</th>
PRO <th>Min<br>Cost</th>
PRO <th>Max<br>Cost</th>
PRO <th>Min<br>Opt Env HV</th>
PRO <th>Max<br>Opt Env HV</th>
PRO <th>First Load</th>
PRO <th>Last Load</th>
PRO <th>Last Active</th>
PRO </tr>
PRO
PRO </table>

select round((sysdate-to_date(:start_time,'dd-mon-rr hh24:mi:ss'))*86400) diff from dual;
PRO <table style="width:100%"><tr><td style="text-align:right; background-color:#ffffff">Time taken: ^^diff. seconds</td></tr></table>
PRO </details><!--Pushkar-->
exec :start_time := to_char(sysdate,'dd-mon-rr hh24:mi:ss');

/* -------------------------
 *
 * gv$sql sql statistics
 *
 * ------------------------- */
PRO <a name="mem_stats"></a><details open><br/><summary id="summary2">Current SQL Statistics (GV$SQL)</summary>
PRO
PRO Performance metrics of child cursors of ^^sql_id. while still in memory.
PRO
PRO <table>
PRO
PRO <tr>
PRO <th>#</th>
PRO <th>Inst<br>ID</th>
PRO <th>Child<br>Num</th>
PRO <th>Plan<br>Hash<br>Value</th>
PRO <th>Execs</th>
PRO <th>Fetch</th>
PRO <th>Loads<br>(Hard<br>Parses)</th>
PRO <th>Inval</th>
PRO <th>Parse<br>Calls</th>
PRO <th>Buffer<br>Gets</th>
PRO <th>Avg<br>Buffer<br>Gets</th>
PRO <th>Disk<br>Reads</th>
PRO <th>Direct<br>Writes</th>
PRO <th>Rows<br>Proc</th>
PRO <th>Elapsed<br>Time<br>(secs)</th>
PRO <th>CPU<br>Time<br>(secs)</th>
PRO <th>Avg<br>Elapsed<br>Time<br>(secs)</th>
PRO <th>Avg<br>CPU<br>Time<br>(secs)</th>
PRO <th>Avg Hard<br>Parse Time<br>(secs)<br>-AHP-</th>
PRO <th>Hard<br>Parses<br>for AHP</th>
PRO <th>IO<br>Time<br>(secs)</th>
PRO <th>Conc<br>Time<br>(secs)</th>
PRO <th>Appl<br>Time<br>(secs)</th>
PRO <th>Clus<br>Time<br>(secs)</th>
PRO <th>PLSQL<br>Time<br>(secs)</th>
PRO <th>Java<br>Time<br>(secs)</th>
PRO <th>Module</th>
PRO <th>Action</th>
PRO <th>Profile</th>
PRO <th>Patch</th>
PRO <th>Sql<br>Plan<br>Baseline</th>
PRO <th>First Hard Parse</th>
PRO <th>Last Hard Parse</th>
PRO <th>Last Active</th>
PRO <th>Optimizer<br>Mode</th>
PRO <th>Cost</th>
PRO <th>Opt Env HV</th>
PRO <th>Parsing<br>Schema<br>Name</th>
PRO <th>End<br>Of<br>Fetch<br>Count</th>
PRO <th>Obsolete?</th>
PRO <th>Bind<br>Sensitive?</th>
PRO <th>Bind<br>Aware?</th>
PRO <th>Shareable?</th>
PRO <th>Reoptimizable?</th>
PRO <th>Resolved<br>Adaptive<br>Plan?</th>
REM PRO <th>Plan<br>Notes</th>
PRO </tr>
PRO
SELECT '<!-- '||TO_CHAR(SYSDATE, 'YYYY-MM-DD/HH24:MI:SS')||' -->' FROM dual;
PRO <!-- Please Wait -->

with hp as
(select /*+ materialize */ inst_id, loads, TO_CHAR(ROUND(avg_hard_parse_time / 1e6, 3), '99999999999990D990') hpt 
   from gv$sqlstats ss 
  where ss.sql_id = :sql_id
)
SELECT /*+ leading(s) */  
       CHR(10)||'<tr>'||CHR(10)||
       '<td class="r">'||ROWNUM||'</td>'||CHR(10)||
       '<td class="r">'||s.inst_id||'</td>'||CHR(10)||
       '<td class="r">'||s.child_number||'</td>'||CHR(10)||
       '<td class="r">'||s.plan_hash_value||'</td>'||CHR(10)||
       '<td class="r">'||s.executions||'</td>'||CHR(10)||
       '<td class="r">'||s.fetches||'</td>'||CHR(10)||
       '<td class="r">'||s.loads||'</td>'||CHR(10)||
       '<td class="r">'||s.invalidations||'</td>'||CHR(10)||
       '<td class="r">'||s.parse_calls||'</td>'||CHR(10)||
       '<td class="r">'||s.buffer_gets||'</td>'||CHR(10)||
       '<td class="r">'||round(s.buffer_gets/GREATEST(executions, 1))||'</td>'||CHR(10)||
       '<td class="r">'||s.disk_reads||'</td>'||CHR(10)||
       '<td class="r">'||s.direct_writes||'</td>'||CHR(10)||
       '<td class="r">'||s.rows_processed||'</td>'||CHR(10)||
       '<td class="r">'||TO_CHAR(ROUND(s.elapsed_time / 1e6, 3), '99999999999990D990')||'</td>'||CHR(10)||
       '<td class="r">'||TO_CHAR(ROUND(s.cpu_time / 1e6, 3), '99999999999990D990')||'</td>'||CHR(10)||
       '<td class="r">'||TO_CHAR(ROUND(s.elapsed_time / 1e6/GREATEST(executions, 1), 3), '99999999999990D990')||'</td>'||CHR(10)||
       '<td class="r">'||TO_CHAR(ROUND(s.cpu_time / 1e6/GREATEST(executions, 1), 3), '99999999999990D990')||'</td>'||CHR(10)||
       '<td class="r">'||hp.hpt||'</td>'||CHR(10)||
       '<td class="r">'||hp.loads||'</td>'||CHR(10)||
       '<td class="r">'||TO_CHAR(ROUND(s.user_io_wait_time / 1e6, 3), '99999999999990D990')||'</td>'||CHR(10)||
       '<td class="r">'||TO_CHAR(ROUND(s.concurrency_wait_time / 1e6, 3), '99999999999990D990')||'</td>'||CHR(10)||
       '<td class="r">'||TO_CHAR(ROUND(s.application_wait_time / 1e6, 3), '99999999999990D990')||'</td>'||CHR(10)||
       '<td class="r">'||TO_CHAR(ROUND(s.cluster_wait_time / 1e6, 3), '99999999999990D990')||'</td>'||CHR(10)||
       '<td class="r">'||TO_CHAR(ROUND(s.plsql_exec_time / 1e6, 3), '99999999999990D990')||'</td>'||CHR(10)||
       '<td class="r">'||TO_CHAR(ROUND(s.java_exec_time / 1e6, 3), '99999999999990D990')||'</td>'||CHR(10)||
       '<td>'||s.module||'</td>'||CHR(10)||
       '<td>'||s.action||'</td>'||CHR(10)||
       '<td>'||s.sql_profile||'</td>'||CHR(10)||
       '<td>'||s.sql_patch||'</td>'||CHR(10)||
       '<td>'||s.sql_plan_baseline||'</td>'||CHR(10)||
       '<td nowrap>'||s.first_load_time||'</td>'||CHR(10)||
       '<td nowrap>'||s.last_load_time||'</td>'||CHR(10)||
       '<td nowrap>'||TO_CHAR(s.last_active_time, 'YYYY-MM-DD/HH24:MI:SS')||'</td>'||CHR(10)||
       '<td>'||s.optimizer_mode||'</td>'||CHR(10)||
       '<td class="r">'||s.optimizer_cost||'</td>'||CHR(10)||
       '<td class="r">'||s.optimizer_env_hash_value||'</td>'||CHR(10)||
       '<td>'||s.parsing_schema_name||'</td>'||CHR(10)||
--PSRv10 start
      '<td class="r">'||s.END_OF_FETCH_COUNT||'</td>'||CHR(10)||
       '<td>'||IS_OBSOLETE||'</td>'||CHR(10)||
       '<td>'||IS_BIND_SENSITIVE||'</td>'||CHR(10)||
       '<td>'||IS_BIND_AWARE||'</td>'||CHR(10)||
       '<td>'||IS_SHAREABLE||'</td>'||CHR(10)||
       '<td>'||IS_REOPTIMIZABLE||'</td>'||CHR(10)||
       '<td>'||IS_RESOLVED_ADAPTIVE_PLAN||'</td>'||CHR(10)||
--       '<td nowrap>'||(select listagg(type,'<br>') within group (order by 1)
--                       from gv$sql_plan a, xmltable('other_xml/info[@note="y"]' passing xmltype(other_xml) 
--                             columns type varchar2(60) path  '@type') b
--                      where inst_id=s.inst_id
--                        and sql_id=s.sql_id
--                        and plan_hash_value=s.plan_hash_value
--                        and child_number=s.child_number
--                        and other_xml is NOT null
--                   group by inst_id, sql_id, plan_hash_value, child_number) ||'</td>'||CHR(10)||       
--PSRv10 end
       '</tr>'
  FROM gv$sql s, hp
 WHERE sql_id = :sql_id
   and s.inst_id = hp.inst_id
 ORDER BY
       s.inst_id,
       s.child_number;

PRO
PRO <tr>
PRO <th>#</th>
PRO <th>Inst<br>ID</th>
PRO <th>Child<br>Num</th>
PRO <th>Plan<br>Hash<br>Value</th>
PRO <th>Execs</th>
PRO <th>Fetch</th>
PRO <th>Loads<br>(Hard<br>Parses)</th>
PRO <th>Inval</th>
PRO <th>Parse<br>Calls</th>
PRO <th>Buffer<br>Gets</th>
PRO <th>Avg<br>Buffer<br>Gets</th>
PRO <th>Disk<br>Reads</th>
PRO <th>Direct<br>Writes</th>
PRO <th>Rows<br>Proc</th>
PRO <th>Elapsed<br>Time<br>(secs)</th>
PRO <th>CPU<br>Time<br>(secs)</th>
PRO <th>Avg<br>Elapsed<br>Time<br>(secs)</th>
PRO <th>Avg<br>CPU<br>Time<br>(secs)</th>
PRO <th>Avg Hard<br>Parse Time<br>(secs)<br>-AHP-</th>
PRO <th>Hard<br>Parses<br>for AHP</th>
PRO <th>IO<br>Time<br>(secs)</th>
PRO <th>Conc<br>Time<br>(secs)</th>
PRO <th>Appl<br>Time<br>(secs)</th>
PRO <th>Clus<br>Time<br>(secs)</th>
PRO <th>PLSQL<br>Time<br>(secs)</th>
PRO <th>Java<br>Time<br>(secs)</th>
PRO <th>Module</th>
PRO <th>Action</th>
PRO <th>Profile</th>
PRO <th>Patch</th>
PRO <th>Sql<br>Plan<br>Baseline</th>
PRO <th>First Hard Parse</th>
PRO <th>Last Hard Parse</th>
PRO <th>Last Active</th>
PRO <th>Optimizer<br>Mode</th>
PRO <th>Cost</th>
PRO <th>Opt Env HV</th>
PRO <th>Parsing<br>Schema<br>Name</th>
PRO <th>End<br>Of<br>Fetch<br>Count</th>
PRO <th>Obsolete?</th>
PRO <th>Bind<br>Sensitive?</th>
PRO <th>Bind<br>Aware?</th>
PRO <th>Shareable?</th>
PRO <th>Reoptimizable?</th>
PRO <th>Resolved<br>Adaptive<br>Plan?</th>
REM PRO <th>Plan<br>Notes</th>
PRO </tr>
PRO
PRO </table>

select round((sysdate-to_date(:start_time,'dd-mon-rr hh24:mi:ss'))*86400) diff from dual;
PRO <table style="width:100%"><tr><td style="text-align:right; background-color:#ffffff">Time taken: ^^diff. seconds</td></tr></table>
PRO </details><!--Pushkar-->
exec :start_time := to_char(sysdate,'dd-mon-rr hh24:mi:ss');

REM Pushkar
EXEC DBMS_APPLICATION_INFO.SET_CLIENT_INFO('^^method.: gv$sql_reoptimization_hints - ' || TO_CHAR(SYSDATE, 'YYYY-MM-DD/HH24:MI:SS'));
PRO <a name="reoptimization_hints"></a><details open><br/><summary id="summary2">Reoptimization Hints (GV$SQL_REOPTIMIZATION_HINTS)</summary>
PRO
PRO Reoptimization Hints for ^^sql_id. (Currently limited to Cardinality Estimates).
PRO
PRO <table>
PRO
PRO <tr>
PRO <th>Inst<br>ID</th>
PRO <th>Plan<br>Hash<br>Value</th>
PRO <th>Child<br>Number</th>
PRO <th>Hint ID</th>
PRO <th>Hint Text</th>
PRO </tr>
PRO
SELECT '<!-- '||TO_CHAR(SYSDATE, 'YYYY-MM-DD/HH24:MI:SS')||' -->' FROM dual;
PRO <!-- Please Wait -->

SELECT CHR(10)||'<tr>'||CHR(10)||
       '<td class="r">'||v.inst_id||'</td>'||CHR(10)||
       '<td class="r">'||v.HASH_VALUE||'</td>'||CHR(10)||
       '<td class="r">'||v.CHILD_NUMBER||'</td>'||CHR(10)||
       '<td class="r">'||v.HINT_ID||'</td>'||CHR(10)||
       '<td>'          ||v.HINT_TEXT||'</td>'||CHR(10)||
       '</tr>'
  FROM (
        select
          INST_ID      ,
          ADDRESS      ,
          HASH_VALUE   ,
          SQL_ID       ,
          CHILD_NUMBER ,
          HINT_ID      ,
          HINT_TEXT    ,
          CLIENT_ID    ,
          REPARSE      ,
          CON_ID       
        from gv$sql_reoptimization_hints
        where sql_id=:sql_id
      ) v
  ORDER BY v.inst_id, v.child_number, v.hint_id;
  
PRO
PRO <tr>
PRO <th>Inst<br>ID</th>
PRO <th>Plan<br>Hash<br>Value</th>
PRO <th>Child<br>Number</th>
PRO <th>Hint ID</th>
PRO <th>Hint Text</th>
PRO </tr>
PRO </table>

select round((sysdate-to_date(:start_time,'dd-mon-rr hh24:mi:ss'))*86400) diff from dual;
PRO <table style="width:100%"><tr><td style="text-align:right; background-color:#ffffff">Time taken: ^^diff. seconds</td></tr></table>
PRO </details><!--Pushkar-->
exec :start_time := to_char(sysdate,'dd-mon-rr hh24:mi:ss');
/* -------------------------
 *
 * dba_hist_sqlstat plans summary
 *
 * ------------------------- */
PRO <a name="awr_plans_sum"></a><details open><br/><summary id="summary2">Historical Plans Summary (DBA_HIST_SQLSTAT)</summary>
PRO
PRO Performance metrics of Execution Plans of ^^sql_id.. Plans ordered by average elapsed time.<br>
PRO This section includes data captured by AWR. If this is a stand-by read-only database then the AWR information below is from the Primary database.
PRO
PRO <table>
PRO
PRO <tr>
PRO <th>#</th>
PRO <th>Plan HV</th>
PRO <th>Avg<br>Elapsed<br>Time<br>(secs)</th>
PRO <th>Avg<br>CPU<br>Time<br>(secs)</th>
PRO <th>Avg<br>IO<br>Time<br>(secs)</th>
PRO <th>Avg<br>Conc<br>Time<br>(secs)</th>
PRO <th>Avg<br>Appl<br>Time<br>(secs)</th>
PRO <th>Avg<br>Clus<br>Time<br>(secs)</th>
PRO <th>Avg<br>PLSQL<br>Time<br>(secs)</th>
PRO <th>Avg<br>Java<br>Time<br>(secs)</th>
PRO <th>Avg<br>Buffer<br>Gets</th>
PRO <th>Avg<br>Disk<br>Reads</th>
PRO <th>Avg<br>Direct<br>Writes</th>
PRO <th>Avg<br>Rows<br>Proc</th>
PRO <th>Total<br>Execs</th>
--PRO <th>Total<br>Fetch</th>
--PRO <th>Total<br>Loads</th>
--PRO <th>Total<br>Inval</th>
--PRO <th>Total<br>Parse<br>Calls</th>
PRO <th>Min<br>Cost</th>
PRO <th>Max<br>Cost</th>
PRO <th>Min<br>Opt Env HV</th>
PRO <th>Max<br>Opt Env HV</th>
PRO <th>First Snapshot</th>
PRO <th>Last Snapshot</th>
PRO </tr>
PRO
SELECT '<!-- '||TO_CHAR(SYSDATE, 'YYYY-MM-DD/HH24:MI:SS')||' -->' FROM dual;
PRO <!-- Please Wait -->

SELECT CHR(10)||'<tr>'||CHR(10)||
       '<td class="r">'||ROWNUM||'</td>'||CHR(10)||
       '<td class="r">'||v.plan_hash_value||'</td>'||CHR(10)||
       '<td class="r">'||TO_CHAR(v.avg_elapsed_time_secs, '99999999999990D990')||'</td>'||CHR(10)||
       '<td class="r">'||TO_CHAR(v.avg_cpu_time_secs, '99999999999990D990')||'</td>'||CHR(10)||
       '<td class="r">'||TO_CHAR(v.avg_user_io_wait_time_secs, '99999999999990D990')||'</td>'||CHR(10)||
       '<td class="r">'||TO_CHAR(v.avg_concurrency_wait_time_secs, '99999999999990D990')||'</td>'||CHR(10)||
       '<td class="r">'||TO_CHAR(v.avg_application_wait_time_secs, '99999999999990D990')||'</td>'||CHR(10)||
       '<td class="r">'||TO_CHAR(v.avg_cluster_wait_time_secs, '99999999999990D990')||'</td>'||CHR(10)||
       '<td class="r">'||TO_CHAR(v.avg_plsql_exec_time_secs, '99999999999990D990')||'</td>'||CHR(10)||
       '<td class="r">'||TO_CHAR(v.avg_java_exec_time_secs, '99999999999990D990')||'</td>'||CHR(10)||
       '<td class="r">'||v.avg_buffer_gets||'</td>'||CHR(10)||
       '<td class="r">'||v.avg_disk_reads||'</td>'||CHR(10)||
       '<td class="r">'||v.avg_direct_writes||'</td>'||CHR(10)||
       '<td class="r">'||v.avg_rows_processed||'</td>'||CHR(10)||
       '<td class="r">'||v.delta_executions||'</td>'||CHR(10)||
       --'<td class="r">'||v.delta_fetches||'</td>'||CHR(10)||
       --'<td class="r">'||v.delta_loads||'</td>'||CHR(10)||
       --'<td class="r">'||v.delta_invalidations||'</td>'||CHR(10)||
       --'<td class="r">'||v.delta_parse_calls||'</td>'||CHR(10)||
       '<td class="r">'||v.min_optimizer_cost||'</td>'||CHR(10)||
       '<td class="r">'||DECODE(v.min_optimizer_cost, v.max_optimizer_cost, NULL, v.max_optimizer_cost)||'</td>'||CHR(10)||
       '<td class="r">'||v.min_optimizer_env_hash_value||'</td>'||CHR(10)||
       '<td class="r">'||DECODE(v.min_optimizer_env_hash_value, v.max_optimizer_env_hash_value, NULL, v.max_optimizer_env_hash_value)||'</td>'||CHR(10)||
       '<td nowrap>'||TO_CHAR(v.first_snap_time, 'YYYY-MM-DD/HH24:MI:SS')||'</td>'||CHR(10)||
       '<td nowrap>'||TO_CHAR(v.last_snap_time, 'YYYY-MM-DD/HH24:MI:SS')||'</td>'||CHR(10)||
       '</tr>'
  FROM (
SELECT /*+ NO_MERGE */
       h.plan_hash_value,
       ROUND((SUM(h.elapsed_time_delta)/SUM(GREATEST(h.executions_delta, 1))) / 1e6, 3) avg_elapsed_time_secs,
       ROUND((SUM(h.cpu_time_delta)/SUM(GREATEST(h.executions_delta, 1))) / 1e6, 3) avg_cpu_time_secs,
       ROUND((SUM(h.iowait_delta)/SUM(GREATEST(h.executions_delta, 1))) / 1e6, 3) avg_user_io_wait_time_secs,
       ROUND((SUM(h.ccwait_delta)/SUM(GREATEST(h.executions_delta, 1))) / 1e6, 3) avg_concurrency_wait_time_secs,
       ROUND((SUM(h.apwait_delta)/SUM(GREATEST(h.executions_delta, 1))) / 1e6, 3) avg_application_wait_time_secs,
       ROUND((SUM(h.clwait_delta)/SUM(GREATEST(h.executions_delta, 1))) / 1e6, 3) avg_cluster_wait_time_secs,
       ROUND((SUM(h.plsexec_time_delta)/SUM(GREATEST(h.executions_delta, 1))) / 1e6, 3) avg_plsql_exec_time_secs,
       ROUND((SUM(h.javexec_time_delta)/SUM(GREATEST(h.executions_delta, 1))) / 1e6, 3) avg_java_exec_time_secs,
       ROUND(SUM(h.buffer_gets_delta)/SUM(GREATEST(h.executions_delta, 1))) avg_buffer_gets,
       ROUND(SUM(h.disk_reads_delta)/SUM(GREATEST(h.executions_delta, 1))) avg_disk_reads,
       ROUND(SUM(h.direct_writes_delta)/SUM(GREATEST(h.executions_delta, 1))) avg_direct_writes,
       ROUND(SUM(h.rows_processed_delta)/SUM(GREATEST(h.executions_delta, 1))) avg_rows_processed,
       SUM(GREATEST(h.executions_delta, 1)) delta_executions,
       --SUM(h.fetches_delta) delta_fetches,
       --SUM(h.loads_delta) delta_loads,
       --SUM(h.invalidations_delta) delta_invalidations,
       --SUM(h.parse_calls_delta) delta_parse_calls,
       MIN(h.optimizer_cost) min_optimizer_cost,
       MAX(h.optimizer_cost) max_optimizer_cost,
       MIN(h.optimizer_env_hash_value) min_optimizer_env_hash_value,
       MAX(h.optimizer_env_hash_value) max_optimizer_env_hash_value,
       MIN(s.end_interval_time) first_snap_time,
       MAX(s.end_interval_time) last_snap_time
  FROM dba_hist_sqlstat h,
       dba_hist_snapshot s
 WHERE 1=1
   AND (:license IN ('T', 'D') or (:license = 'L' and s.begin_interval_time > systimestamp - interval '^^days.' day))
   AND h.dbid = ^^dbid.
   AND h.sql_id = :sql_id
   AND h.snap_id = s.snap_id
   AND h.dbid = s.dbid
   AND h.instance_number = s.instance_number
 GROUP BY
       h.plan_hash_value
 ORDER BY
       2) v;

PRO
PRO <tr>
PRO <th>#</th>
PRO <th>Plan HV</th>
PRO <th>Avg<br>Elapsed<br>Time<br>(secs)</th>
PRO <th>Avg<br>CPU<br>Time<br>(secs)</th>
PRO <th>Avg<br>IO<br>Time<br>(secs)</th>
PRO <th>Avg<br>Conc<br>Time<br>(secs)</th>
PRO <th>Avg<br>Appl<br>Time<br>(secs)</th>
PRO <th>Avg<br>Clus<br>Time<br>(secs)</th>
PRO <th>Avg<br>PLSQL<br>Time<br>(secs)</th>
PRO <th>Avg<br>Java<br>Time<br>(secs)</th>
PRO <th>Avg<br>Buffer<br>Gets</th>
PRO <th>Avg<br>Disk<br>Reads</th>
PRO <th>Avg<br>Direct<br>Writes</th>
PRO <th>Avg<br>Rows<br>Proc</th>
PRO <th>Total<br>Execs</th>
--PRO <th>Total<br>Fetch</th>
--PRO <th>Total<br>Loads</th>
--PRO <th>Total<br>Inval</th>
--PRO <th>Total<br>Parse<br>Calls</th>
PRO <th>Min<br>Cost</th>
PRO <th>Max<br>Cost</th>
PRO <th>Min<br>Opt Env HV</th>
PRO <th>Max<br>Opt Env HV</th>
PRO <th>First Snapshot</th>
PRO <th>Last Snapshot</th>
PRO </tr>
PRO
PRO </table>

select round((sysdate-to_date(:start_time,'dd-mon-rr hh24:mi:ss'))*86400) diff from dual;
PRO <table style="width:100%"><tr><td style="text-align:right; background-color:#ffffff">Time taken: ^^diff. seconds</td></tr></table>
PRO </details><!--Pushkar-->
exec :start_time := to_char(sysdate,'dd-mon-rr hh24:mi:ss');
/* -------------------------
 *
 * dba_hist_sqlstat sql statistics
 * psrv9: fixed error ORA-06502 while extracting other_xml. 
 *        Other_XML could be present on any line, not necessarity on id=1
 *
 * ------------------------- */
PRO <a name="awr_stats_d"></a><details open><br/><summary id="summary2">Historical SQL Statistics - Delta (DBA_HIST_SQLSTAT)</summary>
PRO
PRO Performance metrics of Execution Plans of ^^sql_id..<br>
PRO This section includes data captured by AWR. If this is a stand-by read-only database then the AWR information below is from the Primary database.
PRO
PRO <table>
PRO
PRO <tr>
PRO <th>#</th>
PRO <th>Snap<br>ID</th>
PRO <th>Pre/Post<br>EBR</th>
PRO <th>Snaphot</th>
PRO <th>Inst<br>ID</th>
PRO <th>Plan HV</th>
PRO <th>Vers<br>Cnt</th>
PRO <th>Execs</th>
PRO <th>Fetch</th>
PRO <th>Loads</th>
PRO <th>Inval</th>
PRO <th>Parse<br>Calls</th>
PRO <th>Buffer<br>Gets</th>
PRO <th>Avg<br>Buffer<br>Gets</th>
PRO <th>Disk<br>Reads</th>
PRO <th>Avg<br>Disk<br>Reads</th>
PRO <th>Direct<br>Writes</th>
PRO <th>Rows<br>Proc</th>
PRO <th>Avg<br>Rows</th>
PRO <th>Elapsed<br>Time<br>(secs)</th>
PRO <th>Avg<br>Elapsed<br>Time<br>(secs)</th>
PRO <th>CPU<br>Time<br>(secs)</th>
PRO <th>Avg<br>CPU<br>Time<br>(secs)</th>
PRO <th>%CPU</th>
PRO <th>IO<br>Time<br>(secs)</th>
PRO <th>%IO</th>
PRO <th>Conc<br>Time<br>(secs)</th>
PRO <th>%Conc</th>
PRO <th>Appl<br>Time<br>(secs)</th>
PRO <th>%Appl</th>
PRO <th>Clus<br>Time<br>(secs)</th>
PRO <th>%Clus</th>
PRO <th>PLSQL<br>Time<br>(secs)</th>
PRO <th>%PLSQL</th>
PRO <th>Java<br>Time<br>(secs)</th>
PRO <th>Optimizer<br>Mode</th>
PRO <th>Cost</th>
PRO <th>Opt Env HV</th>
PRO <th>Parsing<br>Schema<br>Name</th>
PRO <th>Module</th>
PRO <th>Action</th>
PRO <th>Profile</th>
PRO <th>Patch</th>
PRO </tr>
PRO
SELECT '<!-- '||TO_CHAR(SYSDATE, 'YYYY-MM-DD/HH24:MI:SS')||' -->' FROM dual;
PRO <!-- Please Wait -->

SELECT CHR(10)||'<tr>'||CHR(10)||
       '<td class="r">'||ROWNUM||'</td>'||CHR(10)||
       '<td class="r">'||v.snap_id||'</td>'||CHR(10)||
       '<td>'
             ||case when v.begin_interval_time < to_date('^^ebr_date.','YYYY-MM-DD/HH24:MI:SS') then 'pre-ebr' 
                    else 'post-ebr' end ||'</td>'||CHR(10)||        
       '<td nowrap>'||TO_CHAR(v.end_interval_time, 'YYYY-MM-DD/HH24:MI:SS')||'</td>'||CHR(10)||
       '<td class="r">'||v.instance_number||'</td>'||CHR(10)||
       '<td class="r">'||v.plan_hash_value||'</td>'||CHR(10)||
       '<td class="r">'||v.version_count||'</td>'||CHR(10)||
       '<td class="r">'||v.executions_delta||'</td>'||CHR(10)||
       '<td class="r">'||v.fetches_delta||'</td>'||CHR(10)||
       '<td class="r">'||v.loads_delta||'</td>'||CHR(10)||
       '<td class="r">'||v.invalidations_delta||'</td>'||CHR(10)||
       '<td class="r">'||v.parse_calls_delta||'</td>'||CHR(10)||
       '<td class="r">'||v.buffer_gets_delta||'</td>'||CHR(10)||
       '<td class="r">'||round(v.buffer_gets_delta/GREATEST(v.executions_delta, 1))||'</td>'||CHR(10)||
       '<td class="r">'||v.disk_reads_delta||'</td>'||CHR(10)||
       '<td class="r">'||round(v.disk_reads_delta/GREATEST(v.executions_delta, 1))||'</td>'||CHR(10)||
       '<td class="r">'||v.direct_writes_delta||'</td>'||CHR(10)||
       '<td class="r">'||v.rows_processed_delta||'</td>'||CHR(10)||
       '<td class="r">'||round(v.rows_processed_delta/GREATEST(v.executions_delta, 1))||'</td>'||CHR(10)||
       '<td class="r">'||TO_CHAR(ROUND(v.elapsed_time_delta / 1e6, 3), '99999999999990D990')||'</td>'||CHR(10)||
       '<td class="r">'||TO_CHAR(ROUND(v.elapsed_time_delta / 1e6 / GREATEST(v.executions_delta, 1), 3), '99999999999990D990')||'</td>'||CHR(10)||
       '<td class="r">'||TO_CHAR(ROUND(v.cpu_time_delta / 1e6, 3), '99999999999990D990')||'</td>'||CHR(10)||
       '<td class="r">'||TO_CHAR(ROUND(v.cpu_time_delta / 1e6 / GREATEST(v.executions_delta, 1), 3), '99999999999990D990')||'</td>'||CHR(10)||
       '<td class="r">'||TO_CHAR(ROUND(100*(v.cpu_time_delta/GREATEST(v.elapsed_time_delta, 1)), 2), '990D90')||'</td>'||CHR(10)||
       '<td class="r">'||TO_CHAR(ROUND(v.iowait_delta / 1e6, 3), '99999999999990D990')||'</td>'||CHR(10)||
       '<td class="r">'||TO_CHAR(ROUND(100*(v.iowait_delta/GREATEST(v.elapsed_time_delta, 1)), 2), '990D90')||'</td>'||CHR(10)||
       '<td class="r">'||TO_CHAR(ROUND(v.ccwait_delta / 1e6, 3), '99999999999990D990')||'</td>'||CHR(10)||
       '<td class="r">'||TO_CHAR(ROUND(100*(v.ccwait_delta/GREATEST(v.elapsed_time_delta, 1)), 2), '990D90')||'</td>'||CHR(10)||
       '<td class="r">'||TO_CHAR(ROUND(v.apwait_delta / 1e6, 3), '99999999999990D990')||'</td>'||CHR(10)||
       '<td class="r">'||TO_CHAR(ROUND(100*(v.apwait_delta/GREATEST(v.elapsed_time_delta, 1)), 2), '990D90')||'</td>'||CHR(10)||
       '<td class="r">'||TO_CHAR(ROUND(v.clwait_delta / 1e6, 3), '99999999999990D990')||'</td>'||CHR(10)||
       '<td class="r">'||TO_CHAR(ROUND(100*(v.clwait_delta/GREATEST(v.elapsed_time_delta, 1)), 2), '990D90')||'</td>'||CHR(10)||
       '<td class="r">'||TO_CHAR(ROUND(v.plsexec_time_delta / 1e6, 3), '99999999999990D990')||'</td>'||CHR(10)||
       '<td class="r">'||TO_CHAR(ROUND(100*(v.plsexec_time_delta/GREATEST(v.elapsed_time_delta, 1)), 2), '990D90')||'</td>'||CHR(10)||
       '<td class="r">'||TO_CHAR(ROUND(v.javexec_time_delta / 1e6, 3), '99999999999990D990')||'</td>'||CHR(10)||
       '<td>'||v.optimizer_mode||'</td>'||CHR(10)||
       '<td class="r">'||v.optimizer_cost||'</td>'||CHR(10)||
       '<td class="r">'||v.optimizer_env_hash_value||'</td>'||CHR(10)||
       '<td>'||v.parsing_schema_name||'</td>'||CHR(10)||
       '<td>'||v.module||'</td>'||CHR(10)||
       '<td>'||v.action||'</td>'||CHR(10)||
       '<td>'||v.sql_profile||'</td>'||CHR(10)||
       '<td>'||v.sql_patch||'</td>'||CHR(10)||
       '</tr>'
  FROM (
SELECT /*+ NO_MERGE */
       h.snap_id,
       s.begin_interval_time,
       s.end_interval_time,
       h.instance_number,
       h.plan_hash_value,
       h.optimizer_cost,
       h.optimizer_mode,
       h.optimizer_env_hash_value,
       h.version_count,
       h.module,
       h.action,
       h.sql_profile,
       (select replace(extractvalue(xmltype(other_xml), '/*/info[@type = "sql_patch"]'), '"', '') from dba_hist_sql_plan sp where sp.dbid = ^^dbid. and sp.sql_id = h.sql_id and other_xml is not null and sp.plan_hash_value = h.plan_hash_value and rownum=1) sql_patch,
       h.parsing_schema_name,
       h.fetches_delta,
       h.executions_delta,
       h.loads_delta,
       h.invalidations_delta,
       h.parse_calls_delta,
       h.disk_reads_delta,
       h.buffer_gets_delta,
       h.rows_processed_delta,
       h.cpu_time_delta,
       h.elapsed_time_delta,
       h.iowait_delta,
       h.clwait_delta,
       h.apwait_delta,
       h.ccwait_delta,
       h.direct_writes_delta,
       h.plsexec_time_delta,
       h.javexec_time_delta
  FROM dba_hist_sqlstat h,
       dba_hist_snapshot s
 WHERE 1=1
   AND h.dbid = ^^dbid.
   AND h.sql_id = :sql_id
   AND h.snap_id = s.snap_id
   AND h.dbid = s.dbid
   AND h.instance_number = s.instance_number
   AND (:license IN ('T', 'D') or (:license = 'L' and s.begin_interval_time > systimestamp - interval '^^days.' day))
 ORDER BY
       s.end_interval_time,
       h.instance_number,
       h.plan_hash_value ) v;

PRO
PRO <tr>
PRO <th>#</th>
PRO <th>Snap<br>ID</th>
PRO <th>Pre/Post<br>EBR</th>
PRO <th>Snaphot</th>
PRO <th>Inst<br>ID</th>
PRO <th>Plan HV</th>
PRO <th>Vers<br>Cnt</th>
PRO <th>Execs</th>
PRO <th>Fetch</th>
PRO <th>Loads</th>
PRO <th>Inval</th>
PRO <th>Parse<br>Calls</th>
PRO <th>Buffer<br>Gets</th>
PRO <th>Avg<br>Buffer<br>Gets</th>
PRO <th>Disk<br>Reads</th>
PRO <th>Avg<br>Disk<br>Reads</th>
PRO <th>Direct<br>Writes</th>
PRO <th>Rows<br>Proc</th>
PRO <th>Avg<br>Rows</th>
PRO <th>Elapsed<br>Time<br>(secs)</th>
PRO <th>Avg<br>Elapsed<br>Time<br>(secs)</th>
PRO <th>CPU<br>Time<br>(secs)</th>
PRO <th>Avg<br>CPU<br>Time<br>(secs)</th>
PRO <th>%CPU</th>
PRO <th>IO<br>Time<br>(secs)</th>
PRO <th>%IO</th>
PRO <th>Conc<br>Time<br>(secs)</th>
PRO <th>%Conc</th>
PRO <th>Appl<br>Time<br>(secs)</th>
PRO <th>%Appl</th>
PRO <th>Clus<br>Time<br>(secs)</th>
PRO <th>%Clus</th>
PRO <th>PLSQL<br>Time<br>(secs)</th>
PRO <th>%PLSQL</th>
PRO <th>Java<br>Time<br>(secs)</th>
PRO <th>Optimizer<br>Mode</th>
PRO <th>Cost</th>
PRO <th>Opt Env HV</th>
PRO <th>Parsing<br>Schema<br>Name</th>
PRO <th>Module</th>
PRO <th>Action</th>
PRO <th>Profile</th>
PRO <th>Patch</th>
PRO </tr>
PRO
PRO </table>

select round((sysdate-to_date(:start_time,'dd-mon-rr hh24:mi:ss'))*86400) diff from dual;
PRO <table style="width:100%"><tr><td style="text-align:right; background-color:#ffffff">Time taken: ^^diff. seconds</td></tr></table>
PRO </details><!--Pushkar-->
exec :start_time := to_char(sysdate,'dd-mon-rr hh24:mi:ss');
/* -------------------------
 *
 * dba_hist_sqlstat sql statistics
 *
 * ------------------------- */
PRO <a name="awr_stats_t"></a><details><br/><summary id="summary2">Historical SQL Statistics - Total (DBA_HIST_SQLSTAT)</summary>
PRO
PRO Performance metrics of Execution Plans of ^^sql_id..<br>
PRO This section includes data captured by AWR. If this is a stand-by read-only database then the AWR information below is from the Primary database.
PRO
PRO <table>
PRO
PRO <tr>
PRO <th>#</th>
PRO <th>Snap<br>ID</th>
PRO <th>Pre/Post<br>EBR</th>
PRO <th>Snaphot</th>
PRO <th>Inst<br>ID</th>
PRO <th>Plan HV</th>
PRO <th>Vers<br>Cnt</th>
PRO <th>Execs</th>
PRO <th>Fetch</th>
PRO <th>Loads</th>
PRO <th>Inval</th>
PRO <th>Parse<br>Calls</th>
PRO <th>Buffer<br>Gets</th>
PRO <th>Disk<br>Reads</th>
PRO <th>Direct<br>Writes</th>
PRO <th>Rows<br>Proc</th>
PRO <th>Elapsed<br>Time<br>(secs)</th>
PRO <th>CPU<br>Time<br>(secs)</th>
PRO <th>IO<br>Time<br>(secs)</th>
PRO <th>Conc<br>Time<br>(secs)</th>
PRO <th>Appl<br>Time<br>(secs)</th>
PRO <th>Clus<br>Time<br>(secs)</th>
PRO <th>PLSQL<br>Time<br>(secs)</th>
PRO <th>Java<br>Time<br>(secs)</th>
PRO <th>Optimizer<br>Mode</th>
PRO <th>Cost</th>
PRO <th>Opt Env HV</th>
PRO <th>Parsing<br>Schema<br>Name</th>
PRO <th>Module</th>
PRO <th>Action</th>
PRO <th>Profile</th>
PRO <th>Patch</th>
PRO </tr>
PRO
SELECT '<!-- '||TO_CHAR(SYSDATE, 'YYYY-MM-DD/HH24:MI:SS')||' -->' FROM dual;
PRO <!-- Please Wait -->

SELECT CHR(10)||'<tr>'||CHR(10)||
       '<td class="r">'||ROWNUM||'</td>'||CHR(10)||
       '<td class="r">'||v.snap_id||'</td>'||CHR(10)||
       '<td>'
             ||case when v.begin_interval_time < to_date('^^ebr_date.','YYYY-MM-DD/HH24:MI:SS') then 'pre-ebr' 
                    else 'post-ebr' end ||'</td>'||CHR(10)||        
       '<td nowrap>'||TO_CHAR(v.end_interval_time, 'YYYY-MM-DD/HH24:MI:SS')||'</td>'||CHR(10)||
       '<td class="r">'||v.instance_number||'</td>'||CHR(10)||
       '<td class="r">'||v.plan_hash_value||'</td>'||CHR(10)||
       '<td class="r">'||v.version_count||'</td>'||CHR(10)||
       '<td class="r">'||v.executions_total||'</td>'||CHR(10)||
       '<td class="r">'||v.fetches_total||'</td>'||CHR(10)||
       '<td class="r">'||v.loads_total||'</td>'||CHR(10)||
       '<td class="r">'||v.invalidations_total||'</td>'||CHR(10)||
       '<td class="r">'||v.parse_calls_total||'</td>'||CHR(10)||
       '<td class="r">'||v.buffer_gets_total||'</td>'||CHR(10)||
       '<td class="r">'||v.disk_reads_total||'</td>'||CHR(10)||
       '<td class="r">'||v.direct_writes_total||'</td>'||CHR(10)||
       '<td class="r">'||v.rows_processed_total||'</td>'||CHR(10)||
       '<td class="r">'||TO_CHAR(ROUND(v.elapsed_time_total / 1e6, 3), '99999999999990D990')||'</td>'||CHR(10)||
       '<td class="r">'||TO_CHAR(ROUND(v.cpu_time_total / 1e6, 3), '99999999999990D990')||'</td>'||CHR(10)||
       '<td class="r">'||TO_CHAR(ROUND(v.iowait_total / 1e6, 3), '99999999999990D990')||'</td>'||CHR(10)||
       '<td class="r">'||TO_CHAR(ROUND(v.ccwait_total / 1e6, 3), '99999999999990D990')||'</td>'||CHR(10)||
       '<td class="r">'||TO_CHAR(ROUND(v.apwait_total / 1e6, 3), '99999999999990D990')||'</td>'||CHR(10)||
       '<td class="r">'||TO_CHAR(ROUND(v.clwait_total / 1e6, 3), '99999999999990D990')||'</td>'||CHR(10)||
       '<td class="r">'||TO_CHAR(ROUND(v.plsexec_time_total / 1e6, 3), '99999999999990D990')||'</td>'||CHR(10)||
       '<td class="r">'||TO_CHAR(ROUND(v.javexec_time_total / 1e6, 3), '99999999999990D990')||'</td>'||CHR(10)||
       '<td>'||v.optimizer_mode||'</td>'||CHR(10)||
       '<td class="r">'||v.optimizer_cost||'</td>'||CHR(10)||
       '<td class="r">'||v.optimizer_env_hash_value||'</td>'||CHR(10)||
       '<td>'||v.parsing_schema_name||'</td>'||CHR(10)||
       '<td>'||v.module||'</td>'||CHR(10)||
       '<td>'||v.action||'</td>'||CHR(10)||
       '<td>'||v.sql_profile||'</td>'||CHR(10)||
       '<td>'||v.sql_patch||'</td>'||CHR(10)||
       '</tr>'
  FROM (
SELECT /*+ NO_MERGE */
       h.snap_id,
       s.begin_interval_time,
       s.end_interval_time,
       h.instance_number,
       h.plan_hash_value,
       h.optimizer_cost,
       h.optimizer_mode,
       h.optimizer_env_hash_value,
       h.version_count,
       h.module,
       h.action,
       h.sql_profile,
       (select replace(extractvalue(xmltype(other_xml), '/*/info[@type = "sql_patch"]'), '"', '') from dba_hist_sql_plan sp where sp.dbid = ^^dbid. and sp.sql_id = h.sql_id and other_xml is not null and sp.plan_hash_value = h.plan_hash_value and rownum=1) sql_patch,
       h.parsing_schema_name,
       h.fetches_total,
       h.executions_total,
       h.loads_total,
       h.invalidations_total,
       h.parse_calls_total,
       h.disk_reads_total,
       h.buffer_gets_total,
       h.rows_processed_total,
       h.cpu_time_total,
       h.elapsed_time_total,
       h.iowait_total,
       h.clwait_total,
       h.apwait_total,
       h.ccwait_total,
       h.direct_writes_total,
       h.plsexec_time_total,
       h.javexec_time_total
  FROM dba_hist_sqlstat h,
       dba_hist_snapshot s
 WHERE 1=1
   AND h.dbid = ^^dbid.
   AND h.sql_id = :sql_id
   AND h.snap_id = s.snap_id
   AND h.dbid = s.dbid
   AND h.instance_number = s.instance_number
   AND (:license IN ('T', 'D') or (:license = 'L' and s.begin_interval_time > systimestamp - interval '^^days.' day))
 ORDER BY
       s.end_interval_time,
       h.instance_number,
       h.plan_hash_value ) v;

PRO
PRO <tr>
PRO <th>#</th>
PRO <th>Snap<br>ID</th>
PRO <th>Pre/Post<br>EBR</th>
PRO <th>Snaphot</th>
PRO <th>Inst<br>ID</th>
PRO <th>Plan HV</th>
PRO <th>Vers<br>Cnt</th>
PRO <th>Execs</th>
PRO <th>Fetch</th>
PRO <th>Loads</th>
PRO <th>Inval</th>
PRO <th>Parse<br>Calls</th>
PRO <th>Buffer<br>Gets</th>
PRO <th>Disk<br>Reads</th>
PRO <th>Direct<br>Writes</th>
PRO <th>Rows<br>Proc</th>
PRO <th>Elapsed<br>Time<br>(secs)</th>
PRO <th>CPU<br>Time<br>(secs)</th>
PRO <th>IO<br>Time<br>(secs)</th>
PRO <th>Conc<br>Time<br>(secs)</th>
PRO <th>Appl<br>Time<br>(secs)</th>
PRO <th>Clus<br>Time<br>(secs)</th>
PRO <th>PLSQL<br>Time<br>(secs)</th>
PRO <th>Java<br>Time<br>(secs)</th>
PRO <th>Optimizer<br>Mode</th>
PRO <th>Cost</th>
PRO <th>Opt Env HV</th>
PRO <th>Parsing<br>Schema<br>Name</th>
PRO <th>Module</th>
PRO <th>Action</th>
PRO <th>Profile</th>
PRO <th>Patch</th>
PRO </tr>
PRO
PRO </table>

select round((sysdate-to_date(:start_time,'dd-mon-rr hh24:mi:ss'))*86400) diff from dual;
PRO <table style="width:100%"><tr><td style="text-align:right; background-color:#ffffff">Time taken: ^^diff. seconds</td></tr></table>
PRO </details><!--Pushkar-->
exec :start_time := to_char(sysdate,'dd-mon-rr hh24:mi:ss');
/* -------------------------
 *
 * gv$active_session_history by plan
 *
 * Uday: added percentage column
 * ------------------------- */
EXEC DBMS_APPLICATION_INFO.SET_CLIENT_INFO('^^method.: GV$ASH by Plan - ' || TO_CHAR(SYSDATE, 'YYYY-MM-DD/HH24:MI:SS'));
PRO <a name="ash_plan"></a><details open><br/><summary id="summary2">Active Session History by Plan (GV$ACTIVE_SESSION_HISTORY)</summary>
PRO
PRO Snapshots counts per Plan and Wait Event for ^^sql_id..<br>
PRO This section includes data captured by AWR.
PRO
PRO <table>
PRO
PRO <tr>
PRO <th>#</th>
PRO <th>Plan<br>Hash<br>Value</th>
PRO <th>Session<br>State</th>
PRO <th>Wait<br>Class</th>
PRO <th>Event</th>
PRO <th>Phase</th>
PRO <th>Snaps<br>Count</th>
PRO <th>% PHV</th>
PRO <th>% PHV+Event</th>
PRO <th>Sampled<br>Executions</th>
PRO <th>Max PGA<br>(MB)</th>
PRO <th>Max Temp<br>(MB)</th>
PRO </tr>
PRO
SELECT '<!-- '||TO_CHAR(SYSDATE, 'YYYY-MM-DD/HH24:MI:SS')||' -->' FROM dual;
PRO <!-- Please Wait -->

SELECT CHR(10)||'<tr>'||CHR(10)||
       '<td class="r">'||ROWNUM||'</td>'||CHR(10)||
       '<td class="r">'||v.sql_plan_hash_value||'</td>'||CHR(10)||
       '<td>'||v.session_state||'</td>'||CHR(10)||
       '<td>'||v.wait_class||'</td>'||CHR(10)||
       '<td>'||v.event||'</td>'||CHR(10)||
       '<td>'||v.phase||'</td>'||CHR(10)||
       '<td class="r">'||v.snaps_count||'</td>'||CHR(10)||
       '<td class="r">'||v.phv_pct||'</td>'||CHR(10)||
       '<td class="r">'||v.phv_event_pct||'</td>'||CHR(10)||
       '<td class="r">'||v.sampled_execs||'</td>'||CHR(10)||
       '<td class="r">'||v.max_pga||'</td>'||CHR(10)||
       '<td class="r">'||v.max_temp||'</td>'||CHR(10)||
       '</tr>'
  FROM (
SELECT /*+ NO_MERGE */
       ash.sql_plan_hash_value,
       ash.session_state,
       ash.wait_class,
       nvl(ash.event, 'On CPU/Waiting for CPU') event
       , CASE WHEN IN_CONNECTION_MGMT     = 'Y' THEN 'CONNECTION_MGMT '     END ||
         CASE WHEN IN_PARSE               = 'Y' THEN 'PARSE '               END ||
         CASE WHEN IN_HARD_PARSE          = 'Y' THEN 'HARD_PARSE '          END ||
         CASE WHEN IN_SQL_EXECUTION       = 'Y' THEN 'SQL_EXECUTION '       END ||
         CASE WHEN IN_PLSQL_EXECUTION     = 'Y' THEN 'PLSQL_EXECUTION '     END ||
         CASE WHEN IN_PLSQL_RPC           = 'Y' THEN 'PLSQL_RPC '           END ||
         CASE WHEN IN_PLSQL_COMPILATION   = 'Y' THEN 'PLSQL_COMPILATION '   END ||
         CASE WHEN IN_JAVA_EXECUTION      = 'Y' THEN 'JAVA_EXECUTION '      END ||
         CASE WHEN IN_BIND                = 'Y' THEN 'BIND '                END ||
         CASE WHEN IN_CURSOR_CLOSE        = 'Y' THEN 'CURSOR_CLOSE '        END ||
         CASE WHEN IN_SEQUENCE_LOAD       = 'Y' THEN 'SEQUENCE_LOAD '       END phase,
       COUNT(*) snaps_count,
       -- ROUND((RATIO_TO_REPORT(COUNT(*)) over())*100, 2) PCT
       round((sum(COUNT(*)) over(partition by ash.sql_plan_hash_value)/sum(COUNT(*)) over())*100, 2) phv_pct,
       ROUND((RATIO_TO_REPORT(COUNT(*)) over(partition by ash.sql_plan_hash_value))*100, 2) phv_event_pct
       , count(distinct ash.inst_id||ash.sql_exec_start) sampled_execs  -- uday psrv10
       , max(pga_allocated/1024/1024) max_pga  -- uday psrv10
       , max(temp_space_allocated/1024/1024) max_temp  -- uday psrv10
  FROM gv$active_session_history ash
 WHERE :license IN ('T', 'D', 'L')
   AND ash.sql_id = :sql_id
 GROUP BY
       ash.sql_plan_hash_value,
       ash.session_state,
       ash.wait_class,
       nvl(ash.event, 'On CPU/Waiting for CPU') 
       , CASE WHEN IN_CONNECTION_MGMT     = 'Y' THEN 'CONNECTION_MGMT '     END ||
         CASE WHEN IN_PARSE               = 'Y' THEN 'PARSE '               END ||
         CASE WHEN IN_HARD_PARSE          = 'Y' THEN 'HARD_PARSE '          END ||
         CASE WHEN IN_SQL_EXECUTION       = 'Y' THEN 'SQL_EXECUTION '       END ||
         CASE WHEN IN_PLSQL_EXECUTION     = 'Y' THEN 'PLSQL_EXECUTION '     END ||
         CASE WHEN IN_PLSQL_RPC           = 'Y' THEN 'PLSQL_RPC '           END ||
         CASE WHEN IN_PLSQL_COMPILATION   = 'Y' THEN 'PLSQL_COMPILATION '   END ||
         CASE WHEN IN_JAVA_EXECUTION      = 'Y' THEN 'JAVA_EXECUTION '      END ||
         CASE WHEN IN_BIND                = 'Y' THEN 'BIND '                END ||
         CASE WHEN IN_CURSOR_CLOSE        = 'Y' THEN 'CURSOR_CLOSE '        END ||
         CASE WHEN IN_SEQUENCE_LOAD       = 'Y' THEN 'SEQUENCE_LOAD '       END 
 ORDER BY
       ash.sql_plan_hash_value,
       5 DESC,
       ash.session_state,
       ash.wait_class,
       event ) v;

PRO
PRO <tr>
PRO <th>#</th>
PRO <th>Plan<br>Hash<br>Value</th>
PRO <th>Session<br>State</th>
PRO <th>Wait<br>Class</th>
PRO <th>Event</th>
PRO <th>Phase</th>
PRO <th>Snaps<br>Count</th>
PRO <th>% PHV</th>
PRO <th>% PHV+Event</th>
PRO <th>Sampled<br>Executions</th>
PRO <th>Max PGA<br>(MB)</th>
PRO <th>Max Temp<br>(MB)</th>
PRO </tr>
PRO
PRO </table>

select round((sysdate-to_date(:start_time,'dd-mon-rr hh24:mi:ss'))*86400) diff from dual;
PRO <table style="width:100%"><tr><td style="text-align:right; background-color:#ffffff">Time taken: ^^diff. seconds</td></tr></table>
PRO </details><!--Pushkar-->
exec :start_time := to_char(sysdate,'dd-mon-rr hh24:mi:ss');
/* -------------------------
 *
 * gv$active_session_history by plan line
 *
 * Uday: added percentage column
 * ------------------------- */
EXEC DBMS_APPLICATION_INFO.SET_CLIENT_INFO('^^method.: GV$ASH by Plan Line - ' || TO_CHAR(SYSDATE, 'YYYY-MM-DD/HH24:MI:SS'));
PRO <a name="ash_line"></a><details open><br/><summary id="summary2">Active Session History by Plan Line (GV$ACTIVE_SESSION_HISTORY)</summary>
PRO
PRO Snapshots counts per Plan Line and Wait Event for ^^sql_id..<br>
PRO This section includes data captured by AWR.<br>
PRO Available on 11g or higher..
PRO
PRO <table>
PRO
PRO <tr>
PRO <th>#</th>
PRO <th>Plan<br>Hash<br>Value</th>
PRO <th>Plan<br>Line<br>ID</th>
PRO <th>Plan<br>Operation</th>
PRO <th>Plan<br>Options</th>
PRO <th>Plan<br>Object<br>Owner</th>
PRO <th>Plan<br>Object<br>Name</th>
PRO <th>Session<br>State</th>
PRO <th>Wait<br>Class</th>
PRO <th>Event</th>
PRO <th>Curr<br>Obj<br>ID</th>
PRO <th>Curr<br>Object<br>Name</th>
PRO <th>Snaps<br>Count</th>
PRO <th>% PHV+Plan Line</th>
PRO <th>Sampled<br>Executions</th>
PRO </tr>
PRO
SELECT '<!-- '||TO_CHAR(SYSDATE, 'YYYY-MM-DD/HH24:MI:SS')||' -->' FROM dual;
PRO <!-- Please Wait -->

SELECT CHR(10)||'<tr>'||CHR(10)||
       '<td class="r">'||ROWNUM||'</td>'||CHR(10)||
       '<td class="r">'||v.sql_plan_hash_value||'</td>'||CHR(10)||
       '<td class="r">'||v.sql_plan_line_id||'</td>'||CHR(10)||
       '<td>'||v.sql_plan_operation||'</td>'||CHR(10)||
       '<td>'||v.sql_plan_options||'</td>'||CHR(10)||
       '<td>'||v.object_owner||'</td>'||CHR(10)||
       '<td>'||v.object_name||'</td>'||CHR(10)||
       '<td>'||v.session_state||'</td>'||CHR(10)||
       '<td>'||v.wait_class||'</td>'||CHR(10)||
       '<td>'||v.event||'</td>'||CHR(10)||
       '<td class="r">'||v.current_obj#||'</td>'||CHR(10)||
       '<td>'||v.current_obj_name||'</td>'||CHR(10)||
       '<td class="r">'||v.snaps_count||'</td>'||CHR(10)||
       '<td class="r">'||v.pct||'</td>'||CHR(10)||
       '<td class="r">'||v.sampled_execs||'</td>'||CHR(10)||
       '</tr>'
  FROM (
SELECT /*+ NO_MERGE */
       ash.sql_plan_hash_value,
       ash.sql_plan_line_id,
       ash.sql_plan_operation,
       ash.sql_plan_options,
       ash.object_owner,
       ash.object_name,
       ash.current_obj#,
       CASE
         WHEN ash.current_obj# IS NOT NULL THEN
           (SELECT obj.owner||'.'||obj.object_name||NVL2(obj.subobject_name, '.'||obj.subobject_name, NULL)
              FROM dba_objects obj
             WHERE obj.object_id = ash.current_obj#)
       END current_obj_name,
       ash.session_state,
       ash.wait_class,
       ash.event,
       COUNT(*) snaps_count,
       -- ROUND((RATIO_TO_REPORT(COUNT(*)) over())*100, 2) PCT
       ROUND((RATIO_TO_REPORT(COUNT(*)) over(partition by ash.sql_plan_hash_value))*100, 2) PCT
       , count(distinct ash.inst_id||ash.sql_exec_start) sampled_execs  -- uday psrv10
  FROM (
        SELECT /*+ NO_MERGE */
               sh.inst_id,
               sh.sql_exec_start,
               sh.sql_plan_hash_value,
               sh.sql_plan_line_id,
               sh.sql_plan_operation,
               sh.sql_plan_options,
               CASE
                 WHEN sh.wait_class IN ('Application', 'Cluster', 'Concurrency', 'User I/O') THEN
                   sh.current_obj#
               END current_obj#,
               sh.session_state,
               sh.wait_class,
               nvl(sh.event, 'On CPU/Waiting for CPU') event,
               sp.object_owner,
               sp.object_name
          FROM gv$active_session_history sh,
               gv$sql_plan sp
         WHERE :license IN ('T', 'D', 'L')
           AND sh.sql_id = :sql_id
           AND sh.sql_plan_line_id > 0
           AND sp.inst_id(+) = sh.inst_id
           AND sp.sql_id(+) = sh.sql_id
           AND sp.child_number(+) = sh.sql_child_number
           AND sp.plan_hash_value(+) = sh.sql_plan_hash_value
           AND sp.id(+) = sh.sql_plan_line_id 
       ) ash
 GROUP BY
       ash.sql_plan_hash_value,
       ash.sql_plan_line_id,
       ash.sql_plan_operation,
       ash.sql_plan_options,
       ash.object_owner,
       ash.object_name,
       ash.session_state,
       ash.wait_class,
       ash.current_obj#,
       ash.event
 ORDER BY
       ash.sql_plan_hash_value,
       ash.sql_plan_line_id,
       12 DESC,
       ash.sql_plan_operation,
       ash.sql_plan_options,
       ash.object_owner,
       ash.object_name,
       ash.session_state,
       ash.wait_class,
       ash.current_obj#,
       ash.event ) v;

PRO
PRO <tr>
PRO <th>#</th>
PRO <th>Plan<br>Hash<br>Value</th>
PRO <th>Plan<br>Line<br>ID</th>
PRO <th>Plan<br>Operation</th>
PRO <th>Plan<br>Options</th>
PRO <th>Plan<br>Object<br>Owner</th>
PRO <th>Plan<br>Object<br>Name</th>
PRO <th>Session<br>State</th>
PRO <th>Wait<br>Class</th>
PRO <th>Event</th>
PRO <th>Curr<br>Obj<br>ID</th>
PRO <th>Curr<br>Object<br>Name</th>
PRO <th>Snaps<br>Count</th>
PRO <th>% PHV+Plan Line</th>
PRO <th>Sampled<br>Executions</th>
PRO </tr>
PRO
PRO </table>

select round((sysdate-to_date(:start_time,'dd-mon-rr hh24:mi:ss'))*86400) diff from dual;
PRO <table style="width:100%"><tr><td style="text-align:right; background-color:#ffffff">Time taken: ^^diff. seconds</td></tr></table>
PRO </details><!--Pushkar-->
exec :start_time := to_char(sysdate,'dd-mon-rr hh24:mi:ss');
/* -------------------------
 *
 * dba_hist_active_sess_history by plan
 *
 * Uday: added percentage column
 * Uday.v6.Aug2016: added snaps subquery to improve performance
 * ------------------------- */
EXEC DBMS_APPLICATION_INFO.SET_CLIENT_INFO('^^method.: DBA_HIST_ASH by Plan - ' || TO_CHAR(SYSDATE, 'YYYY-MM-DD/HH24:MI:SS'));
PRO <a name="awr_plan"></a><details open><br/><summary id="summary2">AWR Active Session History by Plan (DBA_HIST_ACTIVE_SESS_HISTORY)</summary>
PRO
PRO Snapshots counts per Plan and Wait Event for ^^sql_id..<br>
PRO This section includes data captured by AWR. If this is a stand-by read-only database then the AWR information below is from the Primary database.
PRO
PRO <table>
PRO
PRO <tr>
PRO <th>#</th>
PRO <th>Plan<br>Hash<br>Value</th>
PRO <th>Session<br>State</th>
PRO <th>Wait<br>Class</th>
PRO <th>Event</th>
PRO <th>Phase</th>
PRO <th>Snaps<br>Count</th>
PRO <th>% PHV</th>
PRO <th>% PHV+Event</th>
PRO <th>Sampled<br>Executions</th>
PRO <th>Max PGA<br>(MB)</th>
PRO <th>Max Temp<br>(MB)</th>
PRO </tr>
PRO
SELECT '<!-- '||TO_CHAR(SYSDATE, 'YYYY-MM-DD/HH24:MI:SS')||' -->' FROM dual;
PRO <!-- Please Wait -->

-- Uday.PSR.v6
-- added below plsql block to fetch ASH in AWR using snap_id range
-- otherwise, we are doing FTS of dba_hist_active_sess_history that has 172m rows in crmap
--
variable minsnap number
variable maxsnap number

exec :minsnap := -1;
exec :maxsnap := -1;

begin
  select min(h.snap_id) minsnap, max(h.snap_id) maxsnap
    into :minsnap, :maxsnap
    from dba_hist_sqlstat h,
       dba_hist_snapshot s 
   where sql_id = :sql_id
     and (:license IN ('T', 'D') or (:license = 'L' and s.begin_interval_time > systimestamp - interval '^^days.' day))
     and h.dbid = ^^dbid.
     and h.snap_id = s.snap_id
     and h.dbid = s.dbid
     and h.instance_number = s.instance_number
   group by sql_id;
exception 
  when others then null;
end;
/


SELECT CHR(10)||'<tr>'||CHR(10)||
       '<td class="r">'||ROWNUM||'</td>'||CHR(10)||
       '<td class="r">'||v.sql_plan_hash_value||'</td>'||CHR(10)||
       '<td>'||v.session_state||'</td>'||CHR(10)||
       '<td>'||v.wait_class||'</td>'||CHR(10)||
       '<td>'||v.event||'</td>'||CHR(10)||
       '<td>'||v.phase||'</td>'||CHR(10)||
       '<td class="r">'||v.snaps_count||'</td>'||CHR(10)||
       '<td class="r">'||v.phv_pct||'</td>'||CHR(10)||
       '<td class="r">'||v.phv_event_pct||'</td>'||CHR(10)||
       '<td class="r">'||v.sampled_execs||'</td>'||CHR(10)||
       '<td class="r">'||v.max_pga||'</td>'||CHR(10)||
       '<td class="r">'||v.max_temp||'</td>'||CHR(10)||
       '</tr>'
  FROM (
SELECT /*+ NO_MERGE */
       ash.sql_plan_hash_value,
       ash.session_state,
       ash.wait_class,
       nvl(ash.event, 'On CPU/Waiting for CPU') event
       , CASE WHEN IN_CONNECTION_MGMT     = 'Y' THEN 'CONNECTION_MGMT '     END ||
         CASE WHEN IN_PARSE               = 'Y' THEN 'PARSE '               END ||
         CASE WHEN IN_HARD_PARSE          = 'Y' THEN 'HARD_PARSE '          END ||
         CASE WHEN IN_SQL_EXECUTION       = 'Y' THEN 'SQL_EXECUTION '       END ||
         CASE WHEN IN_PLSQL_EXECUTION     = 'Y' THEN 'PLSQL_EXECUTION '     END ||
         CASE WHEN IN_PLSQL_RPC           = 'Y' THEN 'PLSQL_RPC '           END ||
         CASE WHEN IN_PLSQL_COMPILATION   = 'Y' THEN 'PLSQL_COMPILATION '   END ||
         CASE WHEN IN_JAVA_EXECUTION      = 'Y' THEN 'JAVA_EXECUTION '      END ||
         CASE WHEN IN_BIND                = 'Y' THEN 'BIND '                END ||
         CASE WHEN IN_CURSOR_CLOSE        = 'Y' THEN 'CURSOR_CLOSE '        END ||
         CASE WHEN IN_SEQUENCE_LOAD       = 'Y' THEN 'SEQUENCE_LOAD '       END phase,
       COUNT(*) snaps_count,
       -- ROUND((RATIO_TO_REPORT(COUNT(*)) over())*100, 2) PCT
       round((sum(COUNT(*)) over(partition by ash.sql_plan_hash_value)/sum(COUNT(*)) over())*100, 2) phv_pct,
       ROUND((RATIO_TO_REPORT(COUNT(*)) over(partition by ash.sql_plan_hash_value))*100, 2) phv_event_pct
       , count(distinct ash.instance_number||ash.sql_exec_start) sampled_execs  -- uday psrv10
       , max(pga_allocated/1024/1024) max_pga  -- uday psrv10
       , max(temp_space_allocated/1024/1024) max_temp  -- uday psrv10
  FROM dba_hist_active_sess_history ash
 WHERE :license IN ('T', 'D', 'L')
   AND ash.dbid = ^^dbid.
   and ash.sql_id = :sql_id
   and ash.snap_id between :minsnap and :maxsnap
 GROUP BY
       ash.sql_plan_hash_value,
       ash.session_state,
       ash.wait_class,
       nvl(ash.event, 'On CPU/Waiting for CPU') 
       , CASE WHEN IN_CONNECTION_MGMT     = 'Y' THEN 'CONNECTION_MGMT '     END ||
         CASE WHEN IN_PARSE               = 'Y' THEN 'PARSE '               END ||
         CASE WHEN IN_HARD_PARSE          = 'Y' THEN 'HARD_PARSE '          END ||
         CASE WHEN IN_SQL_EXECUTION       = 'Y' THEN 'SQL_EXECUTION '       END ||
         CASE WHEN IN_PLSQL_EXECUTION     = 'Y' THEN 'PLSQL_EXECUTION '     END ||
         CASE WHEN IN_PLSQL_RPC           = 'Y' THEN 'PLSQL_RPC '           END ||
         CASE WHEN IN_PLSQL_COMPILATION   = 'Y' THEN 'PLSQL_COMPILATION '   END ||
         CASE WHEN IN_JAVA_EXECUTION      = 'Y' THEN 'JAVA_EXECUTION '      END ||
         CASE WHEN IN_BIND                = 'Y' THEN 'BIND '                END ||
         CASE WHEN IN_CURSOR_CLOSE        = 'Y' THEN 'CURSOR_CLOSE '        END ||
         CASE WHEN IN_SEQUENCE_LOAD       = 'Y' THEN 'SEQUENCE_LOAD '       END 
 ORDER BY
       ash.sql_plan_hash_value,
       5 DESC,
       ash.session_state,
       ash.wait_class,
       event ) v;

PRO
PRO <tr>
PRO <th>#</th>
PRO <th>Plan<br>Hash<br>Value</th>
PRO <th>Session<br>State</th>
PRO <th>Wait<br>Class</th>
PRO <th>Event</th>
PRO <th>Phase</th>
PRO <th>Snaps<br>Count</th>
PRO <th>% PHV</th>
PRO <th>% PHV+Event</th>
PRO <th>Sampled<br>Executions</th>
PRO <th>Max PGA<br>(MB)</th>
PRO <th>Max Temp<br>(MB)</th>
PRO </tr>
PRO
PRO </table>

select round((sysdate-to_date(:start_time,'dd-mon-rr hh24:mi:ss'))*86400) diff from dual;
PRO <table style="width:100%"><tr><td style="text-align:right; background-color:#ffffff">Time taken: ^^diff. seconds</td></tr></table>
PRO </details><!--Pushkar-->
exec :start_time := to_char(sysdate,'dd-mon-rr hh24:mi:ss');
/* -------------------------
 *
 * dba_hist_active_sess_history by plan line
 *
 * Uday: added percentage column
 * Uday.v6.Aug2016: added snaps subquery to improve performance
 * ------------------------- */
EXEC DBMS_APPLICATION_INFO.SET_CLIENT_INFO('^^method.: DBA_HIST_ASH by Plan Line - ' || TO_CHAR(SYSDATE, 'YYYY-MM-DD/HH24:MI:SS'));
PRO <a name="awr_line"></a><details open><br/><summary id="summary2">AWR Active Session History by Plan Line (DBA_HIST_ACTIVE_SESS_HISTORY)</summary>
PRO
PRO Snapshots counts per Plan Line and Wait Event for ^^sql_id..<br>
PRO This section includes data captured by AWR. If this is a stand-by read-only database then the AWR information below is from the Primary database.<br>
PRO Available on 11g or higher..
PRO
PRO <table>
PRO
PRO <tr>
PRO <th>#</th>
PRO <th>Plan<br>Hash<br>Value</th>
PRO <th>Plan<br>Line<br>ID</th>
PRO <th>Plan<br>Operation</th>
PRO <th>Plan<br>Options</th>
PRO <th>Plan<br>Object<br>Owner</th>
PRO <th>Plan<br>Object<br>Name</th>
PRO <th>Session<br>State</th>
PRO <th>Wait<br>Class</th>
PRO <th>Event</th>
PRO <th>Curr<br>Obj<br>ID</th>
PRO <th>Curr<br>Object<br>Name</th>
PRO <th>Snaps<br>Count</th>
PRO <th>% PHV+Plan Line</th>
PRO <th>Sampled<br>Executions</th>
PRO </tr>
PRO
SELECT '<!-- '||TO_CHAR(SYSDATE, 'YYYY-MM-DD/HH24:MI:SS')||' -->' FROM dual;
PRO <!-- Please Wait -->

SELECT CHR(10)||'<tr>'||CHR(10)||
       '<td class="r">'||ROWNUM||'</td>'||CHR(10)||
       '<td class="r">'||v.sql_plan_hash_value||'</td>'||CHR(10)||
       '<td class="r">'||v.sql_plan_line_id||'</td>'||CHR(10)||
       '<td>'||v.sql_plan_operation||'</td>'||CHR(10)||
       '<td>'||v.sql_plan_options||'</td>'||CHR(10)||
       '<td>'||v.object_owner||'</td>'||CHR(10)||
       '<td>'||v.object_name||'</td>'||CHR(10)||
       '<td>'||v.session_state||'</td>'||CHR(10)||
       '<td>'||v.wait_class||'</td>'||CHR(10)||
       '<td>'||v.event||'</td>'||CHR(10)||
       '<td class="r">'||v.current_obj#||'</td>'||CHR(10)||
       '<td>'||v.current_obj_name||'</td>'||CHR(10)||
       '<td class="r">'||v.snaps_count||'</td>'||CHR(10)||
       '<td class="r">'||v.pct||'</td>'||CHR(10)||
       '<td class="r">'||v.sampled_execs||'</td>'||CHR(10)||
       '</tr>'
  FROM (
SELECT /*+ NO_MERGE */
       ash.sql_plan_hash_value,
       ash.sql_plan_line_id,
       ash.sql_plan_operation,
       ash.sql_plan_options,
       ash.object_owner,
       ash.object_name,
       ash.current_obj#,
       CASE
         WHEN ash.current_obj# IS NOT NULL THEN
           (SELECT obj.owner||'.'||obj.object_name||NVL2(obj.subobject_name, '.'||obj.subobject_name, NULL)
              FROM dba_hist_seg_stat_obj obj
             WHERE obj.obj# = ash.current_obj#
               AND obj.dbid = ^^dbid.
               AND ROWNUM = 1)
       END current_obj_name,
       ash.session_state,
       ash.wait_class,
       ash.event,
       COUNT(*) snaps_count,
       -- ROUND((RATIO_TO_REPORT(COUNT(*)) over())*100, 2) PCT
       ROUND((RATIO_TO_REPORT(COUNT(*)) over(partition by ash.sql_plan_hash_value))*100, 2) PCT
       , count(distinct ash.instance_number||ash.sql_exec_start) sampled_execs  -- uday psrv10
  FROM (
        SELECT /*+ leading(ash sh) NO_MERGE */ /* NO_MERGE */
               sh.instance_number,
               sh.sql_exec_start,
               sh.sql_plan_hash_value,
               sh.sql_plan_line_id,
               sh.sql_plan_operation,
               sh.sql_plan_options,
               CASE
                 WHEN sh.wait_class IN ('Application', 'Cluster', 'Concurrency', 'User I/O') THEN
                   sh.current_obj#
               END current_obj#,
               sh.session_state,
               sh.wait_class,
               nvl(sh.event, 'On CPU/Waiting for CPU') event,
               sp.object_owner,
               sp.object_name
          FROM dba_hist_active_sess_history sh,
               dba_hist_sql_plan sp
         WHERE :license IN ('T', 'D', 'L')
           AND sh.dbid = ^^dbid.
           AND sh.sql_id = :sql_id
           and sh.snap_id between :minsnap and :maxsnap
           AND sh.sql_plan_line_id > 0
           AND sp.dbid(+) = sh.dbid
           AND sp.sql_id(+) = sh.sql_id
           AND sp.plan_hash_value(+) = sh.sql_plan_hash_value
           AND sp.id(+) = sh.sql_plan_line_id 
               ) ash
 GROUP BY
       ash.sql_plan_hash_value,
       ash.sql_plan_line_id,
       ash.sql_plan_operation,
       ash.sql_plan_options,
       ash.object_owner,
       ash.object_name,
       ash.session_state,
       ash.wait_class,
       ash.current_obj#,
       ash.event
 ORDER BY
       ash.sql_plan_hash_value,
       ash.sql_plan_line_id,
       12 DESC,
       ash.sql_plan_operation,
       ash.sql_plan_options,
       ash.object_owner,
       ash.object_name,
       ash.session_state,
       ash.wait_class,
       ash.current_obj#,
       ash.event ) v;

PRO
PRO <tr>
PRO <th>#</th>
PRO <th>Plan<br>Hash<br>Value</th>
PRO <th>Plan<br>Line<br>ID</th>
PRO <th>Plan<br>Operation</th>
PRO <th>Plan<br>Options</th>
PRO <th>Plan<br>Object<br>Owner</th>
PRO <th>Plan<br>Object<br>Name</th>
PRO <th>Session<br>State</th>
PRO <th>Wait<br>Class</th>
PRO <th>Event</th>
PRO <th>Curr<br>Obj<br>ID</th>
PRO <th>Curr<br>Object<br>Name</th>
PRO <th>Snaps<br>Count</th>
PRO <th>% PHV+Plan Line</th>
PRO <th>Sampled<br>Executions</th>
PRO </tr>
PRO
PRO </table>

select round((sysdate-to_date(:start_time,'dd-mon-rr hh24:mi:ss'))*86400) diff from dual;
PRO <table style="width:100%"><tr><td style="text-align:right; background-color:#ffffff">Time taken: ^^diff. seconds</td></tr></table>
PRO </details><!--Pushkar-->
exec :start_time := to_char(sysdate,'dd-mon-rr hh24:mi:ss');
--Uday.PSR.v6: rewrite of above...above was taking time in 12c when rows to process are quite high
--Uday.PSR.v6 with
--Uday.PSR.v6 ash as 
--Uday.PSR.v6 (
--Uday.PSR.v6 SELECT /*+ materialize */ /* NO_MERGE */
--Uday.PSR.v6        ash.dbid,
--Uday.PSR.v6        ash.sql_id,
--Uday.PSR.v6        ash.sql_plan_hash_value,
--Uday.PSR.v6        ash.sql_plan_line_id,
--Uday.PSR.v6        ash.sql_plan_operation,
--Uday.PSR.v6        ash.sql_plan_options,
--Uday.PSR.v6        CASE
--Uday.PSR.v6          WHEN ash.wait_class IN ('Application', 'Cluster', 'Concurrency', 'User I/O') THEN
--Uday.PSR.v6            ash.current_obj#
--Uday.PSR.v6        END current_obj#,
--Uday.PSR.v6        ash.session_state,
--Uday.PSR.v6        ash.wait_class,
--Uday.PSR.v6        ash.event,
--Uday.PSR.v6        COUNT(*) snaps_count,
--Uday.PSR.v6        ROUND((RATIO_TO_REPORT(COUNT(*)) over(partition by ash.sql_plan_hash_value))*100, 2) PCT
--Uday.PSR.v6   FROM dba_hist_active_sess_history ash
--Uday.PSR.v6  WHERE :license IN ('T', 'D')
--Uday.PSR.v6    AND ash.dbid = dbid.
--Uday.PSR.v6    AND ash.sql_id = :sql_id
--Uday.PSR.v6    and ash.snap_id between minsnap and maxsnap
--Uday.PSR.v6    AND ash.sql_plan_line_id > 0
--Uday.PSR.v6  GROUP BY
--Uday.PSR.v6        ash.dbid, ash.sql_id, ash.sql_plan_hash_value, ash.sql_plan_line_id, ash.sql_plan_operation, ash.sql_plan_options, ash.session_state, ash.wait_class, 
--Uday.PSR.v6        CASE
--Uday.PSR.v6          WHEN ash.wait_class IN ('Application', 'Cluster', 'Concurrency', 'User I/O') THEN
--Uday.PSR.v6            ash.current_obj#
--Uday.PSR.v6        END current_obj#,
--Uday.PSR.v6        ash.event
--Uday.PSR.v6 )
--Uday.PSR.v6 SELECT /*+ NO_MERGE */
--Uday.PSR.v6        ash.sql_plan_hash_value,
--Uday.PSR.v6        ash.sql_plan_line_id,
--Uday.PSR.v6        ash.sql_plan_operation,
--Uday.PSR.v6        ash.sql_plan_options,
--Uday.PSR.v6        sp.object_owner,
--Uday.PSR.v6        sp.object_name,
--Uday.PSR.v6        ash.current_obj#,
--Uday.PSR.v6        CASE
--Uday.PSR.v6          WHEN ash.current_obj# IS NOT NULL THEN
--Uday.PSR.v6            (SELECT obj.owner||'.'||obj.object_name||NVL2(obj.subobject_name, '.'||obj.subobject_name, NULL)
--Uday.PSR.v6               FROM dba_hist_seg_stat_obj obj
--Uday.PSR.v6              WHERE obj.obj# = ash.current_obj#
--Uday.PSR.v6                AND obj.dbid = dbid.
--Uday.PSR.v6                AND ROWNUM = 1)
--Uday.PSR.v6        END current_obj_name,
--Uday.PSR.v6        ash.session_state,
--Uday.PSR.v6        ash.wait_class,
--Uday.PSR.v6        ash.event,
--Uday.PSR.v6        snaps_count,
--Uday.PSR.v6        pct
--Uday.PSR.v6   FROM ash, dba_hist_sql_plan sp
--Uday.PSR.v6  where sp.dbid(+) = ash.dbid
--Uday.PSR.v6    AND sp.sql_id(+) = ash.sql_id
--Uday.PSR.v6    AND sp.plan_hash_value(+) = ash.sql_plan_hash_value
--Uday.PSR.v6    AND sp.id(+) = ash.sql_plan_line_id
--Uday.PSR.v6  ORDER BY
--Uday.PSR.v6        ash.sql_plan_hash_value, ash.sql_plan_line_id, snaps_count DESC, ash.sql_plan_operation, ash.sql_plan_options, sp.object_owner, sp.object_name, ash.session_state, ash.wait_class, ash.current_obj#, ash.event 
--Uday.PSR.v6 ;
--Uday.PSR.v6 
--udayRemoved /* -------------------------
--udayRemoved  *
--udayRemoved  * DBMS_STATS System Preferences
--udayRemoved  *
--udayRemoved  * ------------------------- */
--udayRemoved EXEC DBMS_APPLICATION_INFO.SET_CLIENT_INFO('^^method.: DBMS_STATS System Preferences - ' || TO_CHAR(SYSDATE, 'YYYY-MM-DD/HH24:MI:SS'));
--udayRemoved PRO <a name="dbms_stats_sys_prefs"></a><br/><summary id="summary2">DBMS_STATS System Preferences</summary>
--udayRemoved PRO
--udayRemoved PRO DBMS_STATS System Preferences.
--udayRemoved PRO
--udayRemoved PRO < table>
--udayRemoved PRO
--udayRemoved PRO <tr>
--udayRemoved PRO <th>#</th>
--udayRemoved PRO <th>Parameter Name</th>
--udayRemoved PRO <th>Parameter Value</th>
--udayRemoved PRO </tr>
--udayRemoved PRO
--udayRemoved SELECT '<!-- '||TO_CHAR(SYSDATE, 'YYYY-MM-DD/HH24:MI:SS')||' -->' FROM dual;
--udayRemoved PRO <!-- Please Wait --> 
--udayRemoved 
--udayRemoved SELECT /* ^^script..sql DBMS_STATS System Preferences */
--udayRemoved        CHR(10)||'<tr>'||CHR(10)||
--udayRemoved        '<td class="r">'||ROWNUM||'</td>'||CHR(10)||
--udayRemoved        '<td>'||v.sname||'</td>'||CHR(10)||
--udayRemoved        '<td>'||v.spare4||'</td>'||CHR(10)||
--udayRemoved 	   '</tr>'
--udayRemoved   FROM sys.optstat_hist_control$ v
--udayRemoved  WHERE v.sname IN ('AUTOSTATS_TARGET', 
--udayRemoved                    'ESTIMATE_PERCENT',
--udayRemoved                    'DEGREE',
--udayRemoved                    'CASCADE',
--udayRemoved                    'NO_INVALIDATE',
--udayRemoved                    'METHOD_OPT',
--udayRemoved                    'GRANULARITY',
--udayRemoved                    'STATS_RETENTION',
--udayRemoved                    'PUBLISH',
--udayRemoved                    'INCREMENTAL',
--udayRemoved                    'STALE_PERCENT',
--udayRemoved                    'APPROXIMATE_NDV',
--udayRemoved                    'INCREMENTAL_INTERNAL_CONTROL',
--udayRemoved                    'CONCURRENT')
--udayRemoved ORDER BY v.sname;
--udayRemoved 
--udayRemoved PRO
--udayRemoved PRO <tr>
--udayRemoved PRO <th>#</th>
--udayRemoved PRO <th>Preference Name</th>
--udayRemoved PRO <th>Preference Value</th>
--udayRemoved PRO </tr>
PRO
rem PRO < table> -- pushkar removed
/* -------------------------
 *
 * tables
 * PSRv7: added modifications link
 *
 * ------------------------- */
                               
EXEC DBMS_APPLICATION_INFO.SET_CLIENT_INFO('^^method.: Tables Stats and Attributes - ' || TO_CHAR(SYSDATE, 'YYYY-MM-DD/HH24:MI:SS'));
PRO <a name="tables"></a><details open><br/><summary id="summary2">Tables</summary>
PRO
PRO CBO Statistics and relevant attributes.
PRO
PRO <table>
PRO
PRO <tr>
PRO <th>#</th>
PRO <th>Table Name</th>
PRO <th>Owner</th>
PRO <th>Part</th>
PRO <th>Temp</th>
PRO <th>On Commit</th>
PRO <th>Num Rows</th>
PRO <th>Sample<br>Size</th>
PRO <th>Perc</th>
PRO <th>Last Analyzed</th>
PRO <th>Blocks</th>
PRO <th>Avg<br>Row<br>Len</th>
PRO <th>Global<br>Stats</th>
PRO <th>User<br>Stats</th>
PRO <th>Stat<br>Type<br>Locked</th>
PRO <th>Stale<br>Stats</th>
PRO <th>Perc</th>
PRO <th>Table<br>Cols</th>
PRO <th>Indexes</th>
PRO <th>Index<br>Cols</th>
PRO <th>Stat<br>Versions</th>
PRO <th>Tab<br>Modifications</th>
PRO <th>Partition<br>Type</th>
PRO <th>Partition<br>Columns</th>
PRO <th>Partition<br>Count</th>
PRO <th>Subpartition<br>Type</th>
PRO <th>Subpartition<br>Columns</th>
PRO <th>DoP</th>
PRO <th>BootStrap<br>Table<br>Size</th>
PRO <th>Candidate<br>for next<br>BootStrap<br>Stats</th>
PRO <th>Occupied<br>[KB]</th>
PRO <th>Allocated<br>[KB]</th>
PRO </tr>

var no_of_inserts number; 
var row_count_threshold number;
var stale_row_count_threshold number;
var insert_percent_below_threshold number;
var insert_percent_above_threshold number;
exec :no_of_inserts:=1000; :row_count_threshold:=20000; :stale_row_count_threshold:=500000; :insert_percent_below_threshold:=50; :insert_percent_above_threshold:=100;

PRO
SELECT '<!-- '||TO_CHAR(SYSDATE, 'YYYY-MM-DD/HH24:MI:SS')||' -->' FROM dual;
PRO <!-- Please Wait -->

SELECT /* ^^script..sql Tables */
       CHR(10)||'<tr>'||CHR(10)||
       '<td class="r">'||ROWNUM||'</td>'||CHR(10)||
       '<td>'||v.table_name||'</td>'||CHR(10)||
       '<td>'||v.owner||'</td>'||CHR(10)||
       CASE WHEN v.partitioned = 'YES' 
	     THEN '<td class="c"><a href="#tp_'||LOWER(v.table_name||'_'||v.owner)||'">'||v.partitioned||'</a></td>'
		 ELSE '<td class="c">'||v.partitioned||'</td>'
	   END||CHR(10)||
       '<td class="c">'||v.temporary||'</td>'||CHR(10)||
       '<td>'||case when v.duration='SYS$TRANSACTION' then 'DELETE' 
                    when v.duration='SYS$SESSION'     then 'PRESERVE'
                end ||'</td>'||CHR(10)||         
       '<td class="r">'||v.num_rows||'</td>'||CHR(10)||
       '<td class="r">'||v.sample_size||'</td>'||CHR(10)||
       '<td class="r">'||v.sample_size_perc||'</td>'||CHR(10)||
       '<td nowrap>'   ||v.last_analyzed||'</td>'||CHR(10)||
       '<td class="r">'||v.blocks||'</td>'||CHR(10)||
       '<td class="r">'||v.avg_row_len||'</td>'||CHR(10)||
       '<td class="c">'||v.global_stats||'</td>'||CHR(10)||
       '<td class="c">'||v.user_stats||'</td>'||CHR(10)||
       '<td class="c">'||v.stattype_locked||'</td>'||CHR(10)||
       '<td class="c">'||v.stale_stats||'</td>'||CHR(10)||
       '<td class="r">'||TO_CHAR(ROUND(v.modifications * 100/nvl(nullif(v.num_rows,0),1)), '99999990D0')||'</td>'||CHR(10)||
       '<td class="c"><a href="#c_'||LOWER(v.table_name||'_'||v.owner)||'">&nbsp;'||v.columns||'&nbsp;</a></td>'||CHR(10)||
       '<td class="c"><a href="#i_'||LOWER(v.table_name||'_'||v.owner)||'">&nbsp;'||v.indexes||'&nbsp;</a></td>'||CHR(10)||
       '<td class="c"><a href="#ic_'||LOWER(v.table_name||'_'||v.owner)||'">&nbsp;'||v.index_columns||'&nbsp;</a></td>'||CHR(10)||
       '<td class="c"><a href="#tbl_stat_ver">Versions</a></td>'||CHR(10)||
       '<td class="c"><a href="#tbl_modifications">Modifications</a></td>'||CHR(10)||
	     '<td class="c">'||case
	                         when v.p_subp_type is NOT null then
	                            regexp_substr(v.p_subp_type,'(.*)##',1,1,'im',1)||'</td>'||CHR(10)
	                         else '</td>'||CHR(10)
	                       end ||CHR(10)||
	     '<td>'||case
	                         when v.p_part_keys is NOT null then
	                           v.p_part_keys||'</td>'||CHR(10)
	                         else '</td>'||CHR(10)
	                       end ||CHR(10)||
	     '<td class="r">'||case
	                         when v.p_subp_type is NOT null then
	                            regexp_substr(v.p_subp_type,'##(.*)~~',1,1,'im',1)||'</td>'||CHR(10)||
	     '<td class="c">'||     regexp_substr(v.p_subp_type,'~~(.*)',1,1,'im',1)
	                         else '</td><td>'
	                       end ||'</td>'||CHR(10)||
	     '<td>'||case
	                         when v.p_subpart_keys is NOT null then
	                           v.p_subpart_keys||'</td>'||CHR(10)
	                         else '</td>'||CHR(10)
	                       end ||CHR(10)||
       '<td class="c">'||v.degree||'</td>'||CHR(10)|| 
       '<td class="c">'||
          case when v.temporary='N' and ((v.num_rows <= :row_count_threshold or v.num_rows is null) 
                or  (v.num_rows=0 or v.num_rows is null)
                or  (v.num_rows=0)) then 'Small'
               when v.temporary='N' and (v.num_rows between :row_count_threshold and :stale_row_count_threshold) then 'Medium'
               when v.temporary='N' and (v.num_rows > :stale_row_count_threshold) then 'Large'
          end ||'</td>'||CHR(10)||                 
          case when ((v.num_rows <= :row_count_threshold or v.num_rows is null) and abs(v.modifications) > :no_of_inserts) 
                or  (v.num_rows > :row_count_threshold and abs(v.modifications)*100/nvl(nullif(v.num_rows,0),1) >= :insert_percent_below_threshold)               
                or  ((v.num_rows=0 or v.num_rows is null) and v.modifications > 0)
                or  (v.num_rows=0)
          then '<td class="bg_c">'||'YES'
          else '<td class="c">'   ||'NO'
          end ||'</td>'||CHR(10)||       
       '<td class="r">'||v.occupied_size||'</td>'||CHR(10)||
       '<td class="r">'||v.allocated_size||'</td>'||CHR(10)||
       '</tr>' 
  FROM (
--Uday.PSR.v6 WITH object AS (
--Uday.PSR.v6 SELECT /*+ MATERIALIZE */
--Uday.PSR.v6        object_owner owner, object_name name, object_type
--Uday.PSR.v6   FROM gv$sql_plan
--Uday.PSR.v6  WHERE inst_id IN (SELECT inst_id FROM gv$instance)
--Uday.PSR.v6    AND sql_id = :sql_id
--Uday.PSR.v6    AND object_owner IS NOT NULL
--Uday.PSR.v6    AND object_name IS NOT NULL
--Uday.PSR.v6    AND not (object_type = 'TABLE (TEMP)' and object_name like 'SYS_TEMP%') --Uday.v6
--Uday.PSR.v6  UNION
--Uday.PSR.v6 SELECT object_owner owner, object_name name, object_type
--Uday.PSR.v6   FROM dba_hist_sql_plan
--Uday.PSR.v6  WHERE :license IN ('T', 'D')
--Uday.PSR.v6    AND dbid = ^^dbid.
--Uday.PSR.v6    AND sql_id = :sql_id
--Uday.PSR.v6    AND object_owner IS NOT NULL
--Uday.PSR.v6    AND object_name IS NOT NULL
--Uday.PSR.v6    AND not (object_type = 'TABLE (TEMP)' and object_name like 'SYS_TEMP%') --Uday.v6
--Uday.PSR.v6  ), plan_tables AS (
--Uday.PSR.v6 --UdayRemoved.v6 SELECT /*+ MATERIALIZE */
--Uday.PSR.v6 --UdayRemoved.v6        'TABLE' object_type, t.owner object_owner, t.table_name object_name
--Uday.PSR.v6 --UdayRemoved.v6   FROM dba_tab_statistics t, -- include fixed objects
--Uday.PSR.v6 --UdayRemoved.v6        object o
--Uday.PSR.v6 --UdayRemoved.v6  WHERE t.owner = o.owner
--Uday.PSR.v6 --UdayRemoved.v6    AND t.table_name = o.name
--Uday.PSR.v6  SELECT /*+ MATERIALIZE */
--Uday.PSR.v6         'TABLE' object_type, o.owner object_owner, o.name object_name
--Uday.PSR.v6    FROM object o
--Uday.PSR.v6   WHERE o.object_type like 'TABLE%'
--Uday.PSR.v6   UNION
--Uday.PSR.v6  SELECT 'TABLE' object_type, i.table_owner object_owner, i.table_name object_name
--Uday.PSR.v6    FROM dba_indexes i,
--Uday.PSR.v6         object o
--Uday.PSR.v6   WHERE o.object_type like 'INDEX%'  --Uday.v6
--Uday.PSR.v6     AND i.owner = o.owner
--Uday.PSR.v6     AND i.index_name = o.name
--Uday.PSR.v6 )
SELECT /*+ NO_MERGE LEADING(pt s t) */
       s.table_name,
       s.owner,
       t.partitioned,
       case /* Pushkar - added below for partitioned tables */
         when t.partitioned = 'YES' then (select partitioning_type||'##'||partition_count||'~~'||regexp_replace(subpartitioning_type,'NONE',null,1,0,'i') 
                                          from dba_part_tables dt 
                                          where dt.owner = s.owner and dt.table_name = s.table_name)
       end p_subp_type,
       case
         when t.partitioned = 'YES' then (select /*'PARTITION on: '||*/listagg(column_name,'<br>') within group (order by owner, name, object_type, column_position)
                                           from dba_part_key_columns
                                           where owner=s.owner
                                             and name=s.table_name
                                             and object_type='TABLE'
                                           group by owner, name, object_type)
       end p_part_keys,
       case
         when t.partitioned = 'YES' then (select /*'SUBPARTITION on: '||*/listagg(column_name,'<br>') within group (order by owner, name, object_type, column_position)
                                           from dba_subpart_key_columns
                                           where owner=s.owner
                                             and name=s.table_name
                                             and object_type='TABLE'
                                           group by owner, name, object_type)
       end p_subpart_keys,       
       t.degree,
       t.temporary,
       t.duration,
       s.num_rows,
       s.sample_size,
       CASE WHEN s.num_rows > 0 THEN TO_CHAR(ROUND(s.sample_size * 100 / s.num_rows, 1), '99999990D0') END sample_size_perc,
       TO_CHAR(s.last_analyzed, 'YYYY-MM-DD/HH24:MI:SS') last_analyzed,
       s.blocks,
       s.avg_row_len,
       s.global_stats,
       s.user_stats,
       s.stattype_locked,
       s.stale_stats,
       -- Uday: causing performance issue in 12c DB when below view is in the from clause
       --       Did not spend time on the RCA so simply making this scalar subquery
       -- , CASE WHEN s.num_rows > 0 THEN TO_CHAR(ROUND((m.inserts + m.updates + m.deletes) * 100 / s.num_rows, 1), '99999990D0') END stale_stats_perc
       CASE WHEN s.num_rows >= 0 THEN
           (
            select m.inserts + m.updates + m.deletes
              from dba_tab_modifications m
             where t.owner = m.table_owner
               AND t.table_name = m.table_name
               AND m.partition_name IS NULL
           )
         END modifications,
       (SELECT COUNT(*)
          FROM dba_tab_cols c
         WHERE c.owner = s.owner
           AND c.table_name = s.table_name) columns,
       (SELECT COUNT(*)
          FROM dba_indexes i
         WHERE i.table_owner = s.owner
           AND i.table_name = s.table_name) indexes,
       (SELECT COUNT(*)
          FROM dba_ind_columns ic
         WHERE ic.table_owner = s.owner
           AND ic.table_name = s.table_name) index_columns,
        round((s.num_rows*s.avg_row_len/1024),2) occupied_size,
        round(s.blocks*8.192,2) allocated_size
  FROM plan_table pt,
       dba_tab_statistics s,
       dba_tables t
       -- sys.dba_tab_modifications m -- requires sys on 10g
 WHERE pt.object_type = 'TABLE'
   AND STATEMENT_ID = :sql_id
   AND pt.object_owner = s.owner
   AND pt.object_name = s.table_name
   AND pt.object_type = s.object_type
   AND s.owner = t.owner
   AND s.table_name = t.table_name
   -- AND t.owner = m.table_owner(+)
   -- AND t.table_name = m.table_name(+)
   -- AND m.partition_name IS NULL
 ORDER BY
       s.table_name,
       s.owner) v;

PRO
PRO <tr>
PRO <th>#</th>
PRO <th>Table Name</th>
PRO <th>Owner</th>
PRO <th>Part</th>
PRO <th>Temp</th>
PRO <th>On Commit</th>
PRO <th>Num Rows</th>
PRO <th>Sample<br>Size</th>
PRO <th>Perc</th>
PRO <th>Last Analyzed</th>
PRO <th>Blocks</th>
PRO <th>Avg<br>Row<br>Len</th>
PRO <th>Global<br>Stats</th>
PRO <th>User<br>Stats</th>
PRO <th>Stat<br>Type<br>Locked</th>
PRO <th>Stale<br>Stats</th>
PRO <th>Perc</th>
PRO <th>Table<br>Cols</th>
PRO <th>Indexes</th>
PRO <th>Index<br>Cols</th>
PRO <th>Stat<br>Versions</th>
PRO <th>Tab<br>Modifications</th>
PRO <th>Partition<br>Type</th>
PRO <th>Partition<br>Columns</th>
PRO <th>Partition<br>Count</th>
PRO <th>Subpartition<br>Type</th>
PRO <th>Subpartition<br>Columns</th>
PRO <th>DoP</th>
PRO <th>BootStrap<br>Table<br>Size</th>
PRO <th>Candidate<br>for next<br>BootStrap<br>Stats</th>
PRO <th>Occupied<br>[KB]</th>
PRO <th>Allocated<br>[KB]</th>
PRO </tr>
PRO
PRO </table>

select round((sysdate-to_date(:start_time,'dd-mon-rr hh24:mi:ss'))*86400) diff from dual;
PRO <table style="width:100%"><tr><td style="text-align:right; background-color:#ffffff">Time taken: ^^diff. seconds</td></tr></table>
PRO </details><!--Pushkar-->
exec :start_time := to_char(sysdate,'dd-mon-rr hh24:mi:ss');
/* -------------------------
 *
 * DBMS_STATS Table Preferences
 *
 * ------------------------- */
EXEC DBMS_APPLICATION_INFO.SET_CLIENT_INFO('^^method.: DBMS_STATS Table Preferences - ' || TO_CHAR(SYSDATE, 'YYYY-MM-DD/HH24:MI:SS'));
PRO <a name="dbms_stats_tab_prefs"></a><details open><br/><summary id="summary2">DBMS_STATS Table Preferences</summary>
PRO
PRO DBMS_STATS Table Preferences.
PRO
PRO <table>
PRO
PRO <tr>
PRO <th>#</th>
PRO <th>Owner</th>
PRO <th>Table Name</th>
-- PRO <th>Obj#</th>
PRO <th>Parameter Name</th>
PRO <th>Parameter Value</th>
-- PRO <th>Change Time</th>
PRO </tr>
PRO
SELECT '<!-- '||TO_CHAR(SYSDATE, 'YYYY-MM-DD/HH24:MI:SS')||' -->' FROM dual;
PRO <!-- Please Wait --> 

--udayRemoved SELECT /* ^^script..sql DBMS_STATS Table Preferences */
--udayRemoved        CHR(10)||'<tr>'||CHR(10)||
--udayRemoved 	   '<td class="r">'||ROWNUM||'</td>'||CHR(10)||
--udayRemoved        '<td>'||o.object_owner||'</td>'||CHR(10)||
--udayRemoved 	   '<td>'||o.object_name||'</td>'||CHR(10)||
--udayRemoved 	   '<td>'||v.obj#||'</td>'||CHR(10)||
--udayRemoved        '<td>'||v.pname||'</td>'||CHR(10)||
--udayRemoved        '<td>'||v.valchar||'</td>'||CHR(10)||
--udayRemoved 	   '<td>'||v.chgtime||'</td>'||CHR(10)||
--udayRemoved 	   '</tr>'
--udayRemoved   -- FROM sys.optstat_user_prefs$ v,
--udayRemoved 
SELECT /* ^^script..sql DBMS_STATS Table Preferences */
       CHR(10)||'<tr>'||CHR(10)||
	   '<td class="r">'||ROWNUM||'</td>'||CHR(10)||
       '<td>'||o.object_owner||'</td>'||CHR(10)||
	   '<td>'||o.object_name||'</td>'||CHR(10)||
       '<td>'||v.PREFERENCE_NAME||'</td>'||CHR(10)||
       '<td>'||regexp_replace(regexp_replace(regexp_replace(v.PREFERENCE_VALUE,'\s+',' ',1,0,'in'),'\s*,\s*',','),' FOR ','</br>FOR ')||'</td>'||CHR(10)||
	   '</tr>'
  FROM DBA_TAB_STAT_PREFS v,
       plan_table o
 WHERE o.object_owner = v.owner (+)
   AND o.object_name = v.table_name (+)
   AND STATEMENT_ID = :sql_id
ORDER BY o.object_owner, o.object_name, v.PREFERENCE_NAME;

--Uday.PSR.v6       (WITH object AS (
--Uday.PSR.v6          SELECT /*+ MATERIALIZE */
--Uday.PSR.v6                 object_owner owner, object_name name, object# obj#, object_type
--Uday.PSR.v6            FROM gv$sql_plan
--Uday.PSR.v6           WHERE inst_id IN (SELECT inst_id FROM gv$instance)
--Uday.PSR.v6             AND sql_id = :sql_id
--Uday.PSR.v6             AND object_owner IS NOT NULL
--Uday.PSR.v6             AND object_name IS NOT NULL
--Uday.PSR.v6             AND not (object_type = 'TABLE (TEMP)' and object_name like 'SYS_TEMP%') --Uday.v6
--Uday.PSR.v6           UNION
--Uday.PSR.v6          SELECT object_owner owner, object_name name, object# obj#, object_type
--Uday.PSR.v6            FROM dba_hist_sql_plan
--Uday.PSR.v6           WHERE :license IN ('T', 'D')
--Uday.PSR.v6             AND dbid = ^^dbid.
--Uday.PSR.v6             AND sql_id = :sql_id
--Uday.PSR.v6             AND object_owner IS NOT NULL
--Uday.PSR.v6             AND object_name IS NOT NULL
--Uday.PSR.v6             AND not (object_type = 'TABLE (TEMP)' and object_name like 'SYS_TEMP%') --Uday.v6
--Uday.PSR.v6           ), plan_tables AS (
--Uday.PSR.v6           --UdayRemoved.v6 SELECT /*+ MATERIALIZE */
--Uday.PSR.v6           --UdayRemoved.v6        'TABLE' object_type, t.owner object_owner, t.table_name object_name
--Uday.PSR.v6           --UdayRemoved.v6   FROM dba_tab_statistics t, -- include fixed objects
--Uday.PSR.v6           --UdayRemoved.v6        object o
--Uday.PSR.v6           --UdayRemoved.v6  WHERE t.owner = o.owner
--Uday.PSR.v6           --UdayRemoved.v6    AND t.table_name = o.name
--Uday.PSR.v6            SELECT /*+ MATERIALIZE */
--Uday.PSR.v6                   'TABLE' object_type, o.owner object_owner, o.name object_name, o.obj#
--Uday.PSR.v6              FROM object o
--Uday.PSR.v6             WHERE o.object_type like 'TABLE%'
--Uday.PSR.v6            UNION
--Uday.PSR.v6           SELECT 'TABLE' object_type, i.table_owner object_owner, i.table_name object_name, 
--Uday.PSR.v6		          null obj#
--Uday.PSR.v6                          /* Uday.v6 no longer needed
--Uday.PSR.v6		          (SELECT object_id
--Uday.PSR.v6					 FROM dba_objects io
--Uday.PSR.v6					WHERE io.owner = i.table_owner
--Uday.PSR.v6					  AND io.object_name = i.table_name
--Uday.PSR.v6					  AND io.object_type = 'TABLE') obj#
--Uday.PSR.v6                          */
--Uday.PSR.v6             FROM dba_indexes i,
--Uday.PSR.v6                  object o
--Uday.PSR.v6            WHERE o.object_type like 'INDEX%'  --Uday.v6
--Uday.PSR.v6              AND i.owner = o.owner
--Uday.PSR.v6              AND i.index_name = o.name
--Uday.PSR.v6          ) 
--Uday.PSR.v6		  SELECT object_owner, object_name, obj#
--Uday.PSR.v6		    FROM plan_tables
--Uday.PSR.v6          )	o	  
--Uday.PSR.v6 -- WHERE v.obj# = o.obj#

PRO
PRO <tr>
PRO <th>#</th>
PRO <th>Owner</th>
PRO <th>Table Name</th>
-- PRO <th>Obj#</th>
PRO <th>Parameter Name</th>
PRO <th>Parameter Value</th>
-- PRO <th>Change Time</th>
PRO </tr>
PRO
PRO </table>

select round((sysdate-to_date(:start_time,'dd-mon-rr hh24:mi:ss'))*86400) diff from dual;
PRO <table style="width:100%"><tr><td style="text-align:right; background-color:#ffffff">Time taken: ^^diff. seconds</td></tr></table>
PRO </details><!--Pushkar-->
exec :start_time := to_char(sysdate,'dd-mon-rr hh24:mi:ss');


/* -------------------------
 *
 * Table Extensions -- PSRv10
 * Uday
 * ------------------------- */
REM EXEC DBMS_SPD.FLUSH_SQL_PLAN_DIRECTIVE;

PRO
PRO <a name="extensions"></a><details open><br/><summary id="summary2">Table Extensions (DBA_STAT_EXTENSIONS)</summary>
PRO
PRO Table Extensions on objects used in ^^sql_id. 
PRO
PRO <table>
PRO
PRO <tr>
PRO <th>#</th>
PRO <th>Owner</th>
PRO <th>Table Name</th>
PRO <th>Extension<br>Name</th>
PRO <th>Extension</th>
PRO <th>Creator</th>
PRO <th>Droppable</th>
PRO </tr>
PRO
SELECT '<!-- '||TO_CHAR(SYSDATE, 'YYYY-MM-DD/HH24:MI:SS')||' -->' FROM dual;
PRO <!-- Please Wait -->

SELECT CHR(10)||'<tr>'||CHR(10)||
       '<td class="r">'||ROWNUM  ||'</td>'||CHR(10)||
       '<td >'||OWNER            ||'</td>'||CHR(10)||
       '<td >'||TABLE_NAME       ||'</td>'||CHR(10)||
       '<td >'||EXTENSION_NAME   ||'</td>'||CHR(10)||
       '<td >'||EXTENSION        ||'</td>'||CHR(10)||
       '<td >'||CREATOR          ||'</td>'||CHR(10)||
       '<td >'||DROPPABLE        ||'</td>'||CHR(10)
  FROM (
         SELECT /*+ ORDERED  leading(t) cardinality(t 1) */ 
                e.OWNER,
                e.TABLE_NAME,
                e.EXTENSION_NAME,
                replace(replace(To_Char(e.extension),'",',', '),'"') extension,
                e.CREATOR,
                e.DROPPABLE
           FROM plan_table t, dba_stat_extensions e
          WHERE t.object_name is not null and t.object_owner is not null
            AND e.table_name = t.object_name
            AND STATEMENT_ID = :sql_id
          ORDER BY e.table_name, e.EXTENSION_NAME 
       ) v
;

PRO
PRO <tr>
PRO <th>#</th>
PRO <th>Owner</th>
PRO <th>Table Name</th>
PRO <th>Extension<br>Name</th>
PRO <th>Extension</th>
PRO <th>Creator</th>
PRO <th>Droppable</th>
PRO </tr>
PRO
PRO </table>

select round((sysdate-to_date(:start_time,'dd-mon-rr hh24:mi:ss'))*86400) diff from dual;
PRO <table style="width:100%"><tr><td style="text-align:right; background-color:#ffffff">Time taken: ^^diff. seconds</td></tr></table>
PRO </details><!--Pushkar-->
exec :start_time := to_char(sysdate,'dd-mon-rr hh24:mi:ss');


/* -------------------------
 *
 * table columns
 *
 * ------------------------- */
EXEC DBMS_APPLICATION_INFO.SET_CLIENT_INFO('^^method.: Table Columns - ' || TO_CHAR(SYSDATE, 'YYYY-MM-DD/HH24:MI:SS'));
PRO <a name="tbl_cols"></a><details open><br/><summary id="summary2">Table Columns</summary>

SELECT '<!-- '||TO_CHAR(SYSDATE, 'YYYY-MM-DD/HH24:MI:SS')||' -->' FROM dual;
PRO <!-- Please Wait -->

SELECT /* ^^script..sql Table Columns */
       v2.line_text
  FROM (
WITH ic as
 (SELECT /*+ MATERIALIZE leading(pt i)  */
         pt.object_owner table_owner,
         pt.object_name  table_name,
         i.column_name,
         COUNT(*) index_count
    FROM dba_ind_columns i, plan_table pt
   WHERE i.table_owner(+) = pt.object_owner
     AND i.table_name(+) = pt.object_name 
     AND STATEMENT_ID = :sql_id
   GROUP BY
         pt.object_owner,
         pt.object_name,
         i.column_name )
SELECT object_name table_name,
       object_owner owner,
       1 line_type,
       1 row_num,
       '<a name="c_'||LOWER(object_name||'_'||object_owner)||'"></a><details open><br/><summary id="summary3">Table Columns: '||object_name||' ('||object_owner||')</summary>'||CHR(10)||CHR(10)||
       'CBO Statistics and relevant attributes.'||CHR(10)||CHR(10)||
       '<table>'||CHR(10)||CHR(10)||
       '<tr>'||CHR(10)||
       '<th>#</th>'||CHR(10)||
       --'<th>Table Name</th>'||CHR(10)||
       --'<th>Owner</th>'||CHR(10)||
       '<th>Indexes</th>'||CHR(10)||
       '<th>Col<br>ID</th>'||CHR(10)||
       '<th>Column Name</th>'||CHR(10)||
       '<th>Expression</th>'||CHR(10)||       
       '<th>Data<br>Type</th>'||CHR(10)||
       '<th>Null<br>able</th>'||CHR(10)||
       '<th>Num<br>Rows</th>'||CHR(10)||
       '<th>Num<br>Nulls</th>'||CHR(10)||
       '<th>Sample<br>Size</th>'||CHR(10)||
       '<th>Perc</th>'||CHR(10)||
       '<th>Num<br>Distinct</th>'||CHR(10)||
       '<th>Low Value</th>'||CHR(10)||
       '<th>High Value</th>'||CHR(10)||
       '<th>Last Analyzed</th>'||CHR(10)||
       '<th>Avg<br>Col<br>Len</th>'||CHR(10)||
       '<th>Density</th>'||CHR(10)||
       '<th>Num<br>Buckets</th>'||CHR(10)||
       '<th>Histogram</th>'||CHR(10)||
       '<th>Hidden</th>'||CHR(10)||
       '<th>Virtual</th>'||CHR(10)||       
       '<th>Global<br>Stats</th>'||CHR(10)||
       '<th>User<br>Stats</th>'||CHR(10)||
       '</tr>'||CHR(10) line_text
  FROM plan_table
 WHERE object_type = 'TABLE'
   AND STATEMENT_ID = :sql_id
 UNION ALL
SELECT v.table_name,
       v.owner,
       2 line_type,
       ROWNUM row_num,
       CHR(10)||'<tr>'||CHR(10)||
       '<td class="r">'||ROWNUM||'</td>'||CHR(10)||
       --'<td>'||v.table_name||'</td>'||CHR(10)||
       --'<td>'||v.owner||'</td>'||CHR(10)||
       '<td class="c">'||v.indexes||'</td>'||CHR(10)||
       '<td class="c">'||v.column_id||'</td>'||CHR(10)||
       '<td>'||v.column_name||'</td>'||CHR(10)||
       '<td>'||CASE WHEN v.column_name LIKE 'SYS%' THEN 
               (SELECT replace(replace(To_Char(extension),'",',', '),'"') 
                  FROM dba_stat_extensions
                 WHERE v.table_name = table_name 
                   AND v.owner = owner
                   AND v.column_name= extension_name) END||'</td>'||CHR(10)||       
       '<td>'||v.data_type||'</td>'||CHR(10)||
       '<td class="c">'||v.nullable||'</td>'||CHR(10)||
       '<td class="r">'||v.num_rows||'</td>'||CHR(10)||
       '<td class="r">'||v.num_nulls||'</td>'||CHR(10)||
       '<td class="r">'||v.sample_size||'</td>'||CHR(10)||
       '<td class="r">'||v.sample_size_perc||'</td>'||CHR(10)||
       '<td class="r">'||v.num_distinct||'</td>'||CHR(10)||
       '<td nowrap>'||v.low_value||'</td>'||CHR(10)||
       '<td nowrap>'||v.high_value||'</td>'||CHR(10)||
       '<td nowrap>'||v.last_analyzed||'</td>'||CHR(10)||
       '<td class="r">'||v.avg_col_len||'</td>'||CHR(10)||
       '<td class="r">'||v.density||'</td>'||CHR(10)||
       '<td class="r">'||v.num_buckets||'</td>'||CHR(10)||
       '<td>'||v.histogram||'</td>'||CHR(10)||
       '<td class="c">'||v.hidden_column||'</td>'||CHR(10)||
       '<td class="c">'||v.virtual_column||'</td>'||CHR(10)||
       '<td class="c">'||v.global_stats||'</td>'||CHR(10)||
       '<td class="c">'||v.user_stats||'</td>'||CHR(10)||
       '</tr>'||CHR(10) line_text
  FROM (
--Uday.PSR.v6: replace 't' (dba_tables) with 'pt' (plan_table)
SELECT /*+ NO_MERGE LEADING(pt) */
       -- t.table_name,
       -- t.owner,
       pt.object_name table_name,
       pt.object_owner owner,
       NVL(ic.index_count,0) indexes,
       c.column_id,
       c.column_name,
       c.data_type,
       c.data_default,
       c.nullable,
       -- t.num_rows,
       pt.cardinality num_rows,
       c.num_nulls,
       c.sample_size,
       -- CASE
       -- WHEN t.num_rows > c.num_nulls THEN TO_CHAR(LEAST(100, ROUND(c.sample_size * 100 / (t.num_rows - c.num_nulls), 1)), '99999990D0')
       -- WHEN t.num_rows = c.num_nulls THEN TO_CHAR(100, '99999990D0')
       -- END sample_size_perc,
       CASE
         WHEN pt.cardinality > c.num_nulls THEN TO_CHAR(LEAST(100, ROUND(c.sample_size * 100 / (pt.cardinality - c.num_nulls), 1)), '99999990D0')
         WHEN pt.cardinality = c.num_nulls THEN TO_CHAR(100, '99999990D0')
       END sample_size_perc,
       c.num_distinct
       /* uday.psr.v6: getting actual values
       c.low_value,
       c.high_value high_value,
       */
       --Uday.PSR.v6
       -- appending ||'' to avoid ORA-29275: partial multibyte character
       -- sometimes sessions crosses with buffer overflow
       -- 
       ,case when regexp_like(:pii_tables,c.table_name,'i') then NULL
        else
          decode(substr(c.data_type,1,9) -- as there are several timestamp types
          ,'NUMBER'       ,to_char(utl_raw.cast_to_number(c.low_value)) ||''
          ,'VARCHAR2'     ,to_char(utl_raw.cast_to_varchar2(c.low_value)) ||''
          ,'NVARCHAR2'    ,to_char(utl_raw.cast_to_nvarchar2(c.low_value)) ||''
          ,'BINARY_DO'    ,to_char(utl_raw.cast_to_binary_double(c.low_value)) ||''
          ,'BINARY_FL'    ,to_char(utl_raw.cast_to_binary_float(c.low_value)) ||''
          ,'DATE'         ,decode(c.low_value, NULL, NULL, rtrim(
                                to_char(100*(to_number(substr(c.low_value,1,2),'XX')-100)
                                       + (to_number(substr(c.low_value,3,2),'XX')-100),'fm0000')||'-'||
                                to_char(to_number(substr(c.low_value,5,2),'XX'),'fm00')||'-'||
                                to_char(to_number(substr(c.low_value,7,2),'XX'),'fm00')||' '||
                                to_char(to_number(substr(c.low_value,9,2),'XX')-1,'fm00')||':'||
                                to_char(to_number(substr(c.low_value,11,2),'XX')-1,'fm00')||':'||
                                to_char(to_number(substr(c.low_value,13,2),'XX')-1,'fm00'))) ||''
          ,'TIMESTAMP'    ,decode(c.low_value, NULL, NULL, rtrim(
                           to_char(100*(to_number(substr(c.low_value,1,2),'XX')-100)
                                  + (to_number(substr(c.low_value,3,2),'XX')-100),'fm0000')||'-'||
                           to_char(to_number(substr(c.low_value,5,2),'XX'),'fm00')||'-'||
                           to_char(to_number(substr(c.low_value,7,2),'XX'),'fm00')||' '||
                           to_char(to_number(substr(c.low_value,9,2),'XX')-1,'fm00')||':'||
                           to_char(to_number(substr(c.low_value,11,2),'XX')-1,'fm00')||':'||
                           to_char(to_number(substr(c.low_value,13,2),'XX')-1,'fm00')
                          ||'.'||to_number(substr(c.low_value,15,8),'XXXXXXXX')  )) ||''
          , c.low_value
        ) end low_value
       ,case when regexp_like(:pii_tables,c.table_name,'i') then NULL
        else
          decode(substr(c.data_type,1,9) -- as there are several timestamp types
          ,'NUMBER'       ,to_char(utl_raw.cast_to_number(c.high_value)) ||''
          ,'VARCHAR2'     ,to_char(utl_raw.cast_to_varchar2(c.high_value)) ||''
          ,'NVARCHAR2'    ,to_char(utl_raw.cast_to_nvarchar2(c.high_value)) ||''
          ,'BINARY_DO'    ,to_char(utl_raw.cast_to_binary_double(c.high_value)) ||''
          ,'DATE'         ,decode(c.high_value, NULL, NULL, rtrim(
                                to_char(100*(to_number(substr(c.high_value,1,2),'XX')-100)
                                       + (to_number(substr(c.high_value,3,2),'XX')-100),'fm0000')||'-'||
                                to_char(to_number(substr(c.high_value,5,2),'XX'),'fm00')||'-'||
                                to_char(to_number(substr(c.high_value,7,2),'XX'),'fm00')||' '||
                                to_char(to_number(substr(c.high_value,9,2),'XX')-1,'fm00')||':'||
                                to_char(to_number(substr(c.high_value,11,2),'XX')-1,'fm00')||':'||
                                to_char(to_number(substr(c.high_value,13,2),'XX')-1,'fm00'))) ||''
          ,'TIMESTAMP'    ,decode(c.high_value, NULL, NULL, rtrim(
                           to_char(100*(to_number(substr(c.high_value,1,2),'XX')-100)
                                  + (to_number(substr(c.high_value,3,2),'XX')-100),'fm0000')||'-'||
                           to_char(to_number(substr(c.high_value,5,2),'XX'),'fm00')||'-'||
                           to_char(to_number(substr(c.high_value,7,2),'XX'),'fm00')||' '||
                           to_char(to_number(substr(c.high_value,9,2),'XX')-1,'fm00')||':'||
                           to_char(to_number(substr(c.high_value,11,2),'XX')-1,'fm00')||':'||
                           to_char(to_number(substr(c.high_value,13,2),'XX')-1,'fm00')
                          ||'.'||to_char(to_number(substr(c.high_value,15,8),'XXXXXXXX')))) ||''
          , c.high_value
       ) end high_value,
       TO_CHAR(c.last_analyzed, 'YYYY-MM-DD/HH24:MI:SS') last_analyzed,
       c.avg_col_len,
       LOWER(TO_CHAR(c.density, '0D000000EEEE')) density,
       c.num_buckets,
       c.histogram,
       c.hidden_column,
       c.virtual_column,
       c.global_stats,
       c.user_stats
  FROM plan_table pt,
       --Uday.PSR.v6 dba_tables t,
       dba_tab_cols c,
       ic
/* udayRemoved.v6: now this query is in the with clause to improve perf
       (SELECT i.table_owner,
               i.table_name,
               i.column_name,
               COUNT(*) index_count
          FROM dba_ind_columns i
         GROUP BY
               i.table_owner,
               i.table_name,
               i.column_name ) ic
*/
 WHERE pt.object_type = 'TABLE'
   AND STATEMENT_ID = :sql_id
   AND pt.object_owner = c.owner
   AND pt.object_name = c.table_name
   AND ic.table_owner (+) = c.owner
   AND ic.table_name (+) = c.table_name
   AND ic.column_name (+) = c.column_name
 ORDER BY
       -- t.table_name,
       -- t.owner,
       pt.object_name,
       pt.object_owner,
       NVL(ic.index_count,0) DESC,
       c.column_id NULLS LAST,
       c.column_name) v
 UNION ALL
SELECT object_name table_name,
       object_owner owner,
       3 line_type,
       1 row_num,
       '<tr>'||CHR(10)||
       '<th>#</th>'||CHR(10)||
       --'<th>Table Name</th>'||CHR(10)||
       --'<th>Owner</th>'||CHR(10)||
       '<th>Indexes</th>'||CHR(10)||
       '<th>Col<br>ID</th>'||CHR(10)||
       '<th>Column Name</th>'||CHR(10)||
       '<th>Expression</th>'||CHR(10)||       
       '<th>Data<br>Type</th>'||CHR(10)||
       '<th>Null<br>able</th>'||CHR(10)||       
       '<th>Num<br>Rows</th>'||CHR(10)||
       '<th>Num<br>Nulls</th>'||CHR(10)||
       '<th>Sample<br>Size</th>'||CHR(10)||
       '<th>Perc</th>'||CHR(10)||
       '<th>Num<br>Distinct</th>'||CHR(10)||
       '<th>Low Value</th>'||CHR(10)||
       '<th>High Value</th>'||CHR(10)||
       '<th>Last Analyzed</th>'||CHR(10)||
       '<th>Avg<br>Col<br>Len</th>'||CHR(10)||
       '<th>Density</th>'||CHR(10)||
       '<th>Num<br>Buckets</th>'||CHR(10)||
       '<th>Histogram</th>'||CHR(10)||
       '<th>Hidden</th>'||CHR(10)||
       '<th>Virtual</th>'||CHR(10)||
       '<th>Global<br>Stats</th>'||CHR(10)||
       '<th>User<br>Stats</th>'||CHR(10)||
       '</tr>'||CHR(10) line_text
  FROM plan_table
 WHERE object_type = 'TABLE'
   AND STATEMENT_ID = :sql_id
 UNION ALL
SELECT object_name table_name,
       object_owner owner,
       4 line_type,
       1 row_num,
       CHR(10)||'</table></details><!--Pushkar-->'||CHR(10)||CHR(10) line_text
  FROM plan_table
 WHERE object_type = 'TABLE'
   AND STATEMENT_ID = :sql_id) v2
 ORDER BY
       v2.table_name,
       v2.owner,
       v2.line_type,
       v2.row_num;
   
PRO

select round((sysdate-to_date(:start_time,'dd-mon-rr hh24:mi:ss'))*86400) diff from dual;
PRO <table style="width:100%"><tr><td style="text-align:right; background-color:#ffffff">Time taken: ^^diff. seconds</td></tr></table>
PRO </details> <!--Pushkar-->	
exec :start_time := to_char(sysdate,'dd-mon-rr hh24:mi:ss');
/* -------------------------
 *
 * table partitions
 *
 * ------------------------- */
EXEC DBMS_APPLICATION_INFO.SET_CLIENT_INFO('^^method.: Table Partitions - ' || TO_CHAR(SYSDATE, 'YYYY-MM-DD/HH24:MI:SS'));
PRO <a name="tbl_parts"></a><details open><br/><summary id="summary2">Table Partitions</summary>

SELECT '<!-- '||TO_CHAR(SYSDATE, 'YYYY-MM-DD/HH24:MI:SS')||' -->' FROM dual;
PRO <!-- Please Wait -->	

SELECT /* ^^script..sql Table Partitions */
       v2.line_text
  FROM (
--Uday.PSR.v6WITH object AS (
--Uday.PSR.v6SELECT /*+ MATERIALIZE */
--Uday.PSR.v6       object_owner owner, object_name name, object_type
--Uday.PSR.v6  FROM gv$sql_plan
--Uday.PSR.v6 WHERE inst_id IN (SELECT inst_id FROM gv$instance)
--Uday.PSR.v6   AND sql_id = :sql_id
--Uday.PSR.v6   AND object_owner IS NOT NULL
--Uday.PSR.v6   AND object_name IS NOT NULL
--Uday.PSR.v6   AND not (object_type = 'TABLE (TEMP)' and object_name like 'SYS_TEMP%') --Uday.v6
--Uday.PSR.v6 UNION
--Uday.PSR.v6SELECT object_owner owner, object_name name, object_type
--Uday.PSR.v6  FROM dba_hist_sql_plan
--Uday.PSR.v6 WHERE :license IN ('T', 'D')
--Uday.PSR.v6   AND dbid = ^^dbid.
--Uday.PSR.v6   AND sql_id = :sql_id
--Uday.PSR.v6   AND object_owner IS NOT NULL
--Uday.PSR.v6   AND object_name IS NOT NULL
--Uday.PSR.v6   AND not (object_type = 'TABLE (TEMP)' and object_name like 'SYS_TEMP%') --Uday.v6
--Uday.PSR.v6 ), plan_tables AS (
--Uday.PSR.v6 SELECT /*+ MATERIALIZE */
--Uday.PSR.v6        'TABLE' object_type, p.table_owner object_owner, p.table_name object_name
--Uday.PSR.v6   FROM dba_tab_partitions p, -- include fixed objects
--Uday.PSR.v6        object o
--Uday.PSR.v6  WHERE p.table_owner = o.owner
--Uday.PSR.v6    AND p.table_name = o.name
--Uday.PSR.v6    AND o.object_type like 'TABLE%'  --Uday.v6
--Uday.PSR.v6  UNION
--Uday.PSR.v6 SELECT 'TABLE' object_type, i.table_owner object_owner, i.table_name object_name
--Uday.PSR.v6   FROM dba_indexes i,
--Uday.PSR.v6        dba_ind_partitions p,
--Uday.PSR.v6        object o
--Uday.PSR.v6  WHERE i.owner = o.owner
--Uday.PSR.v6    AND o.object_type like 'INDEX%'  --Uday.v6
--Uday.PSR.v6    AND i.index_name = o.name
--Uday.PSR.v6	AND i.owner = p.index_owner(+)  -- partitioned table but not part index in the plan
--Uday.PSR.v6	AND i.index_name = p.index_name(+)  -- same as above
--Uday.PSR.v6)
SELECT object_name table_name,
       object_owner owner,
       1 line_type,
       1 row_num,
       '<a name="tp_'||LOWER(object_name||'_'||object_owner)||'"></a><details><br/><summary id="summary3">Table Partitions: '||object_name||' ('||object_owner||')</summary>'||CHR(10)||CHR(10)||
       'Table partitions and relevant attributes (only the first and last 100).'||CHR(10)||CHR(10)||
       '<table>'||CHR(10)||CHR(10)||
       '<tr>'||CHR(10)||
       '<th>#</th>'||CHR(10)||
       '<th>Partition<br>Position</th>'||CHR(10)||
       '<th>Partition<br>Name</th>'||CHR(10)||
       '<th>Composite</th>'||CHR(10)||
       '<th>Subpartition<br>Count</th>'||CHR(10)||
       '<th>Num<br>Rows</th>'||CHR(10)||
       '<th>Sample<br>Size</th>'||CHR(10)||
       '<th>Perc</th>'||CHR(10)||
       '<th>Last Analyzed</th>'||CHR(10)||
       '<th>Blocks</th>'||CHR(10)||    
       '<th>Avg<br>Row<br>Len</th>'||CHR(10)||
       '<th>Global<br>Stats</th>'||CHR(10)||
       '<th>User<br>Stats</th>'||CHR(10)||
       '<th>Staleness<br>Perc</th>'||CHR(10)||
       '</tr>'||CHR(10) line_text
  FROM plan_table
 WHERE object_type = 'TABLE'
   AND STATEMENT_ID = :sql_id
 UNION ALL
SELECT v.table_name,
       v.table_owner,
       2 line_type,
       ROWNUM row_num,
       CHR(10)||'<tr>'||CHR(10)||
       '<td class="r">'||ROWNUM||'</td>'||CHR(10)||
	   '<td class="c">'||v.partition_position||'</td>'||CHR(10)||
       '<td class="c">'||v.partition_name||'</td>'||CHR(10)||
       '<td class="c">'||v.composite||'</td>'||CHR(10)||
       '<td class="r">'||v.subpartition_count||'</td>'||CHR(10)||
       '<td class="r">'||v.num_rows||'</td>'||CHR(10)||
       '<td class="r">'||v.sample_size||'</td>'||CHR(10)||
       '<td class="r">'||v.sample_size_perc||'</td>'||CHR(10)||
       '<td nowrap>'||v.last_analyzed||'</td>'||CHR(10)||
       '<td class="r">'||v.blocks||'</td>'||CHR(10)||
       '<td class="r">'||v.avg_row_len||'</td>'||CHR(10)||
       '<td class="c">'||v.global_stats||'</td>'||CHR(10)||
       '<td class="c">'||v.user_stats||'</td>'||CHR(10)||
       '<td class="r">'||v.staleness_perc||'</td>'||CHR(10)||
       '</tr>'
  FROM (
SELECT DISTINCT v.table_name,
       v.table_owner,
	   v.partition_name,
	   v.partition_position,
	   v.subpartition_count,
	   v.composite,
       v.num_rows,
       v.sample_size,
       v.sample_size_perc,
       v.last_analyzed,
       v.blocks,
       v.avg_row_len,
       v.global_stats,
       v.user_stats,
       v.staleness_perc
  FROM (  
SELECT /*+ NO_MERGE LEADING(pt s m) */
       s.table_name,
       s.table_owner,
	   s.partition_name,
	   s.partition_position,
	   s.subpartition_count,
	   s.composite,
       s.num_rows,
       s.sample_size,
       CASE WHEN s.num_rows > 0 THEN TO_CHAR(ROUND(s.sample_size * 100 / s.num_rows, 1), '99999990D0') END sample_size_perc,
       TO_CHAR(s.last_analyzed, 'YYYY-MM-DD/HH24:MI:SS') last_analyzed,
       s.blocks,
       s.avg_row_len,
       s.global_stats,
       s.user_stats,
       CASE WHEN s.num_rows > 0 THEN TO_CHAR(ROUND((m.inserts + m.updates + m.deletes) * 100 / s.num_rows, 1), '99999990D0') END staleness_perc,
	   ROW_NUMBER() OVER (PARTITION BY s.table_owner, s.table_name ORDER BY s.partition_position DESC) row_num 
  FROM plan_table pt,
       dba_tab_partitions s,
       sys.dba_tab_modifications m -- requires sys on 10g
 WHERE pt.object_type = 'TABLE'
   AND STATEMENT_ID = :sql_id
   AND pt.object_owner = s.table_owner
   AND pt.object_name = s.table_name
   AND s.table_owner = m.table_owner(+)
   AND s.table_name = m.table_name(+)
   AND s.partition_name = m.partition_name(+)
UNION 
SELECT /*+ NO_MERGE LEADING(pt s m) */
       s.table_name,
       s.table_owner,
	   s.partition_name,
	   s.partition_position,
	   s.subpartition_count,
	   s.composite,
       s.num_rows,
       s.sample_size,
       CASE WHEN s.num_rows > 0 THEN TO_CHAR(ROUND(s.sample_size * 100 / s.num_rows, 1), '99999990D0') END sample_size_perc,
       TO_CHAR(s.last_analyzed, 'YYYY-MM-DD/HH24:MI:SS') last_analyzed,
       s.blocks,
       s.avg_row_len,
       s.global_stats,
       s.user_stats,
       CASE WHEN s.num_rows > 0 THEN TO_CHAR(ROUND((m.inserts + m.updates + m.deletes) * 100 / s.num_rows, 1), '99999990D0') END staleness_perc,
	   ROW_NUMBER() OVER (PARTITION BY s.table_owner, s.table_name ORDER BY s.partition_position ASC) row_num 
  FROM plan_table pt,
       dba_tab_partitions s,
       sys.dba_tab_modifications m -- requires sys on 10g
 WHERE pt.object_type = 'TABLE'
   AND STATEMENT_ID = :sql_id
   AND pt.object_owner = s.table_owner
   AND pt.object_name = s.table_name
   AND s.table_owner = m.table_owner(+)
   AND s.table_name = m.table_name(+)
   AND s.partition_name = m.partition_name(+)   
   ) v
 WHERE v.row_num BETWEEN 1 AND 100
 ORDER BY
       v.table_name,
       v.table_owner,
	   v.partition_position DESC) v
 UNION ALL
SELECT object_name table_name,
       object_owner owner,
       3 line_type,
       1 row_num,
       '<tr>'||CHR(10)||
       '<th>#</th>'||CHR(10)||
       '<th>Partition<br>Position</th>'||CHR(10)||
       '<th>Partition<br>Name</th>'||CHR(10)||
       '<th>Composite</th>'||CHR(10)||
       '<th>Subpartition<br>Count</th>'||CHR(10)||
       '<th>Num<br>Rows</th>'||CHR(10)||
       '<th>Sample<br>Size</th>'||CHR(10)||
       '<th>Perc</th>'||CHR(10)||
       '<th>Last Analyzed</th>'||CHR(10)||
       '<th>Blocks</th>'||CHR(10)||    
       '<th>Avg<br>Row<br>Len</th>'||CHR(10)||
       '<th>Global<br>Stats</th>'||CHR(10)||
       '<th>User<br>Stats</th>'||CHR(10)||
       '<th>Staleness<br>Perc</th>'||CHR(10)||
       '</tr>'||CHR(10) line_text
  FROM plan_table
 WHERE object_type = 'TABLE'
   AND STATEMENT_ID = :sql_id
 UNION ALL
SELECT object_name table_name,
       object_owner owner,
       4 line_type,
       1 row_num,
       CHR(10)||'</table></details><!--Pushkar-->'||CHR(10)||CHR(10) line_text
  FROM plan_table
 WHERE object_type = 'TABLE'
   AND STATEMENT_ID = :sql_id) v2
 ORDER BY
       v2.table_name,
       v2.owner,
       v2.line_type,
       v2.row_num;	      


select round((sysdate-to_date(:start_time,'dd-mon-rr hh24:mi:ss'))*86400) diff from dual;
PRO <table style="width:100%"><tr><td style="text-align:right; background-color:#ffffff">Time taken: ^^diff. seconds</td></tr></table>
PRO </details> <!--Pushkar-->	 
exec :start_time := to_char(sysdate,'dd-mon-rr hh24:mi:ss');  
/* -------------------------
 *
 * table constraints
 *
 * ------------------------- */
EXEC DBMS_APPLICATION_INFO.SET_CLIENT_INFO('^^method.: Table Constraints - ' || TO_CHAR(SYSDATE, 'YYYY-MM-DD/HH24:MI:SS'));
PRO <a name="tbl_constr"></a><details><br/><summary id="summary2">Table Constraints</summary>

SELECT '<!-- '||TO_CHAR(SYSDATE, 'YYYY-MM-DD/HH24:MI:SS')||' -->' FROM dual;
PRO <!-- Please Wait -->	

SELECT /* ^^script..sql Table Constraints */
       v2.line_text
  FROM (
--Uday.PSR.v6 WITH object AS (
--Uday.PSR.v6 SELECT /*+ MATERIALIZE */
--Uday.PSR.v6        object_owner owner, object_name name, object_type
--Uday.PSR.v6   FROM gv$sql_plan
--Uday.PSR.v6  WHERE inst_id IN (SELECT inst_id FROM gv$instance)
--Uday.PSR.v6    AND sql_id = :sql_id
--Uday.PSR.v6    AND object_owner IS NOT NULL
--Uday.PSR.v6    AND object_name IS NOT NULL
--Uday.PSR.v6    AND not (object_type = 'TABLE (TEMP)' and object_name like 'SYS_TEMP%') --Uday.v6
--Uday.PSR.v6  UNION
--Uday.PSR.v6 SELECT object_owner owner, object_name name, object_type
--Uday.PSR.v6   FROM dba_hist_sql_plan
--Uday.PSR.v6  WHERE dbid = ^^dbid.
--Uday.PSR.v6    AND sql_id = :sql_id
--Uday.PSR.v6    AND object_owner IS NOT NULL
--Uday.PSR.v6    AND object_name IS NOT NULL
--Uday.PSR.v6    AND not (object_type = 'TABLE (TEMP)' and object_name like 'SYS_TEMP%') --Uday.v6
--Uday.PSR.v6  ), plan_tables AS (
--Uday.PSR.v6 --UdayRemoved.v6 SELECT /*+ MATERIALIZE */
--Uday.PSR.v6 --UdayRemoved.v6        'TABLE' object_type, p.owner object_owner, p.table_name object_name
--Uday.PSR.v6 --UdayRemoved.v6   FROM dba_tables p, -- include fixed objects
--Uday.PSR.v6 --UdayRemoved.v6        object o
--Uday.PSR.v6 --UdayRemoved.v6  WHERE p.owner = o.owner
--Uday.PSR.v6 --UdayRemoved.v6    AND p.table_name = o.name
--Uday.PSR.v6  SELECT /*+ MATERIALIZE */
--Uday.PSR.v6         'TABLE' object_type, o.owner object_owner, o.name object_name
--Uday.PSR.v6    FROM object o
--Uday.PSR.v6   WHERE o.object_type like 'TABLE%'
--Uday.PSR.v6   UNION
--Uday.PSR.v6  SELECT 'TABLE' object_type, i.table_owner object_owner, i.table_name object_name
--Uday.PSR.v6    FROM dba_indexes i,
--Uday.PSR.v6         object o
--Uday.PSR.v6   WHERE o.object_type like 'INDEX%'  --Uday.v6
--Uday.PSR.v6     AND i.owner = o.owner
--Uday.PSR.v6     AND i.index_name = o.name
--Uday.PSR.v6 )
SELECT object_name table_name,
       object_owner owner,
       1 line_type,
       1 row_num,
       '<a name="tc_'||LOWER(object_name||'_'||object_owner)||'"></a><details><br/><summary id="summary3">Table Constraints: '||object_name||' ('||object_owner||')</summary>'||CHR(10)||CHR(10)||
       'Table constraints and relevant attributes.'||CHR(10)||CHR(10)||
       '<table>'||CHR(10)||CHR(10)||
       '<tr>'||CHR(10)||
       '<th>#</th>'||CHR(10)||
       '<th>Constraint<br>Name</th>'||CHR(10)||
       '<th>Constraint<br>Type</th>'||CHR(10)||
    --  '<th>Search<br>Condition</th>'||CHR(10)||
       '<th>R Owner</th>'||CHR(10)||
       '<th>R Constraint<br>Name</th>'||CHR(10)||
       '<th>Delete<br>Rule</th>'||CHR(10)||
       '<th>Status</th>'||CHR(10)||
       '<th>Defferable</th>'||CHR(10)||    
       '<th>Deferred</th>'||CHR(10)||
       '<th>Validated</th>'||CHR(10)||
       '<th>Generated</th>'||CHR(10)||
       '<th>Rely</th>'||CHR(10)||
	   '<th>Last<br>Change</th>'||CHR(10)||
	   '<th>Index<br>Owner</th>'||CHR(10)||
	   '<th>Index<br>Name</th>'||CHR(10)||
	   '<th>Invalid</th>'||CHR(10)||
	   '<th>View<br>Related</th>'||CHR(10)||
       '</tr>'||CHR(10) line_text
  FROM plan_table
 WHERE object_type = 'TABLE'
   AND STATEMENT_ID = :sql_id
 UNION ALL
SELECT v.table_name,
       v.owner,
       2 line_type,
       ROWNUM row_num,
       CHR(10)||'<tr>'||CHR(10)||
       '<td class="r">'||ROWNUM||'</td>'||CHR(10)||
	   '<td class="c">'||v.constraint_name||'</td>'||CHR(10)||
       '<td class="c">'||v.constraint_type||'</td>'||CHR(10)||
     --  '<td class="c">'||v.search_condition||'</td>'||CHR(10)||
       '<td class="r">'||v.r_owner||'</td>'||CHR(10)||
       '<td class="r">'||v.r_constraint_name||'</td>'||CHR(10)||
       '<td class="r">'||v.delete_rule||'</td>'||CHR(10)||
       '<td class="r">'||v.status||'</td>'||CHR(10)||
       '<td class="r">'||v.deferrable||'</td>'||CHR(10)||
       '<td class="r">'||v.deferred||'</td>'||CHR(10)||
       '<td class="r">'||v.validated||'</td>'||CHR(10)||
       '<td class="c">'||v.generated||'</td>'||CHR(10)||
       '<td class="c">'||v.rely||'</td>'||CHR(10)||
       '<td class="r">'||v.last_change||'</td>'||CHR(10)||
	   '<td class="r">'||v.index_owner||'</td>'||CHR(10)||
	   '<td class="r">'||v.index_name||'</td>'||CHR(10)||
	   '<td class="r">'||v.invalid||'</td>'||CHR(10)||
	   '<td class="r">'||v.view_related||'</td>'||CHR(10)||
       '</tr>'
  FROM (  
SELECT /*+ NO_MERGE LEADING(pt s) */
       s.table_name,
       s.owner,
       s.constraint_name,
	   s.constraint_type,
	  -- dbms_lob.substr(s.search_condition,1,100) search_condition,
	   s.r_owner,
	   s.r_constraint_name,
       s.delete_rule,
       s.status,
       s.deferrable,
       s.deferred,
       s.validated,
       s.generated,
       s.rely,
       s.last_change,
       s.index_owner,
	   s.index_name,
	   s.invalid,
	   s.view_related
  FROM plan_table pt,
       dba_constraints s
 WHERE pt.object_type = 'TABLE'
   AND STATEMENT_ID = :sql_id
   AND pt.object_owner = s.owner
   AND pt.object_name = s.table_name) v
 UNION ALL
SELECT object_name table_name,
       object_owner owner,
       3 line_type,
       1 row_num,
       '<tr>'||CHR(10)||
       '<th>#</th>'||CHR(10)||
       '<th>Constraint<br>Name</th>'||CHR(10)||
       '<th>Constraint<br>Type</th>'||CHR(10)||
     --  '<th>Search<br>Condition</th>'||CHR(10)||
       '<th>R Owner</th>'||CHR(10)||
       '<th>R Constraint<br>Name</th>'||CHR(10)||
       '<th>Delete<br>Rule</th>'||CHR(10)||
       '<th>Status</th>'||CHR(10)||
       '<th>Defferable</th>'||CHR(10)||    
       '<th>Deferred</th>'||CHR(10)||
       '<th>Validated</th>'||CHR(10)||
       '<th>Generated</th>'||CHR(10)||
       '<th>Rely</th>'||CHR(10)||
	   '<th>Last<br>Change</th>'||CHR(10)||
	   '<th>Index<br>Owner</th>'||CHR(10)||
	   '<th>Index<br>Name</th>'||CHR(10)||
	   '<th>Invalid</th>'||CHR(10)||
	   '<th>View<br>Related</th>'||CHR(10)||
       '</tr>'||CHR(10) line_text
  FROM plan_table
 WHERE object_type = 'TABLE'
   AND STATEMENT_ID = :sql_id
 UNION ALL
SELECT object_name table_name,
       object_owner owner,
       4 line_type,
       1 row_num,
       CHR(10)||'</table></details><!--Pushkar-->'||CHR(10)||CHR(10) line_text
  FROM plan_table
 WHERE object_type = 'TABLE'
   AND STATEMENT_ID = :sql_id
 ) v2
 ORDER BY
       v2.table_name,
       v2.owner,
       v2.line_type,
       v2.row_num;		 


select round((sysdate-to_date(:start_time,'dd-mon-rr hh24:mi:ss'))*86400) diff from dual;
PRO <table style="width:100%"><tr><td style="text-align:right; background-color:#ffffff">Time taken: ^^diff. seconds</td></tr></table>
PRO </details> <!--Pushkar--> 
exec :start_time := to_char(sysdate,'dd-mon-rr hh24:mi:ss');
/* -------------------------
 *
 * tables statistics version
 * psrv9: added row change, %-row change columns
 *
 * ------------------------- */
EXEC DBMS_APPLICATION_INFO.SET_CLIENT_INFO('^^method.: Tables Statistics versions - ' || TO_CHAR(SYSDATE, 'YYYY-MM-DD/HH24:MI:SS'));
PRO <a name="tbl_stat_ver"></a><details open><br/><summary id="summary2">Tables Statistics Versions</summary>
PRO
PRO CBO Statistics and relevant attributes.
PRO
PRO <table>
PRO
PRO <tr>
PRO <th>#</th>
PRO <th>Table Name</th>
PRO <th>Owner</th>
PRO <th>Version Type</th>
PRO <th>Save Time</th>
PRO <th>Last Analyzed</th>
PRO <th>Num Rows</th>
PRO <th>Row Change</th>
PRO <th>%-<br>Row Change</th>
PRO <th>Sample<br>Size</th>
PRO <th>Sample<br>Perc</th>
PRO <th>Blocks</th>
PRO <th>Avg<br>Row<br>Len</th>
PRO </tr>
PRO
SELECT '<!-- '||TO_CHAR(SYSDATE, 'YYYY-MM-DD/HH24:MI:SS')||' -->' FROM dual;
PRO <!-- Please Wait -->
	   
SELECT /* ^^script..sql Tables Statistics Versions */
       CHR(10)||'<tr>'||CHR(10)||
       '<td class="r">'||ROWNUM||'</td>'||CHR(10)||
       '<td>'||v.object_name||'</td>'||CHR(10)||
       '<td>'||v.owner||'</td>'||CHR(10)||
       '<td>'||v.version_type||'</td>'||CHR(10)||	   
       '<td nowrap>'||v.savtime||'</td>'||CHR(10)||
       '<td nowrap>'||v.analyzetime||'</td>'||CHR(10)||
       '<td class="r">'||v.rowcnt||'</td>'||CHR(10)||
       '<td class="r">'||v.rowchange||'</td>'||CHR(10)||
       '<td class="r">'||v.pctrowchange||'</td>'||CHR(10)||
       '<td class="r">'||v.samplesize||'</td>'||CHR(10)||
       '<td class="c">'||v.perc||'</td>'||CHR(10)||
       '<td class="c">'||v.blkcnt||'</td>'||CHR(10)||
       '<td class="c">'||v.avgrln||'</td>'||CHR(10)||
       '</tr>'
  FROM (
--Uday.PSR.v6 WITH object AS (
--Uday.PSR.v6 SELECT /*+ MATERIALIZE */
--Uday.PSR.v6        object_owner owner, object_name name, object_type
--Uday.PSR.v6   FROM gv$sql_plan
--Uday.PSR.v6  WHERE inst_id IN (SELECT inst_id FROM gv$instance)
--Uday.PSR.v6    AND sql_id = :sql_id
--Uday.PSR.v6    AND object_owner IS NOT NULL
--Uday.PSR.v6    AND object_name IS NOT NULL
--Uday.PSR.v6    AND not (object_type = 'TABLE (TEMP)' and object_name like 'SYS_TEMP%') --Uday.v6
--Uday.PSR.v6  UNION
--Uday.PSR.v6 SELECT object_owner owner, object_name name, object_type
--Uday.PSR.v6   FROM dba_hist_sql_plan
--Uday.PSR.v6  WHERE :license IN ('T', 'D')
--Uday.PSR.v6    AND dbid = ^^dbid.
--Uday.PSR.v6    AND sql_id = :sql_id
--Uday.PSR.v6    AND object_owner IS NOT NULL
--Uday.PSR.v6    AND object_name IS NOT NULL
--Uday.PSR.v6    AND not (object_type = 'TABLE (TEMP)' and object_name like 'SYS_TEMP%') --Uday.v6
--Uday.PSR.v6  ), plan_tables AS (
--Uday.PSR.v6 --UdayRemoved.v6 SELECT /*+ MATERIALIZE */
--Uday.PSR.v6 --UdayRemoved.v6        'TABLE' object_type, t.owner object_owner, t.table_name object_name
--Uday.PSR.v6 --UdayRemoved.v6   FROM dba_tab_statistics t, -- include fixed objects
--Uday.PSR.v6 --UdayRemoved.v6        object o
--Uday.PSR.v6 --UdayRemoved.v6  WHERE t.owner = o.owner
--Uday.PSR.v6 --UdayRemoved.v6    AND t.table_name = o.name
--Uday.PSR.v6  SELECT /*+ MATERIALIZE */
--Uday.PSR.v6         'TABLE' object_type, o.owner object_owner, o.name object_name
--Uday.PSR.v6    FROM object o
--Uday.PSR.v6   WHERE o.object_type like 'TABLE%'
--Uday.PSR.v6   UNION
--Uday.PSR.v6  SELECT 'TABLE' object_type, i.table_owner object_owner, i.table_name object_name
--Uday.PSR.v6    FROM dba_indexes i,
--Uday.PSR.v6         object o
--Uday.PSR.v6   WHERE o.object_type like 'INDEX%'
--Uday.PSR.v6     AND i.owner = o.owner
--Uday.PSR.v6     AND i.index_name = o.name
--Uday.PSR.v6 )
SELECT 
       object_name,
       owner,
       version_type,
       savtime,
       analyzetime,
       rowcnt,
       case when lead(rowcnt) over(partition by object_name order by savtime desc nulls first) is null then '-'
            else to_char(rowcnt - nvl(lead(rowcnt) over(partition by object_name order by savtime desc nulls first), 0))
       end rowchange,
       case when lead(rowcnt) over(partition by object_name order by savtime desc nulls first) is null then '-'
            when lead(rowcnt) over(partition by object_name order by savtime desc nulls first) = 0 then to_char(100*rowcnt)
       else to_char(round(100*(rowcnt - (lead(rowcnt) over(partition by object_name order by savtime desc nulls first)))/(lead(rowcnt) over(partition by object_name order by savtime desc nulls first)), 1), '99999990D0')
       end pctrowchange,
       samplesize,
       perc,
       blkcnt,
       avgrln
  FROM (
--Uday.PSR.v6 SELECT /*+ NO_MERGE LEADING(pt t) */
--Uday.PSR.v6        t.table_name object_name,
--Uday.PSR.v6        t.owner,
--Uday.PSR.v6        'CURRENT' version_type,
--Uday.PSR.v6        NULL savtime, 
--Uday.PSR.v6        t.last_analyzed analyzetime, 
--Uday.PSR.v6        t.num_rows rowcnt, 
--Uday.PSR.v6        t.sample_size samplesize, 
--Uday.PSR.v6        CASE WHEN t.num_rows > 0 THEN TO_CHAR(ROUND(t.sample_size * 100 / t.num_rows, 1), '99999990D0') END perc, 
--Uday.PSR.v6        t.blocks blkcnt, 
--Uday.PSR.v6        t.avg_row_len avgrln
SELECT /*+ NO_MERGE LEADING(pt t) */
       pt.object_name,
       pt.object_owner owner,
       'CURRENT' version_type,
       NULL savtime, 
       pt.optimizer analyzetime, 
       pt.cardinality rowcnt, 
       pt.cost samplesize, 
       CASE WHEN pt.cardinality > 0 THEN TO_CHAR(ROUND(pt.cost * 100 / pt.cardinality, 1), '99999990D0') END perc, 
       pt.io_cost blkcnt, 
       pt.bytes avgrln
  FROM plan_table pt
       -- dba_tables t
 WHERE pt.object_type = 'TABLE'
   AND STATEMENT_ID = :sql_id
   -- AND pt.object_owner = t.owner
   -- AND pt.object_name = t.table_name
UNION ALL
SELECT /*+ NO_MERGE LEADING(pt t h) index(h I_WRI$_OPTSTAT_TAB_OBJ#_ST) */
       t.object_name,
       t.owner,
       'HISTORY' version_type,
       TO_CHAR(h.savtime, 'YYYY-MM-DD/HH24:MI:SS') savtime, 
       TO_CHAR(h.analyzetime, 'YYYY-MM-DD/HH24:MI:SS') analyzetime, 
       h.rowcnt, 
       h.samplesize, 
       CASE WHEN h.rowcnt > 0 THEN TO_CHAR(ROUND(h.samplesize * 100 / h.rowcnt, 1), '99999990D0') END perc, 
       h.blkcnt, 
       h.avgrln
  FROM plan_table pt,
       dba_objects t,
       sys.WRI$_OPTSTAT_TAB_HISTORY h
 WHERE pt.object_type = 'TABLE'
   AND STATEMENT_ID = :sql_id
   AND pt.object_owner = t.owner
   AND pt.object_name = t.object_name
   AND t.object_type = 'TABLE'
   AND t.object_id = h.obj#
   AND (:license IN ('T', 'D') or (:license = 'L' and h.savtime > systimestamp - interval '^^days.' day))
)
 ORDER BY
       object_name,
       owner,
	   savtime DESC NULLS FIRST
) v;	   

PRO
PRO <tr>
PRO <th>#</th>
PRO <th>Table Name</th>
PRO <th>Owner</th>
PRO <th>Version Type</th>
PRO <th>Save Time</th>
PRO <th>Last Analyzed</th>
PRO <th>Num Rows</th>
PRO <th>Row Change</th>
PRO <th>%-Row Change</th>
PRO <th>Sample<br>Size</th>
PRO <th>Perc</th>
PRO <th>Blocks</th>
PRO <th>Avg<br>Row<br>Len</th>
PRO </tr>
PRO
PRO </table>

select round((sysdate-to_date(:start_time,'dd-mon-rr hh24:mi:ss'))*86400) diff from dual;
PRO <table style="width:100%"><tr><td style="text-align:right; background-color:#ffffff">Time taken: ^^diff. seconds</td></tr></table>
PRO </details><!--Pushkar-->
exec :start_time := to_char(sysdate,'dd-mon-rr hh24:mi:ss');
 
/* -------------------------
 *
 * Bootstrap Jobs 
 *
 * Uday -- PSRv10
 * Jinsoo added source column
 * ------------------------- */
EXEC DBMS_APPLICATION_INFO.SET_CLIENT_INFO('^^method.: Bootstrap Stats Log - ' || TO_CHAR(SYSDATE, 'YYYY-MM-DD/HH24:MI:SS'));
PRO <a name="bootstrap_joblog"></a><details open><br/><summary id="summary2">Bootstrap Stats Log (FND_STATS_BS_LOG)</summary>
PRO
PRO Bootstrap Stats Log
PRO
PRO <table>
PRO
PRO <tr>
PRO <th>#</th>
PRO <th>Table Name</th>
PRO <th>Stats Gather Time</th>
PRO <th>Time<br>Taken<br>sec</th>
PRO <th>Stats Details</th>
PRO <th>Source</th>
PRO </tr>
PRO
SELECT '<!-- '||TO_CHAR(SYSDATE, 'YYYY-MM-DD/HH24:MI:SS')||' -->' FROM dual;
PRO <!-- Please Wait -->

SELECT /* ^^script..sql Bootstrap Jobs */
       CHR(10)||'<tr>'||CHR(10)||
       '<td class="r">'||ROWNUM||'</td>'||CHR(10)||
       '<td>'||v.table_name||'</td>'||CHR(10)||
       '<td>'||v.STATS_GATHER_TIME||'</td>'||CHR(10)||
       '<td class="r">'||round((v.ELAPSED_CENTI/100),1)||'</td>'||CHR(10)||      
       '<td>'||v.STATS_DETAILS||'</td>'||CHR(10)||
       '<td>'||v.SOURCE||'</td>'||CHR(10)||
       '</tr>'
  FROM (
 SELECT /*+ leading(t bs) */
        bs.table_name, TO_CHAR(bs.STATS_GATHER_TIME,'YYYY-MM-DD/HH24:MI:SS') STATS_GATHER_TIME, bs.ELAPSED_CENTI, bs.STATS_DETAILS, bs.SOURCE
   FROM FUSION.FND_STATS_BS_LOG bs,
        plan_table t
  WHERE bs.table_name = t.object_name
    AND t.STATEMENT_ID = :sql_id
    AND bs.STATS_DETAILS like 'N(%'
    and (:license IN ('T', 'D') or (:license = 'L' and bs.STATS_GATHER_TIME > sysdate - interval '^^days.' day))   
 ORDER BY bs.table_name, bs.STATS_GATHER_TIME desc
) v
;

PRO
PRO <tr>
PRO <th>#</th>
PRO <th>Table Name</th>
PRO <th>Stats Gather Time</th>
PRO <th>Time<br>Taken<br>sec</th>
PRO <th>Stats Details</th>
PRO <th>Source</th>
PRO </tr>
PRO
PRO </table>

select round((sysdate-to_date(:start_time,'dd-mon-rr hh24:mi:ss'))*86400) diff from dual;
PRO <table style="width:100%"><tr><td style="text-align:right; background-color:#ffffff">Time taken: ^^diff. seconds</td></tr></table>
PRO </details><!--Pushkar-->
exec :start_time := to_char(sysdate,'dd-mon-rr hh24:mi:ss');

PRO <a name="bootstrap_joblog"></a><details open><br/><summary id="summary2">Gather Table Stats Details (DBA_OPTSTAT_OPERATIONS)</summary>
PRO

PRO<table>
PRO
PRO <tr>
PRO <th>Table Name</th>
PRO <th>Job</th>
PRO <th>Operation</th>
PRO <th>ID</th>
PRO <th>Notes/Parameters to dbms_stats.gather_table_stata</th>
PRO <th>Stats Gather Time</th>
PRO <th>Duration</th>
rem PRO <th>Target #_of_blocks</th>
PRO </tr>
PRO
SELECT '<!-- '||TO_CHAR(SYSDATE, 'YYYY-MM-DD/HH24:MI:SS')||' -->' FROM dual;
PRO <!-- Please Wait -->

select 
  '<tr>'||
  '<td>'|| v.object_name||'</td>'||
  '<td>'|| v.job_name||'</td>'||
  '<td>'|| v.operation||'</td>'||
  '<td>'|| v.id||'</td>'||
  '<td>'|| v.notes||'</td>'|| 
  '<td nowrap>'|| to_char(v.start_time,'YYYY-MM-DD/HH24:MI:SS')||'</td>'||
  '<td nowrap>'|| to_char(v.end_time - v.start_time) ||'</td>'||
--  '<td>'|| (select target_size from dba_optstat_operation_tasks t where t.opid = v.id and upper(t.target)=o.target and t.target_type = 'TABLE') ||'</td>'||  
  '</tr>'
from
( 
select /*+ leading(pt) */
   pt.object_name,
   start_time,
   end_time,
   o.job_name,
   o.operation,
   o.id,
   listagg(v.param_name||'=>'||v.param_val,', ') within group (order by v.param_name desc) notes
from dba_optstat_operations o, plan_table pt,
     xmltable ('params/param' passing xmltype (o.notes) 
               columns
                 param_name varchar2(128) path '@name',
                 param_val  varchar2(128) path '@val'
              ) v
where pt.object_type= 'TABLE'
and pt.statement_id = :sql_id
and regexp_substr(lower(replace(o.target,'"')),'^(.*?)\.([a-z0-9$_#]+)',1,1,'i',2) = pt.object_name
and o.status   = 'COMPLETED'
and o.operation= 'gather_table_stats'
and (param_name NOT LIKE 'st%' and param_name <> 'method_opt')
and (:license IN ('T', 'D') or (:license = 'L' and o.start_time > systimestamp - interval '^^days.' day))
group by pt.object_name, start_time, end_time, o.job_name, o.operation, o.id
) v
order by v.object_name, v.id desc;

PRO
PRO <tr>
PRO <th>Table Name</th>
PRO <th>Job</th>
PRO <th>Operation</th>
PRO <th>ID</th>
PRO <th>Notes/Parameters to dbms_stats.gather_table_stata</th>
PRO <th>Stats Gather Time</th>
PRO <th>Duration</th>
rem PRO <th>Target #_of_blocks</th>
PRO </tr>
PRO
PRO </table>

select round((sysdate-to_date(:start_time,'dd-mon-rr hh24:mi:ss'))*86400) diff from dual;
PRO <table style="width:100%"><tr><td style="text-align:right; background-color:#ffffff">Time taken: ^^diff. seconds</td></tr></table>
PRO </details><!--Pushkar-->
exec :start_time := to_char(sysdate,'dd-mon-rr hh24:mi:ss');


/* -------------------------
 *
 * table modifications
 *
 * Uday
 * ------------------------- */
EXEC DBMS_APPLICATION_INFO.SET_CLIENT_INFO('^^method.: Tables modifications - ' || TO_CHAR(SYSDATE, 'YYYY-MM-DD/HH24:MI:SS'));
PRO <a name="tbl_modifications"></a><details open><br/><summary id="summary2">Table Modifications</summary>
PRO
PRO Table Modifications
PRO
PRO <table>
PRO <tr>
PRO <th>#</th>
PRO <th>Table Name</th>
PRO <th>Owner</th>
PRO <th>Num Rows</th>
PRO <th>Partition</th>
PRO <th>Sub-Partition</th>
PRO <th>Inserts</th>
PRO <th>Updates</th>
PRO <th>Deletes</th>
PRO <th>Truncated</th>
PRO <th>Dropped Segments</th>
PRO <th>Last Analyzed</th>
PRO <th>Last Modified</th>
PRO <th>Percent<br>Modifications</th>
PRO </tr>
PRO
SELECT '<!-- '||TO_CHAR(SYSDATE, 'YYYY-MM-DD/HH24:MI:SS')||' -->' FROM dual;
PRO <!-- Please Wait -->
	   
SELECT /* ^^script..sql Tables modifications */
       CHR(10)||'<tr>'||CHR(10)||
       '<td class="r">'||ROWNUM||'</td>'||CHR(10)||
       '<td>'||v.table_name||'</td>'||CHR(10)||
       '<td>'||v.table_owner||'</td>'||CHR(10)||
       '<td class="r">'||v.num_rows||'</td>'||CHR(10)||
       '<td>'||v.partition_name||'</td>'||CHR(10)||	   
       '<td>'||v.subpartition_name||'</td>'||CHR(10)||	   
       '<td class="r">'||v.inserts||'</td>'||CHR(10)||
       '<td class="r">'||v.updates||'</td>'||CHR(10)||
       '<td class="r">'||v.deletes||'</td>'||CHR(10)||
       '<td class="c">'||v.truncated||'</td>'||CHR(10)||	   
       '<td class="r">'||v.drop_segments||'</td>'||CHR(10)||
       '<td>'||v.last_analyzed||'</td>'||CHR(10)||	   
       '<td>'||v.timestamp||'</td>'||CHR(10)||	   
       '<td class="r">'||v.modpct||'</td>'||CHR(10)||
       '</tr>'
  FROM (
 SELECT /*+ leading(t rm) */
       tm.table_name, tm.table_owner, t.cardinality num_rows, tm.partition_name, tm.subpartition_name, 
       tm.inserts, tm.updates, tm.deletes, tm.truncated, tm.drop_segments, 
       t.optimizer last_analyzed, to_char(tm.timestamp,'YYYY-MM-DD/HH24:MI:SS') timestamp,
       round((Nvl((tm.inserts + tm.updates + tm.deletes),0)/decode(nvl(t.cardinality,0),0,1,t.cardinality))* 100, 2) modpct
   FROM dba_tab_modifications tm, 
	plan_table t
  WHERE tm.table_owner = t.object_owner
    AND tm.table_name = t.object_name
    AND STATEMENT_ID = :sql_id
 ORDER BY tm.table_name, tm.table_owner, tm.partition_name, tm.subpartition_name
) v
;

PRO
PRO <tr>
PRO <th>#</th>
PRO <th>Table Name</th>
PRO <th>Owner</th>
PRO <th>Num Rows</th>
PRO <th>Partition</th>
PRO <th>Sub-Partition</th>
PRO <th>Inserts</th>
PRO <th>Updates</th>
PRO <th>Deletes</th>
PRO <th>Truncated</th>
PRO <th>Dropped Segments</th>
PRO <th>Last Analyzed</th>
PRO <th>Last Modified</th>
PRO <th>Percent<br>Modifications</th>
PRO </tr>
PRO </table>
PRO
PRO <details><br/><summary id="summary3">Modules Contributing to Table Modifications</summary>
PRO
PRO Modules Contributing to Table Modifications
PRO
pro <table>
pro <tr>
PRO <th>#</th>
pro <th>Table Name</th>
pro <th>Table Owner</th>
pro <th>Module</th>
pro </tr>

WITH pl AS
(
  SELECT /*+ leading(pt) */ distinct inst_id, sql_id, plan_hash_value, child_number,
       sqlplan.object_owner, sqlplan.object_name
  from gv$sql_plan sqlplan, plan_table pt
  where sqlplan.operation in ('LOAD TABLE CONVENTIONAL','LOAD AS SELECT','MERGE','UPDATE','DELETE')
  and sqlplan.parent_id=0
  and sqlplan.object_name=pt.object_name
  AND sqlplan.object_owner=pt.object_owner
  AND STATEMENT_ID=:sql_id
)
select
       '<tr>'||
       '<td class="r">'||ROWNUM||'</td>'||CHR(10)||
       '<td>'||object_name||'</td>'||CHR(10)||
       '<td>'||object_owner||'</td>'||CHR(10)||
       '<td>'||module||'</td>'||CHR(10)||
       '<tr>'
  from (
          SELECT /*+ leading (pl) */ DISTINCT pl.object_name, pl.object_owner, module
          FROM   gv$sql gvsql, pl
          WHERE  gvsql.inst_id=pl.inst_id
          AND    gvsql.sql_id=pl.sql_id
          AND    gvsql.plan_hash_value=pl.plan_hash_value
          AND    gvsql.child_number=pl.child_number
          ORDER  BY object_name, object_owner, module
       ) v
;
pro <tr>
PRO <th>#</th>
pro <th>Table Name</th>
pro <th>Table Owner</th>
pro <th>Module</th>
pro </tr>
pro </table>
pro </details>

select round((sysdate-to_date(:start_time,'dd-mon-rr hh24:mi:ss'))*86400) diff from dual;
PRO <table style="width:100%"><tr><td style="text-align:right; background-color:#ffffff">Time taken: ^^diff. seconds</td></tr></table>
PRO </details><!--Pushkar--> 
exec :start_time := to_char(sysdate,'dd-mon-rr hh24:mi:ss');

/* -------------------------
 *
 * indexes
 * Uday:PSR: added status column
 *
 * ------------------------- */
EXEC DBMS_APPLICATION_INFO.SET_CLIENT_INFO('^^method.: Indexes details - ' || TO_CHAR(SYSDATE, 'YYYY-MM-DD/HH24:MI:SS'));
PRO <a name="indexes"></a><details open><br/><summary id="summary2">Indexes</summary>

SELECT '<!-- '||TO_CHAR(SYSDATE, 'YYYY-MM-DD/HH24:MI:SS')||' -->' FROM dual;
PRO <!-- Please Wait -->

/* Pushkar 10.9 */
commit;
INSERT INTO plan_table(STATEMENT_ID, object_owner, object_type, object_name)
  WITH  
    object AS (
       SELECT /*+ MATERIALIZE */
              object_owner owner, object_name name, object_type
         FROM gv$sql_plan
        WHERE inst_id IN (SELECT inst_id FROM gv$instance)
          AND sql_id = :sql_id
          AND object_owner IS NOT NULL
          AND object_name IS NOT NULL
          AND object_type like 'INDEX%'
        UNION
       SELECT object_owner owner, object_name name, object_type
         FROM dba_hist_sql_plan
        WHERE :license IN ('T', 'D', 'L')
          AND dbid = ^^dbid.
          AND sql_id = :sql_id
          AND object_owner IS NOT NULL
          AND object_name IS NOT NULL
          AND object_type like 'INDEX%'
    )
    , plan_tables AS (
         SELECT /*+ MATERIALIZE leading (o) */ 'INDEX' object_type, i.owner object_owner, i.index_name object_name
           FROM dba_indexes i,
                object o
          WHERE o.object_type like 'INDEX%'  --Uday.v6
            AND i.owner = o.owner
            AND i.index_name = o.name            
    )
    select distinct :sql_id, object_owner, object_type, object_name
    from  plan_tables
  ;
  
rem select object_owner, object_type, object_name from plan_table;
rem pause;
  
SELECT /* ^^script..sql Indexes */
       v2.line_text
  FROM (
--Uday.PSR.v6 WITH object AS (
--Uday.PSR.v6 SELECT /*+ MATERIALIZE */
--Uday.PSR.v6        object_owner owner, object_name name, object_type
--Uday.PSR.v6   FROM gv$sql_plan
--Uday.PSR.v6  WHERE inst_id IN (SELECT inst_id FROM gv$instance)
--Uday.PSR.v6    AND sql_id = :sql_id
--Uday.PSR.v6    AND object_owner IS NOT NULL
--Uday.PSR.v6    AND object_name IS NOT NULL
--Uday.PSR.v6    AND not (object_type = 'TABLE (TEMP)' and object_name like 'SYS_TEMP%') --Uday.v6
--Uday.PSR.v6  UNION
--Uday.PSR.v6 SELECT object_owner owner, object_name name, object_type
--Uday.PSR.v6   FROM dba_hist_sql_plan
--Uday.PSR.v6  WHERE :license IN ('T', 'D')
--Uday.PSR.v6    AND dbid = ^^dbid.
--Uday.PSR.v6    AND sql_id = :sql_id
--Uday.PSR.v6    AND object_owner IS NOT NULL
--Uday.PSR.v6    AND object_name IS NOT NULL
--Uday.PSR.v6    AND not (object_type = 'TABLE (TEMP)' and object_name like 'SYS_TEMP%') --Uday.v6
--Uday.PSR.v6  ), plan_tables AS (
--Uday.PSR.v6 --UdayRemoved.v6 SELECT /*+ MATERIALIZE */
--Uday.PSR.v6 --UdayRemoved.v6        'TABLE' object_type, t.owner object_owner, t.table_name object_name
--Uday.PSR.v6 --UdayRemoved.v6   FROM dba_tab_statistics t, -- include fixed objects
--Uday.PSR.v6 --UdayRemoved.v6        object o
--Uday.PSR.v6 --UdayRemoved.v6  WHERE t.owner = o.owner
--Uday.PSR.v6 --UdayRemoved.v6    AND t.table_name = o.name
--Uday.PSR.v6  SELECT /*+ MATERIALIZE */
--Uday.PSR.v6         'TABLE' object_type, o.owner object_owner, o.name object_name
--Uday.PSR.v6    FROM object o
--Uday.PSR.v6   WHERE o.object_type like 'TABLE%'
--Uday.PSR.v6   UNION
--Uday.PSR.v6  SELECT 'TABLE' object_type, i.table_owner object_owner, i.table_name object_name
--Uday.PSR.v6    FROM dba_indexes i,
--Uday.PSR.v6         object o
--Uday.PSR.v6   WHERE o.object_type like 'INDEX%'  --Uday.v6
--Uday.PSR.v6     AND i.owner = o.owner
--Uday.PSR.v6     AND i.index_name = o.name
--Uday.PSR.v6 )
SELECT object_name table_name,
       object_owner owner,
       1 line_type,
       1 row_num,
       '<a name="i_'||LOWER(object_name||'_'||object_owner)||'"></a><details open><br/><summary id="summary3">Indexes: '||object_name||' ('||object_owner||')</summary>'||CHR(10)||CHR(10)||
       'CBO Statistics and relevant attributes.'||CHR(10)||CHR(10)||
       '<table>'||CHR(10)||CHR(10)||
       '<tr>'||CHR(10)||
       '<th>#</th>'||CHR(10)||
       --'<th>Table Name</th>'||CHR(10)||
       --'<th>Owner</th>'||CHR(10)||
       '<th>Index Name</th>'||CHR(10)||
       '<th>Owner</th>'||CHR(10)||
       '<th>Index Type</th>'||CHR(10)||      
       '<th>Part</th>'||CHR(10)||
       '<th>DoP</th>'||CHR(10)||
       '<th>Temp</th>'||CHR(10)||
       '<th>Uniqueness</th>'||CHR(10)||
       '<th>Cols</th>'||CHR(10)||
       '<th>Num<br>Rows</th>'||CHR(10)||
       '<th>Sample<br>Size</th>'||CHR(10)||
       '<th>Perc</th>'||CHR(10)||
       '<th>Last Analyzed</th>'||CHR(10)||
       '<th>Distinct<br>Keys</th>'||CHR(10)||
       '<th>Blevel</th>'||CHR(10)||
       '<th>Leaf<br>Blocks</th>'||CHR(10)||
       '<th>Avg<br>Leaf<br>Blocks<br>per Key</th>'||CHR(10)||
       '<th>Avg<br>Data<br>Blocks<br>per Key</th>'||CHR(10)||
       '<th>Clustering<br>Factor</th>'||CHR(10)||
       '<th>Global<br>Stats</th>'||CHR(10)||
       '<th>User<br>Stats</th>'||CHR(10)||
       '<th>Stat<br>Type<br>Locked</th>'||CHR(10)||
       '<th>Stale<br>Stats</th>'||CHR(10)||
       '<th>Stats<br>Versions</th>'||CHR(10)||
       '<th>Partition<br>Type</th>'||CHR(10)||
       '<th>Partition<br>Columns</th>'||CHR(10)||
       '<th>Partition<br>Count</th>'||CHR(10)||
       '<th>Locality</th>'||CHR(10)||
       '<th>Subpartition<br>Type</th>'||CHR(10)||
       '<th>Subpartition<br>Columns</th>'||CHR(10)||    
       '<th>Status</th>'||CHR(10)||
       '</tr>'||CHR(10) line_text
  FROM plan_table
 WHERE object_type = 'TABLE'
   AND STATEMENT_ID = :sql_id
 UNION ALL
SELECT v.table_name,
       v.table_owner owner,
       2 line_type,
       ROWNUM row_num,
       CHR(10)||
       CASE WHEN v.used = 'Y' THEN '<tr class="bg">'
       ELSE '<tr>'
       END
       ||CHR(10)||
       '<td class="r">'||ROWNUM||'</td>'||CHR(10)||
       --'<td>'||v.table_name||'</td>'||CHR(10)||
       --'<td>'||v.table_owner||'</td>'||CHR(10)||
       '<td><a href="#ic_'||LOWER(v.index_name||'_'||v.owner)||'">'||v.index_name||'</a></td>'||CHR(10)||
       '<td>'||v.owner||'</td>'||CHR(10)||
       '<td>'||v.index_type||'</td>'||CHR(10)||
	   CASE WHEN v.partitioned = 'YES' 
	     THEN '<td class="c"><a href="#ip_'||LOWER(v.table_name||'_'||v.table_owner)||'">'||v.partitioned||'</a></td>'
		 ELSE '<td class="c">'||v.partitioned||'</td>'
	   END||CHR(10)||
       '<td class="c">'||v.degree||'</td>'||CHR(10)||
       '<td class="c">'||v.temporary||'</td>'||CHR(10)||
       '<td>'||v.uniqueness||'</td>'||CHR(10)||
       '<td class="c"><a href="#ic_'||LOWER(v.index_name||'_'||v.owner)||'">'||v.columns||'</a></td>'||CHR(10)||
       '<td class="r">'||v.num_rows||'</td>'||CHR(10)||
       '<td class="r">'||v.sample_size||'</td>'||CHR(10)||
       '<td class="r">'||v.sample_size_perc||'</td>'||CHR(10)||
       '<td nowrap>'||v.last_analyzed||'</td>'||CHR(10)||
       '<td class="r">'||v.distinct_keys||'</td>'||CHR(10)||
       '<td class="r">'||v.blevel||'</td>'||CHR(10)||
       '<td class="r">'||v.leaf_blocks||'</td>'||CHR(10)||
       '<td class="r">'||v.avg_leaf_blocks_per_key||'</td>'||CHR(10)||
       '<td class="r">'||v.avg_data_blocks_per_key||'</td>'||CHR(10)||
       '<td class="r">'||v.clustering_factor||'</td>'||CHR(10)||
       '<td class="c">'||v.global_stats||'</td>'||CHR(10)||
       '<td class="c">'||v.user_stats||'</td>'||CHR(10)||
       '<td class="c">'||v.stattype_locked||'</td>'||CHR(10)||
       '<td class="c">'||v.stale_stats||'</td>'||CHR(10)||
       '<td class="c"><a href="#i_stat_ver_'||LOWER(v.table_name||'_'||v.table_owner)||'">Versions</a></td>'||CHR(10)||
	     '<td class="c">'||case
	                         when v.p_subp_type is NOT null then
	                            regexp_substr(v.p_subp_type,'(.*)##',1,1,'im',1)||'</td>'||CHR(10)
	                         else '</td>'||CHR(10)
	                       end ||CHR(10)||
	     '<td>'||case
	                         when v.p_part_keys is NOT null then
	                           v.p_part_keys||'</td>'||CHR(10)
	                         else '</td>'||CHR(10)
	                       end ||CHR(10)||
	     '<td class="r">'||case
	                         when v.p_subp_type is NOT null then
	                            regexp_substr(v.p_subp_type,'##(.*)#~#',1,1,'im',1)||'</td>'||CHR(10)||
	     '<td class="c">'||     regexp_substr(v.p_subp_type,'#~#(.*)~~',1,1,'im',1)||'</td>'||CHR(10)||
	     '<td class="c">'||     regexp_substr(v.p_subp_type,'~~(.*)',1,1,'im',1)
	                         else '</td><td></td><td>'
	                       end ||'</td>'||CHR(10)||
	     '<td>'||case
	                         when v.p_subpart_keys is NOT null then
	                           v.p_subpart_keys||'</td>'||CHR(10)
	                         else '</td>'||CHR(10)
	                       end ||CHR(10)||
       '<td class="c">'||v.status||'</td>'||CHR(10)||
       '</tr>'||CHR(10) line_text
  FROM (
SELECT /*+ NO_MERGE LEADING(pt s i) */
       CASE WHEN (SELECT count(1) FROM plan_table p WHERE p.object_name=s.index_name AND p.object_type='INDEX') > 0 THEN 'Y'
            ELSE 'N' END used, /* Pushkar 10.9 */
       s.table_name,
       s.table_owner,
       s.index_name,
       s.owner,
       i.index_type,
       i.partitioned,
       case /* Pushkar - added below for partitioned indexes */
         when i.partitioned = 'YES' then (select partitioning_type||'##'||partition_count||'#~#'||locality||'~~'||regexp_replace(subpartitioning_type,'NONE',null,1,0,'i')
                                          from dba_part_indexes dt 
                                          where dt.owner = s.owner and dt.index_name = s.index_name)
       end p_subp_type,
       case
         when i.partitioned = 'YES' then (select /*'PARTITION on: '||*/listagg(column_name,'<br>') within group (order by owner, name, object_type, column_position)
                                           from dba_part_key_columns
                                           where owner=s.owner
                                             and name=s.index_name
                                             and object_type='INDEX'
                                           group by owner, name, object_type)
       end p_part_keys,
       case
         when i.partitioned = 'YES' then (select /*'SUBPARTITION on: '||*/listagg(column_name,'<br>') within group (order by owner, name, object_type, column_position)
                                           from dba_subpart_key_columns
                                           where owner=s.owner
                                             and name=s.index_name
                                             and object_type='INDEX'
                                           group by owner, name, object_type)
       end p_subpart_keys,       
       i.degree,
       i.temporary,
       i.uniqueness,
       (SELECT COUNT(*)
          FROM dba_ind_columns c
         WHERE c.index_owner = s.owner
           AND c.index_name = s.index_name
           AND c.table_owner = s.table_owner
           AND c.table_name = s.table_name) columns,
       s.num_rows,
       s.sample_size,
       CASE WHEN s.num_rows > 0 THEN TO_CHAR(ROUND(s.sample_size * 100 / s.num_rows, 1), '99999990D0') END sample_size_perc,
       TO_CHAR(s.last_analyzed, 'YYYY-MM-DD/HH24:MI:SS') last_analyzed,
       s.distinct_keys,
       s.blevel,
       s.leaf_blocks,
       s.avg_leaf_blocks_per_key,
       s.avg_data_blocks_per_key,
       s.clustering_factor,
       s.global_stats,
       s.user_stats,
       s.stattype_locked,
       s.stale_stats,
       i.status
  FROM plan_table pt,
       dba_ind_statistics s,
       dba_indexes i
 WHERE pt.object_type = 'TABLE'
   AND STATEMENT_ID = :sql_id
   AND pt.object_owner = s.table_owner
   AND pt.object_name = s.table_name
   AND s.object_type = 'INDEX'
   AND s.owner = i.owner
   AND s.index_name = i.index_name
   AND s.table_owner = i.table_owner
   AND s.table_name = i.table_name
 ORDER BY
       s.table_name,
       s.table_owner,
       s.index_name,
       s.owner) v
 UNION ALL
SELECT object_name table_name,
       object_owner owner,
       3 line_type,
       1 row_num,
       '<tr>'||CHR(10)||
       '<th>#</th>'||CHR(10)||
       --'<th>Table Name</th>'||CHR(10)||
       --'<th>Owner</th>'||CHR(10)||
       '<th>Index Name</th>'||CHR(10)||
       '<th>Owner</th>'||CHR(10)||
       '<th>Index Type</th>'||CHR(10)||
       '<th>Part</th>'||CHR(10)||
       '<th>DoP</th>'||CHR(10)||
       '<th>Temp</th>'||CHR(10)||
       '<th>Uniqueness</th>'||CHR(10)||
       '<th>Cols</th>'||CHR(10)||
       '<th>Num<br>Rows</th>'||CHR(10)||
       '<th>Sample<br>Size</th>'||CHR(10)||
       '<th>Perc</th>'||CHR(10)||
       '<th>Last Analyzed</th>'||CHR(10)||
       '<th>Distinct<br>Keys</th>'||CHR(10)||
       '<th>Blevel</th>'||CHR(10)||
       '<th>Leaf<br>Blocks</th>'||CHR(10)||
       '<th>Avg<br>Leaf<br>Blocks<br>per Key</th>'||CHR(10)||
       '<th>Avg<br>Data<br>Blocks<br>per Key</th>'||CHR(10)||
       '<th>Clustering<br>Factor</th>'||CHR(10)||
       '<th>Global<br>Stats</th>'||CHR(10)||
       '<th>User<br>Stats</th>'||CHR(10)||
       '<th>Stat<br>Type<br>Locked</th>'||CHR(10)||
       '<th>Stale<br>Stats</th>'||CHR(10)||
   	   '<th>Stats<br>Versions</th>'||CHR(10)||
       '<th>Partition<br>Type</th>'||CHR(10)||
       '<th>Partition<br>Columns</th>'||CHR(10)||
       '<th>Partition<br>Count</th>'||CHR(10)||
       '<th>Locality</th>'||CHR(10)||
       '<th>Subpartition<br>Type</th>'||CHR(10)||
       '<th>Subpartition<br>Columns</th>'||CHR(10)||       
   	   '<th>Status</th>'||CHR(10)||
       '</tr>'||CHR(10) line_text
  FROM plan_table
 WHERE object_type = 'TABLE'
   AND STATEMENT_ID = :sql_id
 UNION ALL
SELECT object_name table_name,
       object_owner owner,
       4 line_type,
       1 row_num,
       CHR(10)||'</table></details><!--Pushkar-->'||CHR(10)||CHR(10) line_text
  FROM plan_table
 WHERE object_type = 'TABLE'
   AND STATEMENT_ID = :sql_id) v2
 ORDER BY
       v2.table_name,
       v2.owner,
       v2.line_type,
       v2.row_num;	   


select round((sysdate-to_date(:start_time,'dd-mon-rr hh24:mi:ss'))*86400) diff from dual;
PRO <table style="width:100%"><tr><td style="text-align:right; background-color:#ffffff">Time taken: ^^diff. seconds</td></tr></table>
PRO </details> <!--Pushkar-->	
exec :start_time := to_char(sysdate,'dd-mon-rr hh24:mi:ss');
/* -------------------------------------------------------------------*/	   
/* Text indexes     added by  Vivek Jha on 10/17/19     STARTS        */ 
/* -------------------------------------------------------------------*/

EXEC DBMS_APPLICATION_INFO.SET_CLIENT_INFO('^^method.: Text Indexes - ' || TO_CHAR(SYSDATE, 'YYYY-MM-DD/HH24:MI:SS'));
PRO <a name="idx_text"></a><details open><br/><summary id="summary2">Text Indexes</summary>

SELECT '<!-- '||TO_CHAR(SYSDATE, 'YYYY-MM-DD/HH24:MI:SS')||' -->' FROM dual;
PRO <!-- Please Wait -->

set pages 500 lines 1500 verify off feedback off  
SET HEAD OFF serverout on

PRO Text Indexes

PRO <a name="top"></a>

pro <table>
pro <tbody><tr>
pro <th>Index Owner</th>
pro <th>Index Name</th>
pro <th>Table Owner</th>
pro <th>Table Name</th>
pro <th>Index Type</th>
pro <th>Index Columns</th>
pro <th>Index Status</th>
pro <th>Idx Docid Cnt</th>
pro <th>Idx Sync Type</th>
pro <th>Idx Synch Interval</th>
pro <th>Uniqueness</th>
pro <th>Compression</th>
pro <th>Last Analyzed</th>
pro <th>Degree</th>
pro <th>Partitioned</th>
pro <th>Small_R_Row</th>
pro <th>Fast DML</th>
pro </tr>


DECLARE 
   type tabmod is RECORD (
	idx_owner		VARCHAR(128),
	idx_name		VARCHAR(128),
	table_owner		VARCHAR(128),
	table_name		VARCHAR(128),
	Index_Type		VARCHAR(50),
	Index_Columns	VARCHAR(128),
	Index_Status		VARCHAR(50),
	idx_docid_count		NUMBER,
	idx_sync_type		VARCHAR(20),
	idx_sync_interval	VARCHAR(2000),
	uniqueness		VARCHAR(9),
	compression		VARCHAR(13),
	last_analyzed		DATE,
	degree			VARCHAR(40),
	partitioned		VARCHAR2(3));
   vtabmod tabmod;
   sqlqry varchar2(1000);
   sqlqry2 varchar2(1000);
   vsmallrrowcnt  number(3);
   vsmallrrow  varchar2(3);
   vfastdmlcnt	number(3);
   vfastdml		varchar2(3);

   CURSOR c_indexnames is 
	select t1.idx_owner, t1.idx_name, t2.table_owner, t2.table_name, (t2.index_type||'-'||t1.idx_type) Index_Type, t1.idx_text_name Index_Columns, (t2.domidx_status||'-'||t1.idx_status) Index_Status,
	t1.idx_docid_count, t1.idx_sync_type, t1.idx_sync_interval, t2.uniqueness, t2.compression, t2.last_analyzed, t2.degree, t2.partitioned
	from ctxsys.ctx_indexes t1, dba_indexes t2, plan_table t
	where t1.idx_owner = t2.owner
	and t1.idx_name = t2.index_name
        AND t2.table_owner = t.object_owner
	AND t2.table_name = t.object_name
	AND STATEMENT_ID = :sql_id
	and t1.idx_owner = 'FUSION';

BEGIN 
	OPEN c_indexnames; 
   LOOP 
	   FETCH c_indexnames into vtabmod.idx_owner, vtabmod.idx_name, vtabmod.table_owner, vtabmod.table_name, vtabmod.Index_Type, vtabmod.Index_Columns, vtabmod.Index_Status, vtabmod.idx_docid_count, vtabmod.idx_sync_type, 
		vtabmod.idx_sync_interval, vtabmod.uniqueness  , vtabmod.compression , vtabmod.last_analyzed , vtabmod.degree , vtabmod.partitioned ;
		/*dbms_output.put_line('Cursor  '||vtabmod.idx_name|| ' ' || vtabmod.table_name );  */
	      EXIT WHEN c_indexnames%notfound; 

	sqlqry := 'select count(*) from (select row_no, length(data) from DR$'||vtabmod.idx_name||'$R order by row_no)' ;
	/*DBMS_OUTPUT.PUT_LINE('Query Text: ' || sqlqry);*/

  begin
	  EXECUTE IMMEDIATE sqlqry into vsmallrrowcnt;
	  /*dbms_output.put_line (vSmallrRowcnt);*/
        /*dbms_output.put_line('Cursor  '||vtabmod.idx_name|| ' ' || vtabmod.table_name );  */
  	IF vSmallrRowcnt < 2 THEN 
  	  vSmallrRow := 'No';
  	ELSE 
  	  vSmallrRow := 'Yes';
	  END IF;
  exception 
    when others then
      vSmallrRow := NULL;
  end;
--		sqlqry2 := 'select COUNT(*) FROM ctxsys.dr$index i, dba_users u1 where i.idx_owner# = u1.USER_ID and i.idx_name = '''||vtabmod.idx_name||''' AND u1.username = '''||vtabmod.idx_owner||''' and i.idx_option like '''R''';' ;

		--sqlqry2 := 'select COUNT(*) FROM ctxsys.dr$index i, dba_users u1 where i.idx_owner# = u1.USER_ID and i.idx_name = '||vtabmod.idx_name||' AND u1.username = '||vtabmod.idx_owner||'  ;
		sqlqry2 := 'select COUNT(*) FROM ctxsys.dr$index i, dba_users u1 where i.idx_owner# = u1.USER_ID and i.idx_name = '''||vtabmod.idx_name||''' AND u1.username = '''||vtabmod.idx_owner||''' and i.idx_option like ''%R%'' '  ;

  begin
	  EXECUTE IMMEDIATE sqlqry2 into vfastdmlcnt;
  	IF vfastdmlcnt > 0 THEN 
  	  vfastdml := 'Yes';
  	ELSE 
  	  vfastdml := 'No';
	  END IF;
  exception 
    when others then
      vfastdml := NULL;
  end;
		

	 /* DBMS_OUTPUT.PUT_LINE('Table Owner'||chr(9)||chr(9)||chr(9)||'Table Name'||chr(9)||chr(9)||'Module'); */
	 /* DBMS_OUTPUT.PUT_LINE('-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------'); */

	DBMS_OUTPUT.PUT_LINE(
        CHR(10)||'<tr>'||CHR(10)
          ||'<td class="r">'||vtabmod.idx_owner||'</td>'||CHR(10)
          ||'<td class="r">'||vtabmod.idx_name||'</td>'||CHR(10)
          ||'<td class="r">'||vtabmod.table_owner||'</td>'||CHR(10)
          ||'<td class="r">'||vtabmod.table_name||'</td>'||CHR(10)
          ||'<td class="r">'||vtabmod.Index_Type||'</td>'||CHR(10)
          ||'<td class="r">'||vtabmod.Index_Columns||'</td>'||CHR(10)
          ||'<td class="r">'||vtabmod.Index_Status||'</td>'||CHR(10)
          ||'<td class="r">'||vtabmod.idx_docid_count||'</td>'||CHR(10)
          ||'<td class="r">'||vtabmod.idx_sync_type||'</td>'||CHR(10)
          ||'<td class="r">'||vtabmod.idx_sync_interval||'</td>'||CHR(10)
          ||'<td class="r">'||vtabmod.uniqueness||'</td>'||CHR(10)
          ||'<td class="r">'||vtabmod.compression||'</td>'||CHR(10)
          ||'<td class="r">'||vtabmod.last_analyzed||'</td>'||CHR(10)
          ||'<td class="r">'||vtabmod.degree||'</td>'||CHR(10)
          ||'<td class="r">'||vtabmod.partitioned||'</td>'||CHR(10)
          ||'<td class="r">'||vSmallrRow||'</td>'||CHR(10)
          ||'<td class="r">'||vfastdml||'</td>'||CHR(10)
          ||'</tr>'
        );
	
	dbms_output.put(CHR(10));

   END LOOP; 
   CLOSE c_indexnames; 

END; 
/


pro <tr>
pro <th>Index Owner</th>
pro <th>Index Name</th>
pro <th>Table Owner</th>
pro <th>Table Name</th>
pro <th>Index Type</th>
pro <th>Index Columns</th>
pro <th>Index Status</th>
pro <th>Idx Docid Cnt</th>
pro <th>Idx Sync Type</th>
pro <th>Idx Synch Interval</th>
pro <th>Uniqueness</th>
pro <th>Compression</th>
pro <th>Last Analyzed</th>
pro <th>Degree</th>
pro <th>Partitioned</th>
pro <th>Small_R_Row</th>
pro <th>Fast DML</th>
pro </tbody></tr>
pro </table>
pro

select round((sysdate-to_date(:start_time,'dd-mon-rr hh24:mi:ss'))*86400) diff from dual;
PRO <table style="width:100%"><tr><td style="text-align:right; background-color:#ffffff">Time taken: ^^diff. seconds</td></tr></table>
PRO </details> <!--Pushkar--> 
exec :start_time := to_char(sysdate,'dd-mon-rr hh24:mi:ss');



/* -------------------------------------------------------------------*/	   
/* Text indexes     added by  Vivek Jha on 10/17/19     ENDS          */
/* -------------------------------------------------------------------*/



/* -------------------------
 *
 * index columns
 *
 * ------------------------- */
EXEC DBMS_APPLICATION_INFO.SET_CLIENT_INFO('^^method.: Index Columns - ' || TO_CHAR(SYSDATE, 'YYYY-MM-DD/HH24:MI:SS'));
PRO <a name="idx_cols"></a><details open><br/><summary id="summary2">Index Columns</summary>

SELECT '<!-- '||TO_CHAR(SYSDATE, 'YYYY-MM-DD/HH24:MI:SS')||' -->' FROM dual;
PRO <!-- Please Wait -->

rem select object_owner, object_type, object_name from plan_table;
rem pause;

SELECT /* ^^script..sql Index Columns */
       v2.line_text
  FROM (
--Uday.PSR.v6 WITH object AS (
--Uday.PSR.v6 SELECT /*+ MATERIALIZE */
--Uday.PSR.v6        object_owner owner, object_name name, object_type
--Uday.PSR.v6   FROM gv$sql_plan
--Uday.PSR.v6  WHERE inst_id IN (SELECT inst_id FROM gv$instance)
--Uday.PSR.v6    AND sql_id = :sql_id
--Uday.PSR.v6    AND object_owner IS NOT NULL
--Uday.PSR.v6    AND object_name IS NOT NULL
--Uday.PSR.v6    AND not (object_type = 'TABLE (TEMP)' and object_name like 'SYS_TEMP%') --Uday.v6
--Uday.PSR.v6  UNION
--Uday.PSR.v6 SELECT object_owner owner, object_name name, object_type
--Uday.PSR.v6   FROM dba_hist_sql_plan
--Uday.PSR.v6  WHERE :license IN ('T', 'D')
--Uday.PSR.v6    AND dbid = ^^dbid.
--Uday.PSR.v6    AND sql_id = :sql_id
--Uday.PSR.v6    AND object_owner IS NOT NULL
--Uday.PSR.v6    AND object_name IS NOT NULL
--Uday.PSR.v6    AND not (object_type = 'TABLE (TEMP)' and object_name like 'SYS_TEMP%') --Uday.v6
--Uday.PSR.v6  ), plan_tables AS (
--Uday.PSR.v6 --UdayRemoved.v6 SELECT /*+ MATERIALIZE */
--Uday.PSR.v6 --UdayRemoved.v6        'TABLE' object_type, t.owner object_owner, t.table_name object_name
--Uday.PSR.v6 --UdayRemoved.v6   FROM dba_tab_statistics t, -- include fixed objects
--Uday.PSR.v6 --UdayRemoved.v6        object o
--Uday.PSR.v6 --UdayRemoved.v6  WHERE t.owner = o.owner
--Uday.PSR.v6 --UdayRemoved.v6    AND t.table_name = o.name
--Uday.PSR.v6  SELECT /*+ MATERIALIZE */
--Uday.PSR.v6         'TABLE' object_type, o.owner object_owner, o.name object_name
--Uday.PSR.v6    FROM object o
--Uday.PSR.v6   WHERE o.object_type like 'TABLE%'
--Uday.PSR.v6   UNION
--Uday.PSR.v6  SELECT 'TABLE' object_type, i.table_owner object_owner, i.table_name object_name
--Uday.PSR.v6    FROM dba_indexes i,
--Uday.PSR.v6         object o
--Uday.PSR.v6   WHERE o.object_type like 'INDEX%'  --Uday.v6
--Uday.PSR.v6     AND i.owner = o.owner
--Uday.PSR.v6     AND i.index_name = o.name
--Uday.PSR.v6 )
SELECT object_name table_name,
       object_owner owner,
       1 line_type,
       1 row_num,
       '<a name="ic_'||LOWER(object_name||'_'||object_owner)||'"></a><details open><br/><summary id="summary3">Index Columns: '||object_name||' ('||object_owner||')</summary>'||CHR(10)||CHR(10)||
       'CBO Statistics and relevant attributes.'||CHR(10)||CHR(10)||
       '<table>'||CHR(10)||CHR(10)||
       '<tr>'||CHR(10)||
       '<th>#</th>'||CHR(10)||
       --'<th>Table Name</th>'||CHR(10)||
       --'<th>Owner</th>'||CHR(10)||
       '<th>Index Name</th>'||CHR(10)||
       --'<th>Index Owner</th>'||CHR(10)||
       '<th>Col<br>Pos</th>'||CHR(10)||
       '<th>Col<br>ID</th>'||CHR(10)||
       '<th>Column Name</th>'||CHR(10)||
       '<th>Expression</th>'||CHR(10)||       
       '<th>Descend</th>'||CHR(10)||
       '<th>Num<br>Rows</th>'||CHR(10)||
       '<th>Num<br>Nulls</th>'||CHR(10)||
       '<th>Sample<br>Size</th>'||CHR(10)||
       '<th>Perc</th>'||CHR(10)||
       '<th>Num<br>Distinct</th>'||CHR(10)||
       '<th>Low Value</th>'||CHR(10)||
       '<th>High Value</th>'||CHR(10)||
       '<th>Last Analyzed</th>'||CHR(10)||
       '<th>Avg<br>Col<br>Len</th>'||CHR(10)||
       '<th>Density</th>'||CHR(10)||
       '<th>Num<br>Buckets</th>'||CHR(10)||
       '<th>Histogram</th>'||CHR(10)||
       '<th>Global<br>Stats</th>'||CHR(10)||
       '<th>User<br>Stats</th>'||CHR(10)||
       '</tr>'||CHR(10) line_text
  FROM plan_table
 WHERE object_type = 'TABLE'
   AND STATEMENT_ID = :sql_id
 UNION ALL
SELECT v.table_name,
       v.table_owner,
       2 line_type,
       ROWNUM row_num,
       CHR(10)||
       CASE WHEN v.used = 'Y' THEN '<tr class="bg">'
       ELSE '<tr>'
       END
       ||CHR(10)||
       '<td class="r">'||ROWNUM||'</td>'||CHR(10)||
       --'<td>'||v.table_name||'</td>'||CHR(10)||
       --'<td>'||v.table_owner||'</td>'||CHR(10)||
       '<td>'||
       (CASE WHEN v.column_position = 1 THEN '<a name="ic_'||LOWER(v.index_name||'_'||v.index_owner)||'"></a>' END)||
       v.index_name||'</td>'||CHR(10)||
       --'<td>'||v.index_owner||'</td>'||CHR(10)||
       '<td class="r">'||v.column_position||'</td>'||CHR(10)||
       '<td class="c">'||v.column_id||'</td>'||CHR(10)||
       '<td>'||v.column_name||'</td>'||CHR(10)||
       '<td>'||CASE WHEN v.column_name LIKE 'SYS%' THEN 
               (SELECT replace(replace(To_Char(extension),'",',', '),'"')
                  FROM dba_stat_extensions
                 WHERE v.table_name = table_name 
                   AND v.table_owner= owner
                   AND v.column_name= extension_name) END||'</td>'||CHR(10)||
       '<td>'||v.descend||'</td>'||CHR(10)||
       '<td class="r">'||v.num_rows||'</td>'||CHR(10)||
       '<td class="r">'||v.num_nulls||'</td>'||CHR(10)||
       '<td class="r">'||v.sample_size||'</td>'||CHR(10)||
       '<td class="r">'||v.sample_size_perc||'</td>'||CHR(10)||
       '<td class="r">'||v.num_distinct||'</td>'||CHR(10)||
       '<td nowrap>'||v.low_value||'</td>'||CHR(10)||
       '<td nowrap>'||v.high_value||'</td>'||CHR(10)||
       '<td nowrap>'||v.last_analyzed||'</td>'||CHR(10)||
       '<td class="r">'||v.avg_col_len||'</td>'||CHR(10)||
       '<td class="r">'||v.density||'</td>'||CHR(10)||
       '<td class="r">'||v.num_buckets||'</td>'||CHR(10)||
       '<td>'||v.histogram||'</td>'||CHR(10)||
       '<td class="c">'||v.global_stats||'</td>'||CHR(10)||
       '<td class="c">'||v.user_stats||'</td>'||CHR(10)||
       '</tr>'||CHR(10) line_text
  FROM (
SELECT /*+ NO_MERGE LEADING(pt i c c2) */
       CASE WHEN (SELECT count(1) FROM plan_table p WHERE p.object_name=i.index_name AND p.object_type='INDEX') > 0 THEN 'Y'
            ELSE 'N' END used, /* Pushkar 10.9 */
       i.table_name,
       i.table_owner,
       i.index_name,
       i.index_owner,
       i.column_position,
       c.column_id,
       i.column_name,     
       i.descend,
       pt.cardinality num_rows,
       c.num_nulls,
       c.sample_size,
       -- CASE
       -- WHEN t.num_rows > c.num_nulls THEN TO_CHAR(LEAST(100, ROUND(c.sample_size * 100 / (t.num_rows - c.num_nulls), 1)), '99999990D0')
       -- WHEN t.num_rows = c.num_nulls THEN TO_CHAR(100, '99999990D0')
       -- END sample_size_perc,
       CASE
         WHEN pt.cardinality > c.num_nulls THEN TO_CHAR(LEAST(100, ROUND(c.sample_size * 100 / (pt.cardinality - c.num_nulls), 1)), '99999990D0')
         WHEN pt.cardinality = c.num_nulls THEN TO_CHAR(100, '99999990D0')
       END sample_size_perc,
       c.num_distinct
       /* uday.psr.v6: getting actual values
       c.low_value,
       c.high_value high_value,
       */
       --Uday.PSR.v6
       -- appending ||'' to avoid ORA-29275: partial multibyte character
       -- sometimes sessions crosses with buffer overflow
       -- 
       ,case when regexp_like(:pii_tables,c.table_name,'i') then NULL
        else 
          decode(substr(c.data_type,1,9) -- as there are several timestamp types
          ,'NUMBER'       ,to_char(utl_raw.cast_to_number(c.low_value)) ||''
          ,'VARCHAR2'     ,to_char(utl_raw.cast_to_varchar2(c.low_value)) ||''
          ,'NVARCHAR2'    ,to_char(utl_raw.cast_to_nvarchar2(c.low_value)) ||''
          ,'BINARY_DO'    ,to_char(utl_raw.cast_to_binary_double(c.low_value)) ||''
          ,'BINARY_FL'    ,to_char(utl_raw.cast_to_binary_float(c.low_value)) ||''
          ,'DATE'         ,decode(c.low_value, NULL, NULL, rtrim(
                                to_char(100*(to_number(substr(c.low_value,1,2),'XX')-100)
                                       + (to_number(substr(c.low_value,3,2),'XX')-100),'fm0000')||'-'||
                                to_char(to_number(substr(c.low_value,5,2),'XX'),'fm00')||'-'||
                                to_char(to_number(substr(c.low_value,7,2),'XX'),'fm00')||' '||
                                to_char(to_number(substr(c.low_value,9,2),'XX')-1,'fm00')||':'||
                                to_char(to_number(substr(c.low_value,11,2),'XX')-1,'fm00')||':'||
                                to_char(to_number(substr(c.low_value,13,2),'XX')-1,'fm00'))) ||''
          ,'TIMESTAMP'    ,decode(c.low_value, NULL, NULL, rtrim(
                           to_char(100*(to_number(substr(c.low_value,1,2),'XX')-100)
                                  + (to_number(substr(c.low_value,3,2),'XX')-100),'fm0000')||'-'||
                           to_char(to_number(substr(c.low_value,5,2),'XX'),'fm00')||'-'||
                           to_char(to_number(substr(c.low_value,7,2),'XX'),'fm00')||' '||
                           to_char(to_number(substr(c.low_value,9,2),'XX')-1,'fm00')||':'||
                           to_char(to_number(substr(c.low_value,11,2),'XX')-1,'fm00')||':'||
                           to_char(to_number(substr(c.low_value,13,2),'XX')-1,'fm00')
                          ||'.'||to_number(substr(c.low_value,15,8),'XXXXXXXX')  )) ||''
          , c.low_value
        ) end low_value
       ,case when regexp_like(:pii_tables,c.table_name,'i') then NULL
        else
          decode(substr(c.data_type,1,9) -- as there are several timestamp types
          ,'NUMBER'       ,to_char(utl_raw.cast_to_number(c.high_value)) ||''
          ,'VARCHAR2'     ,to_char(utl_raw.cast_to_varchar2(c.high_value)) ||''
          ,'NVARCHAR2'    ,to_char(utl_raw.cast_to_nvarchar2(c.high_value)) ||''
          ,'BINARY_DO'    ,to_char(utl_raw.cast_to_binary_double(c.high_value)) ||''
          ,'DATE'         ,decode(c.high_value, NULL, NULL, rtrim(
                                to_char(100*(to_number(substr(c.high_value,1,2),'XX')-100)
                                       + (to_number(substr(c.high_value,3,2),'XX')-100),'fm0000')||'-'||
                                to_char(to_number(substr(c.high_value,5,2),'XX'),'fm00')||'-'||
                                to_char(to_number(substr(c.high_value,7,2),'XX'),'fm00')||' '||
                                to_char(to_number(substr(c.high_value,9,2),'XX')-1,'fm00')||':'||
                                to_char(to_number(substr(c.high_value,11,2),'XX')-1,'fm00')||':'||
                                to_char(to_number(substr(c.high_value,13,2),'XX')-1,'fm00'))) ||''
          ,'TIMESTAMP'    ,decode(c.high_value, NULL, NULL, rtrim(
                           to_char(100*(to_number(substr(c.high_value,1,2),'XX')-100)
                                  + (to_number(substr(c.high_value,3,2),'XX')-100),'fm0000')||'-'||
                           to_char(to_number(substr(c.high_value,5,2),'XX'),'fm00')||'-'||
                           to_char(to_number(substr(c.high_value,7,2),'XX'),'fm00')||' '||
                           to_char(to_number(substr(c.high_value,9,2),'XX')-1,'fm00')||':'||
                           to_char(to_number(substr(c.high_value,11,2),'XX')-1,'fm00')||':'||
                           to_char(to_number(substr(c.high_value,13,2),'XX')-1,'fm00')
                          ||'.'||to_char(to_number(substr(c.high_value,15,8),'XXXXXXXX')))) ||''
          , c.high_value
       ) end high_value,
       TO_CHAR(c.last_analyzed, 'YYYY-MM-DD/HH24:MI:SS') last_analyzed,
       c.avg_col_len,
       LOWER(TO_CHAR(c.density, '0D000000EEEE')) density,
       c.num_buckets,
       c.histogram,
       c.global_stats,
       c.user_stats
  FROM plan_table pt,
       -- dba_tables t,
       dba_ind_columns i,
       dba_tab_cols c
 WHERE pt.object_type = 'TABLE'
   AND STATEMENT_ID = :sql_id
   -- AND pt.object_owner = t.owner
   -- AND pt.object_name = t.table_name
   -- AND t.owner = i.table_owner
   -- AND t.table_name = i.table_name
   AND pt.object_owner = i.table_owner
   AND pt.object_name = i.table_name
   AND i.table_owner = c.owner
   AND i.table_name = c.table_name
   AND i.column_name = c.column_name
 ORDER BY
       i.table_name,
       i.table_owner,
       i.index_name,
       i.index_owner,
       i.column_position) v
 UNION ALL
SELECT object_name table_name,
       object_owner owner,
       3 line_type,
       1 row_num,
       '<tr>'||CHR(10)||
       '<th>#</th>'||CHR(10)||
       --'<th>Table Name</th>'||CHR(10)||
       --'<th>Owner</th>'||CHR(10)||
       '<th>Index Name</th>'||CHR(10)||
       --'<th>Index Owner</th>'||CHR(10)||
       '<th>Col<br>Pos</th>'||CHR(10)||
       '<th>Col<br>ID</th>'||CHR(10)||
       '<th>Column Name</th>'||CHR(10)||
       '<th>Expression</th>'||CHR(10)||
       '<th>Descend</th>'||CHR(10)||
       '<th>Num<br>Rows</th>'||CHR(10)||
       '<th>Num<br>Nulls</th>'||CHR(10)||
       '<th>Sample<br>Size</th>'||CHR(10)||
       '<th>Perc</th>'||CHR(10)||
       '<th>Num<br>Distinct</th>'||CHR(10)||
       '<th>Low Value</th>'||CHR(10)||
       '<th>High Value</th>'||CHR(10)||
       '<th>Last Analyzed</th>'||CHR(10)||
       '<th>Avg<br>Col<br>Len</th>'||CHR(10)||
       '<th>Density</th>'||CHR(10)||
       '<th>Num<br>Buckets</th>'||CHR(10)||
       '<th>Histogram</th>'||CHR(10)||
       '<th>Global<br>Stats</th>'||CHR(10)||
       '<th>User<br>Stats</th>'||CHR(10)||
       '</tr>'||CHR(10) line_text
  FROM plan_table
 WHERE object_type = 'TABLE'
   AND STATEMENT_ID = :sql_id
 UNION ALL
SELECT object_name table_name,
       object_owner owner,
       4 line_type,
       1 row_num,
       CHR(10)||'</table></details><!--Pushkar-->'||CHR(10)||CHR(10) line_text
  FROM plan_table
 WHERE object_type = 'TABLE'
   AND STATEMENT_ID = :sql_id) v2
 ORDER BY
       v2.table_name,
       v2.owner,
       v2.line_type,
       v2.row_num;

rollback;	  
rem select object_owner, object_type, object_name from plan_table;
rem pause; 


select round((sysdate-to_date(:start_time,'dd-mon-rr hh24:mi:ss'))*86400) diff from dual;
PRO <table style="width:100%"><tr><td style="text-align:right; background-color:#ffffff">Time taken: ^^diff. seconds</td></tr></table>
PRO </details> <!--Pushkar-->
exec :start_time := to_char(sysdate,'dd-mon-rr hh24:mi:ss');
/* -------------------------
 *
 * index partitions
 *
 * ------------------------- */
EXEC DBMS_APPLICATION_INFO.SET_CLIENT_INFO('^^method.: Index Partitions - ' || TO_CHAR(SYSDATE, 'YYYY-MM-DD/HH24:MI:SS'));
PRO <a name="ind_parts"></a><details><br/><summary id="summary2">Index Partitions</summary>

SELECT '<!-- '||TO_CHAR(SYSDATE, 'YYYY-MM-DD/HH24:MI:SS')||' -->' FROM dual;
PRO <!-- Please Wait -->		

SELECT /* ^^script..sql Index Partitions */
       v2.line_text
  FROM (
--Uday.PSR.v6 WITH object AS (
--Uday.PSR.v6 SELECT /*+ MATERIALIZE */
--Uday.PSR.v6        object_owner owner, object_name name, object_type
--Uday.PSR.v6   FROM gv$sql_plan
--Uday.PSR.v6  WHERE inst_id IN (SELECT inst_id FROM gv$instance)
--Uday.PSR.v6    AND sql_id = :sql_id
--Uday.PSR.v6    AND object_owner IS NOT NULL
--Uday.PSR.v6    AND object_name IS NOT NULL
--Uday.PSR.v6    AND not (object_type = 'TABLE (TEMP)' and object_name like 'SYS_TEMP%') --Uday.v6
--Uday.PSR.v6  UNION
--Uday.PSR.v6 SELECT object_owner owner, object_name name, object_type
--Uday.PSR.v6   FROM dba_hist_sql_plan
--Uday.PSR.v6  WHERE :license IN ('T', 'D')
--Uday.PSR.v6    AND dbid = ^^dbid.
--Uday.PSR.v6    AND sql_id = :sql_id
--Uday.PSR.v6    AND object_owner IS NOT NULL
--Uday.PSR.v6    AND object_name IS NOT NULL
--Uday.PSR.v6    AND not (object_type = 'TABLE (TEMP)' and object_name like 'SYS_TEMP%') --Uday.v6
--Uday.PSR.v6  ), plan_tables AS (
--Uday.PSR.v6 --UdayRemoved.v6 SELECT /*+ MATERIALIZE */
--Uday.PSR.v6 --UdayRemoved.v6        'TABLE' object_type, p.table_owner object_owner, p.table_name object_name
--Uday.PSR.v6 --UdayRemoved.v6   FROM dba_tab_partitions p, -- include fixed objects
--Uday.PSR.v6 --UdayRemoved.v6        object o
--Uday.PSR.v6 --UdayRemoved.v6  WHERE p.table_owner = o.owner
--Uday.PSR.v6 --UdayRemoved.v6    AND p.table_name = o.name
--Uday.PSR.v6  SELECT /*+ MATERIALIZE */
--Uday.PSR.v6         'TABLE' object_type, o.owner object_owner, o.name object_name
--Uday.PSR.v6    FROM object o
--Uday.PSR.v6   WHERE o.object_type like 'TABLE%'
--Uday.PSR.v6   UNION
--Uday.PSR.v6  SELECT 'TABLE' object_type, i.table_owner object_owner, i.table_name object_name
--Uday.PSR.v6    FROM dba_indexes i,
--Uday.PSR.v6         dba_ind_partitions p,
--Uday.PSR.v6         object o
--Uday.PSR.v6   WHERE o.object_type like 'INDEX%'  --Uday.v6
--Uday.PSR.v6     AND i.owner = o.owner
--Uday.PSR.v6     AND i.index_name = o.name
--Uday.PSR.v6     AND i.owner = p.index_owner(+)  -- partitioned table but not part index in the plan
--Uday.PSR.v6     AND i.index_name = p.index_name(+)  -- same as above
--Uday.PSR.v6 )
SELECT object_name table_name,
       object_owner owner,
       1 line_type,
       1 row_num,
       '<a name="ip_'||LOWER(object_name||'_'||object_owner)||'"></a><details><br/><summary id="summary3">Index Partitions: '||object_name||' ('||object_owner||')</summary>'||CHR(10)||CHR(10)||
       'CBO Statistics and relevant attributes.'||CHR(10)||CHR(10)||
       '<table>'||CHR(10)||CHR(10)||
       '<tr>'||CHR(10)||
       '<th>#</th>'||CHR(10)||
       '<th>Index Name</th>'||CHR(10)||
       '<th>Owner</th>'||CHR(10)||
       '<th>Partition<br>Position</th>'||CHR(10)||
       '<th>Partition<br>Name</th>'||CHR(10)||
       '<th>Subpartition<br>Count</th>'||CHR(10)||	   
       '<th>Num<br>Rows</th>'||CHR(10)||
       '<th>Sample<br>Size</th>'||CHR(10)||
       '<th>Perc</th>'||CHR(10)||
       '<th>Last Analyzed</th>'||CHR(10)||
       '<th>Distinct<br>Keys</th>'||CHR(10)||
       '<th>Blevel</th>'||CHR(10)||
       '<th>Leaf<br>Blocks</th>'||CHR(10)||
       '<th>Avg<br>Leaf<br>Blocks<br>per Key</th>'||CHR(10)||
       '<th>Avg<br>Data<br>Blocks<br>per Key</th>'||CHR(10)||
       '<th>Clustering<br>Factor</th>'||CHR(10)||
       '</tr>'||CHR(10) line_text
  FROM plan_table
 WHERE object_type = 'TABLE'
   AND STATEMENT_ID = :sql_id
 UNION ALL
SELECT v.table_name,
       v.table_owner owner,
       2 line_type,
       ROWNUM row_num,
       CHR(10)||'<tr>'||CHR(10)||
       '<td class="r">'||ROWNUM||'</td>'||CHR(10)||
       '<td>'||v.index_name||'</td>'||CHR(10)||
       '<td>'||v.owner||'</td>'||CHR(10)||
	   '<td class="c">'||v.partition_position||'</td>'||CHR(10)||
       '<td class="c">'||v.partition_name||'</td>'||CHR(10)||
       '<td class="r">'||v.subpartition_count||'</td>'||CHR(10)||	   
       '<td class="r">'||v.num_rows||'</td>'||CHR(10)||
       '<td class="r">'||v.sample_size||'</td>'||CHR(10)||
       '<td class="r">'||v.sample_size_perc||'</td>'||CHR(10)||
       '<td nowrap>'||v.last_analyzed||'</td>'||CHR(10)||
       '<td class="r">'||v.distinct_keys||'</td>'||CHR(10)||
       '<td class="r">'||v.blevel||'</td>'||CHR(10)||
       '<td class="r">'||v.leaf_blocks||'</td>'||CHR(10)||
       '<td class="r">'||v.avg_leaf_blocks_per_key||'</td>'||CHR(10)||
       '<td class="r">'||v.avg_data_blocks_per_key||'</td>'||CHR(10)||
       '<td class="r">'||v.clustering_factor||'</td>'||CHR(10)||
       '</tr>'||CHR(10) line_text
  FROM (
SELECT DISTINCT v.table_name,
       v.table_owner,
       v.index_name,
       v.owner,
	   v.subpartition_count,
	   v.partition_name,
	   v.partition_position,
       v.num_rows,
       v.sample_size,
       v.sample_size_perc,
       v.last_analyzed,
       v.distinct_keys,
       v.blevel,
       v.leaf_blocks,
       v.avg_leaf_blocks_per_key,
       v.avg_data_blocks_per_key,
       v.clustering_factor
  FROM (  
SELECT /*+ NO_MERGE LEADING(pt s i) */
       s.table_name,
       s.table_owner,
       s.index_name,
       s.owner,
	   i.subpartition_count,
	   i.partition_name,
	   i.partition_position,
       i.num_rows,
       i.sample_size,
       CASE WHEN s.num_rows > 0 THEN TO_CHAR(ROUND(i.sample_size * 100 / i.num_rows, 1), '99999990D0') END sample_size_perc,
       TO_CHAR(i.last_analyzed, 'YYYY-MM-DD/HH24:MI:SS') last_analyzed,
       i.distinct_keys,
       i.blevel,
       i.leaf_blocks,
       i.avg_leaf_blocks_per_key,
       i.avg_data_blocks_per_key,
       i.clustering_factor,
	   ROW_NUMBER() OVER (PARTITION BY s.owner, s.index_name ORDER BY i.partition_position DESC) row_num
  FROM plan_table pt,
       dba_indexes s,
       dba_ind_partitions i
 WHERE pt.object_type = 'TABLE'
   AND STATEMENT_ID = :sql_id
   AND pt.object_owner = s.table_owner
   AND pt.object_name = s.table_name
   AND s.index_name = i.index_name
   AND s.owner = i.index_owner
UNION
SELECT /*+ NO_MERGE LEADING(pt s i) */
       s.table_name,
       s.table_owner,
       s.index_name,
       s.owner,
	   i.subpartition_count,
	   i.partition_name,
	   i.partition_position,
       i.num_rows,
       i.sample_size,
       CASE WHEN s.num_rows > 0 THEN TO_CHAR(ROUND(i.sample_size * 100 / i.num_rows, 1), '99999990D0') END sample_size_perc,
       TO_CHAR(i.last_analyzed, 'YYYY-MM-DD/HH24:MI:SS') last_analyzed,
       i.distinct_keys,
       i.blevel,
       i.leaf_blocks,
       i.avg_leaf_blocks_per_key,
       i.avg_data_blocks_per_key,
       i.clustering_factor,
	   ROW_NUMBER() OVER (PARTITION BY s.owner, s.index_name ORDER BY i.partition_position ASC) row_num
  FROM plan_table pt,
       dba_indexes s,
       dba_ind_partitions i
 WHERE pt.object_type = 'TABLE'
   AND STATEMENT_ID = :sql_id
   AND pt.object_owner = s.table_owner
   AND pt.object_name = s.table_name
   AND s.index_name = i.index_name
   AND s.owner = i.index_owner 
	  ) v 
 WHERE v.row_num BETWEEN 1 AND 100
 ORDER BY
       v.index_name,
       v.owner,
	   v.partition_position DESC	  
	  ) v
 UNION ALL
SELECT object_name table_name,
       object_owner owner,
       3 line_type,
       1 row_num,
       '<tr>'||CHR(10)||
       '<th>#</th>'||CHR(10)||
       '<th>Index Name</th>'||CHR(10)||
       '<th>Owner</th>'||CHR(10)||
       '<th>Partition<br>Position</th>'||CHR(10)||
       '<th>Partition<br>Name</th>'||CHR(10)||
       '<th>Subpartition<br>Count</th>'||CHR(10)||	   
       '<th>Num<br>Rows</th>'||CHR(10)||
       '<th>Sample<br>Size</th>'||CHR(10)||
       '<th>Perc</th>'||CHR(10)||
       '<th>Last Analyzed</th>'||CHR(10)||
       '<th>Distinct<br>Keys</th>'||CHR(10)||
       '<th>Blevel</th>'||CHR(10)||
       '<th>Leaf<br>Blocks</th>'||CHR(10)||
       '<th>Avg<br>Leaf<br>Blocks<br>per Key</th>'||CHR(10)||
       '<th>Avg<br>Data<br>Blocks<br>per Key</th>'||CHR(10)||
       '<th>Clustering<br>Factor</th>'||CHR(10)||
       '</tr>'||CHR(10) line_text
  FROM plan_table
 WHERE object_type = 'TABLE'
   AND STATEMENT_ID = :sql_id
 UNION ALL
SELECT object_name table_name,
       object_owner owner,
       4 line_type,
       1 row_num,
       CHR(10)||'</table></details><!--Pushkar-->'||CHR(10)||CHR(10) line_text
  FROM plan_table
 WHERE object_type = 'TABLE'
   AND STATEMENT_ID = :sql_id) v2
 ORDER BY
       v2.table_name,
       v2.owner,
       v2.line_type,
       v2.row_num;   

PRO </details> <!--Pushkar-->
/* -------------------------
 *
 * index statistics versions
 *
 * ------------------------- */
EXEC DBMS_APPLICATION_INFO.SET_CLIENT_INFO('^^method.: Indexes Statistics Versions - ' || TO_CHAR(SYSDATE, 'YYYY-MM-DD/HH24:MI:SS'));
PRO <a name="idx_stat_ver"></a><details open><br/><summary id="summary2">Indexes Statistics Versions</summary>

SELECT '<!-- '||TO_CHAR(SYSDATE, 'YYYY-MM-DD/HH24:MI:SS')||' -->' FROM dual;
PRO <!-- Please Wait -->

SELECT /* ^^script..sql Indexes Statistics Versions */
       v2.line_text
  FROM (
--Uday.PSR.v6 WITH object AS (
--Uday.PSR.v6 SELECT /*+ MATERIALIZE */
--Uday.PSR.v6        object_owner owner, object_name name, object_type
--Uday.PSR.v6   FROM gv$sql_plan
--Uday.PSR.v6  WHERE inst_id IN (SELECT inst_id FROM gv$instance)
--Uday.PSR.v6    AND sql_id = :sql_id
--Uday.PSR.v6    AND object_owner IS NOT NULL
--Uday.PSR.v6    AND object_name IS NOT NULL
--Uday.PSR.v6    AND not (object_type = 'TABLE (TEMP)' and object_name like 'SYS_TEMP%') --Uday.v6
--Uday.PSR.v6  UNION
--Uday.PSR.v6 SELECT object_owner owner, object_name name, object_type
--Uday.PSR.v6   FROM dba_hist_sql_plan
--Uday.PSR.v6  WHERE :license IN ('T', 'D')
--Uday.PSR.v6    AND dbid = ^^dbid.
--Uday.PSR.v6    AND sql_id = :sql_id
--Uday.PSR.v6    AND object_owner IS NOT NULL
--Uday.PSR.v6    AND object_name IS NOT NULL
--Uday.PSR.v6    AND not (object_type = 'TABLE (TEMP)' and object_name like 'SYS_TEMP%') --Uday.v6
--Uday.PSR.v6  ) , plan_tables AS (
--Uday.PSR.v6 --UdayRemoved.v6 SELECT /*+ MATERIALIZE */
--Uday.PSR.v6 --UdayRemoved.v6        'TABLE' object_type, t.owner object_owner, t.table_name object_name
--Uday.PSR.v6 --UdayRemoved.v6   FROM dba_tab_statistics t, -- include fixed objects
--Uday.PSR.v6 --UdayRemoved.v6        object o
--Uday.PSR.v6 --UdayRemoved.v6  WHERE t.owner = o.owner
--Uday.PSR.v6 --UdayRemoved.v6    AND t.table_name = o.name
--Uday.PSR.v6  SELECT /*+ MATERIALIZE */
--Uday.PSR.v6         'TABLE' object_type, o.owner object_owner, o.name object_name
--Uday.PSR.v6    FROM object o
--Uday.PSR.v6   WHERE o.object_type like 'TABLE%'
--Uday.PSR.v6   UNION
--Uday.PSR.v6  SELECT 'TABLE' object_type, i.table_owner object_owner, i.table_name object_name
--Uday.PSR.v6    FROM dba_indexes i,
--Uday.PSR.v6         object o
--Uday.PSR.v6   WHERE o.object_type like 'INDEX%'  --Uday.v6
--Uday.PSR.v6     AND i.owner = o.owner
--Uday.PSR.v6     AND i.index_name = o.name
--Uday.PSR.v6 )
SELECT object_name table_name,
       object_owner owner,
       1 line_type,
       1 row_num,
       '<a name="i_stat_ver_'||LOWER(object_name||'_'||object_owner)||'"></a><details open><br/><summary id="summary3">Indexes Statistics Versions: '||object_name||' ('||object_owner||')</summary>'||CHR(10)||CHR(10)||
       'CBO Statistics and relevant attributes.'||CHR(10)||CHR(10)||
       '<table>'||CHR(10)||CHR(10)||
       '<tr>'||CHR(10)||
       '<th>#</th>'||CHR(10)||
       '<th>Index Name</th>'||CHR(10)||
       '<th>Owner</th>'||CHR(10)||
	   '<th>Version Type</th>'||CHR(10)||
	   '<th>Save Time</th>'||CHR(10)||
	   '<th>Last Analyzed</th>'||CHR(10)||	   
       '<th>Num<br>Rows</th>'||CHR(10)||
       '<th>Sample<br>Size</th>'||CHR(10)||
       '<th>Perc</th>'||CHR(10)||
       '<th>Distinct<br>Keys</th>'||CHR(10)||
       '<th>Blevel</th>'||CHR(10)||
       '<th>Leaf<br>Blocks</th>'||CHR(10)||
       '<th>Avg<br>Leaf<br>Blocks<br>per Key</th>'||CHR(10)||
       '<th>Avg<br>Data<br>Blocks<br>per Key</th>'||CHR(10)||
       '<th>Clustering<br>Factor</th>'||CHR(10)||
       '</tr>'||CHR(10) line_text
  FROM plan_table
 WHERE object_type = 'TABLE'
   AND STATEMENT_ID = :sql_id
 UNION ALL 
SELECT v.object_name,
       v.object_owner owner,
       2 line_type,
       ROWNUM row_num,
       CHR(10)||'<tr>'||CHR(10)||
       '<td class="r">'||ROWNUM||'</td>'||CHR(10)||
       '<td>'||v.index_name||'</td>'||CHR(10)||
       '<td>'||v.owner||'</td>'||CHR(10)||
	   '<td>'||v.version_type||'</td>'||CHR(10)||
	   '<td nowrap>'||v.save_time||'</td>'||CHR(10)||
       '<td nowrap>'||v.last_analyzed||'</td>'||CHR(10)||	   
       '<td class="r">'||v.num_rows||'</td>'||CHR(10)||
       '<td class="r">'||v.sample_size||'</td>'||CHR(10)||
       '<td class="r">'||v.sample_size_perc||'</td>'||CHR(10)||
       '<td class="r">'||v.distinct_keys||'</td>'||CHR(10)||
       '<td class="r">'||v.blevel||'</td>'||CHR(10)||
       '<td class="r">'||v.leaf_blocks||'</td>'||CHR(10)||
       '<td class="r">'||v.avg_leaf_blocks_per_key||'</td>'||CHR(10)||
       '<td class="r">'||v.avg_data_blocks_per_key||'</td>'||CHR(10)||
       '<td class="r">'||v.clustering_factor||'</td>'||CHR(10)||
       '</tr>'||CHR(10) line_text
  FROM (
SELECT * 
  FROM (  
SELECT /*+ NO_MERGE LEADING(pt i o s) index(s I_WRI$_OPTSTAT_IND_OBJ#_ST) */
       i.table_name object_name,
       i.table_owner object_owner,
       i.index_name,
       i.owner,
	     'HISTORY' version_type,
	     TO_CHAR(s.savtime, 'YYYY-MM-DD/HH24:MI:SS') save_time,
       TO_CHAR(s.analyzetime, 'YYYY-MM-DD/HH24:MI:SS') last_analyzed,	   
       s.rowcnt num_rows,
       s.samplesize sample_size,
       CASE WHEN s.rowcnt > 0 THEN TO_CHAR(ROUND(s.samplesize * 100 / s.rowcnt, 1), '99999990D0') END sample_size_perc,
       s.distkey distinct_keys,
       s.blevel,
       s.leafcnt leaf_blocks,
       s.lblkkey avg_leaf_blocks_per_key,
       s.dblkkey avg_data_blocks_per_key,
       s.clufac clustering_factor
  FROM plan_table pt,
       sys.wri$_optstat_ind_history s,
       dba_indexes i,
       dba_objects o
 WHERE pt.object_type = 'TABLE'
   AND STATEMENT_ID = :sql_id
   AND pt.object_owner = i.table_owner
   AND pt.object_name = i.table_name
   AND o.object_type = 'INDEX'
   AND o.owner = i.owner
   AND o.object_name = i.index_name 
   AND s.obj# = o.object_id
   AND (:license IN ('T', 'D') or (:license = 'L' and s.savtime > systimestamp - interval '^^days.' day))
UNION ALL  
SELECT /*+ NO_MERGE LEADING(pt s) */
       s.table_name,
       s.table_owner,
       s.index_name,
       s.owner,
	   'CURRENT' version_type,
	   NULL save_time,
       TO_CHAR(s.last_analyzed, 'YYYY-MM-DD/HH24:MI:SS') last_analyzed,	   
       s.num_rows,
       s.sample_size,
       CASE WHEN s.num_rows > 0 THEN TO_CHAR(ROUND(s.sample_size * 100 / s.num_rows, 1), '99999990D0') END sample_size_perc,      
       s.distinct_keys,
       s.blevel,
       s.leaf_blocks,
       s.avg_leaf_blocks_per_key,
       s.avg_data_blocks_per_key,
       s.clustering_factor
  FROM plan_table pt,
       dba_ind_statistics s
       -- , dba_indexes i  -- Uday.v6
 WHERE pt.object_type = 'TABLE'
   AND STATEMENT_ID = :sql_id
   AND pt.object_owner = s.table_owner
   AND pt.object_name = s.table_name
   AND s.object_type = 'INDEX'
   --UdayRemoved.v6 AND s.owner = i.owner
   --UdayRemoved.v6 AND s.index_name = i.index_name
   --UdayRemoved.v6 AND s.table_owner = i.table_owner
   --UdayRemoved.v6 AND s.table_name = i.table_name) 
 )
 ORDER BY
       index_name,
       owner,
	   save_time DESC NULLS FIRST) v
UNION ALL
SELECT object_name table_name,
       object_owner owner,
       3 line_type,
       1 row_num,
       '<tr>'||CHR(10)||
       '<th>#</th>'||CHR(10)||
       '<th>Index Name</th>'||CHR(10)||
       '<th>Owner</th>'||CHR(10)||
	   '<th>Version Type</th>'||CHR(10)||
	   '<th>Save Time</th>'||CHR(10)||
	   '<th>Last Analyzed</th>'||CHR(10)||	   
       '<th>Num<br>Rows</th>'||CHR(10)||
       '<th>Sample<br>Size</th>'||CHR(10)||
       '<th>Perc</th>'||CHR(10)||
       '<th>Distinct<br>Keys</th>'||CHR(10)||
       '<th>Blevel</th>'||CHR(10)||
       '<th>Leaf<br>Blocks</th>'||CHR(10)||
       '<th>Avg<br>Leaf<br>Blocks<br>per Key</th>'||CHR(10)||
       '<th>Avg<br>Data<br>Blocks<br>per Key</th>'||CHR(10)||
       '<th>Clustering<br>Factor</th>'||CHR(10)||
       '</tr>'||CHR(10) line_text
  FROM plan_table
 WHERE object_type = 'TABLE'
   AND STATEMENT_ID = :sql_id
 UNION ALL
SELECT object_name table_name,
       object_owner owner,
       4 line_type,
       1 row_num,
       CHR(10)||'</table></details><!--Pushkar-->'||CHR(10)||CHR(10) line_text
  FROM plan_table
 WHERE object_type = 'TABLE'
   AND STATEMENT_ID = :sql_id)  v2
 ORDER BY
       v2.table_name,
       v2.owner,
       v2.line_type,
       v2.row_num;	  
         

select round((sysdate-to_date(:start_time,'dd-mon-rr hh24:mi:ss'))*86400) diff from dual;
PRO <table style="width:100%"><tr><td style="text-align:right; background-color:#ffffff">Time taken: ^^diff. seconds</td></tr></table>
PRO </details> <!--Pushkar-->
exec :start_time := to_char(sysdate,'dd-mon-rr hh24:mi:ss');
/* -------------------------
 *
 * system parameters
 *
 * ------------------------- */
EXEC DBMS_APPLICATION_INFO.SET_CLIENT_INFO('^^method.: System Parameters - ' || TO_CHAR(SYSDATE, 'YYYY-MM-DD/HH24:MI:SS'));
PRO <a name="sys_params"></a><details><br/><summary id="summary2">System Parameters with Non-Default or Modified Values</summary>
PRO
PRO Collected from GV$SYSTEM_PARAMETER2 where isdefault = 'FALSE' OR ismodified != 'FALSE'.
PRO "Is Default" = FALSE means the parameter was set in the spfile.
PRO
PRO <table>
PRO
PRO <tr>
PRO <th>#</th>
PRO <th>Name</th>
PRO <th>Inst</th>
PRO <th>Ord</th>
PRO <th>Is<br>Default</th>
PRO <th>Is<br>Modified</th>
PRO <th>Value</th>
PRO <th>Display<br>Value</th>
PRO <th>Description</th>
PRO </tr>
PRO
SELECT '<!-- '||TO_CHAR(SYSDATE, 'YYYY-MM-DD/HH24:MI:SS')||' -->' FROM dual;
PRO <!-- Please Wait -->

SELECT /* ^^script..sql System Parameters */
       CHR(10)||'<tr>'||CHR(10)||
       '<td class="r">'||ROWNUM||'</td>'||CHR(10)||
       '<td>'||v.name||'</td>'||CHR(10)||
       '<td class="c">'||v.inst_id||'</td>'||CHR(10)||
       '<td class="r">'||v.ordinal||'</td>'||CHR(10)||
       '<td>'||v.isdefault||'</td>'||CHR(10)||
       '<td>'||v.ismodified||'</td>'||CHR(10)||
       '<td>'||v.value||'</td>'||CHR(10)||
       '<td>'||DECODE(v.display_value, v.value, NULL, v.display_value)||'</td>'||CHR(10)||
       '<td>'||v.description||'</td>'||CHR(10)||
       '</tr>'
  FROM (
SELECT /*+ NO_MERGE */ *
  FROM gv$system_parameter2
 WHERE (isdefault = 'FALSE' OR ismodified <> 'FALSE')
 ORDER BY
       name,
       inst_id,
       ordinal ) v;

PRO
PRO <tr>
PRO <th>#</th>
PRO <th>Name</th>
PRO <th>Inst</th>
PRO <th>Ord</th>
PRO <th>Is<br>Default</th>
PRO <th>Is<br>Modified</th>
PRO <th>Value</th>
PRO <th>Display<br>Value</th>
PRO <th>Description</th>
PRO </tr>
PRO
PRO </table>

select round((sysdate-to_date(:start_time,'dd-mon-rr hh24:mi:ss'))*86400) diff from dual;
PRO <table style="width:100%"><tr><td style="text-align:right; background-color:#ffffff">Time taken: ^^diff. seconds</td></tr></table>
PRO </details><!--Pushkar-->
exec :start_time := to_char(sysdate,'dd-mon-rr hh24:mi:ss');
/* -------------------------
 *
 * instance parameters
 *
 * ------------------------- */
PRO <a name="inst_params"></a><details><br/><summary id="summary2">Instance Parameters</summary>
PRO
PRO System Parameters collected from V$SYSTEM_PARAMETER2 for Instance number ^^instance_number..
PRO
PRO <table>
PRO
PRO <tr>
PRO <th>#</th>
PRO <th>Name</th>
PRO <th>Ord</th>
PRO <th>Is<br>Default</th>
PRO <th>Is<br>Modified</th>
PRO <th>Value</th>
PRO <th>Display<br>Value</th>
PRO <th>Description</th>
PRO </tr>
PRO
SELECT '<!-- '||TO_CHAR(SYSDATE, 'YYYY-MM-DD/HH24:MI:SS')||' -->' FROM dual;
PRO <!-- Please Wait -->

SELECT /* ^^script..sql System Parameters */
       CHR(10)||'<tr>'||CHR(10)||
       '<td class="r">'||ROWNUM||'</td>'||CHR(10)||
       '<td>'||v.name||'</td>'||CHR(10)||
       '<td class="r">'||v.ordinal||'</td>'||CHR(10)||
       '<td>'||v.isdefault||'</td>'||CHR(10)||
       '<td>'||v.ismodified||'</td>'||CHR(10)||
       '<td>'||v.value||'</td>'||CHR(10)||
       '<td>'||DECODE(v.display_value, v.value, NULL, v.display_value)||'</td>'||CHR(10)||
       '<td>'||v.description||'</td>'||CHR(10)||
       '</tr>'
  FROM (
SELECT /*+ NO_MERGE */ *
  FROM v$system_parameter2
 ORDER BY
       name,
       ordinal ) v;

PRO
PRO <tr>
PRO <th>#</th>
PRO <th>Name</th>
PRO <th>Ord</th>
PRO <th>Is<br>Default</th>
PRO <th>Is<br>Modified</th>
PRO <th>Value</th>
PRO <th>Display<br>Value</th>
PRO <th>Description</th>
PRO </tr>
PRO
PRO </table>

select round((sysdate-to_date(:start_time,'dd-mon-rr hh24:mi:ss'))*86400) diff from dual;
PRO <table style="width:100%"><tr><td style="text-align:right; background-color:#ffffff">Time taken: ^^diff. seconds</td></tr></table>
PRO </details><!--Pushkar-->
exec :start_time := to_char(sysdate,'dd-mon-rr hh24:mi:ss');

/* -------------------------
 *
 * VPD Policies
 * Uday
 * ------------------------- */
PRO
PRO <a name="vpd_policies"></a><details open><br/><summary id="summary2">VPD Policies (GV$VPD_POLICY)</summary>
PRO
PRO VPD Policies applied on objects used in ^^sql_id. while still in memory.
PRO
PRO <table>
PRO
PRO <tr>
PRO <th>#</th>
PRO <th>Policy</th>
PRO <th>Count</th>
PRO <th>#of Objects</th>
PRO <th>Predicate</th>
PRO </tr>
PRO
SELECT '<!-- '||TO_CHAR(SYSDATE, 'YYYY-MM-DD/HH24:MI:SS')||' -->' FROM dual;
PRO <!-- Please Wait -->

SELECT CHR(10)||'<tr>'||CHR(10)||
       '<td class="r">'||ROWNUM||'</td>'||CHR(10)||
       '<td >'||v.policy||'</td>'||CHR(10)||
       '<td class="r">'||v.cnt||'</td>'||CHR(10)||
       '<td class="r">'||v.cntobj||'</td>'||CHR(10)||
       '<td >'||v.predicate||'</td>'||CHR(10)||
       '</tr>'
  FROM (
        SELECT /*+ NO_MERGE */ distinct 
               policy, 
               count(distinct object_name) over(partition by sql_id, policy) cntobj, 
               count(*) over(partition by sql_id, policy, predicate) cnt, 
               substr(predicate, 1, 4000-150) predicate 
          from gv$vpd_policy 
         where sql_id = :sql_id
         order by policy, predicate
       ) v
;

PRO
PRO <tr>
PRO <th>#</th>
PRO <th>Policy</th>
PRO <th>Count</th>
PRO <th>#of Objects</th>
PRO <th>Predicate</th>
PRO </tr>
PRO
PRO </table>

select round((sysdate-to_date(:start_time,'dd-mon-rr hh24:mi:ss'))*86400) diff from dual;
PRO <table style="width:100%"><tr><td style="text-align:right; background-color:#ffffff">Time taken: ^^diff. seconds</td></tr></table>
PRO </details><!--Pushkar-->
exec :start_time := to_char(sysdate,'dd-mon-rr hh24:mi:ss');

/* -------------------------  SQL Undo Usage - Vivek Jha 9/20/19 ------------------------- */
PRO
PRO <a name="sql_undo_usage"></a><details open><br/><summary id="summary2">SQL Undo Usage</summary>
PRO
PRO I/O Type Usage in ^^sql_id. (includes Undo)
PRO

SELECT '<!-- '||TO_CHAR(SYSDATE, 'YYYY-MM-DD/HH24:MI:SS')||' -->' FROM dual;
PRO <!-- Please Wait -->

pro <table>
pro <tr>
pro <th>sql_plan_hash_value</th>
pro <th>I/O type</th>
pro <th>DB time%</th>
pro </tr>

	SELECT  CHR(10)||'<tr>'||CHR(10)
	    || '<td class="r">'||sql_plan_hash_value||'</td>'||CHR(10)
	    || '<td class="r">'||"I/O type"||'</td>'||CHR(10)
	    || '<td class="r">'||"DB time%"||'</td>'||CHR(10)
		||'</TR>'
	from (	SELECT ash.sql_plan_hash_value,
		    nvl(ts.contents,'not in I/O') "I/O type",
		    round(100 * COUNT(sample_time) / SUM(COUNT(sample_time) ) OVER(),1) "DB time%"
		FROM
		    gv$active_session_history ash,
		    dba_data_files df,
		    dba_tablespaces ts
		WHERE 1=1
		    AND :license IN ('T', 'D') -- NOT available in LITE mode
		    AND ash.p1 = df.file_id (+)
		    AND df.tablespace_name = ts.tablespace_name (+)
        AND ash.sample_time between sysdate - 1 and sysdate
		    AND ash.sql_id = :sql_id
   		GROUP BY
		    ash.sql_plan_hash_value, ts.contents
		ORDER BY
		    ash.sql_plan_hash_value);

pro <tr>
pro <th>sql_plan_hash_value</th>
pro <th>I/O type</th>
pro <th>DB time%</th>
pro </tr>
PRO </table>

select round((sysdate-to_date(:start_time,'dd-mon-rr hh24:mi:ss'))*86400) diff from dual;
PRO <table style="width:100%"><tr><td style="text-align:right; background-color:#ffffff">Time taken: ^^diff. seconds</td></tr></table>
PRO </details><!--Pushkar-->
exec :start_time := to_char(sysdate,'dd-mon-rr hh24:mi:ss');
PRO




/* ------------------------------------------------------------------------------------------------------------------------
-- Vivek Jha v10.5  2019/06/24
-- DESCRIPTION
--  This script generates the Table Stats, Column Stats, Index Stats, Index Column Stats
--  and Bind values for a given SQL ID and PLAN HASH VALUE based on the last HARD PARSE TIME
--  (current stats might be different from the time when the SQL was last hard parsed)
--  
--  Data is fetched from tables in memory. Depending on the Retention period for those tables, 
--  not all tables used in the execution plan might show up in the output
 ------------------------------------------------------------------------------------------------------------------------ */

PRO <a name="sql_stats_hard_parse_time"></a><details open><br/><summary id="summary2">SQL Statistics based on Last Hard Parse Time</summary>
PRO
PRO This section includes Table/Column/Index/IndexColumn Stats and Bind values for a given SQL ID and PLAN HASH VALUE based on the Last Hard Parse Time<br />
PRO (current stats might be different from the time when the SQL was last hard parsed) <br />
PRO Data is fetched from tables in memory. Depending on the Retention period for those tables, not all tables used in the execution plan might show up in the output 
pro <br></br>

var  l_last_load_time varchar2(50) ;
var  l_plan_hash_value number;

begin
select plan_hash_value into :l_plan_hash_value from gv$sql where sql_id = :sql_id order by last_load_time desc FETCH FIRST 1 ROW ONLY;
select last_load_time into :l_last_load_time from gv$sql where sql_id = :sql_id order by last_load_time desc FETCH FIRST 1 ROW ONLY;
end;
/


--PRO <h5>SQL ID: &&sql_id    <br>  Plan Hash Value : &&plan_hash_value  </h5>
--PRO SQL ID: &&sql_id   Plan Hash Value: &&plan_hash_value  
--PRO SQL ID: :sql_id   
--SELECT 'Hard Parse Time: ' || :l_last_load_time from dual;
SELECT '         Plan Hash Value:' ||:l_plan_hash_value ||'        Hard Parse Time: ' || :l_last_load_time from dual;

pro <br></br>

-- Start of Table Stats
PRO <br/><summary id="summary3">Table Statistics </summary>

-- column headers
pro <table>
pro <tbody><tr>
pro <th>Table Name</th>
pro <th>Rowcount</th>
pro <th>Block Cnt</th>
pro <th>Avg Length</th>
pro <th>Analyze Time</th>
pro </tr>

--prompt
--PROMPT ========================================================================================================================================================================
--PROMPT This script provides Table Stats, Column Stats, Index Stats and Index Column Stats for all tables and Indexes used for a particular SQL_ID and Plan_hash_Value
--PROMPT ========================================================================================================================================================================
--prompt
--Prompt **** SQL_ID : &1
--Prompt **** PLAN HASH VALUE : &2
--prompt
--prompt
--Prompt ***** TABLE STATS *****
--prompt

--pro <bluea>Table Stats</bluea>
--PRO <bluea><a name="TABLE_STATS">Table Stats</a></bluea>
--pro <br></br>


   with tablist as
    ( select distinct sql_id, plan_hash_value, object_owner table_owner, object_name table_name, object_type
      from gv$sql_plan where sql_id = :sql_id and plan_hash_value = :l_plan_hash_value
      and object_type = 'TABLE' )
SELECT  CHR(10)||'<tr>'||CHR(10)
    || '<td class="r">'||table_name||'</td>'||CHR(10)
    || '<td class="r">'||rowcnt||'</td>'||CHR(10)
    || '<td class="r">'||blkcnt||'</td>'||CHR(10)
    || '<td class="r">'||avgrln||'</td>'||CHR(10)
    || '<td class="r">'||analyze_time||'</td>'||CHR(10)
        ||'</TR>'
from (select t2.object_name table_name, t1.rowcnt, t1.blkcnt, t1.avgrln, to_char(analyzetime, 'yyyy-mm-dd hh24:mi:ss') Analyze_time, row_number() over (partition by t2.object_name order by analyzetime desc) r
   from SYS.WRI$_OPTSTAT_TAB_HISTORY t1,
   dba_objects t2,
   tablist t3
   where t1.obj# = t2.object_id
   and t2.object_name = t3.table_name
   and t2.owner =  t3.table_owner
   and analyzetime < (select to_date(last_load_time,'yyyy-mm-dd hh24:mi:ss') from gv$sql where sql_id = :sql_id and plan_hash_value = :l_plan_hash_value order by last_load_time desc FETCH FIRST 1 ROW ONLY)
   order by t2.object_name)
   where r=1;

pro <tr>
pro <th>Table Name</th>
pro <th>Rowcount</th>
pro <th>Block Cnt</th>
pro <th>Avg Length</th>
pro <th>Analyze Time</th>
pro </tr>

pro </tbody>
PRO </table>
-- End of Table Stats

--select round((sysdate-to_date(:start_time,'dd-mon-rr hh24:mi:ss'))*86400) diff from dual;
--PRO <table style="width:100%"><tr><td style="text-align:right; background-color:#ffffff">Time taken: ^^diff. seconds</td></tr></table>
--exec :start_time := to_char(sysdate,'dd-mon-rr hh24:mi:ss');

-- start of Column Stats SQL  
-- Modified on 4/27/21 to include only indexed columns and only last 3 stats for every column
-- Commented out on 4/28/21 since this was fetching lots of data

-- PRO <br/><summary id="summary3">Column Statistics </summary>

-- column headers
-- pro <table>
-- pro <tbody><tr>
-- pro <th>Table Name</th>
-- pro <th>CP</th>
-- pro <th>Column Name</th>
-- pro <th>Data Type</th>
-- pro <th>DISTCNT</th>
-- pro <th>NULL_CNT</th>
-- pro <th>AVGCLN</th>
-- pro <th>Sample Size</th>
-- pro <th>Low Value</th>
-- pro <th>High Value</th>
-- pro <th>Last Analyzed</th>
-- pro </tr>

--prompt 
--prompt 
--Prompt ***** COLUMN STATS *****
--prompt 



-- SELECT  CHR(10)||'<tr>'||CHR(10) 
-- 	|| '<td class="r">'||table_name||'</td>'||CHR(10)
-- 	|| '<td class="r">'||cp||'</td>'||CHR(10)
-- 	|| '<td class="r">'||cname||'</td>'||CHR(10)
-- 	|| '<td class="r">'||dty||'</td>'||CHR(10)
-- 	|| '<td class="r">'||distcnt||'</td>'||CHR(10)
-- 	|| '<td class="r">'||null_cnt||'</td>'||CHR(10)
-- 	|| '<td class="r">'||avgcln||'</td>'||CHR(10)
-- 	|| '<td class="r">'||sample_size||'</td>'||CHR(10)
-- 	|| '<td class="r">'||low_value||'</td>'||CHR(10)
-- 	|| '<td class="r">'||high_value||'</td>'||CHR(10)
-- 	|| '<td class="r">'||last_analyzed||'</td>'||CHR(10)
--     ||'</TR>'
-- from (
--with tablist as 
--    ( select distinct sql_id, plan_hash_value, object_owner table_owner, object_name table_name, object_type
--      from gv$sql_plan where sql_id = :sql_id and plan_hash_value = :l_plan_hash_value
--      and object_type = 'TABLE' )
--SELECT table_name, CP, CNAME,  DTY, DISTCNT, NULL_CNT, AVGCLN, SAMPLE_SIZE, low_value, high_value, LAST_ANALYZED
--FROM (SELECT   /*+ OPT_PARAM('_optimizer_adaptive_plans','false') */ tab.table_name, C.COL# CP, RPAD(C.NAME,30) CNAME,  TC.DATA_TYPE DTY,
--          nvl(CSH.DISTCNT, TC.NUM_DISTINCT) DISTCNT,
--          nvl(CSH.NULL_CNT, TC.NUM_NULLS)  NULL_CNT,
--          NVL(CSH.AVGCLN, TC.AVG_COL_LEN) AVGCLN,
--          NVL(CSH.SAMPLE_SIZE, TC.SAMPLE_SIZE) SAMPLE_SIZE,
--       decode(substr(tc.data_type,1,9)
--          ,'NUMBER'       ,to_char(utl_raw.cast_to_number(NVL(NVL(CSH.LOWVAL, TC.LOW_VALUE), TC.LOW_VALUE))) 
--          ,'VARCHAR2'     ,to_char(utl_raw.cast_to_varchar2(NVL(CSH.LOWVAL, TC.LOW_VALUE))) 
--          ,'NVARCHAR2'    ,to_char(utl_raw.cast_to_nvarchar2(NVL(CSH.LOWVAL, TC.LOW_VALUE))) 
--          ,'BINARY_DO'    ,to_char(utl_raw.cast_to_binary_double(NVL(CSH.LOWVAL, TC.LOW_VALUE))) 
--          ,'BINARY_FL'    ,to_char(utl_raw.cast_to_binary_float(NVL(CSH.LOWVAL, TC.LOW_VALUE))) 
--          ,'DATE'         ,decode(NVL(CSH.LOWVAL, TC.LOW_VALUE), NULL, NULL, rtrim(
--                                to_char(100*(to_number(substr(NVL(CSH.LOWVAL, TC.LOW_VALUE),1,2),'XX')-100)
--                                       + (to_number(substr(NVL(CSH.LOWVAL, TC.LOW_VALUE),3,2),'XX')-100),'fm0000')||'-'||
--                                to_char(to_number(substr(NVL(CSH.LOWVAL, TC.LOW_VALUE),5,2),'XX'),'fm00')||'-'||
--                                to_char(to_number(substr(NVL(CSH.LOWVAL, TC.LOW_VALUE),7,2),'XX'),'fm00')||' '||
--                                to_char(to_number(substr(NVL(CSH.LOWVAL, TC.LOW_VALUE),9,2),'XX')-1,'fm00')||':'||
--                                to_char(to_number(substr(NVL(CSH.LOWVAL, TC.LOW_VALUE),11,2),'XX')-1,'fm00')||':'||
--                               to_char(to_number(substr(NVL(CSH.LOWVAL, TC.LOW_VALUE),13,2),'XX')-1,'fm00'))) 
--         ,'TIMESTAMP'    ,decode(NVL(CSH.LOWVAL, TC.LOW_VALUE), NULL, NULL, rtrim(
--                           to_char(100*(to_number(substr(NVL(CSH.LOWVAL, TC.LOW_VALUE),1,2),'XX')-100)
--                                  + (to_number(substr(NVL(CSH.LOWVAL, TC.LOW_VALUE),3,2),'XX')-100),'fm0000')||'-'||
--                           to_char(to_number(substr(NVL(CSH.LOWVAL, TC.LOW_VALUE),5,2),'XX'),'fm00')||'-'||
--                           to_char(to_number(substr(NVL(CSH.LOWVAL, TC.LOW_VALUE),7,2),'XX'),'fm00')||' '||
--                           to_char(to_number(substr(NVL(CSH.LOWVAL, TC.LOW_VALUE),9,2),'XX')-1,'fm00')||':'||
--                           to_char(to_number(substr(NVL(CSH.LOWVAL, TC.LOW_VALUE),11,2),'XX')-1,'fm00')||':'||
--                           to_char(to_number(substr(NVL(CSH.LOWVAL, TC.LOW_VALUE),13,2),'XX')-1,'fm00')||'.'||
--                           to_number(substr(NVL(CSH.LOWVAL, TC.LOW_VALUE),15,8),'XXXXXXXX')  )) 
--                           , NVL(CSH.LOWVAL, TC.LOW_VALUE) ) low_value,
--       decode(substr(tc.data_type,1,9)
--          ,'NUMBER'       ,to_char(utl_raw.cast_to_number(NVL(NVL(csh.hival, tc.high_value), tc.high_value))) 
--          ,'VARCHAR2'     ,to_char(utl_raw.cast_to_varchar2(NVL(csh.hival, tc.high_value))) 
--          ,'NVARCHAR2'    ,to_char(utl_raw.cast_to_nvarchar2(NVL(csh.hival, tc.high_value))) 
--          ,'BINARY_DO'    ,to_char(utl_raw.cast_to_binary_double(NVL(csh.hival, tc.high_value))) 
--          ,'BINARY_FL'    ,to_char(utl_raw.cast_to_binary_float(NVL(csh.hival, tc.high_value))) 
--          ,'DATE'         ,decode(NVL(csh.hival, tc.high_value), NULL, NULL, rtrim(
--                                to_char(100*(to_number(substr(NVL(csh.hival, tc.high_value),1,2),'XX')-100)
--                                       + (to_number(substr(NVL(csh.hival, tc.high_value),3,2),'XX')-100),'fm0000')||'-'||
--                                to_char(to_number(substr(NVL(csh.hival, tc.high_value),5,2),'XX'),'fm00')||'-'||
--                                to_char(to_number(substr(NVL(csh.hival, tc.high_value),7,2),'XX'),'fm00')||' '||
--                                to_char(to_number(substr(NVL(csh.hival, tc.high_value),9,2),'XX')-1,'fm00')||':'||
--                                to_char(to_number(substr(NVL(csh.hival, tc.high_value),11,2),'XX')-1,'fm00')||':'||
--                                to_char(to_number(substr(NVL(csh.hival, tc.high_value),13,2),'XX')-1,'fm00'))) 
--          ,'TIMESTAMP'    ,decode(NVL(csh.hival, tc.high_value), NULL, NULL, rtrim(
--                           to_char(100*(to_number(substr(NVL(csh.hival, tc.high_value),1,2),'XX')-100)
--                                  + (to_number(substr(NVL(csh.hival, tc.high_value),3,2),'XX')-100),'fm0000')||'-'||
--                           to_char(to_number(substr(NVL(csh.hival, tc.high_value),5,2),'XX'),'fm00')||'-'||
--                           to_char(to_number(substr(NVL(csh.hival, tc.high_value),7,2),'XX'),'fm00')||' '||
--                           to_char(to_number(substr(NVL(csh.hival, tc.high_value),9,2),'XX')-1,'fm00')||':'||
--                           to_char(to_number(substr(NVL(csh.hival, tc.high_value),11,2),'XX')-1,'fm00')||':'||
--                           to_char(to_number(substr(NVL(csh.hival, tc.high_value),13,2),'XX')-1,'fm00')||'.'||
--                           to_number(substr(NVL(csh.hival, tc.high_value),15,8),'XXXXXXXX')  )) 
--                           , NVL(csh.hival, tc.high_value) ) high_value,
--          NVL(LPAD(TO_CHAR(CSH.TIMESTAMP#,'YYYY-MM-DD/HH24:MI:SS'),20), LPAD(TO_CHAR(TC.LAST_ANALYZED,'YYYY-MM-DD/HH24:MI:SS'),20)) LAST_ANALYZED,
--          (row_number() over (partition by tab.table_name, CSH.INTCOL# order by tab.table_name, CSH.INTCOL#, CSH.TIMESTAMP# DESC)) r
--          FROM tablist tab,
--               DBA_OBJECTS T,
--               SYS.COL$ C,
--               SYS.WRI$_OPTSTAT_HISTHEAD_HISTORY CSH,
--               DBA_TAB_COLUMNS TC
--          WHERE T.OBJECT_ID    = CSH.OBJ#(+)
--          AND   C.OBJ#         = T.OBJECT_ID
--          AND   C.INTCOL#      = CSH.INTCOL#(+)
--          AND T.OBJECT_NAME = tab.TABLE_NAME AND T.OBJECT_TYPE = 'TABLE'
--          AND   TC.OWNER = T.OWNER
--          AND   TC.TABLE_NAME = T.OBJECT_NAME
--          AND   TC.COLUMN_NAME = C.NAME
--          and timestamp# < (select to_date(last_load_time,'yyyy-mm-dd hh24:mi:ss') from gv$sql where sql_id = :sql_id and plan_hash_value = :l_plan_hash_value order by last_load_time desc FETCH FIRST 1 ROW ONLY)
--          ORDER BY tab.table_name, CSH.INTCOL#, CSH.TIMESTAMP# DESC ) 
--		  WHERE r < 4);
--
--pro <tr>
--pro <th>Table Name</th>
--pro <th>CP</th>
--pro <th>Column Name</th>
--pro <th>Data Type</th>
--pro <th>DISTCNT</th>
--pro <th>NULL_CNT</th>
--pro <th>AVGCLN</th>
--pro <th>Sample Size</th>
--pro <th>Low Value</th>
--pro <th>High Value</th>
--pro <th>Last Analyzed</th>
--pro </tr>


--pro </tbody>
--pro  </table>

-- end of column Stats SQL
select round((sysdate-to_date(:start_time,'dd-mon-rr hh24:mi:ss'))*86400) diff from dual;
PRO <table style="width:100%"><tr><td style="text-align:right; background-color:#ffffff">Time taken: ^^diff. seconds</td></tr></table>
exec :start_time := to_char(sysdate,'dd-mon-rr hh24:mi:ss');

-- start of index Stats SQL
PRO <br/><summary id="summary3">Index Statistics </summary>

-- column headers
pro <table>
pro <tbody><tr>
pro <th>Owner</th>
pro <th>Table Name</th>
pro <th>Index Name</th>
pro <th>Flags</th>
pro <th>Rowcount</th>
pro <th>BLevel</th>
pro <th>Leaf Cnt</th>
pro <th>Dist Key</th>
pro <th>Lblk Key</th>
pro <th>Dblk Key</th>
pro <th>Clustering Factor/th>
pro <th>Sample Size</th>
pro <th>Analyze Time</th>
pro </tr>

--Prompt ***** INDEX STATS *****
--prompt 

   with indlist as 
    ( select distinct sql_id, plan_hash_value, object_owner index_owner, object_name index_name, object_type
           from gv$sql_plan where sql_id = :sql_id and plan_hash_value = :l_plan_hash_value
      and object_type like 'INDEX%' )
SELECT  CHR(10)||'<tr>'||CHR(10) 
	|| '<td class="r">'||owner||'</td>'||CHR(10)
	|| '<td class="r">'||table_name||'</td>'||CHR(10)
	|| '<td class="r">'||index_name||'</td>'||CHR(10)
	|| '<td class="r">'||flags||'</td>'||CHR(10)
	|| '<td class="r">'||rowcnt||'</td>'||CHR(10)
	|| '<td class="r">'||blevel||'</td>'||CHR(10)
	|| '<td class="r">'||leafcnt||'</td>'||CHR(10)
	|| '<td class="r">'||distkey||'</td>'||CHR(10)
	|| '<td class="r">'||lblkkey||'</td>'||CHR(10)
	|| '<td class="r">'||dblkkey||'</td>'||CHR(10)
	|| '<td class="r">'||clufac||'</td>'||CHR(10)
	|| '<td class="r">'||samplesize||'</td>'||CHR(10)
	|| '<td class="r">'||analyze_time||'</td>'||CHR(10)
        ||'</TR>'
 from (select ind.owner, ind.table_name, ind.index_name, flags, rowcnt, hist.blevel , hist.leafcnt, hist.distkey, hist.lblkkey, hist.dblkkey, hist.clufac,hist.samplesize, to_char(analyzetime, 'yyyy-mm-dd hh24:mi:ss') analyze_time, row_number() over (partition by ind.owner, ind.table_name, ind.index_name order by analyzetime desc) r
   from sys.wri$_optstat_ind_history hist, 
   dba_objects obj,
   dba_indexes ind,
   indlist i
   where hist.obj# = obj.object_id 
   and ind.index_name = obj.object_name
   and ind.owner = obj.owner
   and obj.object_type ='INDEX'
   and ind.index_name = i.index_name
   and ind.owner =  i.index_owner
--   and analyzetime < (select to_date(max(last_load_time),'yyyy-mm-dd hh24:mi:ss') from gv$sql where sql_id = '&&sql_id' and plan_hash_value = &&plan_hash_value)
   and analyzetime < (select to_date(last_load_time,'yyyy-mm-dd hh24:mi:ss') from gv$sql where sql_id = :sql_id and plan_hash_value = :l_plan_hash_value order by last_load_time desc FETCH FIRST 1 ROW ONLY)
   order by ind.table_name, ind.index_name)
   where r=1;

pro <tr>
pro <th>Owner</th>
pro <th>Table Name</th>
pro <th>Index Name</th>
pro <th>Flags</th>
pro <th>Rowcount</th>
pro <th>BLevel</th>
pro <th>Leaf Cnt</th>
pro <th>Dist Key</th>
pro <th>Lblk Key</th>
pro <th>Dblk Key</th>
pro <th>Clustering Factor/th>
pro <th>Sample Size</th>
pro <th>Analyze Time</th>
pro </tr>

pro </tbody>
pro  </table>

-- END OF INDEX STATS SQL
select round((sysdate-to_date(:start_time,'dd-mon-rr hh24:mi:ss'))*86400) diff from dual;
PRO <table style="width:100%"><tr><td style="text-align:right; background-color:#ffffff">Time taken: ^^diff. seconds</td></tr></table>
exec :start_time := to_char(sysdate,'dd-mon-rr hh24:mi:ss');

-- START OF INDEX COLUMN STATS SQL
--prompt ***** Modified on 4/27/21 to include only last 3 stats for every column
PRO <br/><summary id="summary3">Index Column Statistics </summary>

pro <table>
pro <tbody><tr>
pro <th>Table Name</th>
pro <th>Index Owner</th>
pro <th>Index Name</th>
pro <th>CP</th>
pro <th>Column Name</th>
pro <th>Data Type</th>
pro <th># of Distinct<br>Values</th>
pro <th># of NULLs</th>
pro <th>Avg Column Length</th>
pro <th>Sample Size</th>
pro <th>Low Value</th>
pro <th>High Value</th>
pro <th>Last Analyzed</th>
pro </tr>


SELECT  CHR(10)||'<tr>'||CHR(10) 
	|| '<td class="r">'||table_name||'</td>'||CHR(10)
	|| '<td class="r">'||index_owner||'</td>'||CHR(10)
	|| '<td class="r">'||index_name||'</td>'||CHR(10)
	|| '<td class="r">'||cp||'</td>'||CHR(10)
	|| '<td class="r">'||cname||'</td>'||CHR(10)
	|| '<td class="r">'||dty||'</td>'||CHR(10)
	|| '<td class="r">'||distcnt||'</td>'||CHR(10)
	|| '<td class="r">'||null_cnt||'</td>'||CHR(10)
	|| '<td class="r">'||avgcln||'</td>'||CHR(10)
	|| '<td class="r">'||sample_size||'</td>'||CHR(10)
	|| '<td class="r">'||low_value||'</td>'||CHR(10)
	|| '<td class="r">'||high_value||'</td>'||CHR(10)
	|| '<td class="r">'||last_analyzed||'</td>'||CHR(10)
    ||'</TR>'
FROM (
with indlist as 
	    ( select distinct sql_id, plan_hash_value, object_owner index_owner, object_name index_name, object_type
	      from gv$sql_plan where sql_id = :sql_id and plan_hash_value = :l_plan_hash_value
	      and object_type like 'INDEX%' )
SELECT table_name, INDEX_OWNER, index_name, CP, CNAME,  DTY, DISTCNT, NULL_CNT, AVGCLN, SAMPLE_SIZE, 
       case when regexp_like(:pii_tables,table_name,'i') then NULL else low_value  end low_value, 
       case when regexp_like(:pii_tables,table_name,'i') then NULL else high_value end high_value, LAST_ANALYZED
FROM (
	SELECT   /*+ OPT_PARAM('_optimizer_adaptive_plans','false') */ TC.TABLE_NAME, IC.INDEX_OWNER, IC.INDEX_NAME, IC.COLUMN_POSITION CP, RPAD(C.NAME,30) CNAME, TC.DATA_TYPE DTY, 
		  nvl(CSH.DISTCNT, TC.NUM_DISTINCT) DISTCNT,
		  nvl(CSH.NULL_CNT, TC.NUM_NULLS)  NULL_CNT,
		  NVL(CSH.AVGCLN, TC.AVG_COL_LEN) AVGCLN,
		  NVL(CSH.SAMPLE_SIZE, TC.SAMPLE_SIZE) SAMPLE_SIZE,
       decode(substr(tc.data_type,1,9)
          ,'NUMBER'       ,to_char(utl_raw.cast_to_number(NVL(NVL(CSH.LOWVAL, TC.LOW_VALUE), TC.LOW_VALUE))) 
          ,'VARCHAR2'     ,to_char(utl_raw.cast_to_varchar2(NVL(CSH.LOWVAL, TC.LOW_VALUE))) 
          ,'NVARCHAR2'    ,to_char(utl_raw.cast_to_nvarchar2(NVL(CSH.LOWVAL, TC.LOW_VALUE))) 
          ,'BINARY_DO'    ,to_char(utl_raw.cast_to_binary_double(NVL(CSH.LOWVAL, TC.LOW_VALUE))) 
          ,'BINARY_FL'    ,to_char(utl_raw.cast_to_binary_float(NVL(CSH.LOWVAL, TC.LOW_VALUE))) 
          ,'DATE'         ,decode(NVL(CSH.LOWVAL, TC.LOW_VALUE), NULL, NULL, rtrim(
                                to_char(100*(to_number(substr(NVL(CSH.LOWVAL, TC.LOW_VALUE),1,2),'XX')-100)
                                       + (to_number(substr(NVL(CSH.LOWVAL, TC.LOW_VALUE),3,2),'XX')-100),'fm0000')||'-'||
                                to_char(to_number(substr(NVL(CSH.LOWVAL, TC.LOW_VALUE),5,2),'XX'),'fm00')||'-'||
                                to_char(to_number(substr(NVL(CSH.LOWVAL, TC.LOW_VALUE),7,2),'XX'),'fm00')||' '||
                                to_char(to_number(substr(NVL(CSH.LOWVAL, TC.LOW_VALUE),9,2),'XX')-1,'fm00')||':'||
                                to_char(to_number(substr(NVL(CSH.LOWVAL, TC.LOW_VALUE),11,2),'XX')-1,'fm00')||':'||
                                to_char(to_number(substr(NVL(CSH.LOWVAL, TC.LOW_VALUE),13,2),'XX')-1,'fm00'))) 
          ,'TIMESTAMP'    ,decode(NVL(CSH.LOWVAL, TC.LOW_VALUE), NULL, NULL, rtrim(
                           to_char(100*(to_number(substr(NVL(CSH.LOWVAL, TC.LOW_VALUE),1,2),'XX')-100)
                                  + (to_number(substr(NVL(CSH.LOWVAL, TC.LOW_VALUE),3,2),'XX')-100),'fm0000')||'-'||
                           to_char(to_number(substr(NVL(CSH.LOWVAL, TC.LOW_VALUE),5,2),'XX'),'fm00')||'-'||
                           to_char(to_number(substr(NVL(CSH.LOWVAL, TC.LOW_VALUE),7,2),'XX'),'fm00')||' '||
                           to_char(to_number(substr(NVL(CSH.LOWVAL, TC.LOW_VALUE),9,2),'XX')-1,'fm00')||':'||
                           to_char(to_number(substr(NVL(CSH.LOWVAL, TC.LOW_VALUE),11,2),'XX')-1,'fm00')||':'||
                           to_char(to_number(substr(NVL(CSH.LOWVAL, TC.LOW_VALUE),13,2),'XX')-1,'fm00')||'.'||
                           to_number(substr(NVL(CSH.LOWVAL, TC.LOW_VALUE),15,8),'XXXXXXXX')  )) 
                           , NVL(CSH.LOWVAL, TC.LOW_VALUE) ) low_value,
       decode(substr(tc.data_type,1,9)
          ,'NUMBER'       ,to_char(utl_raw.cast_to_number(NVL(NVL(csh.hival, tc.high_value), tc.high_value))) 
          ,'VARCHAR2'     ,to_char(utl_raw.cast_to_varchar2(NVL(csh.hival, tc.high_value))) 
          ,'NVARCHAR2'    ,to_char(utl_raw.cast_to_nvarchar2(NVL(csh.hival, tc.high_value))) 
          ,'BINARY_DO'    ,to_char(utl_raw.cast_to_binary_double(NVL(csh.hival, tc.high_value))) 
          ,'BINARY_FL'    ,to_char(utl_raw.cast_to_binary_float(NVL(csh.hival, tc.high_value))) 
          ,'DATE'         ,decode(NVL(csh.hival, tc.high_value), NULL, NULL, rtrim(
                                to_char(100*(to_number(substr(NVL(csh.hival, tc.high_value),1,2),'XX')-100)
                                       + (to_number(substr(NVL(csh.hival, tc.high_value),3,2),'XX')-100),'fm0000')||'-'||
                                to_char(to_number(substr(NVL(csh.hival, tc.high_value),5,2),'XX'),'fm00')||'-'||
                                to_char(to_number(substr(NVL(csh.hival, tc.high_value),7,2),'XX'),'fm00')||' '||
                                to_char(to_number(substr(NVL(csh.hival, tc.high_value),9,2),'XX')-1,'fm00')||':'||
                                to_char(to_number(substr(NVL(csh.hival, tc.high_value),11,2),'XX')-1,'fm00')||':'||
                                to_char(to_number(substr(NVL(csh.hival, tc.high_value),13,2),'XX')-1,'fm00'))) 
          ,'TIMESTAMP'    ,decode(NVL(csh.hival, tc.high_value), NULL, NULL, rtrim(
                           to_char(100*(to_number(substr(NVL(csh.hival, tc.high_value),1,2),'XX')-100)
                                  + (to_number(substr(NVL(csh.hival, tc.high_value),3,2),'XX')-100),'fm0000')||'-'||
                           to_char(to_number(substr(NVL(csh.hival, tc.high_value),5,2),'XX'),'fm00')||'-'||
                           to_char(to_number(substr(NVL(csh.hival, tc.high_value),7,2),'XX'),'fm00')||' '||
                           to_char(to_number(substr(NVL(csh.hival, tc.high_value),9,2),'XX')-1,'fm00')||':'||
                           to_char(to_number(substr(NVL(csh.hival, tc.high_value),11,2),'XX')-1,'fm00')||':'||
                           to_char(to_number(substr(NVL(csh.hival, tc.high_value),13,2),'XX')-1,'fm00')||'.'||
                           to_number(substr(NVL(csh.hival, tc.high_value),15,8),'XXXXXXXX')  )) 
                           , NVL(csh.hival, tc.high_value) ) high_value,
		  NVL(LPAD(TO_CHAR(CSH.TIMESTAMP#,'YYYY-MM-DD/HH24:MI:SS'),20), LPAD(TO_CHAR(TC.LAST_ANALYZED,'YYYY-MM-DD/HH24:MI:SS'),20)) LAST_ANALYZED,
		  (row_number() over (partition by IC.INDEX_OWNER, IC.INDEX_NAME, IC.COLUMN_POSITION, CSH.INTCOL#  order by IC.INDEX_OWNER, IC.INDEX_NAME, IC.COLUMN_POSITION, CSH.INTCOL#, CSH.TIMESTAMP# DESC )) r
          FROM indlist indl,
		       DBA_IND_COLUMNS IC, DBA_OBJECTS T, SYS.COL$ C, SYS.WRI$_OPTSTAT_HISTHEAD_HISTORY CSH,
		       DBA_TAB_COLUMNS TC
		  WHERE IC.TABLE_NAME  = T.OBJECT_NAME
		  AND   IC.TABLE_OWNER = T.OWNER
		  AND   IC.COLUMN_NAME = C.NAME
		  AND   T.OBJECT_ID    = CSH.OBJ#(+)
		  AND   C.OBJ#         = T.OBJECT_ID
		  AND   C.INTCOL#      = CSH.INTCOL#(+)
		  AND  T.OWNER = indl.INDEX_OWNER  AND   IC.index_name = indl.index_name AND T.OBJECT_TYPE = 'TABLE'
		  AND TC.OWNER = T.OWNER
		  AND TC.TABLE_NAME = T.OBJECT_NAME
		  and csh.timestamp# < (select to_date(last_load_time,'yyyy-mm-dd hh24:mi:ss') from gv$sql where sql_id = :sql_id and plan_hash_value =  :l_plan_hash_value order by last_load_time desc FETCH FIRST 1 ROW ONLY)
		  AND TC.COLUMN_NAME = C.NAME
		  ORDER BY IC.INDEX_OWNER, IC.INDEX_NAME, IC.COLUMN_POSITION, CSH.INTCOL#, CSH.TIMESTAMP# DESC )
		  WHERE r < 4);


pro <tr>
pro <th>Table Name</th>
pro <th>Index Owner</th>
pro <th>Index Name</th>
pro <th>CP</th>
pro <th>Column Name</th>
pro <th>Data Type</th>
pro <th># of Distinct<br>Values</th>
pro <th># of NULLs</th>
pro <th>Avg Column Length</th>
pro <th>Sample Size</th>
pro <th>Low Value</th>
pro <th>High Value</th>
pro <th>Last Analyzed</th>
pro </tr>

pro </tbody>
pro  </table>

-- end of Index Column Stats SQL
select round((sysdate-to_date(:start_time,'dd-mon-rr hh24:mi:ss'))*86400) diff from dual;
PRO <table style="width:100%"><tr><td style="text-align:right; background-color:#ffffff">Time taken: ^^diff. seconds</td></tr></table>
exec :start_time := to_char(sysdate,'dd-mon-rr hh24:mi:ss');

------------------------------------------------------------------------------------------------------------------------------------------------------------------
---------- BIND VALUES   -----------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------

-- START OF BINDS : Peeked Vs Monitored Bind Values - In Memory
PRO <br/><summary id="summary3">Peeked Vs Monitored Bind Values - In Memory</summary>

pro <table>
pro <tbody><tr>
pro <th>Instance #</th>
pro <th>SQL Exec ID</th>
pro <th>SQL Exec Start</th>
pro <th>SQL Plan Hash Value</th>
pro <th>Ch#</th>
pro <th>Plan Gen Timestamp</th>
pro <th>SQLMon Elapsed Time</th>
pro <th>SQLMon Buffer Gets</th>
pro <th>Position</th>
pro <th>Bind Name</th>
pro <th>Data Type</th>
pro <th>Peeked Bind Value</th>
pro <th>SQLMon Bind Value</th>
pro </tr>

SELECT  CHR(10)||'<tr>'||CHR(10) 
	|| '<td class="r">'||inst_id||'</td>'||CHR(10)
	|| '<td class="r">'||sql_exec_id||'</td>'||CHR(10)
	|| '<td class="r">'||sql_exec_start||'</td>'||CHR(10)
	|| '<td class="r">'||sql_plan_hash_value||'</td>'||CHR(10)
	|| '<td class="r">'||ch#||'</td>'||CHR(10)
	|| '<td class="r">'||plan_gen_ts||'</td>'||CHR(10)
	|| '<td class="r">'||sqlmon_et||'</td>'||CHR(10)
	|| '<td class="r">'||sqlmon_bg||'</td>'||CHR(10)
	|| '<td class="r">'||position||'</td>'||CHR(10)
	|| '<td class="r">'||name||'</td>'||CHR(10)
	|| '<td class="r">'||datatype_string||'</td>'||CHR(10)
	|| '<td class="r">'||peeked_value||'</td>'||CHR(10)
	|| '<td class="r">'||sqlmon_val||'</td>'||CHR(10)
from (
with peeked as
(
  SELECT /*+ materialize */ inst_id, sql_id, plan_hash_value, address, child_address, child_number, timestamp,
         to_number(extractValue(value(d), '/bind/@pos')) position,
         extractValue(value(d), '/bind/@nam') name,
         max(extractValue(value(d), '/bind')) over(partition by inst_id, sql_id, plan_hash_value, address, child_address, child_number, extractValue(value(d), '/bind/@nam')) value,
         to_number(extractValue(value(d), '/bind/@ppo')) dup_pos,
         extractValue(value(d), '/bind/@dty') dtype,
         to_number(extractValue(value(d), '/bind/@mxl')) max_length
    FROM
         gv$sql_plan c
         , TABLE(XMLSEQUENCE(EXTRACT(XMLTYPE(c.other_xml ), '/*/peeked_binds/bind'))) D
   where c.sql_id = :sql_id
     and c.other_xml is not null
   -- order by sql_id, to_number(EXTRACTVALUE(VALUE(D), '/bind/@pos'))
),
peeked_val as
(
  select peeked.*,
         (case when dtype = 1 then 'VARCHAR2(' || max_length || ')'
               when dtype = 2 then 'NUMBER(' || max_length || ')'
               when dtype = 12 then 'Date(' || max_length || ')'
               when dtype in (180, 181) then 'TIMESTAMP(' || max_length || ')'
          end
         ) datatype_string,
         case
           when dtype = 1  -- VARCHAR2
             then to_char(utl_raw.cast_to_varchar2(value))
           when dtype = 2  -- NUMBER
             then to_char(utl_raw.cast_to_number(value))
           when dtype = 12 -- Date
             then rtrim(
                    to_char(100*(to_number(substr(value,1,2),'XX')-100)
                           + (to_number(substr(value,3,2),'XX')-100),'fm0000')||'-'||
                    to_char(to_number(substr(value,5,2),'XX'),'fm00')||'-'||
                    to_char(to_number(substr(value,7,2),'XX'),'fm00')||' '||
                    to_char(to_number(substr(value,9,2),'XX')-1,'fm00')||':'||
                    to_char(to_number(substr(value,11,2),'XX')-1,'fm00')||':'||
                    to_char(to_number(substr(value,13,2),'XX')-1,'fm00'))
           when dtype in (180, 181)  -- Timestamp and Timestamp with tz
             then rtrim(
                    to_char(100*(to_number(substr(value,1,2),'XX')-100)
                            + (to_number(substr(value,3,2),'XX')-100),'fm0000')||'-'||
                    to_char(to_number(substr(value,5,2),'XX'),'fm00')||'-'||
                    to_char(to_number(substr(value,7,2),'XX'),'fm00')||' '||
                    to_char(to_number(substr(value,9,2),'XX')-1,'fm00')||':'||
                    to_char(to_number(substr(value,11,2),'XX')-1,'fm00')||':'||
                    to_char(to_number(substr(value,13,2),'XX')-1,'fm00')
                    ||'.'||to_number(substr(value,15,8),'XXXXXXXX')  )
           else
              value
         end cvalue
    from peeked
   -- order by position
),
captured_binds as
(
  select sm.key, sm.inst_id, sm.sql_id, sm.sql_exec_id, sm.sql_exec_start, sm.sql_plan_hash_value, sm.sql_child_address, 
         round(sm.elapsed_time/1000000,2) elapsed_time, buffer_gets,
         to_number(extractvalue(value(b), '/bind/@pos')) position,
         extractvalue(value(b), '/bind/@name') name, 
         extractvalue(value(b), '/bind') captured_value,
         extractvalue(value(b), '/bind/@dtystr') datatype_string
   from
         gv$sql_monitor sm
         , table(xmlsequence(extract(xmltype(sm.binds_xml ), '/binds/bind'))) b
   where sm.sql_id = :sql_id
     and sm.binds_xml is not null
   -- ORDER BY inst_id, child_number, position, dup_position
)
select cb.inst_id, cb.sql_exec_id, to_char(cb.sql_exec_start, 'yyyy-mm-dd hh24:mi:ss') sql_exec_start, cb.sql_plan_hash_value
       , max(pv.child_number) over(partition by cb.key) ch# 
       , to_char(max(pv.timestamp) over(partition by cb.key), 'yyyy-mm-dd hh24:mi:ss') plan_gen_ts 
       , cb.elapsed_time sqlmon_et, cb.buffer_gets sqlmon_bg
       , cb.position, cb.name
       , cb.datatype_string
       , case when (cb.datatype_string like 'VARCHAR%' and :pii_used>0) then substr(pv.cvalue,1,length(pv.cvalue)/3+1)||rpad('***********************************', length(pv.cvalue)*2/3)
         else pv.cvalue end peeked_value       
       , case when cb.datatype_string like 'TIMEST%' THEN
               rtrim(
                    to_char(100*(to_number(substr(cb.captured_value,1,2),'XX')-100)
                            + (to_number(substr(cb.captured_value,3,2),'XX')-100),'fm0000')||'-'||
                    to_char(to_number(substr(cb.captured_value,5,2),'XX'),'fm00')||'-'||
                    to_char(to_number(substr(cb.captured_value,7,2),'XX'),'fm00')||' '||
                    to_char(to_number(substr(cb.captured_value,9,2),'XX')-1,'fm00')||':'||
                    to_char(to_number(substr(cb.captured_value,11,2),'XX')-1,'fm00')||':'||
                    to_char(to_number(substr(cb.captured_value,13,2),'XX')-1,'fm00')
                    ||'.'||to_number(substr(cb.captured_value,15,8),'XXXXXXXX')  
               )
               when (cb.datatype_string like 'VARCHAR%' and :pii_used>0) then substr(cb.captured_value,1,length(cb.captured_value)/3+1)||rpad('***********************************', length(cb.captured_value)*2/3)
         else cb.captured_value 
         end sqlmon_val 
  from peeked_val pv, captured_binds cb
 where 1 = 1
   and cb.inst_id = pv.inst_id
   and cb.sql_id  = pv.sql_id
   and cb.sql_child_address = pv.child_address
   and cb.sql_plan_hash_value = pv.plan_hash_value
   and cb.position = pv.position
   and cb.name = pv.name
-- and sql_exec_start < (select to_date(max(last_load_time),'yyyy-mm-dd hh24:mi:ss') from gv$sql where sql_id = '&&sql_id' and plan_hash_value = :l_plan_hash_value)
   and sql_exec_start < (select to_date(last_load_time,'yyyy-mm-dd hh24:mi:ss') from gv$sql where sql_id = :sql_id and plan_hash_value = :l_plan_hash_value order by last_load_time desc FETCH FIRST 1 ROW ONLY)
 order by cb.inst_id, cb.sql_exec_id, cb.sql_exec_start, cb.sql_plan_hash_value, ch#, plan_gen_ts, cb.elapsed_time, cb.buffer_gets, cb.position)
;


pro <tr>
pro <th>Instance #</th>
pro <th>SQL Exec ID</th>
pro <th>SQL Exec Start</th>
pro <th>SQL Plan Hash Value</th>
pro <th>Ch#</th>
pro <th>Plan Gen Timestamp</th>
pro <th>SQLMon Elapsed Time</th>
pro <th>SQLMon Buffer Gets</th>
pro <th>Position</th>
pro <th>Bind Name</th>
pro <th>Data Type</th>
pro <th>Peeked Bind Value</th>
pro <th>SQLMon Bind Value</th>
pro </tr>


pro </tbody>
pro  </table>

-- END OF BINDS : Peeked Vs Monitored Bind Values - In Memory
select round((sysdate-to_date(:start_time,'dd-mon-rr hh24:mi:ss'))*86400) diff from dual;
PRO <table style="width:100%"><tr><td style="text-align:right; background-color:#ffffff">Time taken: ^^diff. seconds</td></tr></table>
exec :start_time := to_char(sysdate,'dd-mon-rr hh24:mi:ss');

-- START OF BINDS : Peeked Vs Captured Bind Values - In Memory 
PRO <br/><summary id="summary3">Peeked Vs Captured Bind Values - In Memory </summary>

pro <table>
pro <tbody><tr>
pro <th>Instance #</th>
pro <th>Plan Hash Value</th>
pro <th>Ch#</th>
pro <th>Plan Gen Ttmestamp</th>
pro <th>Avg Elapsed Time</th>
pro <th>Avg Buffer Gets</th>
pro <th>Position</th>
pro <th>Bind Name</th>
pro <th>Data Type</th>
pro <th>Peeked Bind Value</th>
pro <th>Captured Bind Value</th>
pro <th>Last Captured Date</th>
pro </tr>

SELECT  CHR(10)||'<tr>'||CHR(10) 
	|| '<td class="r">'||inst_id||'</td>'||CHR(10)
	|| '<td class="r">'||plan_hash_value||'</td>'||CHR(10)
	|| '<td class="r">'||ch#||'</td>'||CHR(10)
	|| '<td class="r">'||plan_gen_ts||'</td>'||CHR(10)
	|| '<td class="r">'||Avg_et||'</td>'||CHR(10)
	|| '<td class="r">'||avg_bg||'</td>'||CHR(10)
	|| '<td class="r">'||position||'</td>'||CHR(10)
	|| '<td class="r">'||name||'</td>'||CHR(10)
	|| '<td class="r">'||datatype_string||'</td>'||CHR(10)
	|| '<td class="r">'||peeked_value||'</td>'||CHR(10)
	|| '<td class="r">'||captured_value||'</td>'||CHR(10)
	|| '<td class="r">'||last_captured||'</td>'||CHR(10)
from
(with peeked as
(
  SELECT /*+ materialize */ inst_id, sql_id, plan_hash_value, address, child_address, child_number, timestamp,
         to_number(extractValue(value(d), '/bind/@pos')) position,
         extractValue(value(d), '/bind/@nam') name,
         extractValue(value(d), '/bind') value,
         to_number(extractValue(value(d), '/bind/@ppo')) dup_pos,
         extractValue(value(d), '/bind/@dty') dtype,
         to_number(extractValue(value(d), '/bind/@mxl')) max_length
    FROM
         gv$sql_plan c
         , TABLE(XMLSEQUENCE(EXTRACT(XMLTYPE(c.other_xml ), '/*/peeked_binds/bind'))) D
   where c.sql_id = :sql_id
    and c.other_xml is not null
  -- order by sql_id, to_number(EXTRACTVALUE(VALUE(D), '/bind/@pos'))
)
,
peeked_val as
(
  select peeked.*,
         (case when dtype = 1 then 'VARCHAR2'
               when dtype = 2 then 'NUMBER'
               when dtype = 12 then 'Date'
               when dtype in (180, 181) then 'TIMESTAMP'
          end
         ) datatype_string,
         case
           when dtype = 1  -- VARCHAR2
             then to_char(utl_raw.cast_to_varchar2(value))
           when dtype = 2  -- NUMBER
             then to_char(utl_raw.cast_to_number(value))
           when dtype = 12 -- Date
             then rtrim(
                    to_char(100*(to_number(substr(value,1,2),'XX')-100)
                           + (to_number(substr(value,3,2),'XX')-100),'fm0000')||'-'||
                    to_char(to_number(substr(value,5,2),'XX'),'fm00')||'-'||
                    to_char(to_number(substr(value,7,2),'XX'),'fm00')||' '||
                    to_char(to_number(substr(value,9,2),'XX')-1,'fm00')||':'||
                    to_char(to_number(substr(value,11,2),'XX')-1,'fm00')||':'||
                    to_char(to_number(substr(value,13,2),'XX')-1,'fm00'))
           when dtype in (180, 181)  -- Timestamp and Timestamp with tz
             then rtrim(
                    to_char(100*(to_number(substr(value,1,2),'XX')-100)
                            + (to_number(substr(value,3,2),'XX')-100),'fm0000')||'-'||
                    to_char(to_number(substr(value,5,2),'XX'),'fm00')||'-'||
                    to_char(to_number(substr(value,7,2),'XX'),'fm00')||' '||
                    to_char(to_number(substr(value,9,2),'XX')-1,'fm00')||':'||
                    to_char(to_number(substr(value,11,2),'XX')-1,'fm00')||':'||
                    to_char(to_number(substr(value,13,2),'XX')-1,'fm00')
                    ||'.'||to_number(substr(value,15,8),'XXXXXXXX')  )
           else
              value
         end cvalue
    from peeked
   -- order by position
)
,
captured_binds as
(
  SELECT s.inst_id, s.sql_id, s.plan_hash_value, s.CHILD_ADDRESS, s.CHILD_NUMBER, s.address
         , s.first_load_time, s.last_active_time, s.executions, s.buffer_gets
         , round(s.elapsed_time/1000000/decode(s.executions, 0, 1, s.executions), 3) avg_et
         , round(s.buffer_gets/decode(s.executions, 0, 1, s.executions)) avg_bg
         , b.position, b.name
         , case when b.datatype_string like 'TIMESTAM%' then
                  substr(anydata.accesstimestamp(b.value_anydata),1,50)
                else b.value_string
           end captured_value
         , b.datatype_string
         , b.LAST_CAPTURED
    FROM gv$sql s, gv$sql_bind_capture b
   WHERE s.sql_id = :sql_id
     and b.inst_id = s.inst_id
     and b.sql_id  = s.sql_id
     and b.address = s.address
     and b.child_address = s.child_address
     and b.child_number = s.child_number
   -- ORDER BY inst_id, child_number, position, dup_position
)
select pv.inst_id, pv.plan_hash_value, pv.child_number ch#, to_char(pv.timestamp, 'yyyy-mm-dd hh24:mi:ss') plan_gen_ts, cb.avg_et, cb.avg_bg
       , pv.position, pv.name 
       -- , pv.datatype_string
       , case when cb.datatype_string is not null then cb.datatype_string else pv.datatype_string end datatype_string
       , case when (cb.datatype_string like 'VARCHAR%' and :pii_used>0) then substr(pv.cvalue,1,length(pv.cvalue)/3+1)||rpad('***********************************', length(pv.cvalue)*2/3)
         else pv.cvalue 
         end peeked_value  
       , case when (cb.datatype_string like 'VARCHAR%' and :pii_used>0) then substr(cb.captured_value,1,length(cb.captured_value)/3+1)||rpad('***********************************', length(cb.captured_value)*2/3)
         else cb.captured_value 
         end captured_value
       -- , cb.last_captured
       , to_char(cb.last_captured, 'yyyy-mm-dd hh24:mi:ss') last_captured
  from peeked_val pv, captured_binds cb
 where 1 = 1
   and cb.inst_id = pv.inst_id
   and cb.sql_id  = pv.sql_id
   and cb.address = pv.address
   and cb.child_address = pv.child_address
   and cb.child_number = pv.child_number
   and cb.position = pv.position
   and cb.name = pv.name
-- and last_captured < (select to_date(max(last_load_time),'yyyy-mm-dd hh24:mi:ss') from gv$sql where sql_id = '&&sql_id' and plan_hash_value = :l_plan_hash_value)
   and last_captured < (select to_date(last_load_time,'yyyy-mm-dd hh24:mi:ss') from gv$sql where sql_id = :sql_id and plan_hash_value = :l_plan_hash_value order by last_load_time desc FETCH FIRST 1 ROW ONLY)
 order by pv.timestamp, pv.plan_hash_value, pv.child_number, to_number(pv.position))
;

pro <tr>
pro <th>Instance #</th>
pro <th>Plan Hash Value</th>
pro <th>Ch#</th>
pro <th>Plan Gen Ttmestamp</th>
pro <th>Avg Elapsed Time</th>
pro <th>Avg Buffer Gets</th>
pro <th>Position</th>
pro <th>Bind Name</th>
pro <th>Data Type</th>
pro <th>Peeked Bind Value</th>
pro <th>Captured Bind Value</th>
pro <th>Last Captured Date</th>
pro </tr>

pro </tbody>
pro  </table>

-- END OF BINDS : Peeked Vs Captured Bind Values - In Memory
select round((sysdate-to_date(:start_time,'dd-mon-rr hh24:mi:ss'))*86400) diff from dual;
PRO <table style="width:100%"><tr><td style="text-align:right; background-color:#ffffff">Time taken: ^^diff. seconds</td></tr></table>
exec :start_time := to_char(sysdate,'dd-mon-rr hh24:mi:ss');

-- START OF BINDS : Peeked Vs Captured Bind Values - In AWR 
PRO <br/><summary id="summary3">Peeked Vs Captured Bind Values - In AWR </summary>

pro <table>
pro <tbody><tr>
pro <th>Instance #</th>
pro <th>Snap ID</th>
pro <th>End Interval Time</th>
pro <th>Plan Hash Value</th>
pro <th>Plan Gen Timestamp</th>
pro <th>Avg Elapsed Time</th>
pro <th>Avg Buffer Gets</th>
pro <th>Position</th>
pro <th>Bind Name</th>
pro <th>Peeked Bind Value</th>
pro <th>Captured Bind Value</th>
pro <th>Last Captured Date</th>
pro </tr>

SELECT  CHR(10)||'<tr>'||CHR(10) 
	|| '<td class="r">'||instance_number||'</td>'||CHR(10)
	|| '<td class="r">'||snap_id||'</td>'||CHR(10)
	|| '<td class="r">'||end_interval_time||'</td>'||CHR(10)
	|| '<td class="r">'||plan_hash_value||'</td>'||CHR(10)
	|| '<td class="r">'||plan_gen_ts||'</td>'||CHR(10)
	|| '<td class="r">'||avg_et||'</td>'||CHR(10)
	|| '<td class="r">'||avg_bg||'</td>'||CHR(10)
	|| '<td class="r">'||position||'</td>'||CHR(10)
	|| '<td class="r">'||name||'</td>'||CHR(10)
	|| '<td class="r">'||peeked_value||'</td>'||CHR(10)
	|| '<td class="r">'||captured_value||'</td>'||CHR(10)
	|| '<td class="r">'||last_captured||'</td>'||CHR(10)
from
(with peeked as
(
  SELECT /*+ materialize */ sql_id, plan_hash_value, timestamp,
         to_number(extractValue(value(d), '/bind/@pos')) position,
         extractValue(value(d), '/bind/@nam') name,
         extractValue(value(d), '/bind') value,
         to_number(extractValue(value(d), '/bind/@ppo')) dup_pos,
         extractValue(value(d), '/bind/@dty') dtype,
         to_number(extractValue(value(d), '/bind/@mxl')) max_length
    FROM
         dba_hist_sql_plan c
         , TABLE(XMLSEQUENCE(EXTRACT(XMLTYPE(c.other_xml ), '/*/peeked_binds/bind'))) D
   where 1=1
     and :license IN ('T', 'D', 'L')
     and c.dbid = ^^dbid.
     and c.sql_id = :sql_id
    and c.other_xml is not null
  -- order by sql_id, to_number(EXTRACTVALUE(VALUE(D), '/bind/@pos'))
)
,
peeked_binds as 
(
  select /*+ materialize */ peeked.*,
         (case when dtype = 1 then 'VARCHAR2'
               when dtype = 2 then 'NUMBER'
               when dtype = 12 then 'Date'
               when dtype in (180, 181) then 'TIMESTAMP'
          end
         ) datatype_string, 
         case 
           when dtype = 1  -- VARCHAR2
             then to_char(utl_raw.cast_to_varchar2(value))    
           when dtype = 2  -- NUMBER
             then to_char(utl_raw.cast_to_number(value))
           when dtype = 12 -- Date
             then rtrim(
                    to_char(100*(to_number(substr(value,1,2),'XX')-100)
                           + (to_number(substr(value,3,2),'XX')-100),'fm0000')||'-'||
                    to_char(to_number(substr(value,5,2),'XX'),'fm00')||'-'||
                    to_char(to_number(substr(value,7,2),'XX'),'fm00')||' '||
                    to_char(to_number(substr(value,9,2),'XX')-1,'fm00')||':'||
                    to_char(to_number(substr(value,11,2),'XX')-1,'fm00')||':'||
                    to_char(to_number(substr(value,13,2),'XX')-1,'fm00'))
           when dtype in (180, 181)  -- Timestamp and Timestamp with tz
             then rtrim(
                    to_char(100*(to_number(substr(value,1,2),'XX')-100)
                            + (to_number(substr(value,3,2),'XX')-100),'fm0000')||'-'||
                    to_char(to_number(substr(value,5,2),'XX'),'fm00')||'-'||
                    to_char(to_number(substr(value,7,2),'XX'),'fm00')||' '||
                    to_char(to_number(substr(value,9,2),'XX')-1,'fm00')||':'||
                    to_char(to_number(substr(value,11,2),'XX')-1,'fm00')||':'||
                    to_char(to_number(substr(value,13,2),'XX')-1,'fm00')
                    ||'.'||to_number(substr(value,15,8),'XXXXXXXX')  )
           else
              value
         end cvalue
    from peeked
   -- order by position
)
,
captured_binds as
(
  select /*+ materialize */ s.dbid, s.instance_number, s.snap_id, s.sql_id, s.plan_hash_value, s.executions_delta, s.buffer_gets_delta,
         round(s.elapsed_time_delta/1000000/decode(s.executions_delta, 0, 1, s.executions_delta), 3) avg_et,
         round(s.buffer_gets_delta/decode(s.executions_delta, 0, 1, s.executions_delta)) avg_bg
         , b.position
         -- , bm.name -- PSRv7 - moved to main select to improve performance
         , case when b.datatype_string like 'TIMESTAM%' then substr(anydata.accesstimestamp(b.value_anydata),1,50) 
                when (b.datatype_string like 'VARCHAR%' and :pii_used>0) then substr(b.value_string,1,length(b.value_string)/3+1)||rpad('***********************************', length(b.value_string)*2/3)
           else b.value_string
           end captured_value
         , b.datatype_string
         , b.LAST_CAPTURED
         , ss.END_INTERVAL_TIME
    from dba_hist_sqlstat s, table(dbms_sqltune.extract_binds(s.bind_data)) b
         -- , dba_hist_sql_bind_metadata bm  -- PSRv7 - using only to get name, which we are already getting from peeked binds
         , dba_hist_snapshot ss
   where 1 = 1
     and (:license IN ('T', 'D') or (:license = 'L' and ss.begin_interval_time > systimestamp - interval '^^days.' day))
     and s.dbid = ^^dbid.
     and s.sql_id = :sql_id
     and s.bind_data is not null
     and s.dbid = ss.dbid
     and s.instance_number = ss.instance_number
     and s.snap_id = ss.snap_id
     and s.dbid = ss.dbid
     -- and bm.sql_id = s.sql_id      -- PSRv7
     -- AND bm.position = b.position  -- PSRv7
)
select cb.instance_number, cb.snap_id, cb.end_interval_time, pv.plan_hash_value, to_char(pv.timestamp, 'dd-mon-yy hh24:mi:ss') plan_gen_ts, cb.avg_et, cb.avg_bg, pv.position, pv.name 
       , case when cb.datatype_string is not null then cb.datatype_string else pv.datatype_string end datatype_string
       , case when (pv.datatype_string like 'VARCHAR%' and :pii_used>0) then substr(pv.cvalue,1,length(pv.cvalue)/3+1)||rpad('***********************************', length(pv.cvalue)*2/3)
         else pv.cvalue 
         end peeked_value 
       , cb.captured_value       
       , to_char(cb.last_captured, 'dd-mon-yy hh24:mi:ss') last_captured 
  from peeked_binds pv, captured_binds cb
 where 1 = 1
   and pv.plan_hash_value = cb.plan_hash_value
   and cb.position = pv.position
   and last_captured < (select to_date(last_load_time,'yyyy-mm-dd hh24:mi:ss') from gv$sql where sql_id = :sql_id and plan_hash_value = :l_plan_hash_value order by last_load_time desc FETCH FIRST 1 ROW ONLY)
 order by cb.snap_id desc, pv.plan_hash_value, cb.instance_number, pv.timestamp, to_number(pv.position))
 where rownum < 501;   /* added on 11/6/20 since this was fetching lots of rows with file size > 150MB */

-- order by pv.plan_hash_value, cb.instance_number, cb.snap_id, pv.timestamp, to_number(pv.position)); /* old order by */

pro <tr>
pro <th>Instance #</th>
pro <th>Snap ID</th>
pro <th>End Interval Time</th>
pro <th>Plan Hash Value</th>
pro <th>Plan Gen Timestamp</th>
pro <th>Avg Elapsed Time</th>
pro <th>Avg Buffer Gets</th>
pro <th>Position</th>
pro <th>Bind Name</th>
pro <th>Peeked Bind Value</th>
pro <th>Captured Bind Value</th>
pro <th>Last Captured Date</th>
pro </tr>

pro </tbody>
pro </table>

-- END OF BINDS : Peeked Vs Captured Bind Values - In AWR 

select round((sysdate-to_date(:start_time,'dd-mon-rr hh24:mi:ss'))*86400) diff from dual;
PRO <table style="width:100%"><tr><td style="text-align:right; background-color:#ffffff">Time taken: ^^diff. seconds</td></tr></table>
PRO </details>
exec :start_time := to_char(sysdate,'dd-mon-rr hh24:mi:ss');

-- END OF SQL Statistics based on Last Hard Parse Time 




/* -------------------------
 *
 * SQL Plan Directives -- PSRv10
 * Uday
 * ------------------------- */
REM EXEC DBMS_SPD.FLUSH_SQL_PLAN_DIRECTIVE;

PRO
PRO <a name="spd"></a><details><br/><summary id="summary2">SQL Plan Directives</summary>
PRO
PRO SQL Plan Directives on objects used in ^^sql_id. order by LAST_USED desc 
PRO
PRO <table>
PRO <tr><td>Commented Out for now</td></tr>
/*
PRO <table>
PRO
PRO <tr>
PRO <th>#</th>
PRO <th>Owner</th>
PRO <th>ObjTyp</th>
PRO <th>Object Name</th>
PRO <th>SubObject<br>Name</th>
PRO <th>DirectiveID</th>
PRO <th>Created</th>
PRO <th>Last Modified</th>
PRO <th>Last Used</th>
PRO <th>Auto<br>Drop?</th>
PRO <th>Enabled?</th>
PRO <th>Type</th>
PRO <th>State</th>
PRO <th>Reason</th>
PRO <th>SPD Text</th>
PRO <th>Internal<br>State</th>
PRO <th>Redundant?</th>
PRO </tr>
PRO
SELECT '<!-- '||TO_CHAR(SYSDATE, 'YYYY-MM-DD/HH24:MI:SS')||' -->' FROM dual;
PRO <!-- Please Wait -->

SELECT CHR(10)||'<tr>'||CHR(10)||
       '<td class="r">'||ROWNUM    ||'</td>'||CHR(10)||
       '<td >'||object_owner       ||'</td>'||CHR(10)||
       '<td >'||object_type        ||'</td>'||CHR(10)||
       '<td >'||object_name        ||'</td>'||CHR(10)||
       '<td >'||subobject_name     ||'</td>'||CHR(10)||
       '<td >'||DIRECTIVE_ID       ||'</td>'||CHR(10)||
       '<td >'||CREATED            ||'</td>'||CHR(10)||
       '<td >'||LAST_MODIFIED      ||'</td>'||CHR(10)||
       '<td >'||LAST_USED          ||'</td>'||CHR(10)||
       '<td >'||auto_drop          ||'</td>'||CHR(10)||
       '<td >'||enabled            ||'</td>'||CHR(10)||
       '<td >'||TYPE               ||'</td>'||CHR(10)||
       '<td >'||state              ||'</td>'||CHR(10)||
       '<td >'||reason             ||'</td>'||CHR(10)||
       '<td >'||spd_text           ||'</td>'||CHR(10)||
       '<td >'||internal_state     ||'</td>'||CHR(10)||
       '<td >'||redundant          ||'</td>'||CHR(10)||
       '</tr>'
  FROM (
         SELECT /*+ ORDERED  leading(t) cardinality(t 1) * / 
                t.object_owner, t.object_type, t.object_name, spdo.subobject_name,
                spd.DIRECTIVE_ID,
                spd.CREATED, spd.LAST_MODIFIED, spd.LAST_USED, spd.auto_drop,
                spd.enabled,
                spd.TYPE, spd.state, spd.reason,
                extract(spd.notes, '/spd_note/spd_text/text()' )       spd_text,
                extract(spd.notes, '/spd_note/internal_state/text()' ) internal_state,
                extract(spd.notes, '/spd_note/redundant/text()')       redundant 
           FROM plan_table t,
                dba_sql_plan_dir_objects spdo,
                dba_sql_plan_directives spd
          WHERE t.object_name is not null and t.object_owner is not null
            AND spdo.owner = t.object_owner
            AND spdo.object_name = t.object_name
            AND spd.directive_id = spdo.directive_id
            AND STATEMENT_ID = :sql_id
          ORDER BY spd.last_used desc, t.object_owner, t.object_name
       ) v
;

PRO
PRO <tr>
PRO <th>#</th>
PRO <th>Owner</th>
PRO <th>ObjTyp</th>
PRO <th>Object Name</th>
PRO <th>SubObject<br>Name</th>
PRO <th>DirectiveID</th>
PRO <th>Created</th>
PRO <th>Last Modified</th>
PRO <th>Last Used</th>
PRO <th>Auto<br>Drop?</th>
PRO <th>Enabled?</th>
PRO <th>Type</th>
PRO <th>State</th>
PRO <th>Reason</th>
PRO <th>SPD Text</th>
PRO <th>Internal<br>State</th>
PRO <th>Redundant?</th>
PRO </tr>
PRO
PRO <b>SPD Text Notation:</b><pre> E:equality_predicates_only, C:simple_column_predicates_only, J:index_access_by_join_predicates, F:filter_on_joining_object</pre>
*/
PRO </table>

select round((sysdate-to_date(:start_time,'dd-mon-rr hh24:mi:ss'))*86400) diff from dual;
PRO <table style="width:100%"><tr><td style="text-align:right; background-color:#ffffff">Time taken: ^^diff. seconds</td></tr></table>
PRO </details><!--Pushkar-->
exec :start_time := to_char(sysdate,'dd-mon-rr hh24:mi:ss');
PRO

/* -------------------------
 *
 * SQL Object Dependency
 * Uday: PSRv10
 * ------------------------- */
PRO
PRO <a name="sql_obj_dependency"></a><details open><br/><summary id="summary2">SQL Object Dependency (GV$OBJECT_DEPENDENCY)</summary>
PRO
PRO Objects accessed by the SQL ^^sql_id.. Displayed only if SQL is in memory.
PRO For Views and Synonyms, dependecy hierarchy extracted from DBA_DEPENDENCIES is in the next section.
PRO
PRO <table>
PRO
PRO <tr>
PRO <th>#</th>
PRO <th>Owner</th>
PRO <th>Object Name</th>
PRO <th>object_type</th>
PRO </tr>
PRO
SELECT '<!-- '||TO_CHAR(SYSDATE, 'YYYY-MM-DD/HH24:MI:SS')||' -->' FROM dual;
PRO <!-- Please Wait -->

SELECT CHR(10)||'<tr>'||CHR(10)||
       '<td class="r">'||ROWNUM||'</td>'||CHR(10)||
       '<td >'||v.to_owner||'</td>'||CHR(10)||
       case when v.type <> 'VIEW' THEN '<td class="r">'||v.to_name||'</td>'
            when v.type =  'VIEW' THEN '<td class="r">'||q'{<a href="#}'||v.to_owner||'.'||v.to_name||q'{">}'||v.to_name||'</a></td>'
       END ||CHR(10)||
       '<td class="r">'||v.type||'</td>'||CHR(10)||
       '</tr>'
  FROM (
        SELECT /*+ NO_MERGE */ DISTINCT to_owner, to_name, to_type,
               decode(to_type, 
                       0,'CURSOR',
                       1,'INDEX',
                       2,'TABLE', 
                       3,'CLUSTER',
                       4,'VIEW', 
                       5,'SYNONYM',
                       6,'SEQUENCE',
                       7,'PROCEDURE',
                       8,'FUNCTION',
                       9,'PACKAGE',
                       10,'NON-EXISTENT',
                       11,'PACKAGE BODY',
                       12,'TRIGGER',
                       13,'TYPE',
                       14,'TYPE BODY', 
                       15,'OBJECT',
                       16,'USER',
                       17,'DBLINK',
                       18,'PIPE',
                       19,'TABLE PARTITION', 
                       20,'INDEX PARTITION',
                       21,'LOB',
                       22,'LIBRARY',
                       23,'DIRECTORY',
                       24,'QUEUE', 
                       25,'INDEX-ORGANIZED TABLE',
                       26,'REPLICATION OBJECT GROUP',
                       27,'REPLICATION PROPAGATOR', 
                       28,'JAVA SOURCE',
                       29,'JAVA CLASS',
                       30,'JAVA RESOURCE',
                       31,'JAVA JAR',
                       32,'INDEX TYPE',
                       33,'OPERATOR',
                       34,'TABLE SUBPARTITION',
                       35,'INDEX SUBPARTITION', 
                       36,'REPLICATED TABLE OBJECT',
                       37,'REPLICATION INTERNAL PACKAGE', 
                       38,'CONTEXT POLICY',
                       39,'PUB_SUB',
                       40,'LOB PARTITION',
                       41,'LOB SUBPARTITION',
                       42,'SUMMARY',
                       43,'DIMENSION',
                       44,'APP CONTEXT',
                       45,'STORED OUTLINE',
                       46,'RULESET', 
                       47,'RSRC PLAN',
                       48,'RSRC CONSUMER GROUP',
                       49,'PENDING RSRC PLAN', 
                       50,'PENDING RSRC CONSUMER GROUP',
                       51,'SUBSCRIPTION',
                       52,'LOCATION', 
                       53,'REMOTE OBJECT', 
                       54,'SNAPSHOT METADATA',
                       55,'XDB', 
                       56,'JAVA SHARED DATA',
                       57,'SECURITY PROFILE',
                       'UNDEFINED/INVALID'
                     ) type
          FROM gv$object_dependency
         WHERE 1=1
           and :license IN ('T', 'D') -- NOT available in LITE mode
           -- and to_owner <> 'SYS'
           and (inst_id, from_address, from_hash) IN
               (SELECT inst_id, address, hash_value
                  FROM gv$sql
                 WHERE sql_id = :sql_id
                   AND inst_id IN (SELECT inst_id FROM gv$instance)
               )
         order by to_type desc, to_owner, to_name
       ) v
;

PRO
PRO <tr>
PRO <th>#</th>
PRO <th>Owner</th>
PRO <th>Object Name</th>
PRO <th>object_type</th>
PRO </tr>
PRO
PRO </table>

select round((sysdate-to_date(:start_time,'dd-mon-rr hh24:mi:ss'))*86400) diff from dual;
PRO <table style="width:100%"><tr><td style="text-align:right; background-color:#ffffff">Time taken: ^^diff. seconds</td></tr></table>
PRO </details><!--Pushkar-->
exec :start_time := to_char(sysdate,'dd-mon-rr hh24:mi:ss');

/* -------------------------
 *
 * Views/Synonyms Dependency
 * Uday: PSRv10
 * ------------------------- */
PRO
PRO <a name="sql_views_dependency"></a><details open><br/><summary id="summary2">View/Synonym Dependency Hierarchy (GV$OBJECT_DEPENDENCY/DBA_DEPENDENCIES)</summary>
PRO
PRO Dependecy hierarchy of Views & Synonyms accessed by the SQL ^^sql_id.. 
PRO
PRO <table>
PRO
PRO <tr>
PRO <th>#</th>
PRO <th>Name</th>
PRO <th>Type</th>
PRO <th>Depth</th>
PRO <th>Tree</th>
PRO <th>Dependent Object Name</th>
PRO <th>Dependent Type</th>
PRO <th>IsCycle</th>
PRO <th>Path</th>
PRO </tr>
PRO
SELECT '<!-- '||TO_CHAR(SYSDATE, 'YYYY-MM-DD/HH24:MI:SS')||' -->' FROM dual;
PRO <!-- Please Wait -->

-- PARENT_NAME	TYPE	DEPTH	TREE	REFNAME	REFTYPE	ISCYCLE	PATH
SELECT CHR(10)||'<tr>'||CHR(10)||
       '<td class="r">'||ROWNUM||'</td>'||CHR(10)||
       '<td >'||v.PARENT_NAME||'</td>'||CHR(10)||
       '<td class="r">'||v.TYPE||'</td>'||CHR(10)||
       '<td class="r">'||v.DEPTH||'</td>'||CHR(10)||
       '<td >'||v.TREE||'</td>'||CHR(10)||
       '<td class="r">'||v.REFNAME||'</td>'||CHR(10)||
       '<td class="r">'||v.REFTYPE||'</td>'||CHR(10)||
       '<td class="r">'||v.ISCYCLE||'</td>'||CHR(10)||
       '<td >'||v.PATH||'</td>'||CHR(10)||
       '</tr>'
  FROM (
        select /*+ no_merge */ connect_by_root name parent_name, type, LEVEL-1 depth, 
                -- case when (connect_by_root name = dep.name) 
                --      then '.'
                --      else RPAD('.', (level-1)*2, '.') ||dep.name 
                -- end tree, 
                RPAD('.', (level-1)*2, '.') ||dep.name tree,
                referenced_name refname, referenced_type reftype, 
                CONNECT_BY_ISCYCLE iscycle,
                LPAD(' ', 2*level-1)||SYS_CONNECT_BY_PATH(name, ' / ') ||'/'||referenced_name||'('||referenced_type||')' Path
           FROM dba_dependencies dep
          WHERE 1=1
          start with 1=1
            and owner = 'FUSION'
            and name in (select distinct to_name 
                           from gv$object_dependency 
                          where (inst_id, from_address, from_hash) in 
                                 (select inst_id, address, hash_value 
                                    from gv$sql 
                                   where sql_id = :sql_id 
                                     AND inst_id IN (SELECT inst_id FROM gv$instance)
                                 )
                            and to_type in (4,5) /* views,synonym */
                        )
            and type <> 'PACKAGE BODY'
          connect by NOCYCLE prior referenced_name = name
                 and prior referenced_owner = owner
                 and owner not in ('FUSION_RO','FUSION_ERO') 
                 and prior referenced_type not like 'PACKAGE%'
                 and type not like 'PACKAGE%'
                 and type <> 'NON-EXISTENT'
        ORDER SIBLINGS BY dep.name, reftype, refname desc
       ) v
       where :license IN ('T', 'D') -- NOT available in LITE mode
;

PRO
PRO <tr>
PRO <th>#</th>
PRO <th>Name</th>
PRO <th>Type</th>
PRO <th>Depth</th>
PRO <th>Tree</th>
PRO <th>Dependent Object Name</th>
PRO <th>Dependent Type</th>
PRO <th>IsCycle</th>
PRO <th>Path</th>
PRO </tr>
PRO
PRO </table>

select round((sysdate-to_date(:start_time,'dd-mon-rr hh24:mi:ss'))*86400) diff from dual;
PRO <table style="width:100%"><tr><td style="text-align:right; background-color:#ffffff">Time taken: ^^diff. seconds</td></tr></table>
PRO </details><!--Pushkar-->
exec :start_time := to_char(sysdate,'dd-mon-rr hh24:mi:ss');
/* -------------------------
 *
 * Plan Control Hints -- PSRv10
 * Uday
 * ------------------------- */
PRO <a name="planControlHints"></a><details open><br/><summary id="summary2">Plan Control Hints</summary>
PRO SQL Patches/Profiles/Baselines Hints

SELECT '<!-- '||TO_CHAR(SYSDATE, 'YYYY-MM-DD/HH24:MI:SS')||' -->' FROM dual;
PRO <!-- Please Wait -->

with hints as (
SELECT /*+ materialize */ decode(od.obj_type, 1, 'SQL Profile', 2, 'SQL Plan Baseline', 3, 'SQL Patch') Type, so.name, extractValue(value(h),'.') AS hint
  FROM sys.sqlobj$data od, 
       sys.sqlobj$ so,
       table(xmlsequence(extract(xmltype(od.comp_data),'/outline_data/*'))) h
 WHERE so.signature = :signaturef
   AND so.signature = od.signature
   AND so.category = od.category
   AND so.obj_type = od.obj_type
   AND so.plan_id = od.plan_id
-- ORDER BY type, name
)
-- select chr(10) || chr(10) || 'SQL Patch: ' || name || chr(10) || chr(10) 
select chr(10) || chr(10) || q'{<a name="}' || name || q'{"></a>}' ||'<details open><br/><summary id="summary3">SQL Patch: '|| name ||'</summary>'|| chr(10) || chr(10)
  from hints
 where type = 'SQL Patch'
   and rownum=1 
union all
select '<pre>' from hints
 where type = 'SQL Patch'
   and rownum=1 
union all
select chr(9)||hint
  from hints
 where type = 'SQL Patch'
union all
select '</pre></details>' from hints
 where type = 'SQL Patch'
   and rownum=1 
union all
-- select chr(10) || chr(10) || 'SQL Profile: ' || name || chr(10) || chr(10) 
select chr(10) || chr(10) || q'{<a name="}' || name || q'{"></a>}' ||'<details open><br/><summary id="summary3">SQL Profile: '|| name ||'</summary>'|| chr(10) || chr(10)
  from hints
 where type = 'SQL Profile'
   and rownum=1 
union all
select '<pre>' from hints
 where type = 'SQL Profile'
   and rownum=1 
union all
select chr(9)||hint
  from hints
 where type = 'SQL Profile'
union all
select '</pre></details>' from hints
 where type = 'SQL Profile'
   and rownum=1 
union all
-- select chr(10) || chr(10) || 'SQL Plan Baseline: ' || name || chr(10) || chr(10) 
select chr(10) || chr(10) || q'{<a name="}' || name || q'{"></a>}' ||'<details open><br/><summary id="summary3">SQL Plan Baseline: '|| name ||'</summary>'|| chr(10) || chr(10)
  from hints
 where type = 'SQL Plan Baseline'
   and rownum=1 
union all
select '<pre>' from hints
 where type = 'SQL Plan Baseline'
   and rownum=1 
union all
select chr(9)||hint
  from hints
 where type = 'SQL Plan Baseline'
union all
select '</pre></details>' from hints
 where type = 'SQL Plan Baseline'
   and rownum=1 
;

select round((sysdate-to_date(:start_time,'dd-mon-rr hh24:mi:ss'))*86400) diff from dual;
PRO <table style="width:100%"><tr><td style="text-align:right; background-color:#ffffff">Time taken: ^^diff. seconds</td></tr></table>
PRO </details><!--Pushkar-->
exec :start_time := to_char(sysdate,'dd-mon-rr hh24:mi:ss');


/* -------------------------
 *
 * Metadata
 *
 * ------------------------- */
PRO <a name="metadata"></a><details><br/><summary id="summary2">Metadata</summary>
-- PRO Table and Index Metadata of the objects involved in the plan and their dependent objects
PRO Index and View Metadata of the objects involved in the plan and their dependent objects
PRO
SELECT '<!-- '||TO_CHAR(SYSDATE, 'YYYY-MM-DD/HH24:MI:SS')||' -->' FROM dual;
PRO <!-- Please Wait -->
--PSRv10: compact index definitions
PRO <a name="index_metadata"></a><details><br/><summary id="summary3">Indexes Metadata</summary>
PRO
PRO <pre>
SET long 10000000 longchunksize 10000000

exec dbms_metadata.set_transform_param( dbms_metadata.session_transform, 'STORAGE', FALSE);
exec dbms_metadata.set_transform_param( dbms_metadata.session_transform, 'SEGMENT_ATTRIBUTES', false );
exec dbms_metadata.set_transform_param( dbms_metadata.session_transform, 'SQLTERMINATOR', FALSE);
exec dbms_metadata.set_transform_param( dbms_metadata.session_transform, 'TABLESPACE', FALSE);

--
-- tables: FA tables are too long so not fetching tables metadata
--
--psrv10 WITH object AS (
--psrv10 SELECT /*+ MATERIALIZE */
--psrv10        object_owner owner, object_name name
--psrv10   FROM gv$sql_plan
--psrv10  WHERE inst_id IN (SELECT inst_id FROM gv$instance)
--psrv10    AND sql_id = :sql_id
--psrv10    AND object_owner IS NOT NULL
--psrv10    AND object_name IS NOT NULL
--psrv10    AND 1=2  --uday: disabling for Fusion Apps as tables are very long
--psrv10  UNION
--psrv10 SELECT object_owner owner, object_name name
--psrv10   FROM dba_hist_sql_plan
--psrv10  WHERE :license IN ('T', 'D')
--psrv10    AND dbid = ^^dbid.
--psrv10    AND sql_id = :sql_id
--psrv10    AND object_owner IS NOT NULL
--psrv10    AND object_name IS NOT NULL
--psrv10    AND 1=2  --uday: disabling for Fusion Apps as tables are very long
--psrv10  )
--psrv10  SELECT '<br/><summary id="summary3">Table: '||t.object_owner||'.'||t.object_name||'</summary>'||REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(DBMS_METADATA.GET_DDL('TABLE',t.object_name,t.object_owner), '<', CHR(38)||'lt;'), '>', CHR(38)||'gt;'), '''', CHR(38)||'#39;'), '"', CHR(38)||'quot;'), CHR(10), '<br>'||CHR(10))
--psrv10    FROM (SELECT t.owner object_owner, t.table_name object_name
--psrv10            FROM dba_tables t, -- include fixed objects
--psrv10                 object o
--psrv10           WHERE t.owner = o.owner
--psrv10             AND t.table_name = o.name
--psrv10           UNION
--psrv10          SELECT i.table_owner object_owner, i.table_name object_name
--psrv10            FROM dba_indexes i,
--psrv10                 object o
--psrv10           WHERE i.owner = o.owner
--psrv10             AND i.index_name = o.name) t;
			
WITH object AS (
SELECT /*+ MATERIALIZE */
       object_owner owner, object_name name, object_type
  FROM gv$sql_plan
 WHERE inst_id IN (SELECT inst_id FROM gv$instance)
   AND sql_id = :sql_id
   AND object_owner IS NOT NULL
   AND object_name IS NOT NULL
   AND not (object_type = 'TABLE (TEMP)' and object_name like 'SYS_TEMP%') --Uday.v6
 UNION
SELECT object_owner owner, object_name name, object_type
  FROM dba_hist_sql_plan
 WHERE :license IN ('T', 'D', 'L')
   AND dbid = ^^dbid.
   AND sql_id = :sql_id
   AND object_owner IS NOT NULL
   AND object_name IS NOT NULL
   AND not (object_type = 'TABLE (TEMP)' and object_name like 'SYS_TEMP%') --Uday.v6
 )
, plan_tables AS (
--UdayRemoved.v6 SELECT /*+ MATERIALIZE */
--UdayRemoved.v6        'TABLE' object_type, t.owner object_owner, t.table_name object_name
--UdayRemoved.v6   FROM dba_tables t, -- include fixed objects
--UdayRemoved.v6        object o
--UdayRemoved.v6  WHERE t.owner = o.owner
--UdayRemoved.v6    AND t.table_name = o.name
 SELECT /*+ MATERIALIZE */
        object_type, o.owner object_owner, o.name object_name
   FROM object o
  WHERE (o.object_type like 'TABLE%' OR o.object_type = 'VIEW')
  UNION
 SELECT 'TABLE' object_type, i.table_owner object_owner, i.table_name object_name
   FROM dba_indexes i,
        object o
  WHERE o.object_type like 'INDEX%'  --Uday.v6
    AND i.owner = o.owner
    AND i.index_name = o.name
  UNION
 SELECT /*+ leading (o) */ 'TABLE' object_type, t.owner object_owner, t.table_name object_name
   FROM dba_tables t,
        object o
  WHERE t.owner = o.owner
    AND t.table_name = o.name
    AND o.object_type IS NULL /* PUSHKAR 10.8: this helps in insert statement analysis */     
)
--PSRv10 SELECT '<br/><summary id="summary3">Index: '||s.owner||'.'||s.index_name||'</summary>'||REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(DBMS_METADATA.GET_DDL('INDEX',s.index_name,s.owner), '<', CHR(38)||'lt;'), '>', CHR(38)||'gt;'), '''', CHR(38)||'#39;'), '"', CHR(38)||'quot;'), CHR(10), '<br>'||CHR(10))
SELECT REPLACE(REPLACE(REPLACE(REPLACE(DBMS_METADATA.GET_DDL('INDEX',s.index_name,s.owner), '<', CHR(38)||'lt;'), '>', CHR(38)||'gt;'), '''', CHR(38)||'#39;'), '"', CHR(38)||'quot;')
  FROM plan_tables pt,
       dba_indexes s
 WHERE pt.object_type = 'TABLE'
   AND pt.object_owner = s.table_owner
   AND pt.object_name = s.table_name
   AND s.index_type not like 'LOB%' --Uday.v6
 ORDER BY
       s.table_name,
       s.table_owner,
       s.index_name,
       s.owner;
PRO </pre>

select round((sysdate-to_date(:start_time,'dd-mon-rr hh24:mi:ss'))*86400) diff from dual;
PRO <table style="width:100%"><tr><td style="text-align:right; background-color:#ffffff">Time taken: ^^diff. seconds</td></tr></table>
PRO </details><!--Pushkar-->
exec :start_time := to_char(sysdate,'dd-mon-rr hh24:mi:ss');
--
-- view metadata -- uday
--
--PSRv10: below line
col view_text for A254 wor

PRO <a name="view_metadata"></a><details><br/><summary id="summary3">View Metadata</summary>
PRO <pre>
WITH object AS (
SELECT /*+ MATERIALIZE */
       object_owner owner, object_name view_name, object_type, 'GV_SQL_PLAN' source
  FROM gv$sql_plan
 WHERE inst_id IN (SELECT inst_id FROM gv$instance)
   AND sql_id = :sql_id
   AND object_owner IS NOT NULL
   AND object_name IS NOT NULL
   AND object_type in ('VIEW','MAT_VIEW')
 UNION
SELECT object_owner owner, object_name view_name, object_type, 'DBA_HIST_SQL_PLAN' source
  FROM dba_hist_sql_plan
 WHERE :license IN ('T', 'D', 'L')
   AND dbid = ^^dbid.
   AND sql_id = :sql_id
   AND object_owner IS NOT NULL
   AND object_name IS NOT NULL
   AND object_type in ('VIEW','MAT_VIEW')
UNION
--PSRv10
SELECT to_owner owner, to_name view_name, decode(to_type,2,'MAT_VIEW',4,'VIEW'), 'OBJ_DEPENDENCY' source
  FROM gv$object_dependency
 WHERE to_owner <> 'SYS'
   and to_type IN (2, 4)-- 2.materialized view, 4=views
   and (inst_id, from_address, from_hash) IN
        (SELECT inst_id, address, hash_value
           FROM gv$sql
          WHERE inst_id IN (SELECT inst_id FROM gv$instance)
            and sql_id = :sql_id
        )
), 
views AS (
 SELECT /*+ MATERIALIZE */ distinct owner, view_name, object_type
   FROM object o
  WHERE exists (select 1 from dba_objects v where v.object_name = o.view_name and v.owner = o.owner and v.object_type like '%VIEW%')
UNION
--SELECT /*+ MATERIALIZE */ distinct d.owner, d.referenced_name
--   FROM object o, dba_dependencies d
-- where d.owner = o.owner and d.name = o.view_name and d.referenced_type = 'VIEW'
--   and not exists (select null from object od where od.owner = o.owner and od.view_name = o.view_name and od.source = 'OBJ_DEPENDENCY') -- PSRv10
        select  referenced_owner, referenced_name, referenced_type
           FROM dba_dependencies dep
          WHERE 1=1
            and referenced_type in ('VIEW', 'MATERIALIZED VIEW')
          start with 1=1
            and owner = 'FUSION'
            and name in (select view_name from object)
            and type in ('VIEW', 'MATERIALIZED VIEW')
            and referenced_type in ('VIEW', 'MATERIALIZED VIEW')
          connect by NOCYCLE prior referenced_name = name
                 and prior referenced_owner = 'FUSION'                  
                 and prior referenced_type = type
),
dviews AS (SELECT DISTINCT owner, view_name, Decode(object_type,'MATERIALIZED VIEW','MAT_VIEW',object_type) object_type FROM views)
SELECT q'{<a name="}' || s.owner||'.'||s.view_name || q'{"></a>}'
       -- ||'<br/><summary id="summary3">View: '||s.owner||'.'||s.view_name||'</summary>'||REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(DBMS_METADATA.GET_DDL('VIEW',s.view_name,s.owner), '<', CHR(38)||'lt;'), '>', CHR(38)||'gt;'), '''', CHR(38)||'#39;'), '"', CHR(38)||'quot;'), CHR(10), '<br>'||CHR(10))
       ||'<details open><br/><summary id="summary3">View: '||s.owner||'.'||s.view_name||'</summary>'||
       REPLACE(REPLACE(REPLACE(REPLACE(DBMS_METADATA.GET_DDL(case when s.object_type='VIEW' then 'VIEW' when s.object_type='MAT_VIEW' then 'MATERIALIZED_VIEW' end,s.view_name,s.owner), '<', CHR(38)||'lt;'), '>', CHR(38)||'gt;'), '''', CHR(38)||'#39;'), '"', CHR(38)||'quot;')
       ||'</details>' as view_text
  FROM dviews s
 ORDER BY
       s.owner,
       s.view_name
;
PRO </pre>

select round((sysdate-to_date(:start_time,'dd-mon-rr hh24:mi:ss'))*86400) diff from dual;
PRO <table style="width:100%"><tr><td style="text-align:right; background-color:#ffffff">Time taken: ^^diff. seconds</td></tr></table>
PRO </details><!--Pushkar-->
exec :start_time := to_char(sysdate,'dd-mon-rr hh24:mi:ss');

PRO </details> <!--Pushkar - complete metadata -->
/* -------------------------
 *
 * Index Contention / GC Buffer busy waits
 * Srini Kasam:PSR
 *
 * ------------------------- */




-- Display Index Contention summary from ASH.

/* -------------------------
 *
 * gv$active_session_history
 *
 * ------------------------- */



EXEC DBMS_APPLICATION_INFO.SET_CLIENT_INFO('^^method.: GV$ASH by Plan - ' || TO_CHAR(SYSDATE, 'YYYY-MM-DD/HH24:MI:SS'));
PRO <a name="indexcontention"></a><details open><br/><summary id="summary2">Index Contention details from Active Session History (GV$ACTIVE_SESSION_HISTORY)</summary>
PRO
PRO Snapshots counts per Plan and Wait Event for ^^sql_id..<br>
PRO This section includes data captured by AWR.
PRO
PRO <table>
PRO
PRO <tr>
PRO <th>#</th>
PRO <th>Plan<br>Hash<br>Value</th>
PRO <th>Session<br>State</th>
PRO <th>Wait<br>Class</th>
PRO <th>Event</th>
PRO <th>Phase</th>
PRO <th>Snaps<br>Count</th>
PRO <th>% PHV</th>
PRO <th>% PHV+Event</th>
PRO <th>Sampled<br>Executions</th>
PRO <th>Max PGA<br>(MB)</th>
PRO <th>Max Temp<br>(MB)</th>
PRO </tr>
PRO
SELECT '<!-- '||TO_CHAR(SYSDATE, 'YYYY-MM-DD/HH24:MI:SS')||' -->' FROM dual;
PRO <!-- Please Wait -->

SELECT CHR(10)||'<tr>'||CHR(10)||
       '<td class="r">'||ROWNUM||'</td>'||CHR(10)||
       '<td class="r">'||v.sql_plan_hash_value||'</td>'||CHR(10)||
       '<td>'||v.session_state||'</td>'||CHR(10)||
       '<td>'||v.wait_class||'</td>'||CHR(10)||
       '<td>'||v.event ||'</td>'||CHR(10)||
       '<td>'||v.phase ||'</td>'||CHR(10)||
       '<td class="r">'||v.snaps_count||'</td>'||CHR(10)||
       '<td class="r">'||v.phv_pct||'</td>'||CHR(10)||
       '<td class="r">'||v.phv_event_pct||'</td>'||CHR(10)||
       '<td class="r">'||v.sampled_execs||'</td>'||CHR(10)||
       '<td class="r">'||v.max_pga||'</td>'||CHR(10)||
       '<td class="r">'||v.max_temp||'</td>'||CHR(10)||
       '</tr>'
  FROM (
SELECT /*+ NO_MERGE */
       ash.sql_plan_hash_value,
       ash.session_state,
       ash.wait_class,
       nvl(ash.event, 'On CPU/Waiting for CPU') event
       , CASE WHEN IN_CONNECTION_MGMT     = 'Y' THEN 'CONNECTION_MGMT '     END ||
         CASE WHEN IN_PARSE               = 'Y' THEN 'PARSE '               END ||
         CASE WHEN IN_HARD_PARSE          = 'Y' THEN 'HARD_PARSE '          END ||
         CASE WHEN IN_SQL_EXECUTION       = 'Y' THEN 'SQL_EXECUTION '       END ||
         CASE WHEN IN_PLSQL_EXECUTION     = 'Y' THEN 'PLSQL_EXECUTION '     END ||
         CASE WHEN IN_PLSQL_RPC           = 'Y' THEN 'PLSQL_RPC '           END ||
         CASE WHEN IN_PLSQL_COMPILATION   = 'Y' THEN 'PLSQL_COMPILATION '   END ||
         CASE WHEN IN_JAVA_EXECUTION      = 'Y' THEN 'JAVA_EXECUTION '      END ||
         CASE WHEN IN_BIND                = 'Y' THEN 'BIND '                END ||
         CASE WHEN IN_CURSOR_CLOSE        = 'Y' THEN 'CURSOR_CLOSE '        END ||
         CASE WHEN IN_SEQUENCE_LOAD       = 'Y' THEN 'SEQUENCE_LOAD '       END phase,
       COUNT(*) snaps_count,
       round((sum(COUNT(*)) over(partition by ash.sql_plan_hash_value)/sum(COUNT(*)) over())*100, 2) phv_pct,
       ROUND((RATIO_TO_REPORT(COUNT(*)) over(partition by ash.sql_plan_hash_value))*100, 2) phv_event_pct
       , count(distinct ash.inst_id||ash.sql_exec_start) sampled_execs  
       , max(pga_allocated/1024/1024) max_pga  
       , max(temp_space_allocated/1024/1024) max_temp  
  FROM gv$active_session_history ash
 WHERE 
   ash.sql_id = :sql_id
   AND ash.event like '%buffer busy%'
 GROUP BY
       ash.sql_plan_hash_value,
       ash.session_state,
       ash.wait_class,
       nvl(ash.event, 'On CPU/Waiting for CPU') 
       , CASE WHEN IN_CONNECTION_MGMT     = 'Y' THEN 'CONNECTION_MGMT '     END ||
         CASE WHEN IN_PARSE               = 'Y' THEN 'PARSE '               END ||
         CASE WHEN IN_HARD_PARSE          = 'Y' THEN 'HARD_PARSE '          END ||
         CASE WHEN IN_SQL_EXECUTION       = 'Y' THEN 'SQL_EXECUTION '       END ||
         CASE WHEN IN_PLSQL_EXECUTION     = 'Y' THEN 'PLSQL_EXECUTION '     END ||
         CASE WHEN IN_PLSQL_RPC           = 'Y' THEN 'PLSQL_RPC '           END ||
         CASE WHEN IN_PLSQL_COMPILATION   = 'Y' THEN 'PLSQL_COMPILATION '   END ||
         CASE WHEN IN_JAVA_EXECUTION      = 'Y' THEN 'JAVA_EXECUTION '      END ||
         CASE WHEN IN_BIND                = 'Y' THEN 'BIND '                END ||
         CASE WHEN IN_CURSOR_CLOSE        = 'Y' THEN 'CURSOR_CLOSE '        END ||
         CASE WHEN IN_SEQUENCE_LOAD       = 'Y' THEN 'SEQUENCE_LOAD '       END 
 ORDER BY
       ash.sql_plan_hash_value,
       5 DESC,
       ash.session_state,
       ash.wait_class,
       event ) v;

PRO
PRO <tr>
PRO <th>#</th>
PRO <th>Plan<br>Hash<br>Value</th>
PRO <th>Session<br>State</th>
PRO <th>Wait<br>Class</th>
PRO <th>Event</th>
PRO <th>Phase</th>
PRO <th>Snaps<br>Count</th>
PRO <th>% PHV</th>
PRO <th>% PHV+Event</th>
PRO <th>Sampled<br>Executions</th>
PRO <th>Max PGA<br>(MB)</th>
PRO <th>Max Temp<br>(MB)</th>
PRO </tr>
PRO </table>

select round((sysdate-to_date(:start_time,'dd-mon-rr hh24:mi:ss'))*86400) diff from dual;
PRO <table style="width:100%"><tr><td style="text-align:right; background-color:#ffffff">Time taken: ^^diff. seconds</td></tr></table>
PRO </details><!--Srini-->
exec :start_time := to_char(sysdate,'dd-mon-rr hh24:mi:ss');


EXEC DBMS_APPLICATION_INFO.SET_CLIENT_INFO('^^method.: Indexes Contention - ' || TO_CHAR(SYSDATE, 'YYYY-MM-DD/HH24:MI:SS'));
SELECT '<!-- '||TO_CHAR(SYSDATE, 'YYYY-MM-DD/HH24:MI:SS')||' -->' FROM dual;
PRO <!-- Please Wait -->


SELECT /* ^^script..sql Indexes */
       v2.line_text
  FROM (
SELECT object_name table_name,
       object_owner owner,
       1 line_type,
       1 row_num,
       '<a name="i_'||LOWER(object_name||'_'||object_owner)||'"></a><details open><br/><summary id="summary3">Indexes: '||object_name||' ('||object_owner||')</summary>'||CHR(10)||CHR(10)||
       'CBO Statistics and relevant attributes.'||CHR(10)||CHR(10)||
       '<table>'||CHR(10)||CHR(10)||
       '<tr>'||CHR(10)||
       '<th>#</th>'||CHR(10)||
       '<th>Index Name</th>'||CHR(10)||
       '<th>Owner</th>'||CHR(10)||
       '<th>Index Type</th>'||CHR(10)||
       '<th>Part</th>'||CHR(10)||
       '<th>DoP</th>'||CHR(10)||
       '<th>Temp</th>'||CHR(10)||
       '<th>Uniqueness</th>'||CHR(10)||
       '<th>Cols</th>'||CHR(10)||
       '<th>Num<br>Rows</th>'||CHR(10)||
       '<th>Sample<br>Size</th>'||CHR(10)||
       '<th>Perc</th>'||CHR(10)||
       '<th>Last Analyzed</th>'||CHR(10)||
       '<th>Distinct<br>Keys</th>'||CHR(10)||
       '<th>Blevel</th>'||CHR(10)||
       '<th>Leaf<br>Blocks</th>'||CHR(10)||
       '<th>Avg<br>Leaf<br>Blocks<br>per Key</th>'||CHR(10)||
       '<th>Avg<br>Data<br>Blocks<br>per Key</th>'||CHR(10)||
       '<th>Clustering<br>Factor</th>'||CHR(10)||
       '<th>Global<br>Stats</th>'||CHR(10)||
       '<th>User<br>Stats</th>'||CHR(10)||
       '<th>Stat<br>Type<br>Locked</th>'||CHR(10)||
       '<th>Stale<br>Stats</th>'||CHR(10)||
   	'<th>Stats<br>Versions</th>'||CHR(10)||
   	'<th>Status</th>'||CHR(10)||
       '</tr>'||CHR(10) line_text
FROM plan_table
 WHERE object_type = 'TABLE'
   AND STATEMENT_ID = :sql_id
 UNION ALL
SELECT v.table_name,
       v.table_owner owner,
       2 line_type,
       ROWNUM row_num,
       CHR(10)||'<tr>'||CHR(10)||
       '<td class="r">'||ROWNUM||'</td>'||CHR(10)||
       '<td><a href="#ic_'||LOWER(v.index_name||'_'||v.owner)||'">'||v.index_name||'</a></td>'||CHR(10)||
       '<td>'||v.owner||'</td>'||CHR(10)||
       '<td>'||v.index_type||'</td>'||CHR(10)||
	   CASE WHEN v.partitioned = 'YES' 
	     THEN '<td class="c"><a href="#ip_'||LOWER(v.table_name||'_'||v.table_owner)||'">'||v.partitioned||'</a></td>'
		 ELSE '<td class="c">'||v.partitioned||'</td>'
	   END||CHR(10)||
       '<td class="c">'||v.degree||'</td>'||CHR(10)||
       '<td class="c">'||v.temporary||'</td>'||CHR(10)||
       '<td>'||v.uniqueness||'</td>'||CHR(10)||
       '<td class="c"><a href="#ic_'||LOWER(v.index_name||'_'||v.owner)||'">'||v.columns||'</a></td>'||CHR(10)||
       '<td class="r">'||v.num_rows||'</td>'||CHR(10)||
       '<td class="r">'||v.sample_size||'</td>'||CHR(10)||
       '<td class="r">'||v.sample_size_perc||'</td>'||CHR(10)||
       '<td nowrap>'||v.last_analyzed||'</td>'||CHR(10)||
       '<td class="r">'||v.distinct_keys||'</td>'||CHR(10)||
       '<td class="r">'||v.blevel||'</td>'||CHR(10)||
       '<td class="r">'||v.leaf_blocks||'</td>'||CHR(10)||
       '<td class="r">'||v.avg_leaf_blocks_per_key||'</td>'||CHR(10)||
       '<td class="r">'||v.avg_data_blocks_per_key||'</td>'||CHR(10)||
       '<td class="r">'||v.clustering_factor||'</td>'||CHR(10)||
       '<td class="c">'||v.global_stats||'</td>'||CHR(10)||
       '<td class="c">'||v.user_stats||'</td>'||CHR(10)||
       '<td class="c">'||v.stattype_locked||'</td>'||CHR(10)||
       '<td class="c">'||v.stale_stats||'</td>'||CHR(10)||
       '<td class="c"><a href="#i_stat_ver_'||LOWER(v.table_name||'_'||v.table_owner)||'">Versions</a></td>'||CHR(10)||
       '<td class="c">'||v.status||'</td>'||CHR(10)||
       '</tr>'||CHR(10) line_text
  FROM (
SELECT /*+ NO_MERGE LEADING(pt s i) */
       s.table_name,
       s.table_owner,
       s.index_name,
       s.owner,
       i.index_type,
       i.partitioned,
       i.degree,
       i.temporary,
       i.uniqueness,
       (SELECT COUNT(*)
          FROM dba_ind_columns c
         WHERE c.index_owner = s.owner
           AND c.index_name = s.index_name
           AND c.table_owner = s.table_owner
           AND c.table_name = s.table_name) columns,
       s.num_rows,
       s.sample_size,
       CASE WHEN s.num_rows > 0 THEN TO_CHAR(ROUND(s.sample_size * 100 / s.num_rows, 1), '99999990D0') END sample_size_perc,
       TO_CHAR(s.last_analyzed, 'YYYY-MM-DD/HH24:MI:SS') last_analyzed,
       s.distinct_keys,
       s.blevel,
       s.leaf_blocks,
       s.avg_leaf_blocks_per_key,
       s.avg_data_blocks_per_key,
       s.clustering_factor,
       s.global_stats,
       s.user_stats,
       s.stattype_locked,
       s.stale_stats,
       i.status
FROM plan_table pt,
       dba_ind_statistics s,
       dba_indexes i
 WHERE pt.object_type = 'TABLE'
   AND STATEMENT_ID = :sql_id
   AND pt.object_owner = s.table_owner
   AND pt.object_name = s.table_name
   AND s.object_type = 'INDEX'
   AND s.owner = i.owner
   AND s.index_name = i.index_name
   AND s.table_owner = i.table_owner
   AND s.table_name = i.table_name
 ORDER BY
       s.table_name,
       s.table_owner,
       s.index_name,
       s.owner) v
 UNION ALL
SELECT object_name table_name,
       object_owner owner,
       3 line_type,
       1 row_num,
       '<tr>'||CHR(10)||
       '<th>#</th>'||CHR(10)||
       --'<th>Table Name</th>'||CHR(10)||
       --'<th>Owner</th>'||CHR(10)||
       '<th>Index Name</th>'||CHR(10)||
       '<th>Owner</th>'||CHR(10)||
       '<th>Index Type</th>'||CHR(10)||
       '<th>Part</th>'||CHR(10)||
       '<th>DoP</th>'||CHR(10)||
       '<th>Temp</th>'||CHR(10)||
       '<th>Uniqueness</th>'||CHR(10)||
       '<th>Cols</th>'||CHR(10)||
       '<th>Num<br>Rows</th>'||CHR(10)||
       '<th>Sample<br>Size</th>'||CHR(10)||
       '<th>Perc</th>'||CHR(10)||
       '<th>Last Analyzed</th>'||CHR(10)||
       '<th>Distinct<br>Keys</th>'||CHR(10)||
       '<th>Blevel</th>'||CHR(10)||
       '<th>Leaf<br>Blocks</th>'||CHR(10)||
       '<th>Avg<br>Leaf<br>Blocks<br>per Key</th>'||CHR(10)||
       '<th>Avg<br>Data<br>Blocks<br>per Key</th>'||CHR(10)||
       '<th>Clustering<br>Factor</th>'||CHR(10)||
       '<th>Global<br>Stats</th>'||CHR(10)||
       '<th>User<br>Stats</th>'||CHR(10)||
       '<th>Stat<br>Type<br>Locked</th>'||CHR(10)||
       '<th>Stale<br>Stats</th>'||CHR(10)||
   	'<th>Stats<br>Versions</th>'||CHR(10)||
   	'<th>Status</th>'||CHR(10)||
       '</tr>'||CHR(10) line_text
FROM plan_table
 WHERE object_type = 'TABLE'
   AND STATEMENT_ID = :sql_id
 UNION ALL
SELECT object_name table_name,
       object_owner owner,
       4 line_type,
       1 row_num,
       CHR(10)||'</table></details><!-- Srini -->'||CHR(10)||CHR(10) line_text
  FROM plan_table
 WHERE object_type = 'TABLE'
   AND STATEMENT_ID = :sql_id) v2
 ORDER BY
       v2.table_name,
       v2.owner,
       v2.line_type,
       v2.row_num;	   
	   

-- Display command to partition index



PRO <details open><br/><summary id="summary3">Command to partition index</summary>

select * from (
  SELECT  REPLACE(REPLACE(REPLACE(REPLACE(DBMS_METADATA.GET_DDL('INDEX', i.index_name, i.owner), '<', CHR(38)||'lt;'), '>', CHR(38)||'gt;'), '''', CHR(38)||'#39;'), '"', CHR(38)||'quot;') || 'PARTITION BY HASH('  || c.column_name || ') PARTITIONS 64'
 FROM plan_table pt,
       dba_indexes i,
       dba_ind_columns c,
       gv$active_session_history ash
 WHERE pt.object_type = 'TABLE'
   AND pt.STATEMENT_ID = :sql_id
   AND pt.object_name = i.table_name
   AND ash.sql_id = :sql_id
   AND ash.event like '%buffer busy%'
   AND ash.sql_id = pt.statement_id
   AND i.index_name = c.index_name
   AND c.column_position = 1) where rownum=1;


select round((sysdate-to_date(:start_time,'dd-mon-rr hh24:mi:ss'))*86400) diff from dual;
PRO <table style="width:100%"><tr><td style="text-align:right; background-color:#ffffff">Time taken: ^^diff. seconds</td></tr></table>
PRO </details>
exec :start_time := to_char(sysdate,'dd-mon-rr hh24:mi:ss');
/* -------------------------
 *
 * footer
 *
 * ------------------------- */
PRO
SELECT '<!-- '||TO_CHAR(SYSDATE, 'YYYY-MM-DD/HH24:MI:SS')||' -->' FROM dual;
PRO <hr size="3">
PRO <font class="f">^^mos_doc. ^^method. ^^doc_ver. ^^doc_date. ^^time_stamp2.</font>
PRO </body>
PRO </html>

SPO OFF;

/**************************************************************************************************/

/**************************************************************************************************
 *
 * execution_plans report
 *
 **************************************************************************************************/

EXEC DBMS_APPLICATION_INFO.SET_CLIENT_INFO('^^method.: Execution Plans - ' || TO_CHAR(SYSDATE, 'YYYY-MM-DD/HH24:MI:SS'));

/* -------------------------
 *
 * heading
 *
 * ------------------------- */
SPO ^^files_prefix._3_execution_plans.html;

PRO <html>
PRO <!-- $Header: ^^mos_doc. ^^script..sql ^^doc_ver. ^^doc_date. carlos.sierra $ -->
PRO <!-- Copyright (c) 2000-2012, Oracle Corporation. All rights reserved. -->
PRO <!-- Author: carlos.sierra@oracle.com -->
PRO
PRO <head>
PRO <title>^^files_prefix._3_execution_plans.html</title>
PRO

PRO <style type="text/css">
PRO body {font:10pt Arial,Helvetica,Verdana,Geneva,sans-serif; color:black; background:white;}
PRO a {font-weight:bold; color:#663300;}
PRO pre {font:8pt Monaco,"Courier New",Courier,monospace;} /* for code */
PRO h1 {font-size:16pt; font-weight:bold; color:#336699;}
PRO h2 {font-size:14pt; font-weight:bold; color:#336699;}
PRO h3 {font-size:12pt; font-weight:bold; color:#336699;}
PRO li {font-size:10pt; font-weight:bold; color:#336699; padding:0.1em 0 0 0;}
PRO table {font-size:8pt; color:black; background:white;}
PRO th {font-weight:bold; background:#cccc99; color:#336699; vertical-align:bottom; padding-left:3pt; padding-right:3pt; padding-top:1pt; padding-bottom:1pt; position:sticky; top:0;}
PRO td {text-align:left; background:#fcfcf0; vertical-align:top; padding-left:3pt; padding-right:3pt; padding-top:1pt; padding-bottom:1pt;}
PRO td.c {text-align:center;} /* center */
PRO td.l {text-align:left;} /* left (default) */
PRO td.r {text-align:right;} /* right */
PRO font.n {font-size:8pt; font-style:italic; color:#336699;} /* table footnote in blue */
PRO font.f {font-size:8pt; color:#999999;} /* footnote in gray */
PRO #summary1 {font-weight: bold; font-size: 16pt; color:#336699;}
PRO #summary2 {font-weight: bold; font-size: 14pt; color:#336699;}
PRO #summary3 {font-weight: bold; font-size: 12pt; color:#336699;}
PRO #summary4 {font-weight: bold; font-size: 10pt; color:#336699;}
PRO summary:hover {background-color: #FFFF99;}
PRO .button  {cursor: pointer;}
PRO .button1 {border-radius: 8px; background-color: #FFFF99; color: black;}
PRO .button1:hover {background-color: #4CAF50;color: white;}
PRO #mark_fmt {font:8pt Monaco,"Courier New",Courier,monospace; background-color:#ffcccc;} /* for highlighting plan issues */
PRO </style>
PRO

PRO </head>
PRO <body>
PRO <h1><a target="MOS" href="^^doc_link.^^mos_doc.">^^mos_doc.</a> ^^method.
PRO ^^doc_ver. Report: ^^files_prefix._3_execution_plans.html</h1>
PRO

PRO <pre>
PRO License    : ^^input_license.
PRO Input      : ^^input_parameter.
PRO SIGNATURE  : ^^signature.
PRO SIGNATUREF : ^^signaturef.
PRO RDBMS      : ^^rdbms_version.
PRO Platform   : ^^platform.
PRO Database   : ^^database_name_short.
PRO DBID       : ^^dbid.
PRO Host       : ^^host_name_short.
PRO Instance   : ^^instance_number.
PRO CPU_Count  : ^^sys_cpu.
PRO Num CPUs   : ^^num_cpus.
PRO Num Cores  : ^^num_cores.
PRO Num Sockets: ^^num_sockets.
PRO Block Size : ^^sys_db_block_size.
PRO OFE        : ^^sys_ofe.
PRO DYN_SAMP   : ^^sys_ds.
PRO EBS        : "^^is_ebs."
PRO SIEBEL     : "^^is_siebel."
PRO PSFT       : "^^is_psft."
PRO Date       : ^^time_stamp2.
PRO User       : ^^sessionuser.
PRO </pre>

PRO <ul>
PRO <li><a href="#text">SQL Text</a></li>
PRO <li><a href="#mem_plans_last">Current Execution Plans (last execution)</a></li>
PRO <li><a href="#mem_plans_all">Current Execution Plans (all executions)</a></li>
PRO <li><a href="#awr_plans">Historical Execution Plans</a></li>
PRO </ul>

/* -------------------------
 *
 * sql_text
 *
 * ------------------------- */
PRO <script language="JavaScript" type="text/JavaScript">
PRO function openInNewWindow(url)
PRO {
PRO   window.open(url,"_blank");
PRO }
PRO </script>
PRO <a name="text"></a><details open><br/><summary id="summary2">SQL Text</summary>
PRO <FORM><BUTTON class="button button1" onclick="openInNewWindow(&quot;https://apex.oraclecorp.com/pls/apex/f?p=28906&quot;)">Analyze SQL Text via PSR Tool [use Upload SQL Button]</BUTTON></FORM> 
PRO
PRO <pre>

DECLARE
  l_sql_text CLOB := :sql_text;
  l_pos NUMBER;
BEGIN
  WHILE NVL(LENGTH(l_sql_text), 0) > 0
  LOOP
    l_pos := INSTR(l_sql_text, CHR(10));
    IF l_pos > 0 THEN
      DBMS_OUTPUT.PUT_LINE(SUBSTR(l_sql_text, 1, l_pos - 1));
      l_sql_text := SUBSTR(l_sql_text, l_pos + 1);
    ELSE
      DBMS_OUTPUT.PUT_LINE(l_sql_text);
      l_sql_text := NULL;
    END IF;
  END LOOP;
END;
/

PRO </pre>

select round((sysdate-to_date(:start_time,'dd-mon-rr hh24:mi:ss'))*86400) diff from dual;
PRO <table style="width:100%"><tr><td style="text-align:right; background-color:#ffffff">Time taken: ^^diff. seconds</td></tr></table>
PRO </details><!--Pushkar-->
exec :start_time := to_char(sysdate,'dd-mon-rr hh24:mi:ss');

/* -----------------------------------
 *
 * ARE PII tables in use in the query?
 *
 * ----------------------------------- */
 
begin
  select count(*) into :pii_used
    from plan_table 
  where  regexp_like(:pii_tables,object_name,'i');
end;
/


/* -------------------------
 *
 * DBMS_XPLAN.DISPLAY_CURSOR OUTLINE ALLSTATS LAST
 *
 * ------------------------- */
COL inst_child FOR A21;
BREAK ON inst_child SKIP 2;

PRO <a name="mem_plans_last"></a><details open><br/><summary id="summary2">Current Execution Plans (last execution)</summary>
PRO
PRO Captured while still in memory. Metrics below are for the last execution of each child cursor.<br>
PRO If STATISTICS_LEVEL was set to ALL at the time of the hard-parse then A-Rows column is populated.
PRO
SELECT '<!-- '||TO_CHAR(SYSDATE, 'YYYY-MM-DD/HH24:MI:SS')||' -->' FROM dual;
PRO <!-- Please Wait -->

/* uday replaced with below SQL to get execution order
 *
SELECT RPAD('Inst: '||v.inst_id, 9)||' '||RPAD('Child: '||v.child_number, 11) inst_child, t.plan_table_output
  FROM gv$sql v,
       TABLE(DBMS_XPLAN.DISPLAY('gv$sql_plan_statistics_all', NULL, 'ADVANCED ALLSTATS LAST', 'inst_id = '||v.inst_id||' AND sql_id = '''||v.sql_id||''' AND child_number = '||v.child_number)) t
 WHERE v.sql_id = :sql_id
   AND v.loaded_versions > 0;
*/

DECLARE
   pragma autonomous_transaction;
   l_exec_order number;

    PROCEDURE assign_execution_order (
      p_inst_id         IN NUMBER,
      p_plan_hash_value IN NUMBER,
      p_child_number    IN NUMBER,
      p_id              IN NUMBER )
    IS
    BEGIN
      FOR j IN (SELECT id
                  FROM plan_table
                 WHERE 1 = 1
                   AND partition_id = p_inst_id
                   AND plan_id      = p_plan_hash_value
                   AND STATEMENT_ID = p_child_number
                   AND parent_id    = p_id
                   AND object_name  = :sql_id
                 -- ORDER BY position
                 ORDER BY (case when parent_id = 0 then position else null end) desc, position  -- PSRv10 to fix scalar subquery ordering
                 )
      LOOP
        assign_execution_order (
          p_inst_id         => p_inst_id,
          p_plan_hash_value => p_plan_hash_value,
          p_child_number    => p_child_number,
          p_id              => j.id );
      END LOOP;

      l_exec_order := l_exec_order + 1;

      UPDATE plan_table
         SET cardinality = l_exec_order
       WHERE 1 = 1
         AND partition_id = p_inst_id
         AND plan_id      = p_plan_hash_value
         AND STATEMENT_ID = p_child_number
         AND object_name  = :sql_id
         AND id = p_id;
    END assign_execution_order;

begin

  DELETE plan_table where STATEMENT_ID = :sql_id;
  commit;

  begin
/* uday.psr.v6 replaced with below 
    insert into plan_table 
            (partition_id, object_name, plan_id,         statement_id, id, parent_id, position, cardinality)
      select inst_id,      sql_id,      plan_hash_value, child_number, id, parent_id, position, -1 as exec_order 
        from gv$sql_plan 
       where sql_id = :sql_id
    ;
*/
    insert into plan_table 
            (partition_id, object_name, plan_id, statement_id, id, parent_id, position, cardinality)
      with plans as
      (
       select --+ materialize  
              * 
         from (
               select inst_id, sql_id, child_number, plan_hash_value, 
                      -- executions, 
                      -- round((elapsed_time/decode(nvl(executions, 0), 0, 1, executions))/1000000, 2)  avg_elatime,
                      -- round((buffer_gets/decode(nvl(executions, 0), 0, 1, executions)), 2) avg_bg,
                      row_number() over(partition by sql_id, plan_hash_value order by (case when inst_id = SYS_CONTEXT ('USERENV', 'INSTANCE') then 0 else 1 end), child_number) rn
                 from gv$sql 
                where sql_id = :sql_id
              ) v
        where rn=1   -- getting one plan per phv
      )
      -- uday psrv10 select sp.inst_id, sp.sql_id, sp.plan_hash_value, sp.child_number, id, parent_id, position, -1 as exec_order
      select inst_id, sql_id, plan_hash_value, child_number, id, parent_id, position, exec_order
        from (
              select sp.inst_id, sp.sql_id, sp.plan_hash_value, sp.child_number, 
                     nvl(skp.display_id, id) id, nvl(skp.parent_id, sp.parent_id) parent_id, 
                     position, -1 as exec_order
                     , skp.skipped
                from gv$sql_plan sp, plans,
                     -- uday psrv10 - below query to extract in 12c DB
                     (select p.inst_id, p.sql_id, p.child_number, p.plan_hash_value, xt.*
                        from gv$sql_plan p,
                             XMLTABLE('/other_xml/display_map/row'
                               PASSING xmltype(p.other_xml)
                               COLUMNS
                                 oper_id     number PATH '@op',      -- operation_id
                                 display_id  number PATH '@dis',     -- display_id
                                 parent_id   number PATH '@par',     -- parent_id
                                 part_id     number PATH '@prt',     -- partitioning display id
                                 depth       number PATH '@dep',     -- display depth
                                 skipped     number PATH '@skp'      -- whether to skip this in display
                               ) xt
                       where p.sql_id = :sql_id
                         and other_xml is not null) skp
               where plans.sql_id = sp.sql_id
                 and plans.inst_id = sp.inst_id
                 and plans.plan_hash_value = sp.plan_hash_value
                 and plans.child_number = sp.child_number
                 and skp.sql_id(+) = sp.sql_id
                 and skp.inst_id(+) = sp.inst_id
                 and skp.plan_hash_value(+) = sp.plan_hash_value
                 and skp.child_number(+) = sp.child_number
                 and skp.oper_id(+) = sp.id   -- uday psrv10 for 12c
             ) 
             where skipped = 0 or skipped is null   -- uday psrv10 for 12c skip plan lines that are not executed
    ;

    -- dbms_output.put_line('row count: ' || sql%rowcount);

  exception when others then
    raise_application_error(-20000, 'Please create plan_table using script: $ORACLE_HOME/rdbms/admin/utlxplan.sql');
  end;

  for cn in (select distinct partition_id inst_id, STATEMENT_ID as child_number from plan_table where object_name = :sql_id order by STATEMENT_ID)
  loop
    FOR i IN (SELECT 
                     partition_id inst_id,
                     plan_id      plan_hash_value,
                     STATEMENT_ID child_number,
                     id
                FROM plan_table
               WHERE STATEMENT_ID = cn.child_number
                 and partition_id = cn.inst_id
                 AND object_name = :sql_id
                 AND parent_id IS NULL)
    LOOP
      l_exec_order := 0;

      assign_execution_order (
        p_inst_id         => i.inst_id,
        p_plan_hash_value => i.plan_hash_value,
        p_child_number    => i.child_number,
        p_id              => i.id );
    END LOOP;
  END LOOP;
  COMMIT;

end;
/

-- set termout on

--
--Uday.PSR.v6: Now getting unique plans, and getting from local instance whenever available (see order by clause of analytical function below)
--
With s as
(
 select rownum rn, 
        t.plan_table_output, 
        v.inst_id, v.child_number, v.plan_hash_value phv,
        RPAD('Inst: '||v.inst_id, 9)||' '||RPAD('Child: '||v.child_number, 11) inst_child
   -- FROM gv$sql v,
   FROM 
        (
          select * 
            from (
                  select inst_id, sql_id, child_number, plan_hash_value, executions, 
                         round((elapsed_time/decode(nvl(executions, 0), 0, 1, executions))/1000000, 2)  avg_elatime,
                         round((buffer_gets/decode(nvl(executions, 0), 0, 1, executions)), 2) avg_bg,
                         row_number() over(partition by sql_id, plan_hash_value 
                                               order by (case when inst_id = SYS_CONTEXT ('USERENV', 'INSTANCE') then 0 else 1 end), child_number) rn
                    from gv$sql 
                   where sql_id = :sql_id
                     AND loaded_versions > 0
        ) v
        where rn=1
        ) v,
        TABLE(DBMS_XPLAN.DISPLAY('gv$sql_plan_statistics_all', NULL, 'ADVANCED ALLSTATS LAST'||case when :pii_used>0 then ' -peeked_binds' end, 'inst_id = '||v.inst_id||' AND sql_id = '''||v.sql_id||''' AND child_number = '||v.child_number)) t
		WHERE t.plan_table_output NOT in ('-------------------------------------------------------------',
	                                      '-------------','--------------------------------------',
	                                      '---------------------------------------------------',
								          '-----------------------------------------------------------',
										  '-----', '---------------------')
		  AND NOT regexp_like (t.plan_table_output, '(<q|q>|CDATA)')
)
, p as
  (     -- pline_id: extracting plan id column from plan_table_output
       select rn, phv, to_number(case when regexp_like (plan_table_output,'^[|][*]? *([0-9]+) *[|].*[|]$') then
                 regexp_replace(plan_table_output,'^[|][*]? *([0-9]+) *[|].*[|]$','\1')
                 END) pline_ID
              , child_number child#
              , plan_table_output
              , inst_id
              , inst_child
         from s
  )
, po as
     (-- here we are printing child# on all lines
      select rn, phv, child# child_orig
             , pline_ID
             ,  max(pline_ID) over(partition by inst_id, phv, child#) max_pline_id
             ,  max(child#) over(partition by inst_id, phv, child#) child#
             , plan_table_output
             , inst_id
             , inst_child
        from p
     )
, ef as (select rn, inst_id, phv, child_orig, child#, rn-3 firstl from po where pline_id = 0 ) -- first line of the exec plan
, el as (select rn, inst_id, phv, child_orig, child#, pline_id, rn+1 lastl from po where (inst_id, pline_id, child_orig) in (select distinct inst_id, max_pline_id, child_orig from po )) -- last line of the exec plan
, pre_fmt as 
 (  
  select regexp_replace(
         substr(po.plan_table_output, 1, 7) ||
         case when ef.firstl = po.rn then   '--------'  -- first line
              when ef.firstl+1 = po.rn then ' exeOrd|'  -- 2nd line
              when ef.firstl+2 = po.rn then '--------'  -- 3rd line
              when po.rn between ef.firstl+3 and el.lastl-1 then ' ' || lpad(pt.cardinality, 5, ' ')||' |'  -- cardinality is execution order
              when el.lastl    = po.rn then   '--------' -- last line
         end ||
         substr(po.plan_table_output, 8)
         , '(Plan hash value: [[:digit:]]+)', chr(10)||chr(10)|| po.inst_child|| '\1' ) as plan_table_output
    from po, plan_table pt, ef, el
   where pt.id(+) = po.pline_id
     and pt.STATEMENT_ID(+) = po.child#
     and pt.partition_id(+) = po.inst_id
     and pt.object_name(+) = :sql_id
     and ef.child# = el.child#
     and ef.inst_id = el.inst_id
     and ef.child# = po.child#
     and ef.inst_id = po.inst_id
     and el.child# = po.child#
     and el.inst_id = po.inst_id
   order by po.rn
 )
 select 
     case 
		   when rownum = 1                                                then '<pre>'||t.plan_table_output
 			 when t.plan_table_output like '%Inst:%'                        then '</pre></details><details open><summary ID="summary3">'||t.plan_table_output||'</summary><pre>'        
			 when t.plan_table_output like 'Query Block Name%'              then '</pre></details><details><summary ID="summary4">'||t.plan_table_output||'</summary><pre>' 
			 when t.plan_table_output like 'Outline Data%'                  then '</pre></details><details><summary ID="summary4">'||t.plan_table_output||'</summary><pre>'  
			 when t.plan_table_output like 'Peeked Binds%'                  then '</pre></details><details open><summary ID="summary4">'||t.plan_table_output||'</summary><pre>'  
			 when t.plan_table_output like 'Predicate Information%'         then '</pre></details><details open><summary ID="summary4">'||t.plan_table_output||'</summary><pre>'   
			 when t.plan_table_output like 'Column Projection Information%' then '</pre></details><details><summary ID="summary4">'||t.plan_table_output||'</summary><pre>'  
       when t.plan_table_output like 'Hint Report%'                   then '</pre></details><details><summary ID="summary4">'||t.plan_table_output||'</summary><pre>'  		
       when t.plan_table_output like 'Query Block Registry%'          then '</pre></details><details><summary ID="summary4">'||t.plan_table_output||'</summary><pre>'        
       when t.plan_table_output like 'Note%'                          then '</pre></details><details open><summary ID="summary4">'||t.plan_table_output||'</summary><pre>'  			 
       when t.plan_table_output like '% FULL%'                        then '<mark ID="mark_fmt">'||t.plan_table_output||'</mark>'         
       when t.plan_table_output like '% CARTESIAN%'                   then '<mark ID="mark_fmt">'||t.plan_table_output||'</mark>'  
       when t.plan_table_output like '%SKIP%'                         then '<mark ID="mark_fmt">'||t.plan_table_output||'</mark>'              
--       when t.plan_table_output like '%HASH%'                         then '<mark ID="mark_fmt">'||t.plan_table_output||'</mark>'              
       when t.plan_table_output like '%COLLECTION%ITERATOR%'          then '<mark ID="mark_fmt">'||t.plan_table_output||'</mark>'                  
	     else t.plan_table_output
		end || lead (NULL,1,chr(10)||'</pre>') over (ORDER BY rownum) as plan_table_output
 from pre_fmt t
;

PRO </details>
select round((sysdate-to_date(:start_time,'dd-mon-rr hh24:mi:ss'))*86400) diff from dual;
PRO <table style="width:100%"><tr><td style="text-align:right; background-color:#ffffff">Time taken: ^^diff. seconds</td></tr></table>
exec :start_time := to_char(sysdate,'dd-mon-rr hh24:mi:ss');

/* -------------------------
 *
 * DBMS_XPLAN.DISPLAY_CURSOR OUTLINE ALLSTATS
 *
 * ------------------------- */
PRO <a name="mem_plans_all"></a><details open><br/><summary id="summary2">Current Execution Plans (all executions)</summary>
PRO
PRO Captured while still in memory. Metrics below are an aggregate for all the execution of each child cursor.<br>
PRO If STATISTICS_LEVEL was set to ALL at the time of the hard-parse then A-Rows column is populated.
PRO
SELECT '<!-- '||TO_CHAR(SYSDATE, 'YYYY-MM-DD/HH24:MI:SS')||' -->' FROM dual;
PRO <!-- Please Wait -->


/* uday: replaced with below sql to get execution order
 *
SELECT RPAD('Inst: '||v.inst_id, 9)||' '||RPAD('Child: '||v.child_number, 11) inst_child, t.plan_table_output
  FROM gv$sql v,
       TABLE(DBMS_XPLAN.DISPLAY('gv$sql_plan_statistics_all', NULL, 'ADVANCED ALLSTATS', 'inst_id = '||v.inst_id||' AND sql_id = '''||v.sql_id||''' AND child_number = '||v.child_number)) t
 WHERE v.sql_id = :sql_id
   AND v.loaded_versions > 0
   AND v.executions > 1;
*/


With s as
(
 select rownum rn, 
        t.plan_table_output,
        v.inst_id, v.child_number, v.plan_hash_value phv,
        RPAD('Inst: '||v.inst_id, 9)||' '||RPAD('Child: '||v.child_number, 11) inst_child
   FROM gv$sql v,
        TABLE(DBMS_XPLAN.DISPLAY('gv$sql_plan_statistics_all', NULL, 'ADVANCED ALLSTATS'||case when :pii_used>0 then ' -peeked_binds' end, 'inst_id = '||v.inst_id||' AND sql_id = '''||v.sql_id||''' AND child_number = '||v.child_number)) t
  WHERE v.sql_id = :sql_id
    AND t.plan_table_output NOT in ('-------------------------------------------------------------',
	                                '-------------','--------------------------------------',
	                                '---------------------------------------------------',
									'-----------------------------------------------------------',
									'-----', '---------------------')
		AND NOT regexp_like (t.plan_table_output, '(<q|q>|CDATA)')
    AND v.loaded_versions > 0
)
, p as
  (     -- pline_id: extracting plan id column from plan_table_output
       select rn, phv, to_number(case when regexp_like (plan_table_output,'^[|][*]? *([0-9]+) *[|].*[|]$') then
                 regexp_replace(plan_table_output,'^[|][*]? *([0-9]+) *[|].*[|]$','\1')
                 END) pline_ID
              , child_number child#
              , plan_table_output
              , inst_id
              , inst_child
         from s
  )
, po as
     (-- here we are printing child# on all lines
      select rn, phv, child# child_orig
             , pline_ID
             ,  max(pline_ID) over(partition by inst_id, phv, child#) max_pline_id
             ,  max(child#) over(partition by inst_id, phv, child#) child#
             , plan_table_output
             , inst_id
             , inst_child
        from p
     )
, ef as (select rn, inst_id, phv, child_orig, child#, rn-3 firstl from po where pline_id = 0 ) -- first line of the exec plan
, el as (select rn, inst_id, phv, child_orig, child#, pline_id, rn+1 lastl from po where (inst_id, pline_id, child_orig) in (select distinct inst_id, max_pline_id, child_orig from po )) -- last line of the exec plan
, pre_fmt as 
 (  
  select regexp_replace(
         substr(po.plan_table_output, 1, 7) ||
         case when ef.firstl = po.rn then   '--------'  -- first line
              when ef.firstl+1 = po.rn then ' exeOrd|'  -- 2nd line
              when ef.firstl+2 = po.rn then '--------'  -- 3rd line
              when po.rn between ef.firstl+3 and el.lastl-1 then ' ' || lpad(pt.cardinality, 5, ' ')||' |'  -- cardinality is execution order
              when el.lastl    = po.rn then   '--------' -- last line
         end ||
         substr(po.plan_table_output, 8)
         , '(Plan hash value: [[:digit:]]+)', chr(10)||chr(10)|| po.inst_child|| '\1' ) as plan_table_output
    from po, plan_table pt, ef, el
   where pt.id(+) = po.pline_id
     and pt.STATEMENT_ID(+) = po.child#
     and pt.partition_id(+) = po.inst_id
     AND object_name(+) = :sql_id
     and ef.child# = el.child#
     and ef.inst_id = el.inst_id
     and ef.child# = po.child#
     and ef.inst_id = po.inst_id
     and el.child# = po.child#
     and el.inst_id = po.inst_id
   order by po.rn
 )
 select 
     case 
		   when rownum = 1                                                then '<pre>'||t.plan_table_output
		   when regexp_count(t.plan_table_output,'^SQL_ID')> 0            then '</pre></details><details open><summary ID="summary3">'||'Next plan'||'</summary><pre>'||t.plan_table_output       
 			 when t.plan_table_output like '%Inst:%'                        then '</pre></details><details open><summary ID="summary3">'||t.plan_table_output||'</summary><pre>'        
			 when t.plan_table_output like 'Query Block Name%'              then '</pre></details><details><summary ID="summary4">'||t.plan_table_output||'</summary><pre>' 
			 when t.plan_table_output like 'Outline Data%'                  then '</pre></details><details><summary ID="summary4">'||t.plan_table_output||'</summary><pre>'  
			 when t.plan_table_output like 'Peeked Binds%'                  then '</pre></details><details open><summary ID="summary4">'||t.plan_table_output||'</summary><pre>'  
			 when t.plan_table_output like 'Predicate Information%'         then '</pre></details><details open><summary ID="summary4">'||t.plan_table_output||'</summary><pre>'   
			 when t.plan_table_output like 'Column Projection Information%' then '</pre></details><details><summary ID="summary4">'||t.plan_table_output||'</summary><pre>'  
       when t.plan_table_output like 'Hint Report%'                   then '</pre></details><details><summary ID="summary4">'||t.plan_table_output||'</summary><pre>'  		
       when t.plan_table_output like 'Query Block Registry%'          then '</pre></details><details><summary ID="summary4">'||t.plan_table_output||'</summary><pre>'        
       when t.plan_table_output like 'Note%'                          then '</pre></details open><details><summary ID="summary4">'||t.plan_table_output||'</summary><pre>'  			 
       when t.plan_table_output like '% FULL%'                        then '<mark ID="mark_fmt">'||t.plan_table_output||'</mark>'         
       when t.plan_table_output like '% CARTESIAN%'                   then '<mark ID="mark_fmt">'||t.plan_table_output||'</mark>'  
       when t.plan_table_output like '%SKIP%'                         then '<mark ID="mark_fmt">'||t.plan_table_output||'</mark>'              
--       when t.plan_table_output like '%HASH%'                         then '<mark ID="mark_fmt">'||t.plan_table_output||'</mark>'              
       when t.plan_table_output like '%COLLECTION%ITERATOR%'          then '<mark ID="mark_fmt">'||t.plan_table_output||'</mark>'                  
	     else t.plan_table_output
		end || lead (NULL,1,chr(10)||'</pre>') over (ORDER BY rownum) as plan_table_output
 from pre_fmt t
;

PRO </details>
select round((sysdate-to_date(:start_time,'dd-mon-rr hh24:mi:ss'))*86400) diff from dual;
PRO <table style="width:100%"><tr><td style="text-align:right; background-color:#ffffff">Time taken: ^^diff. seconds</td></tr></table>
exec :start_time := to_char(sysdate,'dd-mon-rr hh24:mi:ss');

/* -------------------------
 *
 * DBMS_XPLAN.DISPLAY_AWR OUTLINE
 *
 * ------------------------- */
PRO <a name="awr_plans"></a><details open><br/><summary id="summary2">Historical Execution Plans</summary>
PRO
PRO This section includes data captured by AWR. If this is a stand-by read-only database then the AWR information below is from the Primary database.
PRO
SELECT '<!-- '||TO_CHAR(SYSDATE, 'YYYY-MM-DD/HH24:MI:SS')||' -->' FROM dual;
PRO <!-- Please Wait -->


/* uday: replaced with below plsql and sql to get execution plan 
SELECT t.plan_table_output
  FROM (SELECT DISTINCT sql_id, plan_hash_value, dbid
          FROM dba_hist_sql_plan WHERE :license IN ('T', 'D') AND dbid = ^^dbid. AND sql_id = :sql_id) v,
       TABLE(DBMS_XPLAN.DISPLAY_AWR(v.sql_id, v.plan_hash_value, v.dbid, 'ADVANCED')) t;
*/

DECLARE
   pragma autonomous_transaction;
   l_exec_order number;

    PROCEDURE assign_execution_order (
      p_plan_hash_value IN NUMBER,
      p_id              IN NUMBER )
    IS
    BEGIN
      FOR j IN (SELECT id
                  FROM plan_table
                 WHERE 1 = 1
                   AND plan_id      = p_plan_hash_value
                   AND parent_id    = p_id
                   AND object_name  = :sql_id
                 -- ORDER BY position
                 ORDER BY (case when parent_id = 0 then position else null end) desc, position  -- PSRv10 to fix scalar subquery ordering
                 )
      LOOP
        assign_execution_order (
          p_plan_hash_value => p_plan_hash_value,
          p_id              => j.id );
      END LOOP;

      l_exec_order := l_exec_order + 1;


      UPDATE plan_table
         SET cardinality = l_exec_order
       WHERE 1 = 1
         AND object_name  = :sql_id
         AND plan_id      = p_plan_hash_value
         AND id = p_id;

      -- dbms_output.put_line('rows updated: ' || sql%rowcount || ' l_exec_order: ' || l_exec_order || ' plan/id: ' || p_plan_hash_value || '/'|| p_id);
    END assign_execution_order;

begin

  DELETE plan_table where object_name = :sql_id;
  commit;

  begin
    insert into plan_table 
            (object_name, plan_id, id, parent_id, position, cardinality)
      -- 
      -- uday psrv10 
      --   select sql_id, plan_hash_value,  id,               parent_id,                  position, -1 as exec_order 
      select sql_id, plan_hash_value, id, parent_id, position, exec_order
        from (
               select sp.sql_id, sp.plan_hash_value, 
                      nvl(skp.display_id, id) id, nvl(skp.parent_id, sp.parent_id) parent_id, 
                      position, -1 as exec_order
                      , skp.skipped
                 from dba_hist_sql_plan sp,
                      -- uday psrv10 - below query to extract in 12c DB
                      (select p.sql_id, p.plan_hash_value, xt.*
                         from dba_hist_sql_plan p,    
                              XMLTABLE('/other_xml/display_map/row'
                                PASSING xmltype(p.other_xml)
                                COLUMNS 
                                  oper_id     number PATH '@op',      -- operation_id
                                  display_id  number PATH '@dis',     -- display_id
                                  parent_id   number PATH '@par',     -- parent_id
                                  part_id     number PATH '@prt',     -- partitioning display id
                                  depth       number PATH '@dep',     -- display depth
                                  skipped     number PATH '@skp'      -- whether to skip this in display
                                ) xt
                        where :license IN ('T', 'D', 'L') --??
                          and p.dbid = ^^dbid. 
                          and p.sql_id = :sql_id
                          and p.other_xml is not null
                      ) skp
                where :license IN ('T', 'D', 'L') --?? 
                  and sp.dbid = ^^dbid. 
                  and sp.sql_id = :sql_id
                  and skp.sql_id(+) = sp.sql_id
                  and skp.plan_hash_value(+) = sp.plan_hash_value
                  and skp.oper_id(+) = sp.id   --uday psrv10 for 12c
             ) 
             where skipped = 0 or skipped is null   -- uday psrv10 for 12c skip plan lines that are not executed
    ;

  exception when others then
    raise_application_error(-20000, 'Please create plan_table using script: $ORACLE_HOME/rdbms/admin/utlxplan.sql');
  end;

  for cn in (select distinct plan_id plan_hash_value from plan_table where object_name = :sql_id order by plan_id)
  loop
    FOR i IN (SELECT 
                     plan_id      plan_hash_value,
                     id
                FROM plan_table
               WHERE plan_id = cn.plan_hash_value
                 AND object_name = :sql_id
                 AND parent_id IS NULL)
    LOOP
      l_exec_order := 0;

      assign_execution_order (
        p_plan_hash_value => i.plan_hash_value,
        p_id              => i.id );
    END LOOP;
  END LOOP;
  COMMIT;

end;
/

With s as
(
 select rownum rn, 
        t.plan_table_output,
        v.plan_hash_value phv
  FROM (SELECT DISTINCT sql_id, plan_hash_value, dbid
          FROM dba_hist_sql_plan 
         WHERE 1=1
           AND (:license IN ('T', 'D') or (:license = 'L' and timestamp > sysdate - interval '^^days.' day))
           AND dbid = ^^dbid. 
           AND sql_id = :sql_id
       ) v,
       TABLE(DBMS_XPLAN.DISPLAY_AWR(v.sql_id, v.plan_hash_value, v.dbid, 'ADVANCED'||case when :pii_used>0 then ' -peeked_binds' end)) t
	   WHERE t.plan_table_output NOT in ('-------------------------------------------------------------',
	                                     '-------------','--------------------------------------',
	                                     '---------------------------------------------------',
									     '-----------------------------------------------------------',
										 '-----', '---------------------')
		   AND NOT regexp_like (t.plan_table_output, '(<q|q>|CDATA)')
)
, p as 
  (     -- pline_id: extracting plan id column from plan_table_output
        --
       select rn, to_number(case when regexp_like (plan_table_output,'^[|][*]? *([0-9]+) *[|].*[|]$') then
              regexp_replace(plan_table_output,'^[|][*]? *([0-9]+) *[|].*[|]$','\1')
                END) pline_ID
              , plan_table_output
              , phv
         from s
  )
, po as
     (
      select rn, pline_ID, plan_table_output, phv
       from p 
     )
, ef as (select phv, rn-3 firstl from po where pline_id = 0 ) -- first line of the exec plan
, el as (select phv, rn+1 lastl from po where (phv, pline_id) in (select phv, max(pline_id) from po group by phv)) -- last line of the exec plan
, pre_fmt as 
 (  
   select 
         substr(po.plan_table_output, 1, 7) ||
         case when ef.firstl = rn then   '--------'  -- first line
              when ef.firstl+1 = rn then ' exeOrd|'  -- 2nd line
              when ef.firstl+2 = rn then '--------'  -- 3rd line
              when rn between firstl+3 and lastl-1 then ' ' || lpad(pt.cardinality, 5, ' ')||' |'  -- cardinality is execution order
              when el.lastl    = rn then   '--------' -- last line
         end ||
         substr(po.plan_table_output, 8) as plan_table_output
    from po, plan_table pt, ef, el
   where pt.id(+) = po.pline_id
     and pt.plan_id(+) = po.phv
     and pt.object_name(+) = :sql_id
     and ef.phv = el.phv
     and ef.phv = po.phv
     and el.phv = po.phv
   order by po.rn
 )
 select 
     case 
		   when rownum = 1                                                then '<pre>'||t.plan_table_output
		   when regexp_count(t.plan_table_output,'^SQL_ID')> 0            then '</pre></details><details open><summary ID="summary3">'||'Next plan'||'</summary><pre>'||t.plan_table_output       
 			 when t.plan_table_output like '%Inst:%'                        then '</pre></details><details open><summary ID="summary3">'||t.plan_table_output||'</summary><pre>'        
			 when t.plan_table_output like 'Query Block Name%'              then '</pre></details><details><summary ID="summary4">'||t.plan_table_output||'</summary><pre>' 
			 when t.plan_table_output like 'Outline Data%'                  then '</pre></details><details><summary ID="summary4">'||t.plan_table_output||'</summary><pre>'  
			 when t.plan_table_output like 'Peeked Binds%'                  then '</pre></details><details open><summary ID="summary4">'||t.plan_table_output||'</summary><pre>'  
			 when t.plan_table_output like 'Predicate Information%'         then '</pre></details><details open><summary ID="summary4">'||t.plan_table_output||'</summary><pre>'   
			 when t.plan_table_output like 'Column Projection Information%' then '</pre></details><details><summary ID="summary4">'||t.plan_table_output||'</summary><pre>'  
       when t.plan_table_output like 'Hint Report%'                   then '</pre></details><details><summary ID="summary4">'||t.plan_table_output||'</summary><pre>'  		
       when t.plan_table_output like 'Query Block Registry%'          then '</pre></details><details><summary ID="summary4">'||t.plan_table_output||'</summary><pre>'        
       when t.plan_table_output like 'Note%'                          then '</pre></details open><details><summary ID="summary4">'||t.plan_table_output||'</summary><pre>'  			 
       when t.plan_table_output like '% FULL%'                        then '<mark ID="mark_fmt">'||t.plan_table_output||'</mark>'         
       when t.plan_table_output like '% CARTESIAN%'                   then '<mark ID="mark_fmt">'||t.plan_table_output||'</mark>'  
       when t.plan_table_output like '%SKIP%'                         then '<mark ID="mark_fmt">'||t.plan_table_output||'</mark>'              
--       when t.plan_table_output like '%HASH%'                         then '<mark ID="mark_fmt">'||t.plan_table_output||'</mark>'              
       when t.plan_table_output like '%COLLECTION%ITERATOR%'          then '<mark ID="mark_fmt">'||t.plan_table_output||'</mark>'                  
	     else t.plan_table_output
		end || lead (NULL,1,chr(10)||'</pre>') over (ORDER BY rownum) as plan_table_output
 from pre_fmt t
;

PRO </details>
select round((sysdate-to_date(:start_time,'dd-mon-rr hh24:mi:ss'))*86400) diff from dual;
PRO <table style="width:100%"><tr><td style="text-align:right; background-color:#ffffff">Time taken: ^^diff. seconds</td></tr></table>
exec :start_time := to_char(sysdate,'dd-mon-rr hh24:mi:ss');
/* -------------------------
 *
 * footer
 *
 * ------------------------- */
PRO
SELECT '<!-- '||TO_CHAR(SYSDATE, 'YYYY-MM-DD/HH24:MI:SS')||' -->' FROM dual;
PRO <hr size="3">
PRO <font class="f">^^mos_doc. ^^method. ^^doc_ver. ^^doc_date. ^^time_stamp2.</font>
PRO </body>
PRO </html>

SPO OFF;

/**************************************************************************************************/

/**************************************************************************************************
 *
 * 11g sql detail report
 *
 **************************************************************************************************/

EXEC DBMS_APPLICATION_INFO.SET_CLIENT_INFO('^^method.: SQL Detail Report - ' || TO_CHAR(SYSDATE, 'YYYY-MM-DD/HH24:MI:SS'));
PRO 11g SQL Detail Report
PRO
SELECT TO_CHAR(SYSDATE, 'YYYY-MM-DD/HH24:MI:SS') FROM dual;
PRO Please Wait

VAR det CLOB;
EXEC :det := 'SQL Detail Report is available on 11.2 and higher';
alter session set events 'emx_control compress_xml=none';
alter session set "_with_subquery"=inline;
set serveroutput on 
SPO ^^files_prefix._4_sql_detail.html;
SELECT '<!-- '||TO_CHAR(SYSDATE, 'YYYY-MM-DD/HH24:MI:SS')||' -->' FROM dual;
PRO <!-- begin DBMS_SQLTUNE.REPORT_SQL_DETAIL
DECLARE
  l_start_time DATE := NULL;
  l_end_time DATE := NULL;
  l_duration NUMBER := NULL;
  l_det clob := 'SQL Detail Report is available on 11.2 and higher';
  l_sql_id varchar2(13) := :sql_id;
BEGIN
  DBMS_LOB.CREATETEMPORARY(:det, TRUE);
  -- IF :minsnap is not null and :maxsnap is not null  -- PSRv8
  IF :minsnap <> -1 and :maxsnap <> -1 
  THEN
    select least(min(mi.begin_interval_time), min(sample_time)) mint, 
           greatest(max(mx.end_interval_time), max(sample_time)) maxt,
           ((cast(greatest(max(mx.end_interval_time), max(sample_time)) as date) - cast(least(min(mi.begin_interval_time), min(sample_time)) as date))  * 24 * 3600) dura1 
      into l_start_time, l_end_time, l_duration
      from dba_hist_snapshot mi, dba_hist_snapshot mx, gv$active_session_history ash
     where mi.snap_id = :minsnap
       and mi.dbid = ^^dbid.
       and mx.snap_id = :maxsnap
       and mx.dbid = ^^dbid.
       and ash.sql_id = :sql_id
    ;
  ELSE
    select min(sample_time) mint, 
           max(sample_time) maxt, 
           ((cast(max(sample_time) as date) - cast(min(sample_time) as date)) * 24 * 3600) dura1 
      into l_start_time, l_end_time, l_duration
      from gv$active_session_history ash
     where ash.sql_id = :sql_id
    ;
  END IF;

  IF l_start_time is not null and DBMS_DB_VERSION.version < 12 THEN
    l_duration := GREATEST(NVL(l_duration, 0), 24 * 3600); -- at least 1 day

    :det := DBMS_SQLTUNE.REPORT_SQL_DETAIL(
       sql_id       => :sql_id,
       start_time   => l_start_time,
       duration     => l_duration,
       report_level => 'ALL',
       type         => 'ACTIVE' );

  END IF;

  IF DBMS_DB_VERSION.version > 11 and l_start_time is not null THEN

    $IF DBMS_DB_VERSION.version > 11
    $THEN
       begin
        l_det := DBMS_PERF.REPORT_SQL (
           sql_id       => l_sql_id,
           is_realtime  => 0,
           outer_start_time   => l_start_time,
           outer_end_time     => l_end_time,
           selected_start_time=> l_start_time,
           selected_end_time  => l_end_time,
           inst_id            => null,
           dbid               => ^^dbid.,
           monitor_list_detail=> 5,
           report_reference   => null,
           report_level => 'typical',
           type         => 'ACTIVE' ); 
       end;
    $END
    NULL;
    :det := l_det;
  END IF;
END;
/
rem PRO end -->
SELECT '<!-- '||TO_CHAR(SYSDATE, 'YYYY-MM-DD/HH24:MI:SS')||' -->' FROM dual;
SELECT :det FROM DUAL;
SELECT '<!-- '||TO_CHAR(SYSDATE, 'YYYY-MM-DD/HH24:MI:SS')||' -->' FROM dual;
SPO OFF;
alter session set "_with_subquery"=OPTIMIZER;
/**************************************************************************************************/

/**************************************************************************************************
 *
 * 11g sql monitor report
 *
 **************************************************************************************************/

EXEC DBMS_APPLICATION_INFO.SET_CLIENT_INFO('^^method.: SQL Monitor Report - ' || TO_CHAR(SYSDATE, 'YYYY-MM-DD/HH24:MI:SS'));
PRO SQL Monitor Report
PRO
SELECT TO_CHAR(SYSDATE, 'YYYY-MM-DD/HH24:MI:SS') FROM dual;
PRO Please Wait

SPO ^^files_prefix._5_sql_monitor.sql;
PRO -- SQL Monitor Report for ^^sql_id.

DECLARE
  l_count NUMBER := 0;
  TYPE mon_rt IS RECORD (
    sql_exec_start DATE,
    file_name varchar2(20),
    sql_exec_id NUMBER,
    sql_plan_hash_value NUMBER,
    inst_id NUMBER,
    elapsed_time number,
    rank_by_start number,
    rank_by_elapsed_desc number,
    rank_by_elapsed_asc number
   );
  mon_rec mon_rt;
  mon_cv SYS_REFCURSOR;

    --PSRv10
    PROCEDURE print_commands (
        mon_rec IN mon_rt
      , p_rpt_typ IN varchar2
    )
    IS
    BEGIN

      DBMS_OUTPUT.PUT_LINE('EXEC :mon_exec_start := '''||TO_CHAR(mon_rec.sql_exec_start, 'YYYYMMDDHH24MISS')||''';');
      DBMS_OUTPUT.PUT_LINE('EXEC :mon_exec_id := '||TO_CHAR(mon_rec.sql_exec_id)||';');
      DBMS_OUTPUT.PUT_LINE('EXEC :mon_sql_plan_hash_value := '||TO_CHAR(mon_rec.sql_plan_hash_value)||';');
      DBMS_OUTPUT.PUT_LINE('EXEC :mon_inst_id := '||TO_CHAR(mon_rec.inst_id)||';');
      DBMS_OUTPUT.PUT_LINE('SPO ^^files_prefix._'||mon_rec.file_name||'_'||TO_CHAR(mon_rec.sql_exec_id)||'_'||TO_CHAR(mon_rec.sql_plan_hash_value)||'_'||TO_CHAR(mon_rec.inst_id)||'_5_sql_monitor'||case when p_rpt_typ = 'ACTIVE' then '.html;' when p_rpt_typ = 'TEXT' then '.txt;' end);
      -- DBMS_OUTPUT.PUT_LINE('SELECT ''<!-- ''||TO_CHAR(SYSDATE, ''YYYY-MM-DD/HH24:MI:SS'')||'' -->'' FROM dual;');
      -- DBMS_OUTPUT.PUT_LINE('PRO <!-- begin DBMS_SQLTUNE.REPORT_SQL_MONITOR');
      DBMS_OUTPUT.PUT_LINE('BEGIN');

      IF DBMS_DB_VERSION.version > 11 THEN -- PSRv7

        $IF DBMS_DB_VERSION.version > 11
        $THEN
          DBMS_OUTPUT.PUT_LINE('  :mon_report := DBMS_SQL_MONITOR.report_sql_monitor(');
        $END
        NULL; -- PSRv8
      ELSE
        DBMS_OUTPUT.PUT_LINE('  :mon_report := DBMS_SQLTUNE.REPORT_SQL_MONITOR (');
      END IF;
      DBMS_OUTPUT.PUT_LINE('    sql_id         => :mon_sql_id,');
      DBMS_OUTPUT.PUT_LINE('    sql_exec_start => TO_DATE(:mon_exec_start, ''YYYYMMDDHH24MISS''),');
      DBMS_OUTPUT.PUT_LINE('    sql_exec_id    => :mon_exec_id,');
      DBMS_OUTPUT.PUT_LINE('    report_level   => ''ALL'',');
      DBMS_OUTPUT.PUT_LINE('    type           => '''||p_rpt_typ||''' );');
      DBMS_OUTPUT.PUT_LINE('END;');
      DBMS_OUTPUT.PUT_LINE('/');
      --DBMS_OUTPUT.PUT_LINE('PRO end -->');
      DBMS_OUTPUT.PUT_LINE('SELECT ''<!-- ''||TO_CHAR(SYSDATE, ''YYYY-MM-DD/HH24:MI:SS'')||'' -->'' FROM dual;');

      IF '^^rdbms_version.' LIKE '11.1%' THEN
        DBMS_OUTPUT.PUT_LINE('PRO <html>');
        DBMS_OUTPUT.PUT_LINE('PRO <head>');
        DBMS_OUTPUT.PUT_LINE('PRO  <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>');
        DBMS_OUTPUT.PUT_LINE('PRO  <base href="http://download.oracle.com/otn_software/"/>');
        DBMS_OUTPUT.PUT_LINE('PRO  <script language="javascript" type="text/javascript" src="emviewers/scripts/flashver.js">');
        DBMS_OUTPUT.PUT_LINE('PRO   <!--Test flash version-->');
        DBMS_OUTPUT.PUT_LINE('PRO  </script>');
        DBMS_OUTPUT.PUT_LINE('PRO  <style>');
        DBMS_OUTPUT.PUT_LINE('PRO      body { margin: 0px; overflow:hidden }');
        DBMS_OUTPUT.PUT_LINE('PRO    </style>');
        DBMS_OUTPUT.PUT_LINE('PRO </head>');
        DBMS_OUTPUT.PUT_LINE('PRO <body scroll="no">');
        DBMS_OUTPUT.PUT_LINE('PRO  <script type="text/xml">');
        DBMS_OUTPUT.PUT_LINE('PRO   <!--FXTMODEL-->');
      END IF;

      DBMS_OUTPUT.PUT_LINE('SELECT :mon_report FROM DUAL;');

      IF '^^rdbms_version.' LIKE '11.1%' THEN
        DBMS_OUTPUT.PUT_LINE('PRO    <!--FXTMODEL-->');
        DBMS_OUTPUT.PUT_LINE('PRO   </script>');
        DBMS_OUTPUT.PUT_LINE('PRO   <script language="JavaScript" type="text/javascript" src="emviewers/scripts/loadswf.js">');
        DBMS_OUTPUT.PUT_LINE('PRO    <!--Load report viewer-->');
        DBMS_OUTPUT.PUT_LINE('PRO   </script>');
        DBMS_OUTPUT.PUT_LINE('PRO   <iframe name="_history" frameborder="0" scrolling="no" width="22" height="0">');
        DBMS_OUTPUT.PUT_LINE('PRO    <html>');
        DBMS_OUTPUT.PUT_LINE('PRO     <head>');
        DBMS_OUTPUT.PUT_LINE('PRO      <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1"/>');
        DBMS_OUTPUT.PUT_LINE('PRO      <script type="text/javascript" language="JavaScript1.2" charset="utf-8">');
        DBMS_OUTPUT.PUT_LINE('PRO                 var v = new top.Vars(top.getSearch(window)); <!-- ; -->');
        DBMS_OUTPUT.PUT_LINE('PRO                 var fv = v.toString("$_"); <!-- ; -->');
        DBMS_OUTPUT.PUT_LINE('PRO               </script>');
        DBMS_OUTPUT.PUT_LINE('PRO     </head>');
        DBMS_OUTPUT.PUT_LINE('PRO     <body>');
        DBMS_OUTPUT.PUT_LINE('PRO      <script type="text/javascript" language="JavaScript1.2" charset="utf-8" src="emviewers/scripts/document.js">');
        DBMS_OUTPUT.PUT_LINE('PRO       <!--Run document script-->');
        DBMS_OUTPUT.PUT_LINE('PRO      </script>');
        DBMS_OUTPUT.PUT_LINE('PRO     </body>');
        DBMS_OUTPUT.PUT_LINE('PRO    </html>');
        DBMS_OUTPUT.PUT_LINE('PRO   </iframe>');
        DBMS_OUTPUT.PUT_LINE('PRO  </body>');
        DBMS_OUTPUT.PUT_LINE('PRO </html>');
      END IF;

      DBMS_OUTPUT.PUT_LINE('SELECT ''<!-- ''||TO_CHAR(SYSDATE, ''YYYY-MM-DD/HH24:MI:SS'')||'' -->'' FROM dual;');
      DBMS_OUTPUT.PUT_LINE('SPO OFF;');
    END print_commands;
BEGIN
  IF :license = 'T' AND '^^rdbms_version.' >= '11' THEN
    DBMS_OUTPUT.PUT_LINE('VAR mon_exec_start VARCHAR2(14);');
    DBMS_OUTPUT.PUT_LINE('VAR mon_exec_id NUMBER;');
    DBMS_OUTPUT.PUT_LINE('VAR mon_sql_plan_hash_value NUMBER;');
    DBMS_OUTPUT.PUT_LINE('VAR mon_inst_id NUMBER;');
    DBMS_OUTPUT.PUT_LINE('VAR mon_report CLOB;');
    DBMS_OUTPUT.PUT_LINE('VAR mon_sql_id VARCHAR2(13);');
    DBMS_OUTPUT.PUT_LINE('EXEC :mon_sql_id := ''^^sql_id.'';');
    DBMS_OUTPUT.PUT_LINE('SET ECHO OFF FEED OFF VER OFF SHOW OFF HEA OFF LIN 2000 NEWP NONE PAGES 0 LONG 2000000 LONGC 2000 SQLC MIX TAB ON TRIMS ON TI OFF TIMI OFF ARRAY 100 NUMF "" SQLP SQL> SUF sql BLO . RECSEP OFF APPI OFF AUTOT OFF;');

    -- cursor variable to avoid error on 10g since v$sql_monitor didn't exist then
--Uday.Replaced with below.v6    OPEN mon_cv FOR
--Uday.Replaced with below.v6      'SELECT DISTINCT '||
--Uday.Replaced with below.v6      '       sql_exec_start, '||
--Uday.Replaced with below.v6      '       sql_exec_id, '||
--Uday.Replaced with below.v6      '       sql_plan_hash_value, '||
--Uday.Replaced with below.v6      '       inst_id '||
--Uday.Replaced with below.v6      '  FROM gv$sql_monitor /* 11g */ '||
--Uday.Replaced with below.v6      ' WHERE process_name = ''ora'' '||
--Uday.Replaced with below.v6      '   AND sql_id = ''^^sql_id.'' '||
--Uday.Replaced with below.v6      ' ORDER BY '||
--Uday.Replaced with below.v6      '       1, '||
--Uday.Replaced with below.v6      '       2';
    OPEN mon_cv FOR
       q'[
       select * from (
       SELECT distinct
              sql_exec_start,
              to_char(sql_exec_start, 'ddmon_hh24mmss'),
              sql_exec_id,
              sql_plan_hash_value,
              inst_id
              , elapsed_time/1000000 elapsed_time
              , rank() over(partition by sql_plan_hash_value order by sql_exec_start desc) rank_by_start
              , rank() over(partition by sql_plan_hash_value order by elapsed_time desc) rank_by_elapsed_desc
              , rank() over(partition by sql_plan_hash_value order by elapsed_time) rank_by_elapsed_asc  -- PSRv10
         FROM gv$sql_monitor 
        WHERE process_name = 'ora'
          AND sql_id = :sql_id
       )
        -- where rank_by_start <= 2 or rank_by_elapsed = 1
        where rank_by_start <= 2 or rank_by_elapsed_desc <= 2 or rank_by_elapsed_asc <= 2 -- PSRv10
        -- ORDER BY 3, 1 desc, 2
        ORDER BY sql_plan_hash_value, sql_exec_start desc, sql_exec_id
      ]' using :sql_id;

    LOOP
      FETCH mon_cv INTO mon_rec;
      EXIT WHEN mon_cv%NOTFOUND;

      l_count := l_count + 1;
      IF l_count > ^^sql_monitor_reports. THEN
        EXIT; -- exits loop
      END IF;
      print_commands(mon_rec, 'ACTIVE'); -- PSRv10
      print_commands(mon_rec, 'TEXT');   -- PSRv10

    END LOOP;
    CLOSE mon_cv;
  ELSE
    DBMS_OUTPUT.PUT_LINE('-- SQL Monitor Reports are available on 11.1 and higher, and they are part of the Oracle Tuning pack.');
  END IF;
END;
/

SPO OFF;

PRO SQL Monitor Report from AWR
PRO
SELECT TO_CHAR(SYSDATE, 'YYYY-MM-DD/HH24:MI:SS') FROM dual;
PRO Please Wait

SPO ^^files_prefix._5_sql_monitor.sql append;
PRO -- SQL Monitor Report for ^^sql_id.

DECLARE
  l_count NUMBER := 0;
  TYPE mon_rt IS RECORD (
    sql_exec_start DATE,
    file_name varchar2(20),
    report_id NUMBER,
    sql_exec_id NUMBER,
    sql_plan_hash_value NUMBER,
    inst_id NUMBER,
    elapsed_time number,
    rank_by_start number,
    rank_by_elapsed_desc number,
    rank_by_elapsed_asc number
   );
  mon_rec mon_rt;
  mon_cv SYS_REFCURSOR;
BEGIN
  IF :license = 'T' 
  THEN
    $IF DBMS_DB_VERSION.version > 11
    $THEN

      DBMS_OUTPUT.PUT_LINE('VAR mon_exec_id NUMBER;');
      DBMS_OUTPUT.PUT_LINE('VAR mon_report_id NUMBER;');
      DBMS_OUTPUT.PUT_LINE('VAR mon_sql_plan_hash_value NUMBER;');
      DBMS_OUTPUT.PUT_LINE('VAR mon_inst_id NUMBER;');
      DBMS_OUTPUT.PUT_LINE('VAR mon_report CLOB;');
      DBMS_OUTPUT.PUT_LINE('VAR mon_sql_id VARCHAR2(13);');
      DBMS_OUTPUT.PUT_LINE('SET ECHO OFF FEED OFF VER OFF SHOW OFF HEA OFF LIN 2000 NEWP NONE PAGES 0 LONG 2000000 LONGC 2000 SQLC MIX TAB ON TRIMS ON TI OFF TIMI OFF ARRAY 100 NUMF "" SQLP SQL> SUF sql BLO . RECSEP OFF APPI OFF AUTOT OFF;');


      OPEN mon_cv FOR
         q'~
            with awr_sql_monitor as
            (
              SELECT report_id, instance_number, key1 sql_id, key2 sql_exec_id, to_date(key3, 'MM/DD/YYYY HH24:MI:SS')  sql_exec_start
                     , to_number(regexp_substr(report_summary, q'{<stat name="elapsed_time">([[:digit:]]+)</stat>}', 1, 1, null, 1)) elapsed_time
                     , regexp_substr(report_summary, q'{<plan_hash>([[:digit:]]+)</plan_hash>}', 1, 1, null, 1)  phv
                FROM dba_hist_reports
               WHERE component_name = 'sqlmonitor'
                 AND key1 = '^^sql_id'
                 --  and EXTRACTVALUE(XMLType(report_summary),'/report_repository_summary/sql/plan_hash') not in
                 --  PSRv9.1
                 -- and regexp_substr(report_summary, q'{<plan_hash>([[:digit:]]+)</plan_hash>}', 1, 1, null, 1) in 
                 --     (
                 --      SELECT distinct sql_plan_hash_value
                 --        FROM gv$sql_monitor
                 --       WHERE process_name = 'ora'
                 --         AND sql_id = '^^sql_id'
                 --     )
            )
            , awr_sql_monitor2 as 
            (
            select distinct 
                          sql_exec_start,
                          to_char(sql_exec_start, 'ddmon_hh24mmss'),
                          report_id,
                          sql_exec_id,
                          phv,
                          instance_number
                          , elapsed_time/1000000 elapsed_time
                          , rank() over(partition by phv order by sql_exec_start desc) rank_by_start
                          , rank() over(partition by phv order by elapsed_time desc) rank_by_elapsed_desc
                          , rank() over(partition by phv order by elapsed_time) rank_by_elapsed_asc  -- PSRv9.1
              from awr_sql_monitor
            )
            select *
              from awr_sql_monitor2
             where rank_by_start <= 2 or rank_by_elapsed_desc <= 2 or rank_by_elapsed_asc <= 2 -- PSRv9.1
             ORDER BY phv, sql_exec_start desc, sql_exec_id
        ~';

      LOOP
        FETCH mon_cv INTO mon_rec;
        EXIT WHEN mon_cv%NOTFOUND;

        l_count := l_count + 1;
        IF l_count > ^^sql_monitor_reports. THEN
          EXIT; -- exits loop
        END IF;

        DBMS_OUTPUT.PUT_LINE('EXEC :mon_exec_start := '''||TO_CHAR(mon_rec.sql_exec_start, 'YYYYMMDDHH24MISS')||''';');
        DBMS_OUTPUT.PUT_LINE('EXEC :mon_report_id := '||TO_CHAR(mon_rec.report_id)||';');
        DBMS_OUTPUT.PUT_LINE('EXEC :mon_exec_id := '||TO_CHAR(mon_rec.sql_exec_id)||';');
        DBMS_OUTPUT.PUT_LINE('EXEC :mon_sql_plan_hash_value := '||TO_CHAR(mon_rec.sql_plan_hash_value)||';');
        DBMS_OUTPUT.PUT_LINE('EXEC :mon_inst_id := '||TO_CHAR(mon_rec.inst_id)||';');
        DBMS_OUTPUT.PUT_LINE('--============');
        -- DBMS_OUTPUT.PUT_LINE('SPO ^^files_prefix._'||TO_CHAR(mon_rec.sql_exec_id)||'_'||TO_CHAR(mon_rec.sql_plan_hash_value)||'_'||TO_CHAR(mon_rec.inst_id)||'_5_awr_sql_monitor.html;');
        DBMS_OUTPUT.PUT_LINE('SPO ^^files_prefix._'||mon_rec.file_name||'_'||TO_CHAR(mon_rec.sql_exec_id)||'_'||TO_CHAR(mon_rec.sql_plan_hash_value)||'_'||TO_CHAR(mon_rec.inst_id)||'_5_awr_sql_monitor.html;');
        DBMS_OUTPUT.PUT_LINE('SELECT ''<!-- ''||TO_CHAR(SYSDATE, ''YYYY-MM-DD/HH24:MI:SS'')||'' -->'' FROM dual;');
        --DBMS_OUTPUT.PUT_LINE('PRO <!-- begin DBMS_AUTO_REPORT.REPORT_REPOSITORY_DETAIL -->');
        DBMS_OUTPUT.PUT_LINE('BEGIN');
        DBMS_OUTPUT.PUT_LINE('  :mon_report := DBMS_AUTO_REPORT.REPORT_REPOSITORY_DETAIL(');
        DBMS_OUTPUT.PUT_LINE('    rid  => :mon_report_id,');
        DBMS_OUTPUT.PUT_LINE('    type => ''ACTIVE'' );');
        DBMS_OUTPUT.PUT_LINE('END;');
        DBMS_OUTPUT.PUT_LINE('/');
        --DBMS_OUTPUT.PUT_LINE('PRO <!-- end -->');
        DBMS_OUTPUT.PUT_LINE('SELECT ''<!-- ''||TO_CHAR(SYSDATE, ''YYYY-MM-DD/HH24:MI:SS'')||'' -->'' FROM dual;');

        DBMS_OUTPUT.PUT_LINE('SELECT :mon_report FROM DUAL;');

        DBMS_OUTPUT.PUT_LINE('SELECT ''<!-- ''||TO_CHAR(SYSDATE, ''YYYY-MM-DD/HH24:MI:SS'')||'' -->'' FROM dual;');
        DBMS_OUTPUT.PUT_LINE('SPO OFF;');
        DBMS_OUTPUT.PUT_LINE('--============');
      END LOOP;
      CLOSE mon_cv;
    $END
    NULL;
  END IF;
END;
/
SPO OFF;

-- 11g
@^^files_prefix._5_sql_monitor.sql

/**************************************************************************************************
 *
 * Uday.PSR.v6
 * - Monitored SQL Binds
 *
 **************************************************************************************************/

EXEC DBMS_APPLICATION_INFO.SET_CLIENT_INFO('^^method.: Monitored SQLs Binds ' || TO_CHAR(SYSDATE, 'YYYY-MM-DD/HH24:MI:SS'));
PRO Fetching Monitored SQLs Binds and Bind Values
PRO
SELECT TO_CHAR(SYSDATE, 'YYYY-MM-DD/HH24:MI:SS') FROM dual;
PRO Please Wait

SET heading on pages 1000
REM Pushkar - converted binds to html format
SPO ^^files_prefix._51_sqlmonitor_binds.html;

PRO <style type="text/css">
PRO body {font:10pt Arial,Helvetica,Verdana,Geneva,sans-serif; color:black; background:white;}
PRO table {font-size:8pt; color:black; background:white;}
PRO th {font-weight:bold; background:#cccc99; color:#336699; vertical-align:bottom; padding-left:3pt; padding-right:3pt; padding-top:1pt; padding-bottom:1pt; position:sticky; top:0;}
PRO td {text-align:left; background:#fcfcf0; vertical-align:top; padding-left:3pt; padding-right:3pt; padding-top:1pt; padding-bottom:1pt;}
PRO </style>

set markup html on

PRO ------------------------------------;
PRO Monitored SQLs Binds and Bind Values
PRO ------------------------------------;

col name for a35 heading "Bind Variable Name"
col val for a40 heading "Bind Value"
col dty for a20 heading "Data Type"
col pos for 999 heading "Position"
col et heading "Elapsed|Time(s)"
col buffer_gets heading "Buffer|Gets"
col sql_plan_hash_value heading "PHV"
col sql_exec_start for a21 heading "SQL Exec|Start"

break on sql_exec_id on sql_exec_start on sql_plan_hash_value on et on buffer_gets skip 1

set timing on
with smon_binds as
(
SELECT c.sql_exec_id, c.sql_exec_start, c.sql_plan_hash_value, round(elapsed_time/1000000,2) et, buffer_gets,
       to_number(EXTRACTVALUE(VALUE(D), '/bind/@pos')) pos,
       EXTRACTVALUE(VALUE(D), '/bind/@name') name, 
       EXTRACTVALUE(VALUE(D), '/bind') val,
       EXTRACTVALUE(VALUE(D), '/bind/@dtystr') dty
FROM
 gv$sql_monitor c
 , TABLE(XMLSEQUENCE(EXTRACT(XMLTYPE(c.BINDS_XML ), '/binds/bind'))) D
where c.sql_id = :sql_id
  and c.binds_xml is not null
)
select sql_exec_id, sql_exec_start, sql_plan_hash_value, et, buffer_gets, pos, name
       , case when dty like 'TIMEST%' THEN
               rtrim(
                    to_char(100*(to_number(substr(val,1,2),'XX')-100)
                            + (to_number(substr(val,3,2),'XX')-100),'fm0000')||'-'||
                    to_char(to_number(substr(val,5,2),'XX'),'fm00')||'-'||
                    to_char(to_number(substr(val,7,2),'XX'),'fm00')||' '||
                    to_char(to_number(substr(val,9,2),'XX')-1,'fm00')||':'||
                    to_char(to_number(substr(val,11,2),'XX')-1,'fm00')||':'||
                    to_char(to_number(substr(val,13,2),'XX')-1,'fm00')
                    ||'.'||to_number(substr(val,15,8),'XXXXXXXX')  
               )
              when (dty like 'VARCHAR%' and :pii_used>0) then substr(val,1,length(val)/3+1)||rpad('***********************************', length(val)*2/3)               
         else val
         end val 
       , dty
  from smon_binds
order by sql_exec_start, sql_exec_id, pos
;
set timing off


PRO 
set markup html off
SPO OFF;

/**************************************************************************************************/

/**************************************************************************************************
 *
 * Uday (Fusion PSR):
 * - Hard parse pct at each FA user level 
 * - VPD policies at child cursor level
 *
 **************************************************************************************************/

EXEC DBMS_APPLICATION_INFO.SET_CLIENT_INFO('^^method.: Hard Parse percent ' || TO_CHAR(SYSDATE, 'YYYY-MM-DD/HH24:MI:SS'));
PRO Hard Parse percent by user (client_id) from AWR and ASH
PRO
SELECT TO_CHAR(SYSDATE, 'YYYY-MM-DD/HH24:MI:SS') FROM dual;
PRO Please Wait

col sql_plan_hash_value heading "Plan Hash|Value"
col client_id for a30 heading "User"
col cnt for 999999999 heading "Samples"
col execs for 999999999 heading "Executions"
col hp_cnt for 999999999 heading "Total|HardParse|Samples"
col hp_pct for 999999999 heading "HardParse|Pct"
col minst for a35 heading "MinSampleTime"
col maxst for a35 heading "MaxSampleTime"
col elap for a35 heading "Elapsed"
col ecid_cnt for 999999 heading "#of|ECIDs"
col min_ecid_hp_cnt for 9999 heading "~Min|Hard|Parse|Time"
col max_ecid_hp_cnt for 9999 heading "~Max|Hard|Parse|Time"

SET heading on pages 1000

--Uday.PSR.v6 : replaced with better one: added min/max hpt
--Uday.PSR.v6 select sql_id, client_id, count(*) cnt, count(distinct sql_exec_start) execs, count(distinct ecid) ecid_cnt
--Uday.PSR.v6        , sum(case when in_hard_parse = 'Y' then 1 else 0 end) hp_cnt
--Uday.PSR.v6        , round((sum(case when in_hard_parse = 'Y' then 1 else 0 end)/count(*))*100 ,2) hp_pct
--Uday.PSR.v6        -- , sum(case when in_hard_parse = 'N' then 1 else 0 end) exec_cnt
--Uday.PSR.v6        , min(sample_time) minst, max(sample_time) maxst, max(sample_time)-min(sample_time) elap
--Uday.PSR.v6   from gv$active_session_history ash
--Uday.PSR.v6  where sql_id = :sql_id
--Uday.PSR.v6  group by sql_id, client_id
--Uday.PSR.v6  order by  sql_id, hp_pct desc, cnt desc
--Uday.PSR.v6 ;
--Uday.PSR.v6 

SPO ^^files_prefix._10_hardParsePctByUser.txt;

PRO
PRO ---------------------------------------------------------;
PRO Hard Parse percent by user (client_id) from in-memory ASH:;
PRO ---------------------------------------------------------;
PRO
PRO
-- set timing on
with hp as
(
select sql_id, client_id, sql_exec_start, ecid, in_hard_parse, sample_time
       , sum(case when in_hard_parse = 'Y' then 1 else 0 end) over(partition by sql_id, client_id, ecid) ecid_hp_cnt 
  from gv$active_session_history ash
 where 1=1
   and sql_id = :sql_id
)
select sql_id, client_id, count(*) cnt, count(distinct sql_exec_start) execs, count(distinct ecid) ecid_cnt
       , min(ecid_hp_cnt) min_ecid_hp_cnt, max(ecid_hp_cnt) max_ecid_hp_cnt
       , sum(case when in_hard_parse = 'Y' then 1 else 0 end) hp_cnt
       , round((sum(case when in_hard_parse = 'Y' then 1 else 0 end)/count(*))*100 ,2) hp_pct
       -- , sum(case when in_hard_parse = 'N' then 1 else 0 end) exec_cnt
       , min(sample_time) minst, max(sample_time) maxst
       -- , max(sample_time)-min(sample_time) elap
  from hp
 where 1=1
 group by sql_id, client_id
 order by sql_id, hp_pct desc, cnt desc
;
-- set timing off

-- Uday.PSR.v6 replacing with better one
-- Uday.PSR.v6 with snaps as (select /*+ materialize */ sql_id, min(snap_id) minsnap, max(snap_id) maxsnap from dba_hist_sqlstat where sql_id = :sql_id group by sql_id)
-- Uday.PSR.v6 select /*+ leading(snaps ash) no_merge */ 
-- Uday.PSR.v6        ash.sql_id, sql_plan_hash_value, client_id, count(*) cnt, count(distinct sql_exec_start) execs
-- Uday.PSR.v6        , sum(case when in_hard_parse = 'Y' then 1 else 0 end) hp_cnt
-- Uday.PSR.v6        , round((sum(case when in_hard_parse = 'Y' then 1 else 0 end)/count(*))*100 ,2) hp_pct
-- Uday.PSR.v6        -- , sum(case when in_hard_parse = 'N' then 1 else 0 end) exec_cnt
-- Uday.PSR.v6        , min(sample_time) minst, max(sample_time) maxst, max(sample_time)-min(sample_time) elap
-- Uday.PSR.v6   from dba_hist_active_sess_history ash
-- Uday.PSR.v6        , snaps
-- Uday.PSR.v6  WHERE :license IN ('T', 'D')
-- Uday.PSR.v6    AND ash.dbid = ^^dbid.
-- Uday.PSR.v6    and ash.sql_id = snaps.sql_id
-- Uday.PSR.v6    and ash.snap_id between snaps.minsnap and snaps.maxsnap
-- Uday.PSR.v6  group by ash.sql_id, sql_plan_hash_value, client_id
-- Uday.PSR.v6  order by  ash.sql_id, hp_pct desc, cnt desc, sql_plan_hash_value
-- Uday.PSR.v6 ;

PRO
PRO Hard Parse percent by user (client_id) from on-disk AWR:
PRO -------------------------------------------------------;
PRO

-- set timing on
with hp as 
	(
	select ash.sql_id, client_id, sql_exec_start, ecid, in_hard_parse, sample_time
	       , sum(case when in_hard_parse = 'Y' then 1 else 0 end) over(partition by ash.sql_id, client_id, ecid) ecid_hp_cnt 
	  from dba_hist_active_sess_history ash
	 WHERE 1=1
	   and :license IN ('T', 'D', 'L')
	   and ash.dbid = ^^dbid.
	   and ash.sql_id = :sql_id
	   and ash.snap_id between :minsnap and :maxsnap
	   and ecid is not null
	-- order by sql_id, ecid  
	)
select /*+ leading(ash) no_merge */
       sql_id, client_id, count(*) cnt, count(distinct sql_exec_start) execs, count(distinct ecid) ecid_cnt
       , min(ecid_hp_cnt) min_ecid_hp_cnt, max(ecid_hp_cnt) max_ecid_hp_cnt
       , sum(case when in_hard_parse = 'Y' then 1 else 0 end) hp_cnt
       , round((sum(case when in_hard_parse = 'Y' then 1 else 0 end)/count(*))*100 ,2) hp_pct
       , min(sample_time) minst, max(sample_time) maxst
  from hp
 group by sql_id, client_id
 order by sql_id, hp_pct desc, cnt desc
;
-- set timing off

PRO
PRO ---------------------------------;
PRO Hard Parse By ECID - Last 7 Days
PRO ---------------------------------;
PRO

COL CNT FOR 999
COL ECID FOR A64
COL START_TIME FOR A26
COL END_TIME FOR A26
COL ELAPSED_TIME FOR A20

select inst_id,
       client_id,
       ecid,
       cnt,
       start_time,
       end_time,
       extract(hour from elapsed_time)||':'||extract(minute from elapsed_time)||':'||extract(second from elapsed_time) elapsed_time
from
(
  select inst_id,
         client_id,
         ecid,
         count(*) cnt,
         min(sample_time) start_time,
         max(sample_time) end_time,
         max(sample_time) - min(sample_time) elapsed_time
  from gv$active_session_history
  where sql_id = :sql_id
  and in_hard_parse = 'Y'
  and sample_time > sysdate - 7
  and ecid is not null
  group by inst_id, client_id, ecid
  having count(*) > 1
  union
  select instance_number inst_id,
         client_id,
         ecid,
         count(*) cnt,
         min(sample_time) start_time,
         max(sample_time) end_time,
         max(sample_time) - min(sample_time) elapsed_time
  from dba_hist_active_sess_history
  where sql_id = :sql_id
  and in_hard_parse = 'Y'
  and sample_time > sysdate - 7
  and ecid is not null
  group by instance_number, client_id, ecid
  having count(*) > 1
)
order by start_time;

PRO 
PRO 

SPO OFF;


EXEC DBMS_APPLICATION_INFO.SET_CLIENT_INFO('^^method.: VPD policy ' || TO_CHAR(SYSDATE, 'YYYY-MM-DD/HH24:MI:SS'));
PRO Getting VPD Policies for each child cursor
PRO
SELECT TO_CHAR(SYSDATE, 'YYYY-MM-DD/HH24:MI:SS') FROM dual;
PRO Please Wait


col child_number for 999 heading "Ch#"
BREAK ON ROW SKIP 1
SPO ^^files_prefix._11_VPD_Policies.txt;

PRO
PRO
PRO VPD Policies for each child cursor from memory:
PRO ----------------------------------------------;
PRO

-- set timing on
select distinct p.sql_id, p.inst_id, p.child_number, p.object_name, p.policy, p.predicate
  from gv$vpd_policy p, gv$sql s
 where s.sql_id = :sql_id
   and s.inst_id = p.inst_id
   and s.sql_id  = p.sql_id
   and s.child_number = p.child_number
   -- and p.policy like '%PII%'
 order by p.sql_id, p.inst_id, p.child_number, p.policy
;
-- set timing off

PRO 
SPO OFF;
SET heading off pages 0
clear breaks

/**************************************************************************************************
 *
 * Uday (Fusion PSR): v6
 * - Histogram Actual Values
 *
 **************************************************************************************************/

EXEC DBMS_APPLICATION_INFO.SET_CLIENT_INFO('^^method.: Histogram Actual Values ' || TO_CHAR(SYSDATE, 'YYYY-MM-DD/HH24:MI:SS'));
PRO Fetching Histogram Actual Values
PRO
SELECT TO_CHAR(SYSDATE, 'YYYY-MM-DD/HH24:MI:SS') FROM dual;
PRO Please Wait

/* -------------------------
 *
 * Uday.PSR.v6
 * inserting tables used in the plans into PLAN_TABLE to improve performance 
 * - with clause is repeated in all the diagnostic SQLs.
 * - slow performance, especially 'table columns'
 *
 * ------------------------- */

DELETE plan_table where STATEMENT_ID = :sql_id;
commit;
insert into plan_table(STATEMENT_ID, object_owner, object_type, object_name, cardinality, cost, optimizer, object_alias, operation, options, io_cost, bytes)
  WITH  
    object AS (
       SELECT /*+ MATERIALIZE */
              object_owner owner, object_name name, object_type
         FROM gv$sql_plan
        WHERE inst_id IN (SELECT inst_id FROM gv$instance)
          AND sql_id = :sql_id
          AND object_owner IS NOT NULL
          AND object_name IS NOT NULL
          AND not (object_type = 'TABLE (TEMP)' and object_name like 'SYS_TEMP%') --Uday.v6
        UNION
       SELECT object_owner owner, object_name name, object_type
         FROM dba_hist_sql_plan
        WHERE :license IN ('T', 'D', 'L')
          AND dbid = ^^dbid.
          AND sql_id = :sql_id
          AND object_owner IS NOT NULL
          AND object_name IS NOT NULL
          AND not (object_type = 'TABLE (TEMP)' and object_name like 'SYS_TEMP%') --Uday.v6
    )
    , plan_tables AS (
         SELECT /*+ MATERIALIZE */
                'TABLE' object_type, o.owner object_owner, o.name object_name
           FROM object o
          WHERE (o.object_type like 'TABLE%' OR o.object_type like 'MAT_VIEW%')
          UNION
         SELECT /*+ leading (o) */ 'TABLE' object_type, i.table_owner object_owner, i.table_name object_name
           FROM dba_indexes i,
                object o
          WHERE o.object_type like 'INDEX%'  --Uday.v6
            AND i.owner = o.owner
            AND i.index_name = o.name
          UNION
         SELECT /*+ leading (o) */ 'TABLE' object_type, t.owner object_owner, t.table_name object_name
           FROM dba_tables t,
                object o
          WHERE t.owner = o.owner
            AND t.table_name = o.name
            AND o.object_type IS NULL /* PUSHKAR 10.8: this helps in insert statement analysis */            
    )
         -- (object_owner, object type,    object_name,  cardinality, cost,         
  -- select t.owner,          pt.object_type, t.table_name, t.num_rows,  t.sample_size, 
  select distinct :sql_id, t.owner,          pt.object_type, t.table_name, t.num_rows,  t.sample_size, 
         -- OPTIMIZER
         TO_CHAR(t.last_analyzed, 'YYYY-MM-DD/HH24:MI:SS') last_analyzed, 
         -- object_alias, operation,   options, io_cost,  bytes
         temporary,       partitioned, degree,  t.blocks, t.avg_row_len
    from plan_tables pt, dba_tables t
   where t.table_name = pt.object_name
     and t.owner = pt.object_owner
  ;
SET heading on pages 50000 trims on verify off feedback off

rem select STATEMENT_ID, object_type, object_owner, object_name from plan_table;
rem pause;

SPO ^^files_prefix._12_histogram_actual_values.html;

rem PRO <style type="text/css">
rem PRO body {font:10pt Arial,Helvetica,Verdana,Geneva,sans-serif; color:black; background:white;}
rem PRO table {font-size:8pt; color:black; background:white;}
rem PRO th {font-weight:bold; background:#cccc99; color:#336699; vertical-align:bottom; padding-left:3pt; padding-right:3pt; padding-top:1pt; padding-bottom:1pt;}
rem PRO td {text-align:left; background:#fcfcf0; vertical-align:top; padding-left:3pt; padding-right:3pt; padding-top:1pt; padding-bottom:1pt;}
rem PRO </style>

rem set markup html on
PRO <html>
PRO <head><title>^^files_prefix._12_histogram_actual_values.html</title></head>
PRO <body><pre>

PRO -----------------------;
PRO Histogram Actual Values
PRO -----------------------;
PRO .                     --- NOTE for HYBRID HISTOGRAM ---;
PRO .            Popularity - IF endpoint_repeat_count > avg SIZE OF the bucket is popular 
PRO .                         ELSE not popular (null)
PRO .
PRO .            Following situations are possible with predicates (assume equi condition)
PRO .            1) popular                   - nn_rows * selectivity
PRO .            2) non popular - WITH BUCKET - nn_rows * greatest (NewDensity, selectivity) 
PRO .            3) non popular - NO   BUCKET - nn_rows * NewDensity

PRO .            NewDensity = ((BktCnt-PopBktCnt)/BktCnt) /(NDV-PopValCnt)
PRO .                         [fraction of non-popularCnt]/[non-popular NDV]
PRO .            BktCnt   = SampleSize
PRO .            PopBktCnt= Sum of Popular endpoint_repeat_counts across popular buckets
PRO .            PopValCnt= How many buckets have popular values

col table_name for a30 heading "Table Name"
col column_name for a30 heading "Column Name"
col approx_value for a30 heading "Approx Value"
col rows_per_bucket for 99999999999 heading "Rows Per|Bucket"
col selectivity for 99.99999999 heading "Selectivity"
column num_rows for 99999999999 heading "Num Rows"
column nn_rows  for 99999999999 heading "Column|Not Null|Rows"
column histogram  for a14 heading "Histogram|Type"
column endpoint_number for 99999999999 heading "Endpoint|Number"
column ENDPOINT_REPEAT_COUNT for 999999999 heading "Endpoint|Repeat|Count"
column POPULAR_REPEAT_COUNT  for 999999999 heading "Popular|Repeat|Count"
column sample_size for 99999999999 heading "SampleSize|BktCnt"
column num_distinct for 99999999999 heading "NDV"
column popular for A7 head "popular|?"

set colsep |

break on table_name skip 2 on num_rows on column_name on nn_rows skip 1

COMPUTE SUM   label PopBktCnt OF popular_repeat_count rows_per_bucket on column_name
COMPUTE COUNT label PopValCnt OF popular on column_name
-- psrv9: added partition by h.column_name to get correct lag value

variable histval refcursor
-- set timing on
BEGIN
  IF '^^rdbms_version' like '11%'
  THEN
    OPEN :histval FOR 
     q'[
         with c as
         (
          select /*+ materialize leading(t) */ t.object_owner owner, t.object_name table_name, 
                 t.cardinality num_rows, c.column_name, c.histogram, 
                 c.sample_size, c.num_nulls, c.num_buckets, c.data_type
            from plan_table t, dba_tab_cols c
           where 1=1
             -- and t.owner = 'FUSION' and t.table_name = 'PER_ALL_ASSIGNMENTS_M' 
             -- and c.column_name in ('ACTION_CODE', 'BUSINESS_UNIT_ID', 'FREEZE_UNTIL_DATE')
             and t.object_owner = c.owner
             and t.object_name  = c.table_name
             AND STATEMENT_ID = '^^sql_id'
             and c.histogram <> 'NONE'
         )
         select /*+ no_merge */ h.table_name, c.num_rows, h.column_name, (c.num_rows-c.num_nulls) nn_rows, c.histogram, c.sample_size, h.endpoint_number
                ,case when regexp_like('^^pii_1',c.table_name,'i') then NULL 
                 else
                   case when c.data_type like '%CHAR%' then
                                   nvl(ENDPOINT_ACTUAL_VALUE,UTL_RAW.CAST_TO_VARCHAR2(SUBSTR(LPAD(TO_CHAR(h.endpoint_value,'fmxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx'),30,'0'),1,12))) ||''
                                 when data_type = 'NUMBER' then
                                   to_char(h.endpoint_value) ||''
                                 when data_type = 'DATE' or data_type like 'TIMESTAMP%' then
                                   to_char(to_date(to_char(trunc(h.endpoint_value)), 'J') + (h.endpoint_value - TRUNC(h.endpoint_value)),'SYYYY / MM / DD HH24:MI:SS') ||''
                   end
                 end approx_value
                ,
                 case when c.histogram IN ('TOP-FREQUENCY', 'FREQUENCY') then
                        round((h.endpoint_number - (lag(h.endpoint_number,1,0) over (partition by h.table_name, h.column_name order by h.endpoint_number))) / c.sample_size * (c.num_rows-c.num_nulls)) 
                     when c.histogram = 'HEIGHT BALANCED' then
                        round((h.endpoint_number - (lag(h.endpoint_number,1,0) over (partition by h.table_name, h.column_name order by h.endpoint_number)) ) / c.num_buckets * (c.num_rows-c.num_nulls)) 
                 end rows_per_bucket
                ,
                 case when c.histogram IN ('TOP-FREQUENCY', 'FREQUENCY') then
                        trunc((h.endpoint_number - lag(h.endpoint_number,1,0) over (partition by h.table_name, h.column_name order by h.endpoint_number)) / c.sample_size,5) 
                     when c.histogram = 'HEIGHT BALANCED' then
                        trunc((h.endpoint_number - lag(h.endpoint_number,1,0) over (partition by h.table_name, h.column_name order by h.endpoint_number)) / c.num_buckets,5)  
                 end selectivity
           from c, dba_tab_histograms h
          where c.owner = h.owner and c.table_name = h.table_name and c.column_name = h.column_name 
          order by h.table_name, h.column_name, h.endpoint_number
       ]';
  ELSIF '^^rdbms_version' like '12%' or '^^rdbms_version' like '19%'
  THEN
    OPEN :histval FOR 
     q'[
         with c as
         (
          select /*+ materialize leading(t) */ t.object_owner owner, t.object_name table_name, 
                 t.cardinality num_rows, c.column_name, c.histogram, 
                 c.sample_size, c.num_nulls, c.num_buckets, c.data_type, c.num_distinct
            from plan_table t, dba_tab_cols c
           where 1=1
             -- and t.owner = 'FUSION' and t.table_name = 'PER_ALL_ASSIGNMENTS_M' 
             -- and c.column_name in ('ACTION_CODE', 'BUSINESS_UNIT_ID', 'FREEZE_UNTIL_DATE')
             and t.object_owner = c.owner
             and t.object_name  = c.table_name
             AND STATEMENT_ID = '^^sql_id'
             and c.histogram <> 'NONE'
         )
        select /*+ ordered use_nl(h) push_pred(h) OPT_PARAM('_optimizer_adaptive_plans','false') no_merge */ 
                h.table_name, c.num_rows, h.column_name, (c.num_rows-c.num_nulls) nn_rows, c.num_distinct, c.histogram, c.sample_size, h.endpoint_number
                , case when c.histogram IN ('TOP-FREQUENCY', 'FREQUENCY') then
                        round((h.endpoint_number - (lag(h.endpoint_number,1,0) over (partition by h.table_name, h.column_name order by h.endpoint_number)))) 
                     when c.histogram = 'HEIGHT BALANCED' then
                        round((h.endpoint_number - (lag(h.endpoint_number,1,0) over (partition by h.table_name, h.column_name order by h.endpoint_number)) ) / c.num_buckets * (c.num_rows-c.num_nulls)) 
                     when c.histogram = 'HYBRID' then
                        round((h.endpoint_number - (lag(h.endpoint_number,1,0) over (partition by h.table_name, h.column_name order by h.endpoint_number)))) 
                        --round(endpoint_repeat_count /c.sample_size * (c.num_rows-c.num_nulls)) 
                 end rows_per_bucket
                ,case when regexp_like('^^pii_1',c.table_name,'i') then NULL 
                 else                
                   case when c.data_type like '%CHAR%' then
                                   nvl(ENDPOINT_ACTUAL_VALUE, UTL_RAW.CAST_TO_VARCHAR2(SUBSTR(LPAD(TO_CHAR(h.endpoint_value,'fmxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx'),30,'0'),1,12))) ||''
                                 when data_type = 'NUMBER' then
                                   to_char(h.endpoint_value) ||''
                                 when data_type = 'DATE' or data_type like 'TIMESTAMP%' then
                                   to_char(to_date(to_char(trunc(h.endpoint_value)), 'J') + (h.endpoint_value - TRUNC(h.endpoint_value)),'SYYYY / MM / DD HH24:MI:SS') ||''
                   end
                 end approx_value
                ,case when c.histogram = 'HYBRID' then
                    endpoint_repeat_count
                 end endpoint_repeat_count                 
                ,
                 case when c.histogram IN ('TOP-FREQUENCY', 'FREQUENCY') then
                        trunc((h.endpoint_number - lag(h.endpoint_number,1,0) over (partition by h.table_name, h.column_name order by h.endpoint_number)) / c.sample_size,5) 
                     when c.histogram = 'HEIGHT BALANCED' then
                        trunc((h.endpoint_number - lag(h.endpoint_number,1,0) over (partition by h.table_name, h.column_name order by h.endpoint_number)) / c.num_buckets,5) 
                     when c.histogram = 'HYBRID' then
                        trunc(endpoint_repeat_count /c.sample_size,5) 
                 end selectivity
                ,
                 case 
                     when c.histogram = 'HYBRID' and endpoint_repeat_count > c.sample_size/c.num_buckets then endpoint_repeat_count
                 end popular_repeat_count 
                ,                 
                 case 
                     when c.histogram = 'HYBRID' and endpoint_repeat_count > c.sample_size/c.num_buckets then 'popular'
                 end popular
           from c, dba_tab_histograms h
          where c.owner = h.owner and c.table_name = h.table_name and c.column_name = h.column_name 
          order by h.table_name, h.column_name, h.endpoint_number
       ]';
  END IF;
END;
/

SET feedback on 
PRINT histval
SET feedback off
-- set timing off

PRO </pre></body></html>
rem set markup html off
SPO OFF;
set colsep " "
CLEAR compute;

/**************************************************************************************************
 *
 * New Script by Vivek Jha v10.5
 * - Histogram Actual Values at Hard Parse time
 *
 **************************************************************************************************/

EXEC DBMS_APPLICATION_INFO.SET_CLIENT_INFO('^^method.: Histogram Actual Values at Hard Parse ' || TO_CHAR(SYSDATE, 'YYYY-MM-DD/HH24:MI:SS'));
PRO Fetching Histogram Actual Values at Hard Parse
PRO
SELECT TO_CHAR(SYSDATE, 'YYYY-MM-DD/HH24:MI:SS') FROM dual;
PRO Please Wait


/*
delete plan_table where STATEMENT_ID = :sql_id;
commit;
insert into plan_table(STATEMENT_ID, object_owner, object_type, object_name, cardinality, cost, optimizer, object_alias, operation, options, io_cost, bytes)
  WITH  
    object AS (
       SELECT /*+ MATERIALIZE * /
              object_owner owner, object_name name, object_type
         FROM gv$sql_plan
        WHERE inst_id IN (SELECT inst_id FROM gv$instance)
          AND sql_id = :sql_id
          AND object_owner IS NOT NULL
          AND object_name IS NOT NULL
          AND not (object_type = 'TABLE (TEMP)' and object_name like 'SYS_TEMP%') 
        UNION
       SELECT object_owner owner, object_name name, object_type
         FROM dba_hist_sql_plan
        WHERE :license IN ('T', 'D')
          AND dbid = ^^dbid.
          AND sql_id = :sql_id
          AND object_owner IS NOT NULL
          AND object_name IS NOT NULL
          AND not (object_type = 'TABLE (TEMP)' and object_name like 'SYS_TEMP%') 
    )
    , plan_tables AS (
         SELECT /*+ MATERIALIZE * /
                'TABLE' object_type, o.owner object_owner, o.name object_name
           FROM object o
          WHERE o.object_type like 'TABLE%'
          UNION
         SELECT 'TABLE' object_type, i.table_owner object_owner, i.table_name object_name
           FROM dba_indexes i,
                object o
          WHERE o.object_type like 'INDEX%'  
            AND i.owner = o.owner
            AND i.index_name = o.name
    )
  select distinct :sql_id, t.owner,          pt.object_type, t.table_name, t.num_rows,  t.sample_size, 
           TO_CHAR(t.last_analyzed, 'DD-MON-YY HH24:MI:SS') last_analyzed, 
         temporary,       partitioned, degree,  t.blocks, t.avg_row_len
    from plan_tables pt, dba_tables t
   where t.table_name = pt.object_name
     and t.owner = pt.object_owner
  ;
*/  
SET heading on pages 1000

var  l_last_load_time varchar2(50) ;
var  l_plan_hash_value number;

begin
select plan_hash_value into :l_plan_hash_value from gv$sql where sql_id = :sql_id order by last_load_time desc FETCH FIRST 1 ROW ONLY;
select last_load_time into :l_last_load_time from gv$sql where sql_id = :sql_id order by last_load_time desc FETCH FIRST 1 ROW ONLY;
end;
/


SPO ^^files_prefix._15_histogram_actual_values_atHardParse.html;

SET heading on pages 10000
col table_name for a30 heading "Table Name"
col num_rows for 99999999999 heading "Table Rows"
col column_name for a30 heading "Column Name"
col SAVTIME for a40 heading "Stats Gather Time"
col Bucket for 99999999999 heading "Bucket"
column nn_rows  for 99999999999 heading "Column|Not Null|Rows"
column histogram  for a16 heading "Histogram|Type"
col approx_value for a100 heading "Approx Value"
col rows_per_bucket for 999999999 heading "Rows Per|Bucket"
col selectivity for 99.999999999 heading "Selectivity"

set colsep |

rem PRO <style type="text/css">
rem PRO body {font:10pt Arial,Helvetica,Verdana,Geneva,sans-serif; color:black; background:white;}
rem PRO table {font-size:8pt; color:black; background:white;}
rem PRO th {font-weight:bold; background:#cccc99; color:#336699; vertical-align:bottom; padding-left:3pt; padding-right:3pt; padding-top:1pt; padding-bottom:1pt;}
rem PRO td {text-align:left; background:#fcfcf0; vertical-align:top; padding-left:3pt; padding-right:3pt; padding-top:1pt; padding-bottom:1pt;}
rem PRO </style>

rem set markup html on
PRO <html>
PRO <head><title>^^files_prefix._15_histogram_actual_values_atHardParse.html</title></head>
PRO <body><pre>


PRO # Histogram Actual Values at Hard Parse 
PRO
PRO This script outputs the Column Histograms for a give SQL ID and PLAN HASH VALUE based on the last HARD PARSE TIME
PRO (current histograms might be different from the time when the SQL was last hard parsed)
PRO Data is fetched from tables in memory. Depending on the Retention period for those tables, not all tables used in the execution plan might show up in the output

col "Plan Hash" format A100 
SELECT '         Plan Hash Value:' ||:l_plan_hash_value ||'        Hard Parse Time: ' || :l_last_load_time "Plan Hash" from dual;



/*
col table_name for a30 heading "Table Name"
col num_rows for 99999999999 heading "Table Rows"
col column_name for a30 heading "Column Name"
col SAVTIME for a40 heading "Stats Gather Time"
col Bucket for 99999999999 heading "Bucket"
column nn_rows  for 99999999999 heading "Column|Not Null|Rows"
column histogram  for a16 heading "Histogram|Type"
col approx_value for a100 heading "Approx Value"
col rows_per_bucket for 999999999 heading "Rows Per|Bucket"
col selectivity for 99.999999999 heading "Selectivity"

break on table_name on num_rows on column_name on nn_rows
*/

--set timing on

         with c as
         (
          select /*+ materialize leading(t) */ t.object_owner owner, t.object_name table_name, 
                 t.cardinality num_rows, c.column_name, c.histogram, 
                 c.sample_size, c.num_nulls, c.num_buckets, c.data_type
            from plan_table t, dba_tab_cols c
           where 1=1
             and t.object_owner = c.owner
             and t.object_name  = c.table_name
             AND STATEMENT_ID = '^^sql_id'
             and c.histogram <> 'NONE'
         ),
         maxst as
         (
           select c.owner , c.table_name, max(savtime) savtimemax
           from c, sys.obj$ o, sys.col$ col, sys.user$ u, sys.wri$_OPTSTAT_HISTGRM_HISTORY hh
	     where  c.owner = u.name and c.table_name = o.name and c.column_name = col.name 
	       and hh.obj# = o.obj#
	       and col.obj# = o.obj#
	       and hh.intcol# = col.col#
	       and o.owner# = u.user#
	       --and hh.savtime < (select to_date(max(last_load_time),'yyyy-mm-dd hh24:mi:ss') from gv$sql where sql_id = :sql_id)
	       and hh.savtime  <  (select to_date(last_load_time,'yyyy-mm-dd hh24:mi:ss') from gv$sql where sql_id = :sql_id and plan_hash_value = :l_plan_hash_value order by last_load_time desc FETCH FIRST 1 ROW ONLY)
	       group by c.owner, c.table_name
              )
         select /*+ ordered use_nl(h) push_pred(h) OPT_PARAM('_optimizer_adaptive_plans','false') no_merge */ 
                c.table_name, c.num_rows, c.column_name,hh.savtime,hh.bucket, (c.num_rows-c.num_nulls) nn_rows, c.histogram, 
                case when regexp_like(:pii_tables,c.table_name,'i') then NULL
                else
                  case when c.data_type like '%CHAR%' then utl_raw.cast_to_varchar2(hh.epvalue_raw) ||''
                      when c.data_type = 'NUMBER'    then utl_raw.cast_to_number(hh.epvalue_raw)  ||''
                      when c.data_type = 'DATE' or data_type like 'TIMESTAMP%' then
                                 to_char(to_date(to_char(trunc(hh.endpoint)), 'J') + (hh.endpoint - TRUNC(hh.endpoint)),'SYYYY / MM / DD HH24:MI:SS') ||''
                  end
                end approx_value
                ,case when c.histogram = 'HYBRID' then
                    hh.ep_repeat_count
                 end endpoint_repeat_count                   
                ,
		case when c.histogram IN ('TOP-FREQUENCY', 'FREQUENCY') then 	
			round((hh.bucket - (lag(hh.bucket,1,0) over (partition by c.table_name, c.column_name order by hh.bucket)))) 
		when c.histogram = 'HEIGHT BALANCED' then			
			round((hh.bucket - (lag(hh.bucket,1,0) over (partition by c.table_name, c.column_name order by hh.bucket)) ) / c.num_buckets * (c.num_rows-c.num_nulls)) 
                when c.histogram = 'HYBRID' then
                        --round(hh.ep_repeat_count /c.sample_size * (c.num_rows-c.num_nulls)) 
                        round((hh.bucket - (lag(hh.bucket,1,0) over (partition by c.table_name, c.column_name order by hh.bucket)))) 
                 end rows_per_bucket
                ,
		case when c.histogram IN ('TOP-FREQUENCY', 'FREQUENCY') then 	
			trunc((hh.bucket - lag(hh.bucket,1,0) over (partition by c.table_name, c.column_name order by hh.bucket)) / c.sample_size,5) 
		when c.histogram = 'HEIGHT BALANCED' then			
			trunc((hh.bucket - lag(hh.bucket,1,0) over (partition by c.table_name, c.column_name order by hh.bucket)) / c.num_buckets,5)  
                when c.histogram = 'HYBRID' then
                        trunc(hh.ep_repeat_count /c.sample_size,5) 
                 end selectivity
                , 
                  case 
                     when c.histogram = 'HYBRID' and hh.ep_repeat_count >= c.sample_size/c.num_buckets then 'popular'
                  else ''
                 end popular                 
	   from c, sys.obj$ o, sys.col$ col, sys.user$ u, sys.wri$_OPTSTAT_HISTGRM_HISTORY hh, maxst
	     where  c.owner = u.name and c.table_name = o.name and c.column_name = col.name 
	       and hh.obj# = o.obj#
	       and col.obj# = o.obj#
	       and hh.intcol# = col.col#
	       and o.owner# = u.user#
	       and c.owner = maxst.owner
	       and c.table_name = maxst.table_name
	       and hh.savtime = maxst.savtimemax
             order by c.table_name, c.column_name, hh.bucket;

--set timing off

PRO </pre></body></html>
rem set markup html off
SPO OFF;

set colsep " "

/*================================= SQL Profile - Vivek Jha =================================*/
/* this creates SQL profile scripts for Top3 PHV's */

SET HEAD OFF
EXEC DBMS_APPLICATION_INFO.SET_CLIENT_INFO('^^method.: SQL Profile Report - ' || TO_CHAR(SYSDATE, 'YYYY-MM-DD/HH24:MI:SS'));
PRO SQL Profile Scripts
PRO
SELECT TO_CHAR(SYSDATE, 'YYYY-MM-DD/HH24:MI:SS') FROM dual;
PRO Please Wait



SET TERM OFF ECHO OFF FEED OFF VER OFF HEA ON LIN 2000 PAGES 100 LONG 8000000 LONGC 800000 TRIMS ON TRIM ON TI OFF TIMI OFF SERVEROUT ON SIZE 1000000 FOR WRA NUMF "" 


SPO ^^files_prefix._16_sql_profiles.sql;
PRO REM SQL Profile Scripts for ^^sql_id.

VAR sql_text CLOB;
VAR sql_text2 CLOB;
VAR other_xml CLOB;
EXEC :sql_text := NULL;
EXEC :sql_text2 := NULL;
EXEC :other_xml := NULL;

DECLARE 
   c_sql_id v$sql.sql_id%type; 
   c_plan_hash_value v$sql.plan_hash_value%type; 
   c_avg_et_secs v$sql.elapsed_time%type; 
   l_sql_text VARCHAR2(32767);
   l_clob_size NUMBER;
   l_offset NUMBER;

  l_pos NUMBER;
  --l_clob_size NUMBER;
  --l_offset NUMBER;
  --l_sql_text VARCHAR2(32767);
  l_len NUMBER;
  l_hint VARCHAR2(32767);
  l_text VARCHAR2(32767);
  l_num_hints pls_integer := 0;
  l_hints_limit constant pls_integer := 1000;

	CURSOR c_phv is 
	WITH
	p AS (
	SELECT sql_id, plan_hash_value
	  FROM gv$sql_plan
	 WHERE sql_id = TRIM(:sql_id)
	   AND other_xml IS NOT NULL
	 UNION
	SELECT sql_id, plan_hash_value
	  FROM dba_hist_sql_plan
	 WHERE sql_id = TRIM(:sql_id)
	   AND other_xml IS NOT NULL ),
	m AS (
	SELECT sql_id, plan_hash_value,
	       SUM(elapsed_time)/SUM(executions) avg_et_secs
	  FROM gv$sql
	 WHERE sql_id = TRIM(:sql_id)
	   AND executions > 0
	 GROUP BY
	       sql_id, plan_hash_value ),
	a AS (
	SELECT sql_id, plan_hash_value,
	       SUM(elapsed_time_total)/SUM(executions_total) avg_et_secs
	  FROM dba_hist_sqlstat
	 WHERE sql_id = TRIM(:sql_id)
	   AND executions_total > 0
	 GROUP BY
	       sql_id, plan_hash_value )
	select * from 
	(SELECT p.sql_id, p.plan_hash_value, NVL(m.avg_et_secs, a.avg_et_secs) avg_et_secs
	  FROM p, m, a
	  WHERE p.plan_hash_value = m.plan_hash_value(+)
	  AND p.plan_hash_value = a.plan_hash_value(+)
	  ORDER BY avg_et_secs )
	WHERE rownum < 4;

BEGIN
	DBMS_OUTPUT.PUT_LINE('REM');
	DBMS_OUTPUT.PUT_LINE('REM');
	DBMS_OUTPUT.PUT_LINE('REM');
	DBMS_OUTPUT.PUT_LINE('REM ################################################################################');
	DBMS_OUTPUT.PUT_LINE('REM       SQL PROFILE Script START      ');
	DBMS_OUTPUT.PUT_LINE('REM (if multiple plans available, you will see multiple scripts appended below  ');
	DBMS_OUTPUT.PUT_LINE('REM (Extract SQL profile for your plan hash value into a separate file to execute');
	DBMS_OUTPUT.PUT_LINE('REM ################################################################################');
	DBMS_OUTPUT.PUT_LINE('REM');
	DBMS_OUTPUT.PUT_LINE('REM');
	DBMS_OUTPUT.PUT_LINE('REM');
	DBMS_OUTPUT.PUT_LINE('REM');
	DBMS_OUTPUT.PUT_LINE('REM This file has SQL Profile Scripts for the following Plan Hash Values');

    OPEN c_phv;
    LOOP
        FETCH c_phv INTO c_sql_id, c_plan_hash_value, c_avg_et_secs ;
	   EXIT WHEN c_phv%notfound; 
        DBMS_OUTPUT.PUT_LINE('REM       Plan Hash Value : '||c_plan_hash_value||'          Avg Elapsed Time :'||round(c_avg_et_secs/1000,2)||'ms');
    END LOOP; 
    CLOSE c_phv; 


   OPEN c_phv; 
	DBMS_OUTPUT.PUT_LINE('REM');

   LOOP 
	   FETCH c_phv into c_sql_id, c_plan_hash_value, c_avg_et_secs ; 
	   EXIT WHEN c_phv%notfound; 

		--dbms_output.put_line('@coe_xfr_sql_profile '||c_sql_id || ' ' || c_plan_hash_value ); 

	   
	   -- get sql_text from memory ------------------------------------------------------------------

	   BEGIN 
	    --DBMS_OUTPUT.PUT_LINE('SQL ID: '||c_sql_id);
	  
		  FOR i IN (SELECT DISTINCT piece, sql_text
			      FROM gv$sqltext_with_newlines
			     WHERE sql_id = TRIM(c_sql_id)
			     ORDER BY 1, 2)
		  LOOP
	    --DBMS_OUTPUT.PUT_LINE('Inside SQL text Loop');
	    --DBMS_OUTPUT.PUT_LINE('SQL Text: '||:sql_text);
	    --DBMS_OUTPUT.PUT_LINE(' ');

		    IF :sql_text IS NULL THEN
		      DBMS_LOB.CREATETEMPORARY(:sql_text, TRUE);
		      DBMS_LOB.OPEN(:sql_text, DBMS_LOB.LOB_READWRITE);
		    END IF;
		    -- removes NULL characters
		    l_sql_text := REPLACE(i.sql_text, CHR(00), ' ');
		    -- adds a NULL character at the end of each line
		  END LOOP;
		  -- if found in memory then sql_text is not null
		  IF :sql_text IS NOT NULL THEN
		    DBMS_LOB.CLOSE(:sql_text);
		  END IF;
		EXCEPTION
		  WHEN OTHERS THEN
		    DBMS_OUTPUT.PUT_LINE('getting sql_text from memory: '||SQLERRM);
		    :sql_text := NULL;
	    END;
	


	--   SELECT :sql_text FROM DUAL;

	-- get sql_text from awr ------------------------------------------------------------------
	    BEGIN
		  IF :sql_text IS NULL OR NVL(DBMS_LOB.GETLENGTH(:sql_text), 0) = 0 THEN
		    SELECT sql_text
		      INTO :sql_text2
		      FROM dba_hist_sqltext
		     WHERE sql_id = TRIM(c_sql_id)
		       AND sql_text IS NOT NULL
		       AND ROWNUM = 1;
		  END IF;
		  -- if found in awr then sql_text2 is not null
		  IF :sql_text2 IS NOT NULL THEN
		    l_clob_size := NVL(DBMS_LOB.GETLENGTH(:sql_text2), 0);
		    l_offset := 1;
		    DBMS_LOB.CREATETEMPORARY(:sql_text, TRUE);
		    DBMS_LOB.OPEN(:sql_text, DBMS_LOB.LOB_READWRITE);
		    -- store in clob as 64 character pieces plus a NUL character at the end of each piece
		    WHILE l_offset < l_clob_size
		    LOOP
		      IF l_clob_size - l_offset > 64 THEN
			l_sql_text := REPLACE(DBMS_LOB.SUBSTR(:sql_text2, 64, l_offset), CHR(00), ' ');
		      ELSE -- last piece
			l_sql_text := REPLACE(DBMS_LOB.SUBSTR(:sql_text2, l_clob_size - l_offset + 1, l_offset), CHR(00), ' ');
		      END IF;
		      DBMS_LOB.WRITEAPPEND(:sql_text, LENGTH(l_sql_text) + 1, l_sql_text||CHR(00));
		      l_offset := l_offset + 64;
		    END LOOP;
		    DBMS_LOB.CLOSE(:sql_text);
		  END IF;
		EXCEPTION
		  WHEN OTHERS THEN
		    DBMS_OUTPUT.PUT_LINE('getting sql_text from awr: '||SQLERRM);
		    :sql_text := NULL;
	    END;

	--	SELECT :sql_text2 FROM DUAL;
	--	SELECT :sql_text FROM DUAL;

	-- validate sql_text
	--SET TERM ON;
	BEGIN
	  IF :sql_text IS NULL THEN
	    RAISE_APPLICATION_ERROR(-20100, 'SQL_TEXT for SQL_ID c_sql_id. was not found in memory (gv$sqltext_with_newlines) or AWR (dba_hist_sqltext).');
	  END IF;
	END;
	   


	-- get other_xml from memory ------------------------------------------------------------------
	BEGIN
	  FOR i IN (SELECT other_xml
		      FROM gv$sql_plan
		     WHERE sql_id = TRIM(c_sql_id )
		       AND plan_hash_value = TO_NUMBER(TRIM(c_plan_hash_value))
		       AND other_xml IS NOT NULL
		     ORDER BY
			   child_number, id)
	  LOOP
	    :other_xml := i.other_xml;
	    EXIT; -- 1st
	  END LOOP;
	EXCEPTION
	  WHEN OTHERS THEN
	    DBMS_OUTPUT.PUT_LINE('getting other_xml from memory: '||SQLERRM);
	    :other_xml := NULL;
	END;
	


	--------- get other_xml from awr ------------------------------------------------------------------
	BEGIN
	  IF :other_xml IS NULL OR NVL(DBMS_LOB.GETLENGTH(:other_xml), 0) = 0 THEN
	    FOR i IN (SELECT other_xml
			FROM dba_hist_sql_plan
		       WHERE sql_id = TRIM(c_sql_id)
			 AND plan_hash_value = TO_NUMBER(TRIM(c_plan_hash_value))
			 AND other_xml IS NOT NULL
		       ORDER BY
			     id)
	    LOOP
	      :other_xml := i.other_xml;
	      EXIT; -- 1st
	    END LOOP;
	  END IF;
	EXCEPTION
	  WHEN OTHERS THEN
	    DBMS_OUTPUT.PUT_LINE('getting other_xml from awr: '||SQLERRM);
	    :other_xml := NULL;
	END;



	-- get other_xml from memory from modified SQL ------------------------------------------------------------------
	BEGIN
	  IF :other_xml IS NULL OR NVL(DBMS_LOB.GETLENGTH(:other_xml), 0) = 0 THEN
	    FOR i IN (SELECT other_xml
			FROM gv$sql_plan
		       WHERE plan_hash_value = TO_NUMBER(TRIM(c_plan_hash_value))
			 AND other_xml IS NOT NULL
		       ORDER BY
			     child_number, id)
	    LOOP
	      :other_xml := i.other_xml;
	      EXIT; -- 1st
	    END LOOP;
	  END IF;
	EXCEPTION
	  WHEN OTHERS THEN
	    DBMS_OUTPUT.PUT_LINE('getting other_xml from memory: '||SQLERRM);
	    :other_xml := NULL;
	END;
	

	-- get other_xml from awr from modified SQL ------------------------------------------------------------------
	BEGIN
	  IF :other_xml IS NULL OR NVL(DBMS_LOB.GETLENGTH(:other_xml), 0) = 0 THEN
	    FOR i IN (SELECT other_xml
			FROM dba_hist_sql_plan
		       WHERE plan_hash_value = TO_NUMBER(TRIM(c_plan_hash_value))
			 AND other_xml IS NOT NULL
		       ORDER BY
			     id)
	    LOOP
	      :other_xml := i.other_xml;
	      EXIT; -- 1st
	    END LOOP;
	  END IF;
	EXCEPTION
	  WHEN OTHERS THEN
	    DBMS_OUTPUT.PUT_LINE('getting other_xml from awr: '||SQLERRM);
	    :other_xml := NULL;
	END;



	--SET TERM ON;
	BEGIN
	  IF :other_xml IS NULL THEN
	    RAISE_APPLICATION_ERROR(-20101, 'PLAN for SQL_ID c_sql_id. and PHV c_plan_hash_value. was not found in memory (gv$sql_plan) or AWR (dba_hist_sql_plan).');
	  END IF;
	END;


--==========================END MAIN SQL PROFILE CREATION SCRIPT =========================================

-- generates script that creates sql profile in target system:
	BEGIN

		DBMS_OUTPUT.PUT_LINE('REM');
		DBMS_OUTPUT.PUT_LINE('REM');
		DBMS_OUTPUT.PUT_LINE('REM'||' START '||c_plan_hash_value);
		DBMS_OUTPUT.PUT_LINE('REM **************************************************************************************************************');
--		DBMS_OUTPUT.PUT_LINE('REM     SQL PROFILE Script for Plan Hash Value : '|| c_plan_hash_value||'        STARTS HERE');  
		DBMS_OUTPUT.PUT_LINE('REM     Script: coe_xfr_sql_profile_'||c_sql_id||'_'||c_plan_hash_value||'.sql');
		DBMS_OUTPUT.PUT_LINE('REM ');
		DBMS_OUTPUT.PUT_LINE('REM ');
		DBMS_OUTPUT.PUT_LINE('REM     Execute coe_xfr_sql_profile_'||c_sql_id||'_'||c_plan_hash_value||'.sql');
		DBMS_OUTPUT.PUT_LINE('REM     on TARGET system in order to create a custom SQL Profile with ');
		DBMS_OUTPUT.PUT_LINE('REM     plan '||c_plan_hash_value||' linked to adjusted sql_text.');
		DBMS_OUTPUT.PUT_LINE('REM ');
		DBMS_OUTPUT.PUT_LINE('REM'||' If more than one PHV, extract individual scripts using regex in notepad++ -> REM START [0-9]+.*?END [0-9]+');		
		--DBMS_OUTPUT.PUT_LINE('REM   Copy text from here till it says ''SQL PROFILE Script for Plan Hash Value : '|| c_plan_hash_value||' ENDS HERE''');  
		DBMS_OUTPUT.PUT_LINE('REM **************************************************************************************************************');
		DBMS_OUTPUT.PUT_LINE('REM');
		DBMS_OUTPUT.PUT_LINE('REM');
		DBMS_OUTPUT.PUT_LINE('REM');

		  DBMS_OUTPUT.PUT_LINE('SPO coe_xfr_sql_profile_'||c_sql_id||'_'||c_plan_hash_value||'.log;');
      DBMS_OUTPUT.PUT_LINE('SET ECHO OFF FEED OFF TERM ON LIN 2000 TRIMS ON TRIM ON SERVEROUT ON SIZE UNLIMITED NUMF 99999999999999999999;');
		  DBMS_OUTPUT.PUT_LINE('REM');
		  DBMS_OUTPUT.PUT_LINE('REM $Header: 215187.1 coe_xfr_sql_profile_'||c_sql_id||'_'||c_plan_hash_value||'.sql 11.4.4.4 '||TO_CHAR(SYSDATE, 'YYYY/MM/DD')||' carlos.sierra $');
		  DBMS_OUTPUT.PUT_LINE('REM');
		  DBMS_OUTPUT.PUT_LINE('REM Copyright (c) 2000-2012, Oracle Corporation. All rights reserved.');
		  DBMS_OUTPUT.PUT_LINE('REM');
		  DBMS_OUTPUT.PUT_LINE('REM AUTHOR');
		  DBMS_OUTPUT.PUT_LINE('REM   carlos.sierra@oracle.com');
		  DBMS_OUTPUT.PUT_LINE('REM');
		  DBMS_OUTPUT.PUT_LINE('REM SCRIPT');
		  DBMS_OUTPUT.PUT_LINE('REM   coe_xfr_sql_profile_'||c_sql_id||'_'||c_plan_hash_value||'.sql');
		  DBMS_OUTPUT.PUT_LINE('REM');
		  DBMS_OUTPUT.PUT_LINE('REM DESCRIPTION');
		  DBMS_OUTPUT.PUT_LINE('REM   This script is generated by coe_xfr_sql_profile.sql');
		  DBMS_OUTPUT.PUT_LINE('REM   It contains the SQL*Plus commands to create a custom');
		  DBMS_OUTPUT.PUT_LINE('REM   SQL Profile for SQL_ID '||c_sql_id||' based on plan hash');
		  DBMS_OUTPUT.PUT_LINE('REM   value '||c_plan_hash_value||'.');
		  DBMS_OUTPUT.PUT_LINE('REM   The custom SQL Profile to be created by this script');
		  DBMS_OUTPUT.PUT_LINE('REM   will affect plans for SQL commands with signature');
		  DBMS_OUTPUT.PUT_LINE('REM   matching the one for SQL Text below.');
		  DBMS_OUTPUT.PUT_LINE('REM   Review SQL Text and adjust accordingly.');
		  DBMS_OUTPUT.PUT_LINE('REM');
		  DBMS_OUTPUT.PUT_LINE('REM PARAMETERS');
		  DBMS_OUTPUT.PUT_LINE('REM   None.');
		  DBMS_OUTPUT.PUT_LINE('REM');
		  DBMS_OUTPUT.PUT_LINE('REM EXAMPLE');
		  DBMS_OUTPUT.PUT_LINE('REM   SQL> START coe_xfr_sql_profile_'||c_sql_id||'_'||c_plan_hash_value||'.sql;');
		  DBMS_OUTPUT.PUT_LINE('REM');
		  DBMS_OUTPUT.PUT_LINE('REM NOTES');
		  DBMS_OUTPUT.PUT_LINE('REM   1. Should be run as SYSTEM or SYSDBA.');
		  DBMS_OUTPUT.PUT_LINE('REM   2. User must have CREATE ANY SQL PROFILE privilege.');
		  DBMS_OUTPUT.PUT_LINE('REM   3. SOURCE and TARGET systems can be the same or similar.');
		  DBMS_OUTPUT.PUT_LINE('REM   4. To drop this custom SQL Profile after it has been created:');
		  DBMS_OUTPUT.PUT_LINE('REM      EXEC DBMS_SQLTUNE.DROP_SQL_PROFILE(''coe_'||c_sql_id||'_'||c_plan_hash_value||''');');
		  DBMS_OUTPUT.PUT_LINE('REM   5. Be aware that using DBMS_SQLTUNE requires a license');
		  DBMS_OUTPUT.PUT_LINE('REM      for the Oracle Tuning Pack.');
		  DBMS_OUTPUT.PUT_LINE('REM   6. If you modified a SQL putting Hints in order to produce a desired');
		  DBMS_OUTPUT.PUT_LINE('REM      Plan, you can remove the artifical Hints from SQL Text pieces below.');
		  DBMS_OUTPUT.PUT_LINE('REM      By doing so you can create a custom SQL Profile for the original');
		  DBMS_OUTPUT.PUT_LINE('REM      SQL but with the Plan captured from the modified SQL (with Hints).');
		  DBMS_OUTPUT.PUT_LINE('REM');
		  DBMS_OUTPUT.PUT_LINE('WHENEVER SQLERROR EXIT SQL.SQLCODE;');
      DBMS_OUTPUT.PUT_LINE(q'{
      
  var Fusion_PDB     varchar2(128)
  var is_multitenant varchar2(4)
  var con_id         number
  var con_name       varchar2(128)
  var pdb_name       varchar2(128)
  var sql_text       clob 
  
  declare
    dbname       varchar(25);
    inst_number  number;
    inst_name    varchar(25);
    cdbid          number;      -- current dbid
  begin
    -- get the current db/instance information
    select d.con_dbid, d.name, sys_context('USERENV', 'CON_ID'), sys_context('USERENV', 'CON_NAME'), upper(d.CDB)
          ,i.instance_number, i.instance_name
    into   cdbid, dbname, :con_id, :con_name, :is_multitenant, inst_number, inst_name
    from   v$database d,
           v$instance i;
      -- display the info
      dbms_output.put_line('~~~~~~~~~~~~~~~~');    
      dbms_output.put_line('Current Instance');
      dbms_output.put_line('~~~~~~~~~~~~~~~~');
      dbms_output.put_line(rpad('DB Id', 15) ||' '||rpad('DB Name', 15) ||' '||
                           rpad('Inst Num', 15) ||' '|| rpad('Instance', 15) ||' '||
                           --rpad('MultiTenant',11)||' '|| 
                           rpad('Container Id', 15) ||' '||
                           rpad('Container Name', 15));
      dbms_output.put_line(rpad('-',15,'-') ||' '|| rpad('-',15,'-') ||' '|| 
                           rpad('-',15,'-') ||' '|| rpad('-',15,'-') ||' '||
                           --rpad('-',11,'-') ||' '||
                           rpad('-',15,'-') ||' '|| rpad('-',15,'-'));
      dbms_output.put_line(rpad(cdbid, 15) ||' '|| 
                           rpad(dbname, 15) || ' ' || 
                           rpad(inst_number,15) ||' '||
                           rpad(inst_name, 15) ||' '|| 
                           --rpad(:is_multitenant, 11) ||' '||
                           rpad(:con_id,15) ||' '|| rpad(:con_name,15));
      dbms_output.put_line(chr(10));
      if :is_multitenant <> 'YES' then
        :Fusion_PDB := :con_name;
      end if;
  end;
  }');
    DBMS_OUTPUT.PUT_LINE('/');
    DBMS_OUTPUT.PUT_LINE(q'{
  declare
    l_pdb_name varchar2(128) := null;
  begin   
    -- show PDB info (highlight supposedly FUSION PDB)
    --if :is_multitenant = 'YES' and :con_id <> 0 then
    if :is_multitenant = 'YES' and :con_id = 1 then 
      -- you are in CDB 
      dbms_output.put_line('!!!!!!!!!!!!!!!!!!! YOU ARE CONNECTED TO A CDB$ROOT !!!!!!!!!!!!!!!!!!!');
      dbms_output.put_line(chr(10));  
      dbms_output.put_line('~~~~~~~~~~~~~~~~~~~~~~~~~~~~');    
      dbms_output.put_line('*Choose from Available PDBs*');
      dbms_output.put_line('~~~~~~~~~~~~~~~~~~~~~~~~~~~~');
      dbms_output.put_line(rpad('PDB NAME', 15)||' '||rpad('FUSION PDB?', 35));
      dbms_output.put_line(rpad('-',15,'-')||' '||rpad('-',35,'-'));
      -- get the PDBs
      for pdb_rec in (select PDB_NAME from dba_pdbs order by 1 desc)
      loop
        if regexp_count(pdb_rec.PDB_NAME,'_F$',1,'i') > 0 then
        --if regexp_count(pdb_rec.PDB_NAME,'1$',1,'i') > 0 then
          dbms_output.put_line(rpad(pdb_rec.PDB_NAME, 15)||' ' ||rpad('YES [*** per the naming convention]', 35));
          l_pdb_name := pdb_rec.PDB_NAME;     
        else
          dbms_output.put_line(rpad(pdb_rec.PDB_NAME, 15)||' ' ||rpad('NO', 35));
          :Fusion_PDB := pdb_rec.PDB_NAME;    
        end if;           
      end loop;
      if l_pdb_name is NOT null then
        :Fusion_PDB := l_pdb_name;
      end if;
    else
      :Fusion_PDB := :con_name;
    end if;
  end;
  }');
    DBMS_OUTPUT.PUT_LINE('/');
  l_text := q'{
   
  pro
  set verify off term off
  column Fusion_PDB new_value Fusion_PDB noprint
  select :Fusion_PDB Fusion_PDB from dual;
  
  spool ask_container.sql
  begin
    if :is_multitenant = 'YES' and :con_id = 1 then
      dbms_output.put_line('pro Please input the container in which you wish to create SQL Profile');
      dbms_output.put_line('pro Press enter if you want container to be "!!Fusion_PDB."');
      dbms_output.put_line('Accept pdb_name char default ''!!Fusion_PDB.'' prompt ''Enter Container Name: ''');
      dbms_output.put_line('pro');
    else
      dbms_output.put_line('def pdb_name=''!!Fusion_PDB.''');
    end if;
  end;
  }';
    l_text := replace(l_text,'!!','&&');
    DBMS_OUTPUT.PUT_LINE(l_text);
    DBMS_OUTPUT.PUT_LINE('/');
  l_text := q'{
  SPO coe_xfr_sql_profile_}'||c_sql_id||'_'||c_plan_hash_value||q'{.log APP;
  set term on
  $ask_container.sql
  
  set term off  
  spool ask_container1.sql
  begin
    if :is_multitenant = 'YES' and :con_id = 1 then
      dbms_output.put_line('exec :pdb_name:=''!!pdb_name.''');
    end if;
  end;
  }';
    l_text := replace(l_text,'!!','&&');
    l_text := replace(l_text,'$','@');  
    DBMS_OUTPUT.PUT_LINE(l_text);
    DBMS_OUTPUT.PUT_LINE('/');
  
    l_text := q'{
  SPO coe_xfr_sql_profile_}'||c_sql_id||'_'||c_plan_hash_value||q'{.log APP;
  $ask_container1.sql
  
  set term on 
  begin
    if upper(:pdb_name)='CDB$ROOT' then
      dbms_output.put_line('>>>>>>>>>>>>>>> IMPORTANT <<<<<<<<<<<<<<<<');
      dbms_output.put_line('YOU ARE CREATING SQL PROFILE IN A CDB$ROOT');
      dbms_output.put_line('>>>>>>>>>>>>>>>>>>>>><<<<<<<<<<<<<<<<<<<<<');
      --RAISE PROGRAM_ERROR;
    end if;
    
    if :is_multitenant = 'YES' and :con_id = 1 then
      execute immediate 'alter session set container='||:pdb_name;
      dbms_output.put_line('>>>>>>>>>> YOU ARE CONNECTED TO A CDB: Setting container to an entered value => '||:pdb_name||' <<<<<<<<<<');
      -- this dbms output will NOT be shown when switching to PDB (bug 30484412 logged against RDBMS)
    else
      --dbms_output.put_line('>>>>>>>>>> Setting container to an entered value => '||:Fusion_PDB.||' <<<<<<<<<<');
      NULL;
    end if;
  exception
    when program_error then
      --dbms_output.put_line('You can''t create SQL Profile in '||:pdb_name);
      RAISE_APPLICATION_ERROR(-20100, 'You can''t create SQL Profile in '||:pdb_name);
    when others then
      --dbms_output.put_line(SQLERRM||chr(10)||'>>>>>>>>>> Can''t continue with the container=>'||:pdb_name||' <<<<<<<<<<');
      RAISE_APPLICATION_ERROR(-20101, SQLERRM||chr(10)||'>>>>>>>>>> Can''t continue with the container=>'||:pdb_name||' <<<<<<<<<<');
  end;
  }';
    l_text := replace(l_text,'$','@');  
    DBMS_OUTPUT.PUT_LINE(l_text);
    DBMS_OUTPUT.PUT_LINE('/');
  l_text := q'{
  
  select sys_context('USERENV', 'CON_NAME') Fusion_PDB from dual;
  pro Proceeding with container "!!Fusion_PDB."
  }';
    l_text := replace(l_text,'!!','&&');
    DBMS_OUTPUT.PUT_LINE(l_text);
		  DBMS_OUTPUT.PUT_LINE('REM');
      DBMS_OUTPUT.PUT_LINE('SET DEF ^');
		  DBMS_OUTPUT.PUT_LINE('VAR signature NUMBER;');
		  DBMS_OUTPUT.PUT_LINE('VAR signaturef NUMBER;');
		  DBMS_OUTPUT.PUT_LINE('REM');
		  DBMS_OUTPUT.PUT_LINE('DECLARE');
		  DBMS_OUTPUT.PUT_LINE('sql_txt CLOB;');
		  DBMS_OUTPUT.PUT_LINE('h       SYS.SQLPROF_ATTR;');
		  DBMS_OUTPUT.PUT_LINE('db_sql_signature NUMBER;');
		  DBMS_OUTPUT.PUT_LINE('PROCEDURE wa (p_line IN VARCHAR2) IS');
		  DBMS_OUTPUT.PUT_LINE('BEGIN');
		  DBMS_OUTPUT.PUT_LINE('DBMS_LOB.WRITEAPPEND(sql_txt, LENGTH(p_line), p_line);');
		  DBMS_OUTPUT.PUT_LINE('END wa;');
		  DBMS_OUTPUT.PUT_LINE('BEGIN');
		  DBMS_OUTPUT.PUT_LINE('DBMS_LOB.CREATETEMPORARY(sql_txt, TRUE);');
		  DBMS_OUTPUT.PUT_LINE('DBMS_LOB.OPEN(sql_txt, DBMS_LOB.LOB_READWRITE);');
		  DBMS_OUTPUT.PUT_LINE('-- SQL Text pieces below do not have to be of same length.');
		  DBMS_OUTPUT.PUT_LINE('-- So if you edit SQL Text (i.e. removing temporary Hints),');
		  DBMS_OUTPUT.PUT_LINE('-- there is no need to edit or re-align unmodified pieces.');
		  l_clob_size := NVL(DBMS_LOB.GETLENGTH(:sql_text), 0);
		  l_offset := 1;
		  WHILE l_offset < l_clob_size
		  LOOP
		    l_pos := DBMS_LOB.INSTR(:sql_text, CHR(00), l_offset);
		    IF l_pos > 0 THEN
		      l_len := l_pos - l_offset;
		    ELSE -- last piece
		      l_len := l_clob_size - l_pos + 1;
		    END IF;
		    l_sql_text := DBMS_LOB.SUBSTR(:sql_text, l_len, l_offset);
		    /* cannot do such 3 replacement since a line could end with a comment using "--"
		    l_sql_text := REPLACE(l_sql_text, CHR(10), ' '); -- replace LF with SP
		    l_sql_text := REPLACE(l_sql_text, CHR(13), ' '); -- replace CR with SP
		    l_sql_text := REPLACE(l_sql_text, CHR(09), ' '); -- replace TAB with SP
		    */
		    l_offset := l_offset + l_len + 1;
		    IF l_len > 0 THEN
		      IF INSTR(l_sql_text, '''[') + INSTR(l_sql_text, ']''') = 0 THEN
			l_sql_text := '['||l_sql_text||']';
		      ELSIF INSTR(l_sql_text, '''{') + INSTR(l_sql_text, '}''') = 0 THEN
			l_sql_text := '{'||l_sql_text||'}';
		      ELSIF INSTR(l_sql_text, '''<') + INSTR(l_sql_text, '>''') = 0 THEN
			l_sql_text := '<'||l_sql_text||'>';
		      ELSIF INSTR(l_sql_text, '''(') + INSTR(l_sql_text, ')''') = 0 THEN
			l_sql_text := '('||l_sql_text||')';
		      ELSIF INSTR(l_sql_text, '''"') + INSTR(l_sql_text, '"''') = 0 THEN
			l_sql_text := '"'||l_sql_text||'"';
		      ELSIF INSTR(l_sql_text, '''|') + INSTR(l_sql_text, '|''') = 0 THEN
			l_sql_text := '|'||l_sql_text||'|';
		      ELSIF INSTR(l_sql_text, '''~') + INSTR(l_sql_text, '~''') = 0 THEN
			l_sql_text := '~'||l_sql_text||'~';
		      ELSIF INSTR(l_sql_text, '''^') + INSTR(l_sql_text, '^''') = 0 THEN
			l_sql_text := '^'||l_sql_text||'^';
		      ELSIF INSTR(l_sql_text, '''@') + INSTR(l_sql_text, '@''') = 0 THEN
			l_sql_text := '@'||l_sql_text||'@';
		      ELSIF INSTR(l_sql_text, '''#') + INSTR(l_sql_text, '#''') = 0 THEN
			l_sql_text := '#'||l_sql_text||'#';
		      ELSIF INSTR(l_sql_text, '''%') + INSTR(l_sql_text, '%''') = 0 THEN
			l_sql_text := '%'||l_sql_text||'%';
		      ELSIF INSTR(l_sql_text, '''$') + INSTR(l_sql_text, '$''') = 0 THEN
			l_sql_text := '$'||l_sql_text||'$';
		      ELSE
			l_sql_text := CHR(96)||l_sql_text||CHR(96);
		      END IF;
		      DBMS_OUTPUT.PUT_LINE('wa(q'''||l_sql_text||''');');
		    END IF;
		  END LOOP;
		  DBMS_OUTPUT.PUT_LINE('DBMS_LOB.CLOSE(sql_txt);');
		  DBMS_OUTPUT.PUT_LINE('h := SYS.SQLPROF_ATTR(');
		  DBMS_OUTPUT.PUT_LINE('q''[BEGIN_OUTLINE_DATA]'',');
		  FOR i IN (SELECT /*+ opt_param('parallel_execution_enabled', 'false') */
				   SUBSTR(EXTRACTVALUE(VALUE(d), '/hint'), 1, 4000) hint
			      FROM TABLE(XMLSEQUENCE(EXTRACT(XMLTYPE(:other_xml), '/*/outline_data/hint'))) d)
		  LOOP
		    l_hint := i.hint;
		    WHILE NVL(LENGTH(l_hint), 0) > 0
		    LOOP
		      IF LENGTH(l_hint) <= 500 THEN
			DBMS_OUTPUT.PUT_LINE('q''['||l_hint||']'',');
			l_hint := NULL;
		      ELSE
			l_pos := INSTR(SUBSTR(l_hint, 1, 500), ' ', -1);
			DBMS_OUTPUT.PUT_LINE('q''['||SUBSTR(l_hint, 1, l_pos)||']'',');
			l_hint := '   '||SUBSTR(l_hint, l_pos);
		      END IF;
		    END LOOP;
		  END LOOP;
		  DBMS_OUTPUT.PUT_LINE('q''[END_OUTLINE_DATA]'');');
		  DBMS_OUTPUT.PUT_LINE(':signature := DBMS_SQLTUNE.SQLTEXT_TO_SIGNATURE(sql_txt);');
		  DBMS_OUTPUT.PUT_LINE(':signaturef := DBMS_SQLTUNE.SQLTEXT_TO_SIGNATURE(sql_txt, TRUE);');
		  DBMS_OUTPUT.PUT_LINE('begin');
		  DBMS_OUTPUT.PUT_LINE('  begin');
		  DBMS_OUTPUT.PUT_LINE('    select exact_matching_signature');
		  DBMS_OUTPUT.PUT_LINE('    into db_sql_signature');
		  DBMS_OUTPUT.PUT_LINE('    from gv$sql');
		  DBMS_OUTPUT.PUT_LINE('    where sql_id = '''||c_sql_id||'''');
		  DBMS_OUTPUT.PUT_LINE('    and rownum = 1;');
		  DBMS_OUTPUT.PUT_LINE('  if db_sql_signature = :signature');
		  DBMS_OUTPUT.PUT_LINE('  then');
		  DBMS_OUTPUT.PUT_LINE('    dbms_output.put_line(''SQL signature matches EXACT_MATCHING_SIGNATURE from GV$SQL.'');');
		  DBMS_OUTPUT.PUT_LINE('  else');
		  DBMS_OUTPUT.PUT_LINE('    dbms_output.put_line(''SQL signature '' || to_char(:signature) || '' does not match EXACT_MATCHING_SIGNATURE '' || to_char(db_sql_signature) ||  '' from GV$SQL'');');
		  DBMS_OUTPUT.PUT_LINE('    RAISE_APPLICATION_ERROR(-20100, ''SQL signature and GV$SQL exact matching signature do not match.'');');
		  DBMS_OUTPUT.PUT_LINE('  end if;');
		  DBMS_OUTPUT.PUT_LINE('  exception');
		  DBMS_OUTPUT.PUT_LINE('    when no_data_found then');
		  DBMS_OUTPUT.PUT_LINE('      db_sql_signature := -1;');
		  DBMS_OUTPUT.PUT_LINE('    when others then');
		  DBMS_OUTPUT.PUT_LINE('      raise;');
		  DBMS_OUTPUT.PUT_LINE('  end;');
		  DBMS_OUTPUT.PUT_LINE('  if db_sql_signature = -1');
		  DBMS_OUTPUT.PUT_LINE('  then');
		  DBMS_OUTPUT.PUT_LINE('    begin ');
		  DBMS_OUTPUT.PUT_LINE('      select force_matching_signature');
		  DBMS_OUTPUT.PUT_LINE('      into db_sql_signature');
		  DBMS_OUTPUT.PUT_LINE('      from dba_hist_sqlstat');
		  DBMS_OUTPUT.PUT_LINE('      where sql_id = '''||c_sql_id||'''');
		  DBMS_OUTPUT.PUT_LINE('      and force_matching_signature != 0');
		  DBMS_OUTPUT.PUT_LINE('      and rownum = 1;');
		  DBMS_OUTPUT.PUT_LINE('      if db_sql_signature = :signaturef');
		  DBMS_OUTPUT.PUT_LINE('      then');
		  DBMS_OUTPUT.PUT_LINE('        dbms_output.put_line(''SQL force signature matches FORCE_MATCHING_SIGNATURE from DBA_HIST_SQLSTAT.'');');
		  DBMS_OUTPUT.PUT_LINE('      else');
		  DBMS_OUTPUT.PUT_LINE('        dbms_output.put_line(''Force SQL signature '' || to_char(:signaturef) || '' does not match FORCE_MATCHING_SIGNATURE '' || to_char(db_sql_signature) || '' from DBA_HIST_SQLSTAT.'');');
		  DBMS_OUTPUT.PUT_LINE('        RAISE_APPLICATION_ERROR(-20100, ''Force SQL signature and DBA_HIST_SQLSTAT force matching signature do not match.'');');
		  DBMS_OUTPUT.PUT_LINE('      end if;');
		  DBMS_OUTPUT.PUT_LINE('    exception ');
		  DBMS_OUTPUT.PUT_LINE('      when no_data_found then');
		  DBMS_OUTPUT.PUT_LINE('        dbms_output.put_line(''Unable to validate SQL signature because SQL_ID was not found in GV$SQL or DBA_HIST_SQLSTAT.'');');
		  DBMS_OUTPUT.PUT_LINE('      when others then');
		  DBMS_OUTPUT.PUT_LINE('        raise;');
		  DBMS_OUTPUT.PUT_LINE('    end;');
		  DBMS_OUTPUT.PUT_LINE('  end if;');
		  DBMS_OUTPUT.PUT_LINE('end;');
		  DBMS_OUTPUT.PUT_LINE('DBMS_SQLTUNE.IMPORT_SQL_PROFILE (');
		  DBMS_OUTPUT.PUT_LINE('sql_text    => sql_txt,');
		  DBMS_OUTPUT.PUT_LINE('profile     => h,');
		  DBMS_OUTPUT.PUT_LINE('name        => ''coe_'||c_sql_id||'_'||c_plan_hash_value||''',');
		  DBMS_OUTPUT.PUT_LINE('description => ''coe '||c_sql_id||' '||c_plan_hash_value||' ''||:signature||'' ''||:signaturef||'''',');
		  DBMS_OUTPUT.PUT_LINE('category    => ''DEFAULT'',');
		  DBMS_OUTPUT.PUT_LINE('validate    => TRUE,');
		  DBMS_OUTPUT.PUT_LINE('replace     => TRUE,');
		  DBMS_OUTPUT.PUT_LINE('force_match => FALSE /* TRUE:FORCE (match even when different literals in SQL). FALSE:EXACT (similar to CURSOR_SHARING) */ );');
		  DBMS_OUTPUT.PUT_LINE('DBMS_LOB.FREETEMPORARY(sql_txt);');
		  DBMS_OUTPUT.PUT_LINE('END;');
		  DBMS_OUTPUT.PUT_LINE('/');
		  DBMS_OUTPUT.PUT_LINE('WHENEVER SQLERROR CONTINUE');
		  DBMS_OUTPUT.PUT_LINE('SET ECHO OFF;');
		  DBMS_OUTPUT.PUT_LINE('PRINT signature');
		  DBMS_OUTPUT.PUT_LINE('PRINT signaturef');
		  DBMS_OUTPUT.PUT_LINE('PRO');
		  DBMS_OUTPUT.PUT_LINE('PRO ... manual custom SQL Profile has been created');
		  DBMS_OUTPUT.PUT_LINE('PRO');
		  DBMS_OUTPUT.PUT_LINE('SPO OFF;');
	    DBMS_OUTPUT.PUT_LINE('SET TERM ON ECHO OFF NUMF "" FEED ON;');
	    DBMS_OUTPUT.PUT_LINE('SET DEF ON;');
		  DBMS_OUTPUT.PUT_LINE('PRO');
		  DBMS_OUTPUT.PUT_LINE('PRO COE_XFR_SQL_PROFILE_'||c_sql_id||'_'||c_plan_hash_value||' completed');
		DBMS_OUTPUT.PUT_LINE('REM');
		DBMS_OUTPUT.PUT_LINE('REM');
		DBMS_OUTPUT.PUT_LINE('REM');
		DBMS_OUTPUT.PUT_LINE('REM');
		DBMS_OUTPUT.PUT_LINE('REM');
		DBMS_OUTPUT.PUT_LINE('REM');
		DBMS_OUTPUT.PUT_LINE('REM');
		DBMS_OUTPUT.PUT_LINE('REM **************************************************************************************************************');
		DBMS_OUTPUT.PUT_LINE('REM *******    SQL PROFILE Script for Plan Hash Value : '|| c_plan_hash_value||'         ENDS HERE');  
		DBMS_OUTPUT.PUT_LINE('REM **************************************************************************************************************');
		DBMS_OUTPUT.PUT_LINE('REM'||' END '||c_plan_hash_value);
		DBMS_OUTPUT.PUT_LINE('REM');
		DBMS_OUTPUT.PUT_LINE('REM');
		DBMS_OUTPUT.PUT_LINE('REM');
		DBMS_OUTPUT.PUT_LINE('REM');
		DBMS_OUTPUT.PUT_LINE('REM');
		DBMS_OUTPUT.PUT_LINE('REM');
		DBMS_OUTPUT.PUT_LINE('REM');
		DBMS_OUTPUT.PUT_LINE('REM');

	END;


--==========================END MAIN SQL PROFILE CREATION SCRIPT =========================================


	-- Main Cursor check
	   EXIT WHEN c_phv%notfound; 
   END LOOP; 
   CLOSE c_phv; 
DBMS_OUTPUT.PUT_LINE('REM ');
DBMS_OUTPUT.PUT_LINE('REM ');
DBMS_OUTPUT.PUT_LINE('REM ');
DBMS_OUTPUT.PUT_LINE('REM ################################################################################');
DBMS_OUTPUT.PUT_LINE('REM               ALL SQL PROFILE Scripts END ');
DBMS_OUTPUT.PUT_LINE('REM ################################################################################');
DBMS_OUTPUT.PUT_LINE('REM');
DBMS_OUTPUT.PUT_LINE('REM');

END; 
/
SPO OFF;

--SET DEF ON TERM OFF ECHO OFF FEED OFF VER OFF HEA ON LIN 2000 PAGES 100 LONG 8000000 LONGC 800000 TRIMS ON TI OFF TIMI OFF SERVEROUT ON SIZE 1000000 NUMF "" SQLP SQL>;
--SET TERM ON ECHO OFF FEED ON VER ON HEA ON LIN 80 PAGES 14 LONG 80 LONGC 80 TRIMS OFF TI OFF TIMI OFF SERVEROUT OFF 
--SET DEF ON TERM ON ECHO OFF FEED OFF VER OFF HEA ON LIN 2000 SERVEROUT OFF

--SET TERM ON ECHO OFF FEED OFF VER OFF HEA OFF LIN 2000 PAGES 1000 LONG 2000000 LONGC 2000 TRIMS ON TI OFF TIMI OFF SERVEROUT ON SIZE 1000000 NUMF "" ;

rem PRO end -->
rem SELECT '<!-- '||TO_CHAR(SYSDATE, 'YYYY-MM-DD/HH24:MI:SS')||' -->' FROM dual;
rem SELECT :det FROM DUAL;
rem SELECT '<!-- '||TO_CHAR(SYSDATE, 'YYYY-MM-DD/HH24:MI:SS')||' -->' FROM dual;
--SPO OFF;



/*================================= SQL Profile - Vivek Jha END=================================*/



/**************************************************************************************************
 *
 * Uday.PSR.v6
 * - ALL binds
 *   - monitored 
 *   - peeked (mem, awr)
 *   - captured (mem, awr)
 *
 **************************************************************************************************/

EXEC DBMS_APPLICATION_INFO.SET_CLIENT_INFO('^^method.: All Bind Values ' || TO_CHAR(SYSDATE, 'YYYY-MM-DD/HH24:MI:SS'));
SELECT TO_CHAR(SYSDATE, 'YYYY-MM-DD/HH24:MI:SS') FROM dual;
PRO Please Wait

SET heading on pages 1000 lines 300 trimspool on

col INST_ID format 99999 heading Inst#
col plan_hash_value heading "Plan Hash|Value"
col position for 999 heading "Position"
col name for a30 heading "Bind Variable Name"
col peeked_value for a30 heading "Peeked Value"
col captured_value for a31 heading "Captured Value"
col dup_pos for 999 heading "Dup|Pos"
col dtype for a15 heading "Data Type"
col datatype_string for a15 heading "Data Type"
col max_length for 9999 heading "Max|Len"
col ch# for 999 heading "Child|Num"
col plan_gen_ts for a21 heading "Plan Generated|On"
col LAST_CAPTURED for a21 heading "Captured|On"
col avg_et for 999999.999 heading "Avg|Elapsed|Time"
col avg_bg for 9999999999 heading "Avg|Buffer|Gets"
col sqlmon_et for 999999.999 heading "Elapsed|Time"
col sqlmon_bg for 9999999999 heading "Buffer|Gets"
col sqlmon_val for a31 heading "Monitored Bind|Value"
col sql_exec_start for a22 heading "SQL Exec Start"
col instance_number for 99 heading "Inst#"
col END_INTERVAL_TIME for a30 heading "Snapshot"

SPO ^^files_prefix._13_all_bind_values.html;

rem set markup html on
PRO <html>
PRO <head><title>^^files_prefix._13_all_bind_values.html</title></head>
PRO <body><pre>


PRO
PRO Sections:
PRO --------;
PRO  1. Peeked Vs Monitored Bind Values - In Memory
PRO  2. Peeked Vs Captured  Bind Values - In Memory
PRO  3. Peeked Vs Captured  Bind Values - In AWR
PRO
PRO -----------------------------------------------;
PRO Peeked Vs Monitored Bind Values - In Memory
PRO -----------------------------------------------;
PRO
break on inst_id on sql_exec_id on sql_exec_start on plan_gen_ts on plan_hash_value on ch# on sqlmon_et on sqlmon_bg

-- set timing on
with peeked as
(
  SELECT /*+ materialize */ inst_id, sql_id, plan_hash_value, address, child_address, child_number, timestamp,
         to_number(extractValue(value(d), '/bind/@pos')) position,
         extractValue(value(d), '/bind/@nam') name,
         max(extractValue(value(d), '/bind')) over(partition by inst_id, sql_id, plan_hash_value, address, child_address, child_number, extractValue(value(d), '/bind/@nam')) value,
         to_number(extractValue(value(d), '/bind/@ppo')) dup_pos,
         extractValue(value(d), '/bind/@dty') dtype,
         to_number(extractValue(value(d), '/bind/@mxl')) max_length
    FROM
         gv$sql_plan c
         , TABLE(XMLSEQUENCE(EXTRACT(XMLTYPE(c.other_xml ), '/*/peeked_binds/bind'))) D
   where c.sql_id = :sql_id
     and c.other_xml is not null
   -- order by sql_id, to_number(EXTRACTVALUE(VALUE(D), '/bind/@pos'))
)
,
peeked_val as
(
  select peeked.*,
         (case when dtype = 1 then 'VARCHAR2(' || max_length || ')'
               when dtype = 2 then 'NUMBER(' || max_length || ')'
               when dtype = 12 then 'Date(' || max_length || ')'
               when dtype in (180, 181) then 'TIMESTAMP(' || max_length || ')'
          end
         ) datatype_string,
         case
           when dtype = 1  -- VARCHAR2
             then to_char(utl_raw.cast_to_varchar2(value))
           when dtype = 2  -- NUMBER
             then to_char(utl_raw.cast_to_number(value))
           when dtype = 12 -- Date
             then rtrim(
                    to_char(100*(to_number(substr(value,1,2),'XX')-100)
                           + (to_number(substr(value,3,2),'XX')-100),'fm0000')||'-'||
                    to_char(to_number(substr(value,5,2),'XX'),'fm00')||'-'||
                    to_char(to_number(substr(value,7,2),'XX'),'fm00')||' '||
                    to_char(to_number(substr(value,9,2),'XX')-1,'fm00')||':'||
                    to_char(to_number(substr(value,11,2),'XX')-1,'fm00')||':'||
                    to_char(to_number(substr(value,13,2),'XX')-1,'fm00'))
           when dtype in (180, 181)  -- Timestamp and Timestamp with tz
             then rtrim(
                    to_char(100*(to_number(substr(value,1,2),'XX')-100)
                            + (to_number(substr(value,3,2),'XX')-100),'fm0000')||'-'||
                    to_char(to_number(substr(value,5,2),'XX'),'fm00')||'-'||
                    to_char(to_number(substr(value,7,2),'XX'),'fm00')||' '||
                    to_char(to_number(substr(value,9,2),'XX')-1,'fm00')||':'||
                    to_char(to_number(substr(value,11,2),'XX')-1,'fm00')||':'||
                    to_char(to_number(substr(value,13,2),'XX')-1,'fm00')
                    ||'.'||to_number(substr(value,15,8),'XXXXXXXX')  )
           else
              value
         end cvalue
    from peeked
   -- order by position
)
,
captured_binds as
(
  select sm.key, sm.inst_id, sm.sql_id, sm.sql_exec_id, sm.sql_exec_start, sm.sql_plan_hash_value, sm.sql_child_address, 
         round(sm.elapsed_time/1000000,2) elapsed_time, buffer_gets,
         to_number(extractvalue(value(b), '/bind/@pos')) position,
         extractvalue(value(b), '/bind/@name') name, 
         extractvalue(value(b), '/bind') captured_value,
         extractvalue(value(b), '/bind/@dtystr') datatype_string
   from
         gv$sql_monitor sm
         , table(xmlsequence(extract(xmltype(sm.binds_xml ), '/binds/bind'))) b
   where sm.sql_id = :sql_id
     and sm.binds_xml is not null
   -- ORDER BY inst_id, child_number, position, dup_position
)
select cb.inst_id, cb.sql_exec_id, to_char(cb.sql_exec_start, 'dd-mon-yy hh24:mi:ss') sql_exec_start, cb.sql_plan_hash_value 
       , max(pv.child_number) over(partition by cb.key) ch# 
       , to_char(max(pv.timestamp) over(partition by cb.key), 'dd-mon-yy hh24:mi:ss') plan_gen_ts 
       , cb.elapsed_time sqlmon_et, cb.buffer_gets sqlmon_bg
       , cb.position, cb.name
       , cb.datatype_string
       , case when (cb.datatype_string like 'VARCHAR%' and :pii_used>0) then substr(pv.cvalue,1,length(pv.cvalue)/3+1)||rpad('***********************************', length(pv.cvalue)*2/3)
         else pv.cvalue 
         end peeked_value
       , case when cb.datatype_string like 'TIMEST%' THEN
               rtrim(
                    to_char(100*(to_number(substr(cb.captured_value,1,2),'XX')-100)
                            + (to_number(substr(cb.captured_value,3,2),'XX')-100),'fm0000')||'-'||
                    to_char(to_number(substr(cb.captured_value,5,2),'XX'),'fm00')||'-'||
                    to_char(to_number(substr(cb.captured_value,7,2),'XX'),'fm00')||' '||
                    to_char(to_number(substr(cb.captured_value,9,2),'XX')-1,'fm00')||':'||
                    to_char(to_number(substr(cb.captured_value,11,2),'XX')-1,'fm00')||':'||
                    to_char(to_number(substr(cb.captured_value,13,2),'XX')-1,'fm00')
                    ||'.'||to_number(substr(cb.captured_value,15,8),'XXXXXXXX')  
               )
              when (cb.datatype_string like 'VARCHAR%' and :pii_used>0) then substr(cb.captured_value,1,length(cb.captured_value)/3+1)||rpad('***********************************', length(cb.captured_value)*2/3)
         else cb.captured_value 
         end sqlmon_val 
  from peeked_val pv, captured_binds cb
 where 1 = 1
   and cb.inst_id = pv.inst_id
   and cb.sql_id  = pv.sql_id
   and cb.sql_child_address = pv.child_address
   and cb.sql_plan_hash_value = pv.plan_hash_value
   and cb.position = pv.position
   and cb.name = pv.name
 order by cb.inst_id, cb.sql_exec_id, cb.sql_exec_start, cb.sql_plan_hash_value, ch#, plan_gen_ts, cb.elapsed_time, cb.buffer_gets, cb.position
;
-- set timing off

clear breaks

PRO
PRO ------------------------------------------;
PRO Peeked Vs Captured Bind Values - In Memory 
PRO ------------------------------------------;
PRO

break on inst_id on plan_hash_value on ch# on plan_gen_ts on avg_et on avg_bg

-- set timing on
with peeked as
(
  SELECT /*+ materialize */ inst_id, sql_id, plan_hash_value, address, child_address, child_number, timestamp,
         to_number(extractValue(value(d), '/bind/@pos')) position,
         extractValue(value(d), '/bind/@nam') name,
         extractValue(value(d), '/bind') value,
         to_number(extractValue(value(d), '/bind/@ppo')) dup_pos,
         extractValue(value(d), '/bind/@dty') dtype,
         to_number(extractValue(value(d), '/bind/@mxl')) max_length
    FROM
         gv$sql_plan c
         , TABLE(XMLSEQUENCE(EXTRACT(XMLTYPE(c.other_xml ), '/*/peeked_binds/bind'))) D
   where c.sql_id = :sql_id
    and c.other_xml is not null
  -- order by sql_id, to_number(EXTRACTVALUE(VALUE(D), '/bind/@pos'))
)
,
peeked_val as
(
  select peeked.*,
         (case when dtype = 1 then 'VARCHAR2'
               when dtype = 2 then 'NUMBER'
               when dtype = 12 then 'Date'
               when dtype in (180, 181) then 'TIMESTAMP'
          end
         ) datatype_string,
         case
           when dtype = 1  -- VARCHAR2
             then to_char(utl_raw.cast_to_varchar2(value))
           when dtype = 2  -- NUMBER
             then to_char(utl_raw.cast_to_number(value))
           when dtype = 12 -- Date
             then rtrim(
                    to_char(100*(to_number(substr(value,1,2),'XX')-100)
                           + (to_number(substr(value,3,2),'XX')-100),'fm0000')||'-'||
                    to_char(to_number(substr(value,5,2),'XX'),'fm00')||'-'||
                    to_char(to_number(substr(value,7,2),'XX'),'fm00')||' '||
                    to_char(to_number(substr(value,9,2),'XX')-1,'fm00')||':'||
                    to_char(to_number(substr(value,11,2),'XX')-1,'fm00')||':'||
                    to_char(to_number(substr(value,13,2),'XX')-1,'fm00'))
           when dtype in (180, 181)  -- Timestamp and Timestamp with tz
             then rtrim(
                    to_char(100*(to_number(substr(value,1,2),'XX')-100)
                            + (to_number(substr(value,3,2),'XX')-100),'fm0000')||'-'||
                    to_char(to_number(substr(value,5,2),'XX'),'fm00')||'-'||
                    to_char(to_number(substr(value,7,2),'XX'),'fm00')||' '||
                    to_char(to_number(substr(value,9,2),'XX')-1,'fm00')||':'||
                    to_char(to_number(substr(value,11,2),'XX')-1,'fm00')||':'||
                    to_char(to_number(substr(value,13,2),'XX')-1,'fm00')
                    ||'.'||to_number(substr(value,15,8),'XXXXXXXX')  )
           else
              value
         end cvalue
    from peeked
   -- order by position
)
,
captured_binds as
(
  SELECT s.inst_id, s.sql_id, s.plan_hash_value, s.CHILD_ADDRESS, s.CHILD_NUMBER, s.address
         , s.first_load_time, s.last_active_time, s.executions, s.buffer_gets
         , round(s.elapsed_time/1000000/decode(s.executions, 0, 1, s.executions), 3) avg_et
         , round(s.buffer_gets/decode(s.executions, 0, 1, s.executions)) avg_bg
         , b.position, b.name
         , case when b.datatype_string like 'TIMESTAM%' then substr(anydata.accesstimestamp(b.value_anydata),1,50)
                when (b.datatype_string like 'VARCHAR%' and :pii_used>0) then substr(b.value_string,1,length(b.value_string)/3+1)||rpad('***********************************', length(b.value_string)*2/3)
           else b.value_string
           end captured_value
         , b.datatype_string
         , b.LAST_CAPTURED
    FROM gv$sql s, gv$sql_bind_capture b
   WHERE s.sql_id = :sql_id
     and b.inst_id = s.inst_id
     and b.sql_id  = s.sql_id
     and b.address = s.address
     and b.child_address = s.child_address
     and b.child_number = s.child_number
   -- ORDER BY inst_id, child_number, position, dup_position
)
select pv.inst_id, pv.plan_hash_value, pv.child_number ch#, to_char(pv.timestamp, 'dd-mon-yy hh24:mi:ss') plan_gen_ts, cb.avg_et, cb.avg_bg
       , pv.position, pv.name 
       -- , pv.datatype_string
       , case when cb.datatype_string is not null then cb.datatype_string else pv.datatype_string end datatype_string
       , case when (pv.datatype_string like 'VARCHAR%' and :pii_used>0) then substr(pv.cvalue,1,length(pv.cvalue)/3+1)||rpad('***********************************', length(pv.cvalue)*2/3)
         else pv.cvalue 
         end peeked_value
       , cb.captured_value
       -- , cb.last_captured
       , to_char(cb.last_captured, 'dd-mon-yy hh24:mi:ss') last_captured
  from peeked_val pv, captured_binds cb
 where 1 = 1
   and cb.inst_id = pv.inst_id
   and cb.sql_id  = pv.sql_id
   and cb.address = pv.address
   and cb.child_address = pv.child_address
   and cb.child_number = pv.child_number
   and cb.position = pv.position
   and cb.name = pv.name
 order by pv.timestamp, pv.plan_hash_value, pv.child_number, to_number(pv.position)
;
-- set timing off

clear breaks

PRO
PRO ---------------------------------------;
PRO Peeked Vs Captured Bind Values - In AWR 
PRO ---------------------------------------;
PRO

break on instance_number on snap_id on end_interval_time on plan_hash_value on plan_gen_ts on avg_et on avg_bg

-- set timing on
with peeked as 
(
  SELECT /*+ materialize */ sql_id, plan_hash_value, timestamp,
         to_number(extractValue(value(d), '/bind/@pos')) position,
         extractValue(value(d), '/bind/@nam') name,
         extractValue(value(d), '/bind') value,
         to_number(extractValue(value(d), '/bind/@ppo')) dup_pos,
         extractValue(value(d), '/bind/@dty') dtype,
         to_number(extractValue(value(d), '/bind/@mxl')) max_length
    FROM
         dba_hist_sql_plan c
         , TABLE(XMLSEQUENCE(EXTRACT(XMLTYPE(c.other_xml ), '/*/peeked_binds/bind'))) D
   where 1=1
     and (:license IN ('T', 'D') or (:license = 'L' and c.timestamp > sysdate - interval '^^days.' day))
     and c.dbid = ^^dbid.
     and c.sql_id = :sql_id
    and c.other_xml is not null
  -- order by sql_id, to_number(EXTRACTVALUE(VALUE(D), '/bind/@pos'))
)
,
peeked_binds as 
(
  select /*+ materialize */ peeked.*,
         (case when dtype = 1 then 'VARCHAR2'
               when dtype = 2 then 'NUMBER'
               when dtype = 12 then 'Date'
               when dtype in (180, 181) then 'TIMESTAMP'
          end
         ) datatype_string, 
         case 
           when dtype = 1  -- VARCHAR2
             then to_char(utl_raw.cast_to_varchar2(value))
           when dtype = 2  -- NUMBER
             then to_char(utl_raw.cast_to_number(value))
           when dtype = 12 -- Date
             then rtrim(
                    to_char(100*(to_number(substr(value,1,2),'XX')-100)
                           + (to_number(substr(value,3,2),'XX')-100),'fm0000')||'-'||
                    to_char(to_number(substr(value,5,2),'XX'),'fm00')||'-'||
                    to_char(to_number(substr(value,7,2),'XX'),'fm00')||' '||
                    to_char(to_number(substr(value,9,2),'XX')-1,'fm00')||':'||
                    to_char(to_number(substr(value,11,2),'XX')-1,'fm00')||':'||
                    to_char(to_number(substr(value,13,2),'XX')-1,'fm00'))
           when dtype in (180, 181)  -- Timestamp and Timestamp with tz
             then rtrim(
                    to_char(100*(to_number(substr(value,1,2),'XX')-100)
                            + (to_number(substr(value,3,2),'XX')-100),'fm0000')||'-'||
                    to_char(to_number(substr(value,5,2),'XX'),'fm00')||'-'||
                    to_char(to_number(substr(value,7,2),'XX'),'fm00')||' '||
                    to_char(to_number(substr(value,9,2),'XX')-1,'fm00')||':'||
                    to_char(to_number(substr(value,11,2),'XX')-1,'fm00')||':'||
                    to_char(to_number(substr(value,13,2),'XX')-1,'fm00')
                    ||'.'||to_number(substr(value,15,8),'XXXXXXXX')  )
           else
              value
         end cvalue
    from peeked
   -- order by position
)
,
captured_binds as
(
  select /*+ materialize */ s.dbid, s.instance_number, s.snap_id, s.sql_id, s.plan_hash_value, s.executions_delta, s.buffer_gets_delta,
         round(s.elapsed_time_delta/1000000/decode(s.executions_delta, 0, 1, s.executions_delta), 3) avg_et,
         round(s.buffer_gets_delta/decode(s.executions_delta, 0, 1, s.executions_delta)) avg_bg
         , b.position
         -- , bm.name -- PSRv7 - moved to main select to improve performance
         , case when b.datatype_string like 'TIMESTAM%' then substr(anydata.accesstimestamp(b.value_anydata),1,50) 
                when (b.datatype_string like 'VARCHAR%' and :pii_used>0) then substr(b.value_string,1,length(b.value_string)/3+1)||rpad('***********************************', length(b.value_string)*2/3)
           else b.value_string
           end captured_value
         , b.datatype_string
         , b.LAST_CAPTURED
         , ss.END_INTERVAL_TIME
    from dba_hist_sqlstat s, table(dbms_sqltune.extract_binds(s.bind_data)) b
         -- , dba_hist_sql_bind_metadata bm  -- PSRv7 - using only to get name, which we are already getting from peeked binds
         , dba_hist_snapshot ss
   where 1 = 1
     and (:license IN ('T', 'D') or (:license = 'L' and ss.begin_interval_time > systimestamp - interval '^^days.' day))
     and s.dbid = ^^dbid.
     and s.sql_id = :sql_id
     and s.bind_data is not null
     and s.dbid = ss.dbid
     and s.instance_number = ss.instance_number
     and s.snap_id = ss.snap_id
     and s.dbid = ss.dbid
     -- and bm.sql_id = s.sql_id      -- PSRv7
     -- AND bm.position = b.position  -- PSRv7
)
select instance_number, snap_id, end_interval_time, plan_hash_value, plan_gen_ts, avg_et, avg_bg, position, name, datatype_string, peeked_value, captured_value, last_captured
FROM (
select cb.instance_number, cb.snap_id, cb.end_interval_time, pv.plan_hash_value, to_char(pv.timestamp, 'dd-mon-yy hh24:mi:ss') plan_gen_ts, cb.avg_et, cb.avg_bg, pv.position, pv.name 
       , case when cb.datatype_string is not null then cb.datatype_string else pv.datatype_string end datatype_string
       , case when (pv.datatype_string like 'VARCHAR%' and :pii_used>0) then substr(pv.cvalue,1,length(pv.cvalue)/3+1)||rpad('***********************************', length(pv.cvalue)*2/3)
         else pv.cvalue 
         end peeked_value
       , cb.captured_value, to_char(cb.last_captured, 'dd-mon-yy hh24:mi:ss') last_captured -- PSRv7
  from peeked_binds pv, captured_binds cb
 where 1 = 1
   and pv.plan_hash_value = cb.plan_hash_value
   and cb.position = pv.position
 --order by pv.plan_hash_value, cb.instance_number, cb.snap_id, pv.timestamp, to_number(pv.position)
 order by cb.snap_id desc, pv.plan_hash_value, cb.instance_number, pv.timestamp, to_number(pv.position)
) where rownum < 501;   /* added on 11/6/20 since this was fetching lots of rows with file size > 100MB */
-- set timing off

PRO 
rem set markup html off
PRO </pre></body></html>
SPO OFF;

/**************************************************************************************************
 *
 * Uday.PSR.v10
 * - generate executable script with peeked binds
 *
 **************************************************************************************************/

SELECT TO_CHAR(SYSDATE, 'YYYY-MM-DD/HH24:MI:SS') FROM dual;
PRO Please Wait

SET heading on pages 1000 lines 300 trimspool on

SPO ^^files_prefix._14_executable_script.sql
col sql_text for A150 wor

prompt --;
prompt -- executable script with peeked binds
prompt --;
set pages 10000 head off 
prompt set serveroutput off pages 1000 lines 250 trimspool on
prompt --;
prompt ;
prompt ;
prompt -- WHENEVER SQLERROR EXIT SQL.SQLCODE;
prompt -- ;
prompt -- begin
prompt --  if user <> 'FUSION' then
prompt --      RAISE_APPLICATION_ERROR(-20002, 'please login as FUSION user');
prompt --  end if;
prompt -- end;
prompt -- /
prompt -- ;
prompt -- Prompt  ;
prompt -- Prompt Enter SYSTEM password. It is used to fetch execution plan later in the script. It is not printed anywhere. 
prompt -- prompt  ;
prompt -- ;
prompt -- accept system_password CHAR PROMPT 'SYSTEM Password (not printed anywhere):  ' HIDE
prompt -- ;
prompt -- set timing off serveroutput off trimspool on lines 250 pages 10000 verify off
prompt -- ;
prompt -- COL time_stamp NEW_V time_stamp FOR A15;
prompt -- SELECT TO_CHAR(SYSDATE, 'ddmonHH24MISS') time_stamp FROM DUAL;
prompt -- ;
prompt -- col spoolf new_value spoolf
prompt -- select 'bug20902533_17m3u5qn35d8c_&&time_stamp' spoolf from dual;
prompt -- spool &&spoolf..log
prompt ;
prompt ;
prompt ;
prompt alter session set current_schema=fusion;;
prompt alter session set statistics_level=all;;
prompt -- alter session set tracefile_identifier = 'psr_17m3u5qn35d8c_&&time_stamp';
prompt -- alter session set events 'sql_trace wait=true, bind=true, plan_stat=adaptive: trace[rdbms.SQL_Optimizer.*]:10730 trace name context forever, level 1';
prompt -- ALTER SESSION SET events '10730 trace name context forever, level 1';
prompt -- ALTER session SET events='10235 trace name context forever, level 2:27072 trace name errorstack level 3';
prompt -- alter session set events 'trace[rdbms.SQL_Optimizer.*]';

prompt --;
prompt ;
prompt -- prompt ;
prompt -- prompt -----------;
prompt -- prompt attaching to FND Session...
prompt -- prompt -----------;
prompt -- prompt
prompt -- declare
prompt --   p_user_guid varchar2(32);
prompt --   p_user_name varchar2(60) := '43417567';
prompt --   fnd_session_id varchar2(32);
prompt -- BEGIN
prompt --   select SESSION_ID
prompt --     into fnd_session_id
prompt --     from ( select * from FUSION.FND_SESSIONS 
prompt --             where USER_NAME=p_user_name
prompt --             order by LAST_CONNECT desc
prompt --   ) where rownum <= 1
prompt --   ;
prompt --   ;
prompt --   fnd_session_mgmt.attach_session(fnd_session_id);
prompt -- END;
prompt -- /

with peeked as
(
  SELECT /*+ materialize */ distinct '1gv$' source, inst_id, sql_id, plan_hash_value, address, child_address, child_number, timestamp,
         -1 position, null name, null value, null dup_pos, null dtype, null max_length
    FROM
         gv$sql_plan sp
   where sp.sql_id = :sql_id
union all
  SELECT /*+ materialize */ '1gv$' source, inst_id, sql_id, plan_hash_value, address, child_address, child_number, timestamp,
         to_number(extractValue(value(d), '/bind/@pos')) position,
         extractValue(value(d), '/bind/@nam') name,
         max(extractValue(value(d), '/bind')) over(partition by inst_id, sql_id, plan_hash_value, address, child_address, child_number, extractValue(value(d), '/bind/@nam')) value,
         to_number(extractValue(value(d), '/bind/@ppo')) dup_pos,
         extractValue(value(d), '/bind/@dty') dtype,
         to_number(extractValue(value(d), '/bind/@mxl')) max_length
    FROM
         gv$sql_plan sp
         , TABLE(XMLSEQUENCE(EXTRACT(XMLTYPE(sp.other_xml ), '/*/peeked_binds/bind'))) D
   where sp.sql_id = :sql_id
     and sp.other_xml is not null
   -- order by sql_id, to_number(EXTRACTVALUE(VALUE(D), '/bind/@pos'))
union all
  SELECT /*+ materialize */ distinct '2awr' source, 0 inst_id, sql_id, plan_hash_value, null address, null child_address, -1 child_number, timestamp,
         -1 position, null name, null value, null dup_pos, null dtype, null max_length
    FROM
         dba_hist_sql_plan sp
   where 1=1
     and (:license IN ('T', 'D') or (:license = 'L' and sp.timestamp > sysdate - interval '^^days.' day))
     and sp.dbid = ^^dbid.
     and sp.sql_id = :sql_id
union all
  SELECT /*+ materialize */ '2awr' source, 0 inst_id, sql_id, plan_hash_value, null address, null child_address, -1 child_number, timestamp,
         to_number(extractValue(value(d), '/bind/@pos')) position,
         extractValue(value(d), '/bind/@nam') name,
         extractValue(value(d), '/bind') value,
         to_number(extractValue(value(d), '/bind/@ppo')) dup_pos,
         extractValue(value(d), '/bind/@dty') dtype,
         to_number(extractValue(value(d), '/bind/@mxl')) max_length
    FROM
         dba_hist_sql_plan sp
         , TABLE(XMLSEQUENCE(EXTRACT(XMLTYPE(sp.other_xml ), '/*/peeked_binds/bind'))) D
   where 1=1
     and (:license IN ('T', 'D') or (:license = 'L' and sp.timestamp > sysdate - interval '^^days.' day))
     and sp.dbid = ^^dbid.
     and sp.sql_id = :sql_id
     and sp.other_xml is not null
   -- order by sql_id, to_number(EXTRACTVALUE(VALUE(D), '/bind/@pos'))
)
,
peeked_val as
(
  select peeked.*,
         case regexp_substr(replace(name,':',''),'[[:digit:]]') when replace(name,':','') then Replace(name, ':', ':PSR') end bind_name,
         (case when dtype = 1 then 'VARCHAR2(' || max_length || ')'
               when dtype = 2 then 'NUMBER(' || max_length || ')'
               when dtype in (180, 181, 12) then 'VARCHAR2(30)'
--               when dtype in (180, 181) then 'TIMESTAMP(' || max_length || ')'
          end
         ) datatype_string,
         case
           when dtype = 1  -- VARCHAR2
             then to_char(utl_raw.cast_to_varchar2(value))
           when dtype = 2  -- NUMBER
             then to_char(utl_raw.cast_to_number(value))
           when dtype = 12 -- Date
             then rtrim(
                    to_char(100*(to_number(substr(value,1,2),'XX')-100)
                           + (to_number(substr(value,3,2),'XX')-100),'fm0000')||'-'||
                    to_char(to_number(substr(value,5,2),'XX'),'fm00')||'-'||
                    to_char(to_number(substr(value,7,2),'XX'),'fm00')||' '||
                    to_char(to_number(substr(value,9,2),'XX')-1,'fm00')||':'||
                    to_char(to_number(substr(value,11,2),'XX')-1,'fm00')||':'||
                    to_char(to_number(substr(value,13,2),'XX')-1,'fm00'))
           when dtype in (180, 181)  -- Timestamp and Timestamp with tz
             then rtrim(
                    to_char(100*(to_number(substr(value,1,2),'XX')-100)
                            + (to_number(substr(value,3,2),'XX')-100),'fm0000')||'-'||
                    to_char(to_number(substr(value,5,2),'XX'),'fm00')||'-'||
                    to_char(to_number(substr(value,7,2),'XX'),'fm00')||' '||
                    to_char(to_number(substr(value,9,2),'XX')-1,'fm00')||':'||
                    to_char(to_number(substr(value,11,2),'XX')-1,'fm00')||':'||
                    to_char(to_number(substr(value,13,2),'XX')-1,'fm00')
                    ||'.'||to_number(substr(value,15,8),'XXXXXXXX')  )
           else
              value
         end cvalue
    from peeked
)
,
formatted_val as 
( 
    select peeked_val.*, 
	   decode(cvalue, NULL, 'NULL', cvalue) as nvalue,
       case when dtype in (12)       then q'{to_date     ('}'|| decode(cvalue, '-- ::'  , NULL, cvalue) || q'{','YYYY-MM-DD HH24:MI:SS' )}'
	        when dtype in (180, 181) then q'{to_timestamp('}'|| decode(cvalue, '-- ::.' , NULL, cvalue) || q'{','YYYY-MM-DD HH24:MI:SS.')}'
	   end dtvalue
    from peeked_val
)
select --* 
--       inst_id, sql_id, plan_hash_value, address, child_address, child_number, timestamp, position,
--       bind_name, name,
       case when position = -1 and source = '1gv$'
            then '--**************************************************************' || chr(10) || 
                 '-- Source: GV$, inst/phv/ch#: ' || inst_id ||'/'|| plan_hash_value || '/' || child_number || chr(10) ||
                 '--**************************************************************' 
            when position = -1 and source = '2awr' 
            then '--**************************************************************' || chr(10) || 
                 '-- Source: AWR, phv: ' || plan_hash_value || chr(10) ||
                 '--**************************************************************' 
            else  'variable ' || REPLACE(NAME, ':', '') || ' ' || case when datatype_string like 'NUMBER%' then 'NUMBER' else datatype_string end || chr(10) || 
                  'exec ' || name || ' := ' || case when datatype_string like 'NUMBER%' then nvalue  || ';' 
				                                    when dtype in (12, 180, 181)     then dtvalue || ';'
                                                when (dtype = 1 and :pii_used>0) then '''' || substr(cvalue,1,length(cvalue)/3+1)||rpad('***********************************', length(cvalue)*2/3) || ''';' 
				                                    else                                  '''' || cvalue  || ''';' 
											   end
       end str
  from formatted_val
 order by source, sql_id, inst_id, child_number, plan_hash_value, position
;

prompt --;
prompt --;
prompt COL time_stamp NEW_V time_stamp FOR A15
prompt SELECT TO_CHAR(SYSDATE, 'ddmonHH24MISS') time_stamp FROM DUAL;;
prompt --;
prompt --;

set pagesize 0 echo off timing off linesize 1000 trimspool on trim on long 2000000 longchunksize 2000000 feedback off

with str(sql_text) as 
(SELECT sql_fulltext
          FROM gv$sql
         WHERE sql_id = :sql_id
           AND ROWNUM = 1
        UNION ALL
        SELECT sql_text
          FROM dba_hist_sqltext
         WHERE sql_id = :sql_id
           AND ROWNUM = 1
       ),
cnt as (select sql_text, 
               case when regexp_count(sql_text,'(select|insert|update|delete|merge)[[:space:]]+(--\+|\/\*\+)',1,'i') > 0 then 1
               else 0 
               end hinted 
        from str)
select case when hinted=1 then regexp_replace(sql_text,'(select|insert|update|delete|merge)[[:space:]]+(--\+|\/\*\+)(.*)?(\*\/|.+)','\1 \2 gather_plan_statistics psr_^^time_stamp._^^sql_id \3 \4',1,1,'i')
       else regexp_replace(sql_text,'(select|insert|update|delete|merge)','\1 /*+ gather_plan_statistics psr_^^time_stamp._^^sql_id */',1,1,'i') 
       end
from cnt
 WHERE ROWNUM = 1; 

prompt ;;
prompt --;
prompt select * from table(dbms_xplan.display_cursor(NULL,NULL,'ADVANCED ALLSTATS LAST -OUTLINE -PROJECTION -ALIAS +PEEKED_BINDS'));;

spool off

/**************************************************************************************************/
/**************************************************************************************************/

/**************************************************************************************************
 *
 * Uday (Fusion PSR):
 * - Export table stats
 * - todo: write datapump code to export table...use export_stats_table.sql from this folder
 * - todo: will implement later once 12c version is stable and performing well
 **************************************************************************************************/

--udayRemove EXEC DBMS_APPLICATION_INFO.SET_CLIENT_INFO('^^method.: exporting table stats ' || TO_CHAR(SYSDATE, 'YYYY-MM-DD/HH24:MI:SS'));
--udayRemove PRO
--udayRemove SELECT TO_CHAR(SYSDATE, 'YYYY-MM-DD/HH24:MI:SS') FROM dual;
--udayRemove PRO Please Wait
--udayRemove 
--udayRemove set serveroutput ON
--udayRemove SPO ^^script..log APP
--udayRemove PRO
--udayRemove PRO exporting table stats
--udayRemove PRO
--udayRemove DECLARE
--udayRemove   l_stat_tab_owner VARCHAR2(12) := '^^sessionuser.';
--udayRemove   l_stat_table     VARCHAR2(30) := '^^script._^^sql_id.';
--udayRemove   l_stat_id        VARCHAR2(32) :=  '^^script._^^sql_id.';
--udayRemove 
--udayRemove BEGIN
--udayRemove 
--udayRemove   dbms_stats.Create_stat_table (ownname => l_stat_tab_owner, stattab => l_stat_table);
--udayRemove 
--udayRemove   for cur_tables in (select object_owner owner, object_name table_name from gv$sql_plan 
--udayRemove                       where sql_id = '^^sql_id.' 
--udayRemove                         and object_type = 'TABLE'
--udayRemove                      union
--udayRemove                      select object_owner owner, object_name table_name from dba_hist_sql_plan 
--udayRemove                       where sql_id = '^^sql_id.' 
--udayRemove                         and object_type = 'TABLE'
--udayRemove                     )
--udayRemove   LOOP
--udayRemove     dbms_output.put_line('exporting stats for table: ' || cur_tables.table_name);
--udayRemove     DBMS_STATS.EXPORT_TABLE_STATS
--udayRemove             (
--udayRemove               ownname  => cur_tables.owner,
--udayRemove               tabname  => cur_tables.table_name,
--udayRemove               stattab  => l_stat_table,
--udayRemove               statid   => l_stat_id,
--udayRemove               cascade  => TRUE,
--udayRemove               statown  => l_stat_tab_owner
--udayRemove              );
--udayRemove 
--udayRemove     dbms_output.put_line('exporting table preferences: ' || cur_tables.table_name);
--udayRemove     DBMS_STATS.EXPORT_TABLE_PREFS
--udayRemove             (
--udayRemove               ownname  => cur_tables.owner,
--udayRemove               tabname  => cur_tables.table_name,
--udayRemove               stattab  => l_stat_table,
--udayRemove               statid   => l_stat_id,
--udayRemove               statown  => l_stat_tab_owner
--udayRemove              );
--udayRemove   END LOOP;
--udayRemove 
--udayRemove   dbms_output.Put_line('exporting system stats: ');
--udayRemove   DBMS_STATS.EXPORT_SYSTEM_STATS
--udayRemove             (
--udayRemove               stattab  => l_stat_table,
--udayRemove               statid   => l_stat_id,
--udayRemove               statown  => l_stat_tab_owner
--udayRemove              );
--udayRemove 
--udayRemove   dbms_output.Put_line('Export the statistics table using the below command and upload to the bug:');
--udayRemove   dbms_output.Put_line('exp tables='||l_stat_tab_owner||'.'||l_stat_table||' file='||l_stat_table||'.dmp log=STAT.log');
--udayRemove END;
--udayRemove /
--udayRemove SPO off
--udayRemove set serveroutput OFF

-- HOS echo exp tables=^^sessionuser..^^script._^^sql_id file=^^script._^^sql_id..dmp log=STAT.log

/**************************************************************************************************/

/**************************************************************************************************/

/* -------------------------
 *
 * wrap up
 *
 * ------------------------- */

-- turing trace off
-- ALTER SESSION SET SQL_TRACE = FALSE;
--ALTER SESSION SET STATISTICS_LEVEL = 'TYPICAL';

-- get udump directory path
COL udump_path NEW_V udump_path FOR A500;
-- SELECT value||DECODE(INSTR(value, '/'), 0, '\', '/') udump_path FROM v$parameter2 WHERE name = 'user_dump_dest'; -- PSRv7
SELECT value||DECODE(INSTR(value, '/'), 0, '\', '/') udump_path FROM v$diag_info where name = 'Diag Trace';

-- tkprof for trace from execution of tool in case someone reports slow performance in tool
-- HOS tkprof ^^udump_path.*^^script._^^unique_id.*.trc ^^files_prefix._tkprof_nosort.txt
-- HOS tkprof ^^udump_path.*^^script._^^unique_id.*.trc ^^files_prefix._tkprof_sort.txt sort=prsela exeela fchela

-- windows workaround (copy below will error out on linux and unix)
-- HOS copy ^^udump_path.*^^script._^^unique_id.*.trc ^^udump_path.^^script._^^unique_id..trc
-- HOS tkprof ^^udump_path.^^script._^^unique_id..trc ^^files_prefix._tkprof_nosort.txt
-- HOS tkprof ^^udump_path.^^script._^^unique_id..trc ^^files_prefix._tkprof_sort.txt sort=prsela exeela fchela

SPO ^^script..log APP
set head off
SELECT 'START: ' || to_timestamp('^^sqlhcstart', 'DD-Mon-RR HH24:MI:SS.FF') from dual;
SELECT 'End:   ' || to_timestamp(to_char(systimestamp, 'DD-Mon-RR HH24:MI:SS.FF'), 'DD-Mon-RR HH24:MI:SS.FF') from dual;

-- SELECT 'END:   '||TO_CHAR(SYSDATE, 'YYYY-MM-DD/HH24:MI:SS') FROM dual;
SELECT 'Time: ' || (to_timestamp(to_char(systimestamp, 'DD-Mon-RR HH24:MI:SS.FF'), 'DD-Mon-RR HH24:MI:SS.FF') - to_timestamp('^^sqlhcstart', 'DD-Mon-RR HH24:MI:SS.FF')) as sqlhc_runtime from dual;
set head on
SPO OFF;

/**************************************************************************************************
 *
 * end_common: from begin_common to end_common sqlhc.sql and sqlhcxec.sql are identical
 *
 **************************************************************************************************/

-- zip now in case DBMS_SQLDIAG.DUMP_TRACE disconnects
HOS zip -m ^^files_prefix..zip ^^files_prefix._1_health_check.html
HOS zip -m ^^files_prefix..zip ^^files_prefix._2_diagnostics.html
HOS zip -m ^^files_prefix..zip ^^files_prefix._3_execution_plans.html
HOS zip -m ^^files_prefix..zip ^^files_prefix._4_sql_detail.html

HOS zip -m ^^files_prefix._9_log.zip ask_container.sql ask_container1.sql
HOS zip -m ^^files_prefix._9_log.zip sql_shared_cursor_sum_^^sql_id..sql
HOS zip -m ^^files_prefix._9_log.zip sql_shared_cursor_col_^^sql_id..sql
HOS zip -m ^^files_prefix._9_log.zip sql_shared_cursor_cur_^^sql_id..sql
-- HOS zip -m ^^files_prefix._9_log.zip ^^files_prefix._tkprof_*.txt
HOS zip -m ^^files_prefix._9_log.zip ^^files_prefix._5_sql_monitor.sql
HOS zip -m ^^files_prefix._5_sql_monitor.zip ^^files_prefix.*monitor*.*
HOS zip -m ^^files_prefix..zip ^^files_prefix._5_sql_monitor.zip
-- Uday.PSR.v5 added below files 
HOS zip -m ^^files_prefix..zip ^^files_prefix._10_hardParsePctByUser.txt
HOS zip -m ^^files_prefix..zip ^^files_prefix._11_VPD_Policies.txt
-- Uday.PSR.v6
HOS zip -m ^^files_prefix..zip ^^files_prefix._12_histogram_actual_values.html
HOS zip -m ^^files_prefix..zip ^^files_prefix._13_all_bind_values.html
HOS zip -m ^^files_prefix..zip ^^files_prefix._14_executable_script.sql
HOS zip -m ^^files_prefix..zip ^^files_prefix._15_histogram_actual_values_atHardParse.html
HOS zip -m ^^files_prefix..zip ^^files_prefix._16_sql_profiles.sql

-- generate DBMS_SQLDIAG.DUMP_TRACE 10053. this api is called down here in case it disconnects.
EXEC DBMS_APPLICATION_INFO.SET_CLIENT_INFO('^^method.: DBMS_SQLDIAG.DUMP_TRACE - ' || TO_CHAR(SYSDATE, 'YYYY-MM-DD/HH24:MI:SS'));

var cbo_trace_generated varchar2(1);
DECLARE
  childno pls_integer := null;
BEGIN
  SELECT MIN(child_number) INTO childno FROM v$sql where sql_id=:sql_id;

  IF childno is not null 
  THEN
    IF '^^rdbms_version.' >= '11.2' THEN
      DBMS_SQLDIAG.DUMP_TRACE (
        p_sql_id    => :sql_id,
        p_child_number => childno,
        p_component => 'Optimizer',
        p_file_id   => 'SQLHCCBO_^^unique_id.');
    END IF;
  ELSE
    :cbo_trace_generated := 'N';
  END IF;
END;
/
EXEC DBMS_APPLICATION_INFO.SET_CLIENT_INFO('^^method.: DBMS_SQLDIAG.DUMP_TRACE Done - ' || TO_CHAR(SYSDATE, 'YYYY-MM-DD/HH24:MI:SS'));

-- copy DBMS_SQLDIAG.DUMP_TRACE 10053
SET TERM ON;
SPO ^^script..log APP
EXEC if :cbo_trace_generated = 'N' then dbms_output.put_line('NO CBO trace generated, as the child cursor was NOT found on current inst = '||^^current_instance.||'... Try running on another instance ... ');  end if;
SPO OFF
PRO Ignore CP or COPY error below
SET TERM OFF;
HOS cp ^^udump_path.*_SQLHCCBO_^^unique_id.*.trc   ^^files_prefix._6_10053_trace_from_cursor.trc
HOS copy ^^udump_path.*_SQLHCCBO_^^unique_id.*.trc ^^files_prefix._6_10053_trace_from_cursor.trc
HOS zip -m ^^files_prefix..zip ^^files_prefix._6_10053_trace_from_cursor.trc
HOS zip -m ^^files_prefix._9_log.zip ^^script..log
HOS zip -m ^^files_prefix..zip ^^files_prefix._9_log.zip

SET TERM ON;
EXEC :L_SQLHC_MIN := round((sysdate - TO_DATE('^^unique_id.', 'YYYYMMDD_HH24MISS')) * 24 * 60);

PRO Time taken for SQLHC (in min)
PRINT L_SQLHC_MIN

/*
 sma starts
*/

Set echo off  FEED OFF verify off heading on LINESIZE 300 pagesize 500 TI OFF TIMI OFF SERVEROUT ON SIZE UNL;
REM
REM $Header: 1294364.1 sma.sql 19c 6 2021/05/27 jinsoo.eo $
REM
REM Copyright (c) 2018, Oracle Corporation. All rights reserved.
REM
REM AUTHOR
REM   jinsoo.eo@oracle.com
REM
REM SCRIPT NAME (SQL MONITOR ANALYZER)
REM   sma.sql
REM
REM DESCRIPTION
REM
REM   This script generates a spool output file that contains the recommendation to improve
REM   the performance for Fusion Apps (FA) SQL only.
REM
REM   There are too many factors which can affect SQL performance. So This script
REM   will cover only few factors or their cases which are frequently happened in FA only.
REM   For more information, visit the following site.
REM   https://confluence.oraclecorp.com/confluence/display/~jinsoo.eo@oracle.com/FusionApps+SQL+Tuning+Automation
REM
REM WHO
REM
REM   This script will be good for any engineer who has very limited knowledge on SQL TUNING.
REM   If you hava good knowledge on this area, you do not need to use this script.
REM
REM RESTRICTION
REM
REM   In order to get full information, the sql information should be in gv$sql_plan_monitor and gv$sql_plan.
REM   If the issue sql is taking less than some seconds, there is high possibility that gv$sql_plan_monitor will not keep.
REM   So ideal issue SQL with this script will be a sql taking some seconds or more.
REM   The script works from DB 12c.
REM
REM HOW TO USE
REM #1 WHEN YOU WANT TO SEE ALL EXECUTION PLAN LINE, USE OPTION P.
REM
REM    Login SQL*Plus with SYSDBA user and execute sma.sql script with SQL_ID of the issue SQL.
REM    SQL>start sma.sql <sql_id> P
REM    The output file name is sma_<date_time>_<sql_id>.sql
REM
REM    e.g) If SQL of the issue SQL is 2tm1axh0pdf2g, run the following method.
REM    $sqlplus / as sysdba
REM    SQL>start sma.sql 2tm1axh0pdf2g P
REM    The output file, sma_20180307_044411_2tm1axh0pdf2g.sql will be created under the current directory.
REM
REM #2 WHEN YOU WANT TO SEE SQL TUNE ADVISOR OUTPUT AS WELL AS ALL EXECUTION PLAN LINE, USE OPTION S.
REM
REM    Login SQL*Plus with SYSDBA user and execute sma.sql script with SQL_ID of the issue SQL.
REM    SQL>start sma.sql <sql_id> S
REM    The output file name is sma_<date_time>_<sql_id>.sql
REM
REM    e.g) If SQL of the issue SQL is 2tm1axh0pdf2g, run the following method.
REM    $sqlplus / as sysdba
REM    SQL>start sma.sql 2tm1axh0pdf2g S
REM    The output file, sma_20180307_044411_2tm1axh0pdf2g.sql will be created under the current directory.
REM
REM #3 WHEN YOU WANT TO SEE ONLY HIGHLIGHTED EXECUTION PLAN, USE NO OPTION.
REM
REM    Login SQL*Plus with SYSDBA user and execute sma.sql script with SQL_ID of the issue SQL.
REM    SQL>start sma.sql <sql_id>
REM    The output file name is sma_<date_time>_<sql_id>.sql
REM
REM    e.g) If SQL of the issue SQL is 2tm1axh0pdf2g, run the following method.
REM    $sqlplus / as sysdba
REM    SQL>start sma.sql 2tm1axh0pdf2g
REM    The output file, sma_20180307_044411_2tm1axh0pdf2g.sql will be created under the current directory.
REM
REM  LOG history
REM   V1 .. TEXT version
REM   V2 .. html version 2018 Nov 30
REM   V3 .. enhanced features ; compare bind to column
REM   V4 .. AWRSMA
REM   V19C .19C features
REM
REM   more detail information : https://confluence.oraclecorp.com/confluence/display/~jinsoo.eo@oracle.com/SMA+log
REM

set echo off  FEED OFF verify off heading on LINESIZE 300 pagesize 500 TI OFF TIMI OFF SERVEROUT ON SIZE UNL;
alter session set "_optimizer_adaptive_plans"=false;
alter session set nls_date_format = 'YYYY-MM-DD HH24:MI:SS';
exec DBMS_APPLICATION_INFO.SET_MODULE ( module_name=>'SMA', action_name=>'SMA');

VAR l_smastart VARCHAR2(50);
begin
SELECT  to_char(systimestamp, 'YYYY-MM-DD HH24:MI:SS:FF') into :l_smastart FROM DUAL;
end ;
/
-- 1st parameter
DEF sql_id = '&&1';
-- 2nd parameter
column 2 new_value 2 noprint
select '' "2" from dual where rownum = 0;
DEF PLAN_PRINT = &2 "NO"

VAR   L_ACCESS_RATIO     NUMBER;
EXEC :L_ACCESS_RATIO := 10;

VAR   L_SQL_GROUP     VARCHAR2(30);
EXEC :L_SQL_GROUP     := 'DEFAULT';
VAR   L_SQL_GROUP_ID  NUMBER;


VAR   L_SQL_GROUP1     VARCHAR2(30);
EXEC :L_SQL_GROUP1     := null;

--SPOOL sma_&&sql_id..log;

VAR L_last_load_time  VARCHAR2(30);
VAR L_last_load_time_CORRECT  VARCHAR2(3);

VAR L_SHORT_DB_VERSION VARCHAR2(20);
VAR L_OFE_VERSION      VARCHAR2(20);
VAR L_DBID             NUMBER;
VAR L_DBNAME           VARCHAR2(30);
VAR L_INST_ID          NUMBER;
VAR L_SQL_ID           VARCHAR2(100)
VAR L_PLAN_HASH_VALUE  VARCHAR2(100)
VAR L_PLAN_HASH_VALUE1 VARCHAR2(100)
VAR L_PLAN_HASH_VALUE2 VARCHAR2(100)
VAR L_PLAN_HASH_VALUE_PROFILE VARCHAR2(100)
VAR L_CHILD_NUMBER     NUMBER
VAR L_SNAP_ID          NUMBER

VAR SQL_FROM_MEM       NUMBER
VAR SQL_FROM_AWR       NUMBER
VAR SQL_FROM_SPM       NUMBER
VAR SQL_FROM_AWR_SPM   NUMBER
EXEC :SQL_FROM_AWR_SPM := 0;

VAR L_LAST_LOAD_TIME   VARCHAR2(76)
VAR L_PX               NUMBER

VAR L_ADJ_PROCESSED_ROW NUMBER
VAR L_PPRV_NR           NUMBER;
VAR L_NXT_NR            NUMBER;

VAR L_CUR_NR          NUMBER;
VAR L_CUR_KEY         NUMBER;
VAR L_CUR_PHV         NUMBER;
VAR L_CUR_OID         NUMBER;

/* 20200804 FP COL STATS BEGIN */
VAR L_CUR_OBJECT_OWNER  VARCHAR2(100)
VAR L_CUR_OBJECT_NAME   VARCHAR2(100)
VAR L_CUR_OBJECT_ALIAS  VARCHAR2(100)
VAR L_FILTER_PREDICATES VARCHAR2(3000)
/* 20200804 FP COL STATS BEGIN */

VAR L_PRV_KEY          NUMBER;
VAR L_PRV_PHV          NUMBER;
VAR L_PRV_ID           NUMBER;
VAR L_PRV_OID          NUMBER;
VAR L_PRV_PID          NUMBER;
VAR L_PRV_NR           NUMBER;
VAR L_PRV_OBJECT       VARCHAR2(100);
VAR L_PRV_OBJECT_OWNER VARCHAR2(100);
VAR L_PRV_OPERATION    VARCHAR2(100);
VAR L_PRV_QBLOCK       VARCHAR2(100);
VAR L_PRV_ALIAS        VARCHAR2(100);
VAR L_PRV_OBJECT_TYPE  VARCHAR2(30);

VAR L_PPRV_KEY         NUMBER;
VAR L_PPRV_PHV         NUMBER;
VAR L_PPRV_ID          NUMBER;
VAR L_PPRV_OID         NUMBER;
VAR L_PPRV_PID         NUMBER;
VAR L_PPRV_NR          NUMBER;
VAR L_PPRV_OBJECT      VARCHAR2(100);
VAR L_PPRV_OBJECT_OWNER VARCHAR2(100);
VAR L_PPRV_OPERATION   VARCHAR2(100);
VAR L_PPRV_QBLOCK      VARCHAR2(100);
VAR L_PPRV_ALIAS       VARCHAR2(100);
VAR L_PPRV_OBJECT_TYPE VARCHAR2(30);


VAR L_INDEX_TYPE         VARCHAR2(50);
VAR L_COLUMN_EXPRESSION  VARCHAR2(1000);
VAR L_COLUMN_COMBINATION VARCHAR2(4000);
exec :L_COLUMN_COMBINATION := null ;

VAR L_PRV_CARDINALITY  NUMBER;
VAR L_NEXT_MO          NUMBER;

VAR L_PR               VARCHAR2(30);
VAR L_PW               VARCHAR2(30);
VAR L_PGA              VARCHAR2(30);
VAR L_TEMP             VARCHAR2(30);

VAR l_co5              NUMBER;
VAR l_co4              NUMBER;
VAR l_co3              NUMBER;
VAR l_co2              NUMBER;
VAR l_co1              NUMBER;
VAR l_mo5              NUMBER;
VAR l_mo4              NUMBER;
VAR l_mo3              NUMBER;
VAR l_mo2              NUMBER;
VAR l_mo1              NUMBER;
---------------------------------
VAR l_as5              NUMBER;
VAR l_as4              NUMBER;
VAR l_as3              NUMBER;
VAR l_as2              NUMBER;
VAR l_as1              NUMBER;
VAR l_occ5             NUMBER;
VAR l_occ4             NUMBER;
VAR l_occ3             NUMBER;
VAR l_occ2             NUMBER;
VAR l_occ1             NUMBER;
VAR l_occ              NUMBER;
VAR l_wc5              NUMBER;
VAR l_wc4              NUMBER;
VAR l_wc3              NUMBER;
VAR l_wc2              NUMBER;
VAR l_wc1              NUMBER;
VAR l_wc               NUMBER;


VAR L_COLOR            NUMBER;
exec :L_COLOR := 0;
VAR L_COLOR_TYPE       VARCHAR2(10)

var  issue_blind_input  number ;
/*-- Class: Blind input or unselective input  */
var  issue_blind_query  number ;
/*-- Class: Blind query                       */
var  issue_inac_card_estim  number ;
/*-- Class: Cardinality estimation            */
var  issue_cbo  number ;
/*-- Class: CBO issue                         */
var  issue_error  number ;
/*-- Class: Error                             */
var  issue_improper_index  number ;
/*-- Class: Index and column condition        */
var  issue_MJ_CP  number ;
/*-- Class: Merge Join with Cartesian Product */
var  issue_blind_condition  number ;
/*-- Class: Unselective condition or input    */
var  issue_stats number ;
/*-- Class: Stats                             */
var  issue_throw_away number ;
/*-- Class: Throw-away                        */

var  error_from_sm number ;
/*-- Class: Error from SM                  */

VAR L_TABLE_NAME   VARCHAR2(100);
/* USE THIS TO STORE THE TABLE NAME FOR THE INDEX BY OPR. */

VAR ISSUE_HEAVY_OPERATION  NUMBER;

begin
  :issue_blind_input := 0;
  :issue_blind_query := 0;
  :issue_inac_card_estim := 0;
  :issue_cbo := 0;
  :issue_error := 0;
  :issue_improper_index := 0;
  :issue_MJ_CP := 0;
  :issue_blind_condition := 0;
  :issue_stats := 0;
  :issue_throw_away := 0;
  :error_from_sm := 0;
  :ISSUE_HEAVY_OPERATION := 0;
end;
/

VAR L_TITLE            NUMBER;
EXEC :L_TITLE :=0;

VAR l_CKmark           VARCHAR2(3);
VAR l_IOmark           VARCHAR2(3);
VAR l_WAmark           VARCHAR2(3);
VAR l_CPUmark          VARCHAR2(3);
---------------------------------

VAR L_1ST_MJC          NUMBER;
VAR L_2ND_MJC          NUMBER;
VAR L_3RD_MJC          NUMBER;
VAR L_MJ_STALE_OBJ     VARCHAR2(100);
VAR L_MJ_STALE_OBJ_STATUS NUMBER;
VAR L_1ST_OPR_STATUS   NUMBER;

VAR L_IND_STALE_STATS  VARCHAR2(3);
VAR L_TAB_STALE_STATS  VARCHAR2(3);
VAR L_WHERE_LOG        VARCHAR2(200);

VAR M_SQL_PROFILE      VARCHAR2(50);
VAR B_SQL_ID           VARCHAR2(50);
VAR B_PLAN_HASH_VALUE  VARCHAR2(50);
VAR M_SQL_ID           VARCHAR2(50);
VAR M_PLAN_HASH_VALUE  VARCHAR2(50);
VAR L_PPV_MESSAGE      NUMBER;

var L_ROWCNT           number;
var L_ANALYZETIME      varchar2(50);
VAR L_FLAGS            VARCHAR2(50);

VAR L_FORCE_MATCHING_SIGNATURE  NUMBER;
VAR L_LITERAL_SQL      NUMBER;

EXEC :L_FORCE_MATCHING_SIGNATURE := 0;
EXEC :L_LITERAL_SQL := 0;

------------------------
VAR L_HPT              NUMBER;
EXEC :L_HPT := 0;
VAR L_VPD_CNT          NUMBER;
EXEC :L_VPD_CNT := 0;
------------------------
VAR L_SHARABLE_MEM      NUMBER;
EXEC :L_SHARABLE_MEM := 0;

VAR L_BIND_LOG         VARCHAR2(10);
EXEC :L_BIND_LOG := 'ON';
----------------------
VAR L_NOTE_LOG         VARCHAR2(10);
EXEC :L_NOTE_LOG := 'ON';
----------------------

VAR L_OTHER_XML CLOB;
EXEC :L_OTHER_XML := NULL;

VAR L_PDB VARCHAR2(300)
BEGIN
  :L_PDB := NULL;
  --select nvl((select 'alter session set container='||pdb_name||';' from dba_pdbs where pdb_name like '%_F' and status = 'NORMAL' and rownum = 1), 'NOPDB')
  SELECT NVL(
            (select  case when cnt =  1 then   'alter session set container='||pdb_name||';'
                          when cnt >  1 then   'alter session set container= <Select Correct one PDB among> '||pdb_name
                     end
             from ( select max(pdbs) pdb_name, count(distinct pdbs) cnt
                    from ( select substr(SYS_CONNECT_BY_PATH(pdb_name, ','),2) pdbs
                           from (select pdb_name, rownum seq from dba_pdbs where pdb_name like '%_F' and status = 'NORMAL')
                           start with   seq=1  connect by prior seq+1=seq )
            )), 'NOPDB')
  into :L_PDB from dual;
END;
/
/*
    IF ( :L_PDB <> 'NOPDB' ) THEN
      DBMS_OUTPUT.PUT_LINE('SQL><blue>'||:L_PDB||'</blue>');
    END IF;
*/


COL unique_id NEW_V unique_id FOR A15;
SELECT TO_CHAR(SYSDATE, 'YYYYMMDD_HH24MISS') unique_id FROM DUAL;
VAR L_PLAN_PRINT      VARCHAR2(10)

/*   need to use rem each line for sma. */
/* rem FOR SMA
rem FOR SMA
rem EXEC :L_SQL_ID := TRIM('&&sql_id.');
rem EXEC :L_PLAN_PRINT := NVL(TRIM('&&PLAN_PRINT.'),'NO');
rem COL files_prefix NEW_V files_prefix FOR A40;
rem SELECT '&&unique_id._&&sql_id.' files_prefix FROM DUAL;
rem SPOOL sma_&&files_prefix..sql1;
*/

REM FOR SQLHC
EXEC :L_SQL_ID := TRIM('^^input_sql_id.');
EXEC :L_PLAN_PRINT := 'P';
SPOOL sma_^^files_prefix..sql1

--html version
PRO <html>
PRO <!-- Author: jinsoo.eo@oracle.com -->
PRO
-- sma
--PRO <head>
--PRO <title>sma_&&files_prefix..html</title>
PRO
-- sqlhc
PRO <head>
PRO <title>sma_^^files_prefix..html</title>
PRO

PRO <style type="text/css">
PRO body {font:10pt Arial,Helvetica,Verdana,Geneva,sans-serif; color:black; background:white;}
PRO a {font-weight:bold; color:#663300;}
PRO bluea {font-weight:bold; color:#336699;}
PRO red {font-weight:bold; color:#ff0000;}
PRO green {font-weight:bold; color:#33ff3c;}
PRO pink {font-weight:bold; color:#f933ff;}
PRO blue {font-weight:bold; color:#336699;}
PRO smanc {font:8pt Arial,Helvetica,Geneva,sans-serif;color:black;background:White;vertical-align:top;}
PRO smac  {font:8pt Arial,Helvetica,Geneva,sans-serif;color:black;background:#FFFFCC; vertical-align:top;}
PRO pre {font:8pt Monaco,"Courier New",Courier,monospace;} /* for code */
PRO h1 {font-size:16pt; font-weight:bold; color:#336699;}
PRO h2 {font-size:14pt; font-weight:bold; color:#336699;}
PRO h3 {font-size:12pt; font-weight:bold; color:#336699;}
PRO li {font-size:10pt; font-weight:bold; color:#336699; padding:0.1em 0 0 0;}
PRO table {font-size:8pt; color:black; background:white;}
PRO th {font-weight:bold; background:#cccc99; color:#336699; vertical-align:bottom; padding-left:3pt; padding-right:3pt; padding-top:1pt; padding-bottom:1pt;}
PRO td {text-align:left; background:#fcfcf0; vertical-align:top; padding-left:3pt; padding-right:3pt; padding-top:1pt; padding-bottom:1pt;}
PRO td.c {text-align:center;} /* center */
PRO td.l {text-align:left;} /* left (default) */
PRO td.r {text-align:right;} /* right */
PRO font.n {font-size:8pt; font-style:italic; color:#336699;} /* table footnote in blue */
PRO font.f {font-size:8pt; color:#999999;} /* footnote in gray */
PRO </style>
PRO

PRO </head>
PRO <body>
--20210324
PRO <table style="width:100%"><tr><td style="text-align:right; background-color:#ffffff"><a href='#/' id='expAll' class='exp'>Collapse All</a></td></tr></table>
PRO <script>
PRO // Reference the toggle link
PRO var xa = document.getElementById('expAll')
PRO
PRO // Register link on click event
PRO xa.addEventListener('click', function(e) {
PRO
PRO e.target.classList.toggle('exp')
PRO e.target.classList.toggle('col')
PRO 
PRO // Collect all <details> into a NodeList
PRO var details = document.querySelectorAll('details')
PRO 
PRO Array.from(details).forEach(function(obj, idx) {
PRO
PRO if (e.target.classList.contains('exp')) {
PRO   obj.open = true
PRO   xa.innerHTML = "Collapse All"
PRO // Otherwise make it false
PRO } else {
PRO   obj.open = false
PRO   xa.innerHTML = "Expand All"
PRO }
PRO 
PRO })
PRO }, false)
PRO </script>

PRO <a name="top"></a>
--sma
--PRO <h1>SMA V19C05 Beta sma_&&files_prefix..html</h1>
--sqlhc
PRO <h1>SMA V19C05 Beta sma_^^files_prefix..html</h1>
SET DEFINE OFF
PRO <table border="0">
PRO <tr>
PRO <!-- Column 1 -->
PRO <td class="lw">
PRO <h4>Source</h4>
PRO <ul>
PRO <li><a href="#ENVIRONMENT">Environment</a></li>
PRO <li><a href="#SUMMARY_OF_DATA_SOURCES">Summary of Data Sources</a></li>
PRO </ul>
PRO </td>
PRO <!-- Column 2 -->
PRO <td class="lw">&nbsp;&nbsp;&nbsp;&nbsp;</td><td class="lw">
PRO <h4>SQL</h4>
PRO <ul>
PRO <li><a href="#SQL_CONTEXT">SQL context</a></li>
PRO <li><a href="#SQL_LEVEL_Observations">SQL level Observations</a></li>
PRO </ul>
PRO </td>
PRO <!-- Column 3 -->
PRO <td class="lw">&nbsp;&nbsp;&nbsp;&nbsp;</td><td class="lw">
PRO <h4>Plan</h4>
PRO <ul>
PRO <li><a href="#PHV_STATS">Plan Hash Value comparison</a></li>
PRO <li><a href="#PHV_ANALYSIS">PHV level Analysis</a></li>
--PRO <li><a href="#APPENDIX">Appendix/Supporting details</a></li>
PRO </ul>
PRO </td>
PRO <!-- Column 4 -->
PRO <td class="lw">&nbsp;&nbsp;&nbsp;&nbsp;</td><td class="lw">
PRO <h4>Appendix/Supporting details</h4>
PRO <ul>
--PRO <li><a href="#APPENDIX">Appendix/Supporting details</a></li>
PRO <li><a href="#STATSFEEDBACK">STATISTICS FEEDBACK (MEM)</a></li>
PRO <li><a href="#HARDPARSE">Hard Parsing Time and VPD by Plan Hash Value (MEM)</a></li>
/* 20200722 repeated predicates start */
PRO <li><a href="#REP_APREDICATES">Repeated Access Predicates (MEM)</a></li>
PRO <li><a href="#REP_FPREDICATES">Repeated Filter Predicates  (MEM)</a></li>
/* 20200722 repeated predicates end */
PRO <li><a href="#BINDUSAGE">Bind Usage Pattern Information (MEM)</a></li>
PRO <li><a href="#MISSINGTABLE">Missing Table Stats Prefs, Unnecessary Histogram/Extended Stats/Spd</a></li>
PRO <li><a href="#OBJECTDDL">Object DDL time within recent 30 days</a></li>
PRO <li><a href="#AUTOINDEX">Auto Index Verifications</a></li>
PRO <li><a href="#GVASHHEADER">GV$ASH by ECID/SQL_EXEC_ID</a></li>
PRO <li><a href="#GVASHDETAIL">GV$ASH details by ECID/SQL_EXEC_ID</a></li>
PRO <li><a href="#DBAASHHEADER">DBA_ASH by ECID/SQL_EXEC_ID</a></li>
PRO <li><a href="#DBAASHDETAIL">DBA_ASH details by ECID/SQL_EXEC_ID</a></li>
PRO <li><a href="#19C_GV$SQL_INVALID">19C_GV$SQL_INVALID</a></li>
--20201223
PRO <li><a href="#SQLSET_SQL_STATS">SQLSET_SQL_STATS</a></li>

pro
PRO </ul>
PRO </td>
PRO <!-- Column 5 -->
PRO <td class="lw">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td>
PRO <td class="lw">
--rem PRO <pre>
SET DEFINE ON
BEGIN
  DBMS_OUTPUT.PUT_LINE('<PRE>SQL_ID: '||:L_SQL_ID);
  IF (:L_PLAN_PRINT = 'P' ) THEN
    DBMS_OUTPUT.PUT_LINE('SMA OPTION: <blue>P</blue> (Print All execution plan line)');
  ELSIF (:L_PLAN_PRINT = 'S' ) THEN
    DBMS_OUTPUT.PUT_LINE('SMA OPTION: <blue>S</blue> (SQLTune Advisor Output)');
  ELSIF (:L_PLAN_PRINT IN ('NO', 'L')) THEN
    DBMS_OUTPUT.PUT_LINE('SMA OPTION: <blue>L</blue> (HighLight execution plan line only)');
  ELSE
    DBMS_OUTPUT.PUT_LINE('SMA OPTION: <blue>Unrecognized Option</blue>');
  END IF;
  DBMS_OUTPUT.PUT_LINE('SMA START: '||:L_smastart||'</PRE>');
END;
/
--rem PRO </pre>
PRO </td>
PRO </tr>
PRO </table>



--prompt
--PROMPT DB SECTION
--prompt **********

VAR L_POD_SIZE   VARCHAR2(100)
EXEC :L_POD_SIZE := NULL;

DECLARE
  QUERY VARCHAR2(4000);
  TYPE    CurTyp IS REF CURSOR;
  SM_CV   CurTyp;
BEGIN

     SELECT NVL(
            (SELECT 1  FROM DBA_OBJECTS
             WHERE OBJECT_NAME = 'V$LCM_AUDIT' AND OWNER = 'SYS'),
            0
            )  INTO :L_POD_SIZE
     FROM DUAL ;

     IF ( :L_POD_SIZE = 1 ) THEN
       QUERY := 'SELECT NVL( (
                 SELECT SUBSTR(DIMENSION_PARAMETER,
                     INSTR(DIMENSION_PARAMETER,'':'',INSTR(DIMENSION_PARAMETER,'':'',1)+1)+1,
                      INSTR(DIMENSION_PARAMETER,'':'',(INSTR(DIMENSION_PARAMETER,'':'',INSTR(DIMENSION_PARAMETER,'':'',1)+1)+1))
                       - INSTR(DIMENSION_PARAMETER,'':'',INSTR(DIMENSION_PARAMETER,'':'',1)+1)-1 )
                 FROM ( SELECT DIMENSION_PARAMETER
                        FROM SYS.V$LCM_AUDIT
                        WHERE ACTION = ''AUDIT''
                        order by to_date(AUDIT_DATE,''mm-dd-yyyy hh24:mi:ss'') desc )
                 WHERE ROWNUM = 1)
                 , ''N/A'')
                 FROM DUAL' ;
       OPEN SM_CV FOR QUERY ;
       LOOP
          FETCH SM_CV INTO :L_POD_SIZE;
          EXIT WHEN SM_CV%NOTFOUND;
          IF (:L_POD_SIZE = 'N/A') THEN
            SELECT DECODE(VALUE,6,'XSMALL',8,'SMALL',16,'MLT-STAGE',30,'MLT-PROD',40,'MEDIUM-STAGE_PROD',
              DECODE(SIGN(VALUE-40)||ISDEFAULT,'1TRUE','LARGE-STAGE_PROD','CPU_COUNT:'||VALUE))
              --DECODE(ISDEFAULT,'TRUE','LARGE-STAGE_PROD','FALSE','CPU_COUNT:'||VALUE))
              into :L_POD_SIZE
            from v$parameter
            where name = 'cpu_count';
          END IF;
       END LOOP;
       CLOSE SM_CV;
     END IF;
--20200615
     IF (:L_POD_SIZE = 0 ) THEN
            SELECT DECODE(VALUE,6,'XSMALL',8,'SMALL',16,'MLT-STAGE',30,'MLT-PROD',40,'MEDIUM-STAGE_PROD',
              DECODE(SIGN(VALUE-40)||ISDEFAULT,'1TRUE','LARGE-STAGE_PROD','CPU_COUNT:'||VALUE))
              --DECODE(ISDEFAULT,'TRUE','LARGE-STAGE_PROD','FALSE','CPU_COUNT:'||VALUE))
            into :L_POD_SIZE
            from v$parameter
            where name = 'cpu_count';
     END IF;
--20200615
     EXCEPTION
     WHEN OTHERS THEN
       SELECT DECODE(VALUE,6,'XSMALL',8,'SMALL',16,'MLT-STAGE',30,'MLT-PROD',40,'MEDIUM-STAGE_PROD',
              DECODE(SIGN(VALUE-40)||ISDEFAULT,'1TRUE','LARGE-STAGE_PROD','CPU_COUNT:'||VALUE))
              --DECODE(ISDEFAULT,'TRUE','LARGE-STAGE_PROD','FALSE','CPU_COUNT:'||VALUE))
       into :L_POD_SIZE
       from v$parameter
       where name = 'cpu_count';
       -- :L_POD_SIZE := NULL;
END;
/
--                                      XS      S     X XS  X XS      MLT    MLT    MEDIUM    LARGE
--                                                    X STG X PROD    STG    PRD    STG PRD   STG PRD
--13	CPU_COUNT	Hot	CDB	6	8     X	16  X 30      16     30	    40	      leave default


PRO <a name="ENVIRONMENT"></a><h2>Environment</h2>
PRO <h3>* Database</h3>
PRO <table>
PRO <tr>
PRO <th>DB NAME</th>
PRO <th>DBID</th>
PRO <th>CDB</th>
PRO <th>LOG_MODE</th>
PRO <th>PLATFORM</th>
PRO <th>MACHINE</th>
PRO <th>CELLS</th>
PRO <th>POD</th>
PRO <th>POD SIZE</th>
PRO <th>Patch Level</th>
PRO </tr>
BEGIN

--  X4-8:  cpu/cores: 240/120 ; memory: 2TB ( only OPC)  :: many product pods but high cpu times.
--  X5-2:  cpu/cores: 72/36   ; memory: 768G ( only OPC)    :: many dev/test pods with better cpu times.
--  X6-2:  cpu/cores: 88/44   ; memory: 1TB.  ( In case of OCI:  cpu/cores: 84/42 ; memory: 708G )
--  #cell depends on exadata type. If it is X4-8,  14 cells ; if it is X5-2, 14 cells,  for X6-2/X7-2, 10 cells

  SELECT DBID, NAME INTO :L_DBID, :L_DBNAME FROM V$DATABASE ;
  SELECT MAX(SNAP_ID) INTO :L_SNAP_ID  FROM DBA_HIST_SNAPSHOT  WHERE DBID = :L_DBID ;

  FOR I IN ( SELECT D.PLATFORM_NAME, D.NAME DB_NAME, D.LOG_MODE LOG_MODE, D.DBID --, D.INST_ID
             , D.CDB  --11i
             --,(select upper(substr(name,1, instr(name,'_')-1)) POD
             , (SELECT DECODE(CPUS||'-'||CORES,'240-120','X4-8: 14 cells','72-36','X5-2: 14 cells','88-44','X6-2: 10 cells','CPU:'||CPUS||' - CORES:'||CORES)
                FROM ( select (select value from dba_hist_osstat where stat_name = 'NUM_CPUS'      AND DBID = :L_DBID AND SNAP_ID = :L_SNAP_ID AND ROWNUM = 1) CPUS,
                              (select value from dba_hist_osstat where stat_name = 'NUM_CPU_CORES' AND DBID = :L_DBID AND SNAP_ID = :L_SNAP_ID AND ROWNUM = 1) CORES from dual )) MACHINE
             , (select replace(CAST(extract(xmltype(confval), '/cli-output/cell/makeModel/text()') AS VARCHAR2(70)),
                'Oracle Corporation SUN SERVER','')  make_model FROM  v$cell_config WHERE  conftype = 'CELL' and rownum = 1) CELLS
             ,(select upper(substr( name,1,length(name)-3 )) POD  from V$ACTIVE_SERVICES
               where ( GOAL = 'SERVICE_TIME' OR AQ_HA_NOTIFICATION = 'YES' ) and   rownum = 1 ) POD
             , :L_POD_SIZE POD_SIZE
             , (select DESCRIPTION from (select DESCRIPTION||' since '||ACTION_TIME DESCRIPTION
                from  DBA_REGISTRY_SQLPATCH order by ACTION_TIME desc ) where rownum = 1)  PATCH_LEVEL
             FROM   V$DATABASE D
             --ORDER BY D.INST_ID
            )
  LOOP
        DBMS_OUTPUT.PUT_LINE(
        CHR(10)||'<tr>'||CHR(10)
        ||'<td class="r">'||I.DB_NAME||'</td>'||CHR(10)
        ||'<td class="r">'||I.DBID||'</td>'||CHR(10)
        ||'<td class="r">'||I.CDB||'</td>'||CHR(10)
        ||'<td class="r">'||I.LOG_MODE||'</td>'||CHR(10)
        ||'<td class="r">'||I.PLATFORM_NAME||'</td>'||CHR(10)
        ||'<td class="r">'||I.MACHINE||'</td>'||CHR(10)
        ||'<td class="r">'||I.CELLS||'</td>'||CHR(10)
        ||'<td class="r">'||I.POD||'</td>'||CHR(10)
        ||'<td class="r">'||I.POD_SIZE||'</td>'||CHR(10)
        ||'<td class="r">'||I.PATCH_LEVEL||'</td>'||CHR(10)
        ||'</tr>'
        );
        :L_DBID :=  I.DBID;
  END LOOP;
  EXCEPTION  WHEN OTHERS THEN DBMS_OUTPUT.PUT_LINE('ERROR ON DB: '||SQLERRM);
END ;
/
PRO </table>

/*----------------------------------------------------*/
begin
 select SUBSTR(I.VERSION, 1, LENGTH(I.VERSION)-4) SHORT_DB_VERSION into :L_SHORT_DB_VERSION
 from V$INSTANCE I;
end;
/

PRO <h3>* Instance</h3>
PRO <table>
PRO <tbody><tr>
PRO <th>INST_ID</th>
PRO <th>INSTANCE_NAME</th>
PRO <th>VERSION</th>
PRO <th>HOST</th>
PRO <th>STARTUP_TIME</th>
PRO </tr>

BEGIN
  --DBMS_OUTPUT.PUT_LINE('INSTANCE SECTION');
 IF (:L_SHORT_DB_VERSION LIKE '12%') THEN
   FOR I IN ( SELECT  I.INST_ID INST_ID, I.INSTANCE_NAME INSTANCE_NAME, I.VERSION DB_VERSION, I.HOST_NAME HOST_NAME, I.STARTUP_TIME
             FROM GV$INSTANCE I
             ORDER BY I.inst_id )
   LOOP
     DBMS_OUTPUT.PUT_LINE(
     CHR(10)||'<tr>'||CHR(10)
     ||'<td class="r">'||I.INST_ID||'</td>'||CHR(10)
     ||'<td class="r">'||I.INSTANCE_NAME||'</td>'||CHR(10)
     ||'<td class="r">'||I.DB_VERSION||'</td>'||CHR(10)
     ||'<td class="r">'||I.HOST_NAME||'</td>'||CHR(10)
     ||'<td class="r">'||I.STARTUP_TIME||'</td>'||CHR(10)
     ||'</tr>');
   END LOOP;
 END IF;
  EXCEPTION
  WHEN OTHERS THEN
    DBMS_OUTPUT.PUT_LINE('ERROR ON INSTANCE12: '||SQLERRM);
END ;
/

DECLARE
  QUERY VARCHAR2(4000);
  TYPE    CurTyp IS REF CURSOR;
  SM_CV   CurTyp;
  QR_DB_VERSION               VARCHAR2(50);
  QR_INSTANCE_NAME            VARCHAR2(50);
  QR_INST_ID                  VARCHAR2(50);
  QR_HOST_NAME                VARCHAR2(50);
  QR_STARTUP_TIME             VARCHAR2(50);
  QR_SHORT_DB_VERSION         VARCHAR2(50);
  QR_SHARED_SERVER            VARCHAR2(50);
BEGIN

     IF ( (:L_SHORT_DB_VERSION LIKE '19%' OR :L_SHORT_DB_VERSION LIKE '2%') ) THEN
       QUERY := 'SELECT
             I.INST_ID INST_ID, I.INSTANCE_NAME  INSTANCE_NAME, I.VERSION_FULL DB_VERSION, I.HOST_NAME HOST_NAME, I.STARTUP_TIME
             FROM GV$INSTANCE I
             ORDER BY I.inst_id';
       OPEN SM_CV FOR QUERY ;
       LOOP
          FETCH SM_CV INTO
            QR_INST_ID       ,
            QR_INSTANCE_NAME ,
            QR_DB_VERSION    ,
            QR_HOST_NAME     ,
            QR_STARTUP_TIME  ;
          EXIT WHEN SM_CV%NOTFOUND;

          DBMS_OUTPUT.PUT_LINE(
 		   CHR(10)||'<tr>'||CHR(10)
			  ||'<td class="r">'||QR_INST_ID               ||'</td>'||CHR(10)
			  ||'<td class="r">'||QR_INSTANCE_NAME         ||'</td>'||CHR(10)
			  ||'<td class="r">'||QR_DB_VERSION            ||'</td>'||CHR(10)
			  ||'<td class="r">'||QR_HOST_NAME             ||'</td>'||CHR(10)
			  ||'<td class="r">'||QR_STARTUP_TIME          ||'</td>'||CHR(10)
			  ||'</tr>'	);
       END LOOP;
       CLOSE SM_CV;
     END IF;
     EXCEPTION
     WHEN OTHERS THEN
      DBMS_OUTPUT.PUT_LINE('ERROR ON INSTANCE19: '||SQLERRM);
       -- :L_POD_SIZE := NULL;
END;
/


pro </tbody>
PRO </TABLE>
--rem pro <pre>
-- select substr(value, length(value)-3,3) dispatches from v$parameter a where a.name = 'dispatchers' ;
-- select instr(value, 'XDB') dispatches from v$parameter a where a.name = 'dispatchers' ;
-- Find out XDB Dispatches.

--prompt
--PROMPT FIX_CONTROL and PARMETER SECTION
--prompt ********************************

pro

BEGIN
  FOR I IN ( SELECT ROWNUM RWNM, RECOMM.NAME, RECOMM.VALUE RVALUE, P.VALUE CVALUE
               FROM
             ( SELECT '_securefiles_concurrency_estimate'  NAME ,    '50'      VALUE FROM DUAL UNION ALL
               SELECT '_b_tree_bitmap_plans'               NAME ,   'FALSE'      VALUE FROM DUAL UNION ALL
               SELECT 'parallel_force_local'               NAME ,   'TRUE'       VALUE FROM DUAL 
               UNION ALL                                                                                      --11i
               SELECT '_optimizer_use_feedback'            NAME ,   'FALSE'      VALUE FROM DUAL UNION ALL    --11i
               SELECT '_optimizer_dsdir_usage_control'     NAME ,   '0'          VALUE FROM DUAL UNION ALL    --11i
               SELECT '_sql_plan_directive_mgmt_control'   NAME ,   '0'          VALUE FROM DUAL              --11i
             ) RECOMM,
             V$PARAMETER P
             WHERE RECOMM.NAME  = P.NAME(+)
             AND   RECOMM.VALUE = P.VALUE(+)
             AND  ( RECOMM.VALUE  <> P.VALUE OR P.VALUE IS NULL ) )
  LOOP
     IF (I.CVALUE IS NULL AND I.NAME = '_securefiles_concurrency_estimate' AND :L_POD_SIZE LIKE '%LARGE%') THEN
           IF (I.RWNM = 1) THEN
             DBMS_OUTPUT.PUT_LINE('<PRE><blue>Action Item : OPERATION TEAM<blue></PRE>');
           END IF;
           DBMS_OUTPUT.PUT_LINE('<PRE>Parameter, '||I.NAME||' is not set with recommendable value '||I.RVALUE||' for large POD size.');
           DBMS_OUTPUT.PUT_LINE('=>Suggestion: '||'alter system set "'||I.NAME||'" = '||I.RVALUE||' scope=both sid=''*'';</PRE>');
     END IF;
     IF (I.CVALUE IS NULL AND I.NAME <> '_securefiles_concurrency_estimate') THEN
--sma19c
        IF ( :L_SHORT_DB_VERSION LIKE '12%' ) THEN
           IF (I.RWNM = 1) THEN
             DBMS_OUTPUT.PUT_LINE('<PRE><blue>Action Item : OPERATION TEAM<blue></PRE>');
           END IF;
           DBMS_OUTPUT.PUT_LINE('<PRE>Parameter, '||I.NAME||' is not set with recommendable value, '||I.RVALUE||'.');
           DBMS_OUTPUT.PUT_LINE('=>To turn off: '||'alter system set "'||I.NAME||'" = '||I.RVALUE||' scope=both sid=''*'';</PRE>');
--        ELSE
--           DBMS_OUTPUT.PUT_LINE('<PRE>Parameter, '||I.NAME||' is not set to '||I.RVALUE||'.');
        END IF;
     END IF;
  END LOOP;
  FOR I IN ( SELECT COUNT(*) CNT
             FROM
             ( --SELECT 20355502 BUGNO, 8 VALUE FROM DUAL UNION ALL  -- PARSING
               SELECT 14545269 BUGNO, 0 VALUE FROM DUAL WHERE :L_SHORT_DB_VERSION LIKE '12%' UNION ALL  -- PARSING  when USE_CONCAT
               SELECT  9633142 BUGNO, 1 VALUE FROM DUAL WHERE :L_SHORT_DB_VERSION LIKE '12%' UNION ALL  -- NOT PUSH PREDICATES
               SELECT  6708183 BUGNO, 1 VALUE FROM DUAL                                      UNION ALL  -- TABLE() CARDINALITY ISSUE
               SELECT 29302565 BUGNO, 1 VALUE FROM DUAL WHERE :L_SHORT_DB_VERSION LIKE '19%' UNION ALL
               SELECT 29867728 BUGNO, 1 VALUE FROM DUAL WHERE :L_SHORT_DB_VERSION LIKE '19%' UNION ALL
               SELECT 29304314 BUGNO, 1 VALUE FROM DUAL WHERE :L_SHORT_DB_VERSION LIKE '19%' UNION ALL
               SELECT 29450812 BUGNO, 1 VALUE FROM DUAL WHERE :L_SHORT_DB_VERSION LIKE '19%'
             ) RECOMM,
               V$SYSTEM_FIX_CONTROL SFC
             WHERE RECOMM.BUGNO = SFC.BUGNO
             AND   RECOMM.VALUE = SFC.VALUE
             )
  LOOP
     IF (I.CNT <> 3  AND :L_SHORT_DB_VERSION LIKE '12%' ) THEN
          DBMS_OUTPUT.PUT_LINE('<PRE><blue>Action Item : OPERATION TEAM</BLUE></PRE>');
          DBMS_OUTPUT.PUT_LINE('<pre>All recommendable fix_controls are not implemented.');
          DBMS_OUTPUT.PUT_LINE('=>Suggestion: '||'alter system set "_fix_control" = ''14545269:OFF'',''6708183:ON'',''9633142:ON'' scope=both sid=''*''; </pre>');
--sma19c
--     ELSIF (I.CNT = 4  AND :L_SHORT_DB_VERSION LIKE '19%' ) THEN
--          DBMS_OUTPUT.PUT_LINE('<PRE><blue>Action Item : OPERATION TEAM</BLUE></PRE>');
--          DBMS_OUTPUT.PUT_LINE('<pre>All recommendable fix_controls are not implemented.');
--          DBMS_OUTPUT.PUT_LINE('=>Suggestion: '||'alter system set "_fix_control" = ''6708183:ON'',''29302565:ON'',''29867728:ON'',''29304314:ON'' scope=both sid=''*''; </pre>');
     ELSIF (I.CNT <>5  AND ( :L_SHORT_DB_VERSION LIKE '19%' or :L_SHORT_DB_VERSION LIKE '2%') ) THEN
          DBMS_OUTPUT.PUT_LINE('<PRE><blue>Action Item : OPERATION TEAM</BLUE></PRE>');
          DBMS_OUTPUT.PUT_LINE('<pre>All recommendable fix_controls are not implemented.');
          DBMS_OUTPUT.PUT_LINE('=>Suggestion: '||'alter system set "_fix_control" = ''6708183:ON'',''29302565:ON'',''29867728:ON'',''29304314:ON'',''29450812:ON'' scope=both sid=''*''; </pre>');
     ELSE
        DBMS_OUTPUT.PUT_LINE('<pre><blue> All recommendable fix_controls are implemented.</blue></pre>');
     END IF;
  END LOOP;
  --DBMS_OUTPUT.PUT_LINE('++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++');
  EXCEPTION
  WHEN OTHERS THEN
    DBMS_OUTPUT.PUT_LINE('ERROR ON FIX_CONTROL: '||SQLERRM);
END ;
/
/*
     BUGNO defaultVALUE   12.2.0.1
---------- ------------ -------------
   6708183          0   need 1
   9633142          0   need 1
  14545269          0   default
  19046459          1   new

PARAMETER                             RECOMMAND
_b_tree_bitmap_plans                = false
_fix_control_key                    = 1343505842
parallel_force_local                = true
_optimizer_use_feedback             = false
_optimizer_dsdir_usage_control      = 0
_sql_plan_directive_mgmt_control    = 0
_optimizer_adaptive_plans           = false

*/

--pro <details><summary><h3>* AUTO_SPM_EVOLVE DBA_ADVISOR_PARAMETERS (USED)</h3></summary>
pro <details><summary><blue>* Configuration for AUTO_SPM/AUTO_INDEX/REAL TIME STATS</blue></summary>
pro <table>
pro <tbody><tr>
pro <th>PARAMETER<BR>TYPE</th>
pro <th>PARAMETER_NAME</th>
pro <th>PARAMETER_VALUE</th>
pro <th>IS_DEFAULT</th>
pro <th>DESCRIPTION</th>
pro </tr>
--SMA19C 20200228
SET HEAD OFF
SELECT  CHR(10)||'<tr>'||CHR(10)
     ||'<td class="c">'||PARAMETER_TYPE||'</td>'||CHR(10)
     ||'<td class="r">'||PARAMETER_NAME||'</td>'||CHR(10)
     ||'<td class="r">'||PARAMETER_VALUE||'</td>'||CHR(10)
     ||'<td class="c">'||IS_DEFAULT||'</td>'||CHR(10)
     ||'<td class="l">'||DESCRIPTION||'</td>'||CHR(10)
     ||'</TR>'
FROM (
  SELECT 'SPM' PARAMETER_TYPE, PARAMETER_NAME,
  DECODE(PARAMETER_VALUE,'AUTO','<RED>AUTO</RED>','ON','<RED>ON</RED>','TRUE','<RED>TRUE</RED>',PARAMETER_VALUE) PARAMETER_VALUE,
  IS_DEFAULT, 'AUTO SPM '||DESCRIPTION DESCRIPTION
  FROM   DBA_ADVISOR_PARAMETERS
  WHERE  TASK_NAME = 'SYS_AUTO_SPM_EVOLVE_TASK'
  AND PARAMETER_VALUE <> 'UNUSED'
  UNION ALL
  SELECT 'RTS' PARAMETER_TYPE, PARAMETER_NAME, 
  DECODE(PARAMETER_VALUE,'AUTO','<RED>AUTO</RED>','ON','<RED>ON</RED>','TRUE','<RED>TRUE</RED>',PARAMETER_VALUE), 
  NULL,  'REAL TIME STATS '||DECODE(MODIFIED_BY,NULL,NULL,'by '||MODIFIED_BY||' at '||LAST_MODIFIED)
  FROM   DBA_SQL_MANAGEMENT_CONFIG
  WHERE  PARAMETER_NAME LIKE 'AUTO_SPM_EVOLVE_TASK%'
  UNION ALL
  SELECT 'AI' PARAMETER_TYPE, PARAMETER_NAME, DECODE(PARAMETER_VALUE,'IMPLEMENT','<RED>IMPLEMENT</RED>','AUTO','<RED>AUTO</RED>','ON','<RED>ON</RED>','TRUE','<RED>TRUE</RED>',PARAMETER_VALUE), 
  NULL,'AUTO INDEX '||DECODE(MODIFIED_BY,NULL,NULL,'by '||MODIFIED_BY||' at '||LAST_MODIFIED)
  FROM   CDB_AUTO_INDEX_CONFIG
  WHERE  CON_ID <> 1  AND PARAMETER_VALUE IS NOT NULL
  )
ORDER BY PARAMETER_TYPE, PARAMETER_NAME
/
pro </tbody>
pro </table>
pro </details>
SET HEAD ON


--rem pro </pre>
pro <a name="SUMMARY_OF_DATA_SOURCES"></a><h2><span title="For all cases including 0 Execution">Summary of Data Sources</span></h2>
--rem pro <pre>

pro <table>
pro <tbody><tr>
pro <th>Data Source</th>
pro <th>Available</th>
pro <th>AVG<br>CPU Time<br>(secs)</th>
pro <th>AVG<br>Elapsed Time<br>(secs)</th>
pro <th>Total<br>Number of<br>Execution</th>
pro <th>First Load Time</th>
pro <th>Last Load Time</th>
pro </tr>

SET HEAD OFF
SELECT  CHR(10)||'<tr>'||CHR(10)
     ||'<td class="r">'||'GV$SQL_MONITOR'||'</td>'||CHR(10)
     ||'<td class="c">'||DECODE(MAX(SQL_ID), NULL, '<RED>NO</RED>','<blue>YES</blue>')||'</td>'||CHR(10)
     ||'<td class="r">'||ROUND((SUM(CPU_TIME)/1000000/COUNT(*)),3)||'</td>'||CHR(10)
     ||'<td class="r">'||ROUND((SUM(ELAPSED_TIME)/1000000/COUNT(*)),3)||'</td>'||CHR(10)
     ||'<td class="r">'||COUNT(*)||'</td>'||CHR(10)
     ||'<td class="r">'||MIN(FIRST_REFRESH_TIME)||'</td>'||CHR(10)
     ||'<td class="r">'||MAX(LAST_REFRESH_TIME)||'</td>'||CHR(10)
     ||'</TR>'
FROM GV$SQL_MONITOR
WHERE SQL_ID = :L_SQL_ID
/
SELECT CHR(10)||'<tr>'||CHR(10)
     ||'<td class="r">'||'GV$SQL'||'</td>'||CHR(10)
     ||'<td class="c">'||DECODE(MAX(SQL_ID), NULL, '<RED>NO</RED>','<blue>YES</blue>')||'</td>'||CHR(10)
     ||'<td class="r">'||ROUND((SUM(CPU_TIME)/1000000/SUM(GREATEST(executions, 1))),3)||'</td>'||CHR(10)
     ||'<td class="r">'||ROUND((SUM(ELAPSED_TIME)/1000000/SUM(GREATEST(executions, 1))),3)||'</td>'||CHR(10)
     ||'<td class="r">'||SUM(executions)||'</td>'||CHR(10)
--     ||'<td class="r">'||SUM(GREATEST(executions, 1))||'</td>'||CHR(10)
     ||'<td class="r">'||MIN(first_load_time)||'</td>'||CHR(10)
     ||'<td class="r">'||MAX(LAST_LOAD_TIME)||'</td>'||CHR(10)
     ||'</TR>'
FROM GV$SQL
WHERE SQL_ID = :L_SQL_ID
--AND  EXECUTIONS > 0
/
SELECT  CHR(10)||'<tr>'||CHR(10)
     ||'<td class="r">'||'DBA_HIST_SQLSTAT'||'</td>'||CHR(10)
     ||'<td class="c">'||FLAG||'</td>'||CHR(10)
     ||'<td class="r">'||CPU_TIME||'</td>'||CHR(10)
     ||'<td class="r">'||ELAPSED_TIME||'</td>'||CHR(10)
     ||'<td class="r">'||EXECUTIONS||'</td>'||CHR(10)
     ||'<td class="r">'||MIN_SNAP_TIME||'</td>'||CHR(10)
     ||'<td class="r">'||MAX_SNAP_TIME||'</td>'||CHR(10)
     ||'</TR>'
FROM (
  SELECT FLAG, CPU_TIME, ELAPSED_TIME,EXECUTIONS,
  (select A.BEGIN_INTERVAL_TIME from dba_hist_snapshot A where a.dbid = :L_DBID AND a.snap_id = MIN_SNAP_ID AND ROWNUM = 1) MIN_SNAP_TIME,
  (select A.END_INTERVAL_TIME   from dba_hist_snapshot A where a.dbid = :L_DBID AND a.snap_id = MAX_SNAP_ID AND ROWNUM = 1) MAX_SNAP_TIME
  FROM ( SELECT DECODE(MAX(SQL_ID), NULL,  '<RED>NO</RED>','<blue>YES</blue>') FLAG,
                ROUND((SUM(CPU_TIME_DELTA)/1000000/SUM(GREATEST(EXECUTIONS_DELTA, 1))),3) CPU_TIME,
                ROUND((SUM(ELAPSED_TIME_DELTA)/1000000/SUM(GREATEST(EXECUTIONS_DELTA, 1))),3) ELAPSED_TIME,
--                SUM(GREATEST(EXECUTIONS_DELTA, 1)) EXECUTIONS,
                SUM(EXECUTIONS_DELTA) EXECUTIONS,
                MIN(SNAP_ID) MIN_SNAP_ID, MAX(SNAP_ID) MAX_SNAP_ID
         FROM DBA_HIST_SQLSTAT
         WHERE SQL_ID = :L_SQL_ID
         --AND   EXECUTIONS_DELTA > 0
         AND   DBID = :L_DBID
          --2020922
         AND SNAP_ID BETWEEN :L_SNAP_ID - 720 AND :L_SNAP_ID  )
)
/

SELECT  CHR(10)||'<tr>'||CHR(10)
     ||'<td class="r">'||'DBA_HIST_REPORTS'||'</td>'||CHR(10)
     ||'<td class="c">'||FLAG||'</td>'||CHR(10)
     ||'<td class="c">'||'-'||'</td>'||CHR(10)
     ||'<td class="c">'||'-'||'</td>'||CHR(10)
     ||'<td class="c">'||'-'||'</td>'||CHR(10)
     ||'<td class="r">'||MIN_SNAP_TIME||'</td>'||CHR(10)
     ||'<td class="r">'||MAX_SNAP_TIME||'</td>'||CHR(10)
     ||'</TR>'
FROM (
SELECT FLAG,
(select A.BEGIN_INTERVAL_TIME from dba_hist_snapshot A where a.dbid = :L_DBID AND a.snap_id = MIN_SNAP_ID and rownum = 1) MIN_SNAP_TIME,
(select A.END_INTERVAL_TIME   from dba_hist_snapshot A where a.dbid = :L_DBID AND a.snap_id = MAX_SNAP_ID and rownum = 1) MAX_SNAP_TIME
FROM ( SELECT DECODE(MAX(KEY1), NULL,  '<RED>NO</RED>','<blue>YES</blue>') FLAG,  MIN(SNAP_ID) MIN_SNAP_ID, MAX(SNAP_ID) MAX_SNAP_ID
FROM DBA_HIST_REPORTS
WHERE KEY1 = :L_SQL_ID
AND   DBID = :L_DBID
AND   COMPONENT_NAME = 'sqlmonitor'
--2020922
AND SNAP_ID BETWEEN :L_SNAP_ID - 720 AND :L_SNAP_ID )
)
/
SELECT  CHR(10)||'<tr>'||CHR(10)
     ||'<td class="r">'||'DBA_SQLSET'||'</td>'||CHR(10)
     ||'<td class="c">'||FLAG||'</td>'||CHR(10)
     ||'<td class="c">'||'-'||'</td>'||CHR(10)
     ||'<td class="c">'||'-'||'</td>'||CHR(10)
     ||'<td class="c">'||'-'||'</td>'||CHR(10)
     ||'<td class="r">'||MIN_SNAP_TIME||'</td>'||CHR(10)
     ||'<td class="r">'||MAX_SNAP_TIME||'</td>'||CHR(10)
     ||'</TR>'
FROM  (
SELECT DECODE(MAX(SQL_ID), NULL,  '<RED>NO</RED>','<blue>YES</blue>') FLAG,  MIN(PLAN_TIMESTAMP) MIN_SNAP_TIME, MAX(PLAN_TIMESTAMP) MAX_SNAP_TIME
FROM dba_sqlset_statements
WHERE SQL_ID = :L_SQL_ID
--20210104
)
/
pro </tbody>
pro  </table>
SET HEAD ON

--rem pro </pre>
pro <a name="SQL_CONTEXT"></a><h2>SQL context</h2>
--rem pro <pre>
--rem pro </pre>
pro <h3>* SQL Statement</h3>

/* -------------------------
 *
 * get sql_text
 *
 * ------------------------- */

--set long 8000 longc 80
--set LONG 2000000 LONGC 2000
set long 10000000 longchunksize 10000000

VAR sql_text CLOB;
EXEC :sql_text := NULL;

-- get sql_text from memory
DECLARE
  l_sql_text VARCHAR2(32767);
BEGIN -- 10g see bug 5017909
  --DBMS_OUTPUT.PUT_LINE('getting sql_text from memory');
  FOR i IN (SELECT DISTINCT piece, sql_text
              FROM gv$sqltext_with_newlines
             WHERE sql_id = :L_SQL_ID
             ORDER BY 1, 2)
  LOOP
    IF :sql_text IS NULL THEN
      DBMS_LOB.CREATETEMPORARY(:sql_text, TRUE);
      DBMS_LOB.OPEN(:sql_text, DBMS_LOB.LOB_READWRITE);
    END IF;
    l_sql_text := REPLACE(i.sql_text, CHR(00), ' ');
    DBMS_LOB.WRITEAPPEND(:sql_text, LENGTH(l_sql_text), l_sql_text);
  END LOOP;
  IF :sql_text IS NOT NULL THEN
    DBMS_LOB.CLOSE(:sql_text);
  END IF;
EXCEPTION
  WHEN OTHERS THEN
    --DBMS_OUTPUT.PUT_LINE('getting sql_text from memory: '||SQLERRM);
    :sql_text := NULL;
END;
/

-- get sql_text from awr
BEGIN
  IF (:sql_text IS NULL OR NVL(DBMS_LOB.GETLENGTH(:sql_text), 0) = 0) THEN
    --DBMS_OUTPUT.PUT_LINE('getting sql_text from awr');
    SELECT REPLACE(sql_text, CHR(00), ' ')
      INTO :sql_text
      FROM dba_hist_sqltext
     WHERE dbid = :L_DBID
       AND sql_id = :L_SQL_ID
       AND sql_text IS NOT NULL
       AND ROWNUM = 1;
  END IF;
EXCEPTION
  WHEN OTHERS THEN
    --DBMS_OUTPUT.PUT_LINE('getting sql_text from awr: '||SQLERRM);
    :sql_text := NULL;
END;
/

BEGIN
  IF (:sql_text IS NULL) THEN
    SELECT REPLACE(SQL_TEXT, CHR(00), ' ')
      INTO :sql_text
      FROM gv$sql_monitor
     WHERE sql_id = :L_SQL_ID
       AND sql_text IS NOT NULL
       AND ROWNUM = 1;
  END IF;
EXCEPTION
  WHEN OTHERS THEN
    --DBMS_OUTPUT.PUT_LINE('getting sql_text from sql_monitor: '||SQLERRM);
    :sql_text := NULL;
END;
/

set head off PAGES 0 HEADING OFF
--pro <textarea cols="100" rows="10" >
pro <textarea rows="10" >
--20201223 start
col :sql_text format A150 wor
--20201221 end
SELECT :sql_text FROM DUAL;
pro </textarea>
set head on PAGES 500 HEADING ON

--rem pro <pre>
--rem pro </pre>
pro <h3><span title="By Module/Action from DBA_HIST_SQLSTAT and GV$SQL">* SQL Location</span></h3>
--rem <pre>

------------------
------------------



pro <table>
pro <tbody><tr>
pro <th>MODULE</th>
pro <th>ACTION</th>
--pro <th>PROGRAM</th>
--pro <th>SERVICE_NAME</th>
pro </tr>

SET HEAD OFF

SELECT CHR(10)||'<tr>'||CHR(10)
     ||'<td class="r">'||MODULE||'</td>'||CHR(10)
     ||'<td class="r">'||ACTION||'</td>'||CHR(10)
  --   ||'<td class="C">'||'-'||'</td>'||CHR(10)
  --   ||'<td class="C">'||'-'||'</td>'||CHR(10)
     ||'</TR>'
FROM (
SELECT MODULE, ACTION
FROM DBA_HIST_SQLSTAT
WHERE SQL_ID = :L_SQL_ID
AND   DBID = :L_DBID
--2020922
AND SNAP_ID BETWEEN :L_SNAP_ID - 720 AND :L_SNAP_ID
GROUP BY MODULE, ACTION
UNION
SELECT MODULE, ACTION
FROM GV$SQL
WHERE SQL_ID = :L_SQL_ID
GROUP BY MODULE, ACTION )
ORDER BY MODULE, ACTION
/

pro </tbody>
pro </table>

SET HEAD ON

--20180807 ECID

--rem pro </pre>
pro <h3><span title="By ECID/Module from GV$ACTIVE_SESSION_HISTORY">* SQL Time Consumption</span></h3>
--rem pro <pre>
pro <table>
pro <tbody><tr>
pro <th>MODULE</th>
pro <th>Number<br>of<br>ECID</th>
pro <th>MIN<br>Contribution<br>%</th>
pro <th>MAX<br>Contribution<br>%</th>
pro <th>AVG<br>Contribution<br>%</th>
BEGIN
  DBMS_OUTPUT.PUT_LINE('<th>'||:L_SQL_ID||'<br>SQL TIME<br>(secs)</th>');
END;
/
--pro <th>Total<br>SQL TIME<br>(secs)</th>
pro <th>Total<br>ECID TIME<br>(secs)</th>
pro <th>AVG<br>SQL-EXECS<br>PER ECID</th>
pro </tr>
set head off
with a as ( select MODULE, ecid, sql_sample_time, no_EXECS
            from ( select MODULE, ecid, count(*) sql_sample_time,
                   --ROUND((RATIO_TO_REPORT(COUNT(*)) OVER())*100, 2) SPCT,
                   ROUND(AVG(COUNT(*)) OVER()) AVG_SAMPLES
                   /*v3*/  ,count(distinct SQL_EXEC_START) no_EXECS
                   from gv$active_session_history ash
                   where  ash.sql_id = :L_SQL_ID and ecid is not null and module is not null Group by MODULE, ecid )
            where   sql_sample_time >= AVG_SAMPLES
            )
   , b as ( select MODULE, count( distinct ecid ) ndv_ecid from a GROUP BY MODULE )
   , c as ( select ash.module, ash.ecid, count(*) ecid_sample_time from  a, gv$active_session_history ash
            where a.module = ash.module and a.ecid = ash.ecid group by ash.module, ash.ecid )
   , d as ( select a.module,  b.ndv_ecid, a.ecid, a.sql_sample_time, c.ecid_sample_time, a.sql_sample_time/c.ecid_sample_time pct
          /*v3*/, a.no_EXECS
            from a , b , c
            where a.ecid = c.ecid and a.module = c.module
            and   b.module = c.module )
select  CHR(10)||'<tr>'||CHR(10)||
'<td class="r">'||MODULE||'</td>'||CHR(10)||
'<td class="r">'||NDV_ECID||'</td>'||CHR(10)||
'<td class="r">'||MINP||'</td>'||CHR(10)||
'<td class="r">'||MAXP||'</td>'||CHR(10)||
'<td class="r">'||AVGP||'</td>'||CHR(10)||
'<td class="r">'||SQL_SAMPLE_TIME||'</td>'||CHR(10)||
'<td class="r">'||ECID_SAMPLE_TIME||'</td>'||CHR(10)||
'<td class="r">'||AVG_SQL_EXECS_PER_ECID||'</td>'||CHR(10)||
'</tr>'
from
(select '**SUMMARY LEVEL**' MODULE, count(ndv_ecid) NDV_ECID, round(min(pct),3)*100 "MINP",
round(max(pct),3)*100 "MAXP", round(avg(pct),3)*100 "AVGP",sum(sql_sample_time) sql_sample_time, sum(ecid_sample_time) ecid_sample_time
/*v3*/, round(avg(no_EXECS)) AVG_SQL_EXECS_PER_ECID
from d
union all
select ' - '||MODULE, count(ndv_ecid) NDV_ECID, round(min(pct),3)*100 "MINP",
round(max(pct),3)*100 "MAXP", round(avg(pct),3)*100 "AVGP",sum(sql_sample_time) sql_sample_time, sum(ecid_sample_time) ecid_sample_time
/*v3*/, round(avg(no_EXECS)) AVG_SQL_EXECS_PER_ECID
from d
GROUP BY MODULE
order by 7 desc, 6 desc, 5 desc, 1 desc ) ;
set head on
pro </tbody>
pro </table>

pro <pre>

col key for 9999999999999
col inst_sid_ser for a13
col username for a24
col mod_action for a32
col R_MB for 9999999
col W_MB for 9999
col px for 99

VAR L_SQL_PROFILE       VARCHAR2(100)
VAR L_SQL_PATCH         VARCHAR2(100)
VAR L_SQL_PLAN_BASELINE VARCHAR2(100)

-- pro sqlhc
-- 20201010 need to fix
var   L_SQLHC_MIN_FLAG    NUMBER
EXEC :L_SQLHC_MIN_FLAG := 10;
begin
   if( :L_SQLHC_MIN > 15 or :license = 'L') then
     :L_SQLHC_MIN_FLAG := 16 ;
   end if;
end;
/

-- 20201215 consumption group start from awr-sm

var L_REPORT_ID          NUMBER;
var L_INSTANCE_NUMBER    NUMBER;
var L_B_SNAP_ID          NUMBER;
var L_E_SNAP_ID          NUMBER;

begin
     FOR SM IN ( select report_id, INSTANCE_NUMBER,
                      ( select max(B.snap_id)
                        from dba_hist_snapshot B
                        where  B.DBID = :l_dbid
                        AND B.SNAP_ID BETWEEN :L_SNAP_ID - 720 AND :L_SNAP_ID
                        and B.END_INTERVAL_TIME <= A.PERIOD_START_TIME
                        and B.instance_number = A.instance_number ) B_SNAP_ID,
                      ( select min(E.snap_id)
                        from dba_hist_snapshot E
                        where  E.DBID = :l_dbid
                        AND E.SNAP_ID BETWEEN :L_SNAP_ID - 720 AND :L_SNAP_ID
                        and E.END_INTERVAL_TIME >= A.PERIOD_END_TIME
                        and E.instance_number = A.instance_number ) E_SNAP_ID
                 FROM ( SELECT  report_id, INSTANCE_NUMBER, PERIOD_START_TIME, PERIOD_END_TIME
                        FROM DBA_HIST_REPORTS
                        WHERE COMPONENT_NAME ='sqlmonitor'
                        AND   KEY1 = :l_sql_id
                        AND   DBID = :L_DBID
                        AND   SNAP_ID BETWEEN :L_SNAP_ID - 720 AND :L_SNAP_ID
                        ORDER BY GENERATION_TIME DESC ) A
                 WHERE ROWNUM < 2 )
      LOOP
           :L_REPORT_ID         := SM.REPORT_ID ;
           :L_INSTANCE_NUMBER   := SM.INSTANCE_NUMBER ;
           :L_B_SNAP_ID         := SM.B_SNAP_ID ;
           :L_E_SNAP_ID         := SM.E_SNAP_ID ;
           :SQL_FROM_AWR_SPM    := 1 ;
      END LOOP;
      EXCEPTION  WHEN OTHERS THEN
           :L_REPORT_ID       := 0;
           :L_INSTANCE_NUMBER := 0;
end ;
/


BEGIN
  FOR SM IN (
       select extractValue(value(d), '/target/rminfo/@rmcg')  RMCG
       from  DBA_HIST_REPORTS_DETAILS c,
             TABLE(XMLSEQUENCE(EXTRACT(XMLTYPE(c.report), '/report/sql_monitor_report/target'))) D
       where c.DBID = :L_DBID  AND C.INSTANCE_NUMBER = :L_INSTANCE_NUMBER
       AND  C.SNAP_ID BETWEEN :L_SNAP_ID - 720 AND :L_SNAP_ID
       and  c.report_id = :L_REPORT_ID and  :L_REPORT_ID <> 0
       AND   :SQL_FROM_AWR_SPM = 1
        )
  LOOP
      :L_SQL_GROUP := SM.RMCG;
  END LOOP ;
  EXCEPTION  WHEN OTHERS THEN
      :L_REPORT_ID       := 0;
      :L_INSTANCE_NUMBER := 0;
      :SQL_FROM_AWR_SPM  := 0;
END;
/
-- 20201215 consumption group end from awr-sm

--prompt
--PROMPT SQL STATS SECTION
--prompt *****************

--pro <h3><span title="By ECID/Module from GV$ACTIVE_SESSION_HISTORY">* SQL PLAN Control Objects</span></h3>
pro <h3>* SQL PLAN Control Objects</h3>
DECLARE
  V_BASELINE_ORIGIN VARCHAR2(30) ;
BEGIN
--  DBMS_OUTPUT.PUT_LINE('.');
--  DBMS_OUTPUT.PUT_LINE('*****************************************');
--  DBMS_OUTPUT.PUT_LINE('SQL STATS SECTION [SQL_ID: '||:L_SQL_ID||']');
--  DBMS_OUTPUT.PUT_LINE('*****************************************');
--  DBMS_OUTPUT.PUT_LINE('.');
  :SQL_FROM_MEM        := 0;
  :L_PLAN_HASH_VALUE   := 0;
  :L_PLAN_HASH_VALUE_PROFILE := 0;

  :L_SQL_PROFILE       := NULL;
  :L_SQL_PATCH         := NULL;
  :L_SQL_PLAN_BASELINE := NULL;
-- 20201010 need to fix
  FOR I IN (
            SELECT  /*+ no_parallel opt_param('parallel_execution_enabled', 'false') */
                   S.MODULE, S.ACTION, S.SQL_ID,
                   S.SQL_PROFILE, S.SQL_PATCH, S.SQL_PLAN_BASELINE,
                   (select '('||ORIGIN||')' FROM DBA_SQL_PLAN_BASELINES WHERE PLAN_NAME = S.SQL_PLAN_BASELINE) BASELINE_ORIGIN,
                   S.PLAN_HASH_VALUE,
                   S.CHILD_NUMBER, S.INST_ID, S.LAST_LOAD_TIME,
                   ROUND(S.elapsed_time / 1e6/GREATEST(s.executions, 1), 3) ELAPSED_TIME,
                   TO_CHAR(ROUND(S.cpu_time / 1e6/GREATEST(s.executions, 1), 3),     '99999990D990') CPU_TIME,
/* v3 */
                   ROUND(HP.avg_hard_parse_time/ HP.VERSION_COUNT / 1e6, 3) hpt,
                   --TO_CHAR(ROUND(HP.avg_hard_parse_time /  1e6, 3), '990D990') hpt,
                   S.ROWS_PROCESSED,
                   S.IS_OBSOLETE,S.IS_BIND_SENSITIVE,S.IS_BIND_AWARE,S.IS_SHAREABLE,
                   S.FORCE_MATCHING_SIGNATURE,S.SHARABLE_MEM,
/*V19C*/
                   (SELECT COUNT(*) FROM GV$VPD_POLICY V
                    WHERE  V.INST_ID = S.INST_ID
                    AND V.SQL_ID = S.SQL_ID
                    AND V.SQL_ID = :L_SQL_ID
                    AND V.CHILD_NUMBER = S.CHILD_NUMBER
                    AND V.POLICY like '%PII%'
                    AND V.Predicate IS NOT NULL
                    AND ROWNUM <= 3
                    ) VPD_CNT,
                   (SELECT CONSUMER_GROUP
                    FROM
                    (SELECT SM.RM_CONSUMER_GROUP  CONSUMER_GROUP
                     FROM  GV$SQL_MONITOR SM
                     WHERE SM.INST_ID = S.INST_ID
                     AND   SM.SQL_ID =  S.SQL_ID
                     AND   SM.SQL_ID = :L_SQL_ID
                     AND   SM.SQL_PLAN_HASH_VALUE = S.PLAN_HASH_VALUE
--20200708           AND   SM.RM_CONSUMER_GROUP = 'FUSIONAPPS_ONLINE_GROUP'
                     UNION ALL
                     SELECT SES.RESOURCE_CONSUMER_GROUP  CONSUMER_GROUP
                     FROM GV$SESSION SES
                     WHERE SES.INST_ID = S.INST_ID
                     AND   SES.SQL_ID =  S.SQL_ID
                     AND   SES.SQL_ID = :L_SQL_ID
--20200708           AND   SES.RESOURCE_CONSUMER_GROUP = 'FUSIONAPPS_ONLINE_GROUP'
                     UNION ALL
--20201215
                     SELECT :L_SQL_GROUP FROM DUAL
                     --SELECT /*+ PUSH_PRED */ CR.CONSUMER_GROUP
                     --FROM GV$ACTIVE_SESSION_HISTORY ASH, DBA_RSRC_CONSUMER_GROUPS CR
                     --WHERE ASH.INST_ID = S.INST_ID
                     --AND ASH.SQL_ID = S.SQL_ID
                     --AND ASH.SQL_ID =  S.SQL_ID
                     --AND ASH.SQL_ID = :L_SQL_ID
                     --AND ASH.SQL_PLAN_HASH_VALUE = S.PLAN_HASH_VALUE
                     --AND ASH.CONSUMER_GROUP_ID = CR.CONSUMER_GROUP_ID
                     )
                    WHERE ROWNUM = 1
                    )  CONSUMER_GROUP
            FROM  GV$SQL S, GV$SQLSTATS HP
            WHERE S.PLAN_HASH_VALUE = HP.PLAN_HASH_VALUE(+) AND S.SQL_ID = HP.SQL_ID(+)
            AND   S.SQL_ID =  :L_SQL_ID AND S.INST_ID = HP.INST_ID(+)
            AND   :L_SQLHC_MIN_FLAG < 15
            ORDER BY S.PLAN_HASH_VALUE, S.INST_ID, S.LAST_LOAD_TIME )
  LOOP

--sma19c
    IF (  :L_PLAN_HASH_VALUE <> I.PLAN_HASH_VALUE and
      (I.SQL_PROFILE IS NOT NULL OR I.SQL_PATCH IS NOT NULL OR I.SQL_PLAN_BASELINE IS NOT NULL) )  THEN

       --SELECT (select '('||ORIGIN||')' FROM DBA_SQL_PLAN_BASELINES WHERE PLAN_NAME = I.SQL_PLAN_BASELINE) INTO V_BASELINE_ORIGIN
       --FROM DUAL where I.SQL_PLAN_BASELINE IS NOT NULL;
       --DBMS_OUTPUT.PUT_LINE('MEM BASELINE ORIGIN:'||V_BASELINE_ORIGIN);

       DBMS_OUTPUT.PUT_LINE('MEM PHV:'||I.PLAN_HASH_VALUE||' PROFILE:<blue>'||I.SQL_PROFILE
       ||'</blue> PATCH:<blue>'||I.SQL_PATCH||'</blue> BASELINE:<blue>'||I.SQL_PLAN_BASELINE||I.BASELINE_ORIGIN||'</blue>');

    END IF;
--    DBMS_OUTPUT.PUT_LINE('MEM)'
--    ||' PHV:'||I.PLAN_HASH_VALUE||' CHD_NO:'||I.CHILD_NUMBER||' IS_BIND_AWARE:'||I.IS_BIND_AWARE||' INST_ID:'||I.INST_ID
--   ||' HARD PARSING TIME:'||I.HPT
--   ||' MODULE:'||I.MODULE||' ACTION:'||I.ACTION||' PROFILE:'||I.SQL_PROFILE||' PATCH:'||I.SQL_PATCH );

--    DBMS_OUTPUT.PUT_LINE(    ' TIME: '||I.ELAPSED_TIME    ||' CPUT: '||I.CPU_TIME    ||' HARD PARSING TIME: '||I.HPT
--    ||' ROWS_PROCESSED: '||I.ROWS_PROCESSED     ||' IS_BIND_AWARE:'||I.IS_BIND_AWARE);
/*V3*/
    :L_FORCE_MATCHING_SIGNATURE := I.FORCE_MATCHING_SIGNATURE;

    IF ( :L_PLAN_HASH_VALUE <> I.PLAN_HASH_VALUE AND  I.HPT > I.ELAPSED_TIME * 0.5 AND I.HPT > 1 AND I.VPD_CNT = 0
       AND I.SHARABLE_MEM >= 1500000 AND I.CONSUMER_GROUP = 'FUSIONAPPS_ONLINE_GROUP' ) THEN
       DBMS_OUTPUT.PUT_LINE('* Analysis: The sql used high sharable_memory ('||I.SHARABLE_MEM||') and it required AVG '
       ||I.HPT||' second of hard parsing time for PHV, '||I.PLAN_HASH_VALUE||'. This figure is too high for ONLINE Group SQL');
/*v3*/
       DBMS_OUTPUT.PUT_LINE('<blue>Action Item : DEVELOPMENT TEAM/OPERATION TEAM/PSR</BLUE>');
       DBMS_OUTPUT.PUT_LINE('=> Suggestion : Check if OPT_PARAM(''_optimizer_cost_based_transformation'',''off'') hint can work for the short term fix with sqlhc*14_executable_script.sql');
       DBMS_OUTPUT.PUT_LINE('=> Suggestion: Replace the view with the table(s) and minimize the SQL business for long term.');
    END IF;
    IF ( :L_PLAN_HASH_VALUE <> I.PLAN_HASH_VALUE AND  I.HPT > I.ELAPSED_TIME * 0.5 AND I.HPT > 1 AND I.VPD_CNT = 0
       AND I.SHARABLE_MEM < 1500000 AND I.CONSUMER_GROUP = 'FUSIONAPPS_ONLINE_GROUP' ) THEN
       DBMS_OUTPUT.PUT_LINE('<blue>Action Item : OPERATION TEAM</BLUE>');
       DBMS_OUTPUT.PUT_LINE('=> Suggestion: Check if the sql needed AVG '||I.HPT||' second hard parsing time on PHV, '||I.PLAN_HASH_VALUE||' under the cold run.');
/*v3*/
       DBMS_OUTPUT.PUT_LINE('<blue>Action Item : DEVELOPMENT TEAM/OPERATION TEAM/PSR</BLUE>');
       DBMS_OUTPUT.PUT_LINE('=> Suggestion : Check if OPT_PARAM(''_optimizer_cost_based_transformation'',''off'') hint can work for the short term fix with sqlhc*14_executable_script.sql');
    END IF;
    IF ( :L_PLAN_HASH_VALUE <> I.PLAN_HASH_VALUE AND
       I.HPT > I.ELAPSED_TIME * 0.5 AND I.HPT > 1 AND I.VPD_CNT >= 3 ) THEN
       DBMS_OUTPUT.PUT_LINE('<blue>Action Item : DEVELOPMENT TEAM/OPERATION TEAM</BLUE>');
       DBMS_OUTPUT.PUT_LINE('=>Suggestion: Check if complex VPD or too many VPD predicates made any issue.(AVG '
--       ||I.HPT||' second Hard Parsing on PHV:'||I.PLAN_HASH_VALUE||' with '||I.VPD_CNT||' VPDs)');
/*v3*/
       ||I.HPT||' second Hard Parsing on PHV:'||I.PLAN_HASH_VALUE||')');
       --DBMS_OUTPUT.PUT_LINE('=>Suggestion: check if FND_SANDBOX VPD fix was applied with Bug 29701089');
    END IF;
    IF ( :L_PLAN_HASH_VALUE <> I.PLAN_HASH_VALUE AND
         (I.SQL_PROFILE IS NOT NULL OR I.SQL_PATCH IS NOT NULL OR I.SQL_PLAN_BASELINE IS NOT NULL
          ) )  THEN
--      DBMS_OUTPUT.PUT_LINE('NOTE. PHV:'||I.PLAN_HASH_VALUE||' PROFILE:<blue>'||I.SQL_PROFILE
--       ||'</blue> PATCH:<blue>'||I.SQL_PATCH||'</blue> BASELINE:<blue>'||I.SQL_PLAN_BASELINE||'</blue>');
       IF ( I.SQL_PROFILE IS NOT NULL OR  I.SQL_PATCH IS NOT NULL OR I.SQL_PLAN_BASELINE IS NOT NULL ) THEN
         :L_SQL_PROFILE       := I.SQL_PROFILE      ;
         :L_SQL_PATCH         := I.SQL_PATCH        ;
         :L_SQL_PLAN_BASELINE := I.SQL_PLAN_BASELINE;
         :L_PLAN_HASH_VALUE_PROFILE := I.PLAN_HASH_VALUE ;
       END IF;
    END IF;
    IF ( :L_PLAN_HASH_VALUE <> I.PLAN_HASH_VALUE ) THEN
         null;
    --   DBMS_OUTPUT.PUT_LINE('* PHV:'||I.PLAN_HASH_VALUE||' is available in memory.');
    END IF;
    :L_SQL_GROUP        := I.CONSUMER_GROUP;
     if ( :L_HPT < I.HPT ) then
        :L_HPT             := I.HPT;
     end if;
     if ( :L_VPD_CNT < I.VPD_CNT ) then
        :L_VPD_CNT          := I.VPD_CNT;
     end if;
    :SQL_FROM_MEM      := 1;
    :SQL_FROM_AWR      := 0;
    --:L_LAST_LOAD_TIME  := I.LAST_LOAD_TIME;
    :L_SQL_ID          := I.SQL_ID;
    :L_CHILD_NUMBER    := I.CHILD_NUMBER;
    :L_PLAN_HASH_VALUE := I.PLAN_HASH_VALUE;
    :L_INST_ID         := I.INST_ID;
    :L_SHARABLE_MEM := I.SHARABLE_MEM;
  END LOOP;
--  DBMS_OUTPUT.PUT_LINE('++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++');
EXCEPTION
  WHEN OTHERS THEN
    DBMS_OUTPUT.PUT_LINE('ERROR ON SQL STATS (MEMORY): '||SQLERRM);
    :L_OTHER_XML := NULL;
END;
/
DECLARE
  V_BASELINE_ORIGIN VARCHAR2(30) ;
BEGIN
--SMA19C
-- 20201118 -need l_sqlhc_min_flag.
IF (:SQL_FROM_MEM in ( 0,1 ) AND :L_SQLHC_MIN_FLAG < 15  /* limits */ ) THEN   -- 20200811 regardless of memory
--IF (:SQL_FROM_MEM = 0) THEN
  --DBMS_OUTPUT.PUT_LINE('As there is no data in memory, the predicates information will not be available in SQL PLAN SECTION.');
  :L_PLAN_HASH_VALUE := 0;
  FOR I IN ( SELECT DISTINCT S.MODULE, S.ACTION, S.SQL_ID, S.SQL_PROFILE,
  --sma19c
      (select replace(extractvalue(xmltype(other_xml), '/*/info[@type = "sql_patch"]'), '"', '') from dba_hist_sql_plan sp where sp.sql_id = s.sql_id
       AND SP.DBID = :L_DBID
       and sp.other_xml is not null and sp.plan_hash_value = s.plan_hash_value and rownum=1) sql_patch,
      (select replace(extractvalue(xmltype(other_xml), '/*/info[@type = "baseline"]'), '"', '') from dba_hist_sql_plan sp where sp.sql_id = s.sql_id
       AND SP.DBID = :L_DBID
       and sp.other_xml is not null and sp.plan_hash_value = s.plan_hash_value and rownum=1) sql_plan_baseline,
  S.PLAN_HASH_VALUE, S.INSTANCE_NUMBER, S.SNAP_ID,
                   DECODE(S.EXECUTIONS_DELTA,0,TRUNC(S.ELAPSED_TIME_DELTA/1000000,3),
                             TRUNC(S.ELAPSED_TIME_DELTA/1000000/GREATEST(S.EXECUTIONS_DELTA, 1),3)) ELAPSED_TIME,
                   DECODE(S.EXECUTIONS_DELTA,0,TRUNC(S.CPU_TIME_DELTA/1000000,3),
                             TRUNC(S.CPU_TIME_DELTA/1000000/GREATEST(S.EXECUTIONS_DELTA, 1),3)) CPU_TIME,
                   S.ROWS_PROCESSED_DELTA,
                   S.FORCE_MATCHING_SIGNATURE, SHARABLE_MEM,
--20201215
                   :L_SQL_GROUP  CONSUMER_GROUP
                 --  (SELECT CR.CONSUMER_GROUP
                 --   FROM DBA_HIST_ACTIVE_SESS_HISTORY ASH, DBA_RSRC_CONSUMER_GROUPS CR
                 --   WHERE ROWNUM = 1
                 --   AND ASH.SQL_ID = S.SQL_ID
                 --   AND ASH.sql_id = :L_SQL_ID
                 --   AND ASH.DBID = S.DBID AND ASH.INSTANCE_NUMBER = S.INSTANCE_NUMBER
                 --   AND ASH.SQL_PLAN_HASH_VALUE = S.PLAN_HASH_VALUE
                 --   AND ASH.DBID = :L_DBID
                 --   AND ASH.SNAP_ID BETWEEN :L_SNAP_ID - 720 AND :L_SNAP_ID
                 --   AND ASH.CONSUMER_GROUP_ID = CR.CONSUMER_GROUP_ID )  CONSUMER_GROUP
              FROM DBA_HIST_SQLSTAT S
             WHERE S.sql_id = :L_SQL_ID  AND S.DBID = :L_DBID
             --2020922
             AND S.SNAP_ID BETWEEN :L_SNAP_ID - 720 AND :L_SNAP_ID
             --AND   S.EXECUTIONS_DELTA > 0
           ORDER BY S.PLAN_HASH_VALUE, S.INSTANCE_NUMBER, S.SNAP_ID )
  LOOP
--sma19c
    IF (  :L_PLAN_HASH_VALUE <> I.PLAN_HASH_VALUE and
       ( I.SQL_PROFILE IS NOT NULL OR I.SQL_PATCH IS NOT NULL OR I.SQL_PLAN_BASELINE IS NOT NULL ) )  THEN

       SELECT (select '('||ORIGIN||')' FROM DBA_SQL_PLAN_BASELINES WHERE PLAN_NAME = I.SQL_PLAN_BASELINE) INTO V_BASELINE_ORIGIN
       FROM DUAL where I.SQL_PLAN_BASELINE IS NOT NULL;

       DBMS_OUTPUT.PUT_LINE('AWR PHV:'||I.PLAN_HASH_VALUE||' PROFILE:<blue>'||I.SQL_PROFILE
       ||'</blue> PATCH:<blue>'||I.SQL_PATCH||'</blue> BASELINE:<blue>'||I.SQL_PLAN_BASELINE||V_BASELINE_ORIGIN||'</blue>');
    END IF;

--    DBMS_OUTPUT.PUT_LINE('AWR)'
--    ||' PHV:'||I.PLAN_HASH_VALUE||' SNAP_ID:'||I.SNAP_ID||' INST_ID:'||I.INSTANCE_NUMBER
--    ||' MODULE:'||I.MODULE||' ACTION:'||I.ACTION||' SQL_PROFILE:'||I.SQL_PROFILE);
    :L_FORCE_MATCHING_SIGNATURE := I.FORCE_MATCHING_SIGNATURE;
-- sma19c
/*
    IF ( :L_PLAN_HASH_VALUE <> I.PLAN_HASH_VALUE AND
        (I.SQL_PROFILE IS NOT NULL) )  THEN
       DBMS_OUTPUT.PUT_LINE('PHV:'||I.PLAN_HASH_VALUE||' PROFILE:'||I.SQL_PROFILE);
    END IF;
*/
--sma19c
    IF ( :L_PLAN_HASH_VALUE <> I.PLAN_HASH_VALUE AND
         (I.SQL_PROFILE IS NOT NULL OR I.SQL_PATCH IS NOT NULL OR I.SQL_PLAN_BASELINE IS NOT NULL
          ) )  THEN
       IF ( I.SQL_PROFILE IS NOT NULL OR  I.SQL_PATCH IS NOT NULL OR I.SQL_PLAN_BASELINE IS NOT NULL ) THEN
         :L_SQL_PROFILE       := I.SQL_PROFILE      ;
         :L_SQL_PATCH         := I.SQL_PATCH        ;
         :L_SQL_PLAN_BASELINE := I.SQL_PLAN_BASELINE;
         :L_PLAN_HASH_VALUE_PROFILE := I.PLAN_HASH_VALUE ;
       END IF;
    END IF;

    :L_SQL_GROUP        := I.CONSUMER_GROUP;
    :SQL_FROM_AWR := 1;
    :L_SQL_ID := I.SQL_ID;
    :L_PLAN_HASH_VALUE := I.PLAN_HASH_VALUE;
    --:L_SNAP_ID := I.SNAP_ID;
    :L_INST_ID := I.INSTANCE_NUMBER;
    :L_SHARABLE_MEM := I.SHARABLE_MEM;
  END LOOP;
  -- DBMS_OUTPUT.PUT_LINE('++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++');
END IF;
  EXCEPTION
  WHEN OTHERS THEN
    DBMS_OUTPUT.PUT_LINE('ERROR ON SQL STATS (AWR): '||SQLERRM);
    :L_OTHER_XML := NULL;

END;
/

/*
SQL TYPE
*/

-- find any additional sql_group
col CONSUMER_GROUP format a30

BEGIN
     IF ( :L_SQL_GROUP <> 'DEFAULT' ) THEN
        FOR S IN (
              SELECT CR.CONSUMER_GROUP     --into :L_SQL_GROUP1
              FROM GV$ACTIVE_SESSION_HISTORY ASH, DBA_RSRC_CONSUMER_GROUPS CR
              WHERE ROWNUM = 1
              AND ASH.INST_ID = :L_INST_ID
              AND ASH.SQL_ID  = :L_SQL_ID
              AND ASH.SQL_PLAN_HASH_VALUE = :L_PLAN_HASH_VALUE
              AND ASH.CONSUMER_GROUP_ID = CR.CONSUMER_GROUP_ID
              AND CR.CONSUMER_GROUP <> :L_SQL_GROUP )
        LOOP
              :L_SQL_GROUP1 := S.CONSUMER_GROUP;
        END LOOP;
     END IF;
     EXCEPTION
     WHEN OTHERS THEN
        NULL;
END;
/
BEGIN
    --DBMS_OUTPUT.PUT_LINE('CONSUMER_GROUP: '||:L_SQL_GROUP);
    IF    (:L_SQL_GROUP = 'FUSIONAPPS_ONLINE_GROUP') THEN   :L_ACCESS_RATIO :=  5;
    ELSIF (:L_SQL_GROUP = 'LOW_GROUP' )              THEN   :L_ACCESS_RATIO :=  7;
    ELSIF (:L_SQL_GROUP = 'FUSIONAPPS_DIAG_GROUP'  ) THEN   :L_ACCESS_RATIO :=  7;
    ELSIF (:L_SQL_GROUP = 'FUSIONAPPS_BATCH_GROUP' ) THEN   :L_ACCESS_RATIO := 10;
    ELSIF (:L_SQL_GROUP = 'BATCH_GROUP' )            THEN   :L_ACCESS_RATIO := 10;
    ELSIF (:L_SQL_GROUP = 'DSS_GROUP' )              THEN   :L_ACCESS_RATIO := 15;
    ELSIF (:L_SQL_GROUP = 'ETL_GROUP' )              THEN   :L_ACCESS_RATIO := 15;
    ELSIF (:L_SQL_GROUP = 'SYS_GROUP' )              THEN   :L_ACCESS_RATIO := 10;
    ELSIF (:L_SQL_GROUP = 'OTHER_GROUPS' )           THEN   :L_ACCESS_RATIO := 10;
    ELSE  :L_SQL_GROUP := 'DEFAULT'; :L_ACCESS_RATIO := 10;
    END IF;
--    DBMS_OUTPUT.PUT_LINE('CONSUMER_GROUP: '||:L_SQL_GROUP||' ['||:L_ACCESS_RATIO||']');
--    DBMS_OUTPUT.PUT_LINE('.');
END;
/

--prompt
--PROMPT OBJECT STATS AND BS GATHERING STATS SECTION (under construction)
--prompt ***************************************************************


/***********************************************************************************
PROMPT SQL LIST USING SAME PHV

SELECT INST_ID, SQL_ID, SQL_TEXT
FROM GV$SQLAREA WHERE PLAN_HASH_VALUE IN
(SELECT PLAN_HASH_VALUE FROM GV$SQLAREA WHERE SQL_ID = :L_SQL_ID)

************************************************************************************/

/***********************************************************************************
PROMPT SQLPROFILE AND SQLPROFILE LIST   --

- CHECK WHEN THE ISSUE SQL WORKED AT LAST. (THE LAST EXECUTION)
- CHECK IF THE W/A PHV WORKED BETWEEN THE LAST ANALYZED TIME AND THE LAST EXECUTION.
  OR BETWEEN THE LAST EXECUTION AND THE LAST ANALYZED TIME.
- CHECK IF THE W/A PHV HAS ACTUAL EXECUTION. (NOT 0)
- CHECK IF THE W/A PHV WAS NOT LISTED IN THE GV$SQL_MONITOR.
- CHECK IF THE W/A PHV IS SAME AS THE CURRENT PROFILE/PATCH PHV IS.

************************************************************************************/
SPOOL off

-- FOR SMA AND SLQHC
SPOOL sma_&&files_prefix..sql3;

--pro </pre><a name="PHV_STATS"></a><h2>Plan Hash Value comparison</h2><pre>
pro </pre><a name="PHV_STATS"></a><h2><span title="Only for non zero Executions">Plan Hash Value comparison</span></h2><pre>

--sma19c  20191223

VAR L_CURRENT_BEST number;
EXEC :L_CURRENT_BEST := -1;
VAR L_CURRENT_BEST_TIME number;
EXEC :L_CURRENT_BEST_TIME := NULL;
VAR L_CURRENT_BEST_AVG_PROW number;
EXEC :L_CURRENT_BEST_AVG_PROW := NULL;

VAR L_COUNT number;
EXEC :L_COUNT := 0;

VAR L_CURRENT_WORST1 NUMBER;
EXEC  :L_CURRENT_WORST1 := -1;

VAR L_CURRENT_WORST1_time NUMBER;
EXEC  :L_CURRENT_WORST1_time := -1;

VAR L_CURRENT_WORST2 NUMBER;
EXEC  :L_CURRENT_WORST2 := -1;

VAR L_CURRENT_WORST2 NUMBER;
EXEC  :L_CURRENT_WORST2 := -1;

VAR L_CURRENT_WORST3 NUMBER;
EXEC  :L_CURRENT_WORST3 := -1;

VAR L_CURRENT_WORST4 NUMBER;
EXEC  :L_CURRENT_WORST4 := -1;

VAR L_CURRENT_WORST5 NUMBER;
EXEC  :L_CURRENT_WORST5 := -1;

col CF format a15


/*
STATUS 	VARCHAR2(19) 	SQL execution status:
    EXECUTING - SQL statement is still executing
    DONE (ERROR) - Execution terminated with an error
    DONE (FIRST N ROWS) - Execution terminated by the application before all rows were fetched
    DONE (ALL ROWS) - Execution terminated and all rows were fetched
    DONE - Execution terminated (parallel execution)
*/
/***********************************************************************************
PROMPT SQL TEXT SCAN  : As it needs the parser, hold it here.
************************************************************************************/

--PROMPT
--PROMPT SQL PLAN SECTION
--PROMPT ****************

-- 20210302
-- SQL PLAN COMPARISON AND GENERATE HINT START


BEGIN
  SELECT
   NVL( (SELECT 1 FROM GV$SQL_SHARED_CURSOR SC
         WHERE SC.AUTH_CHECK_MISMATCH = 'Y' AND ROWNUM = 1 AND SC.SQL_ID = :L_SQL_ID), 0)
  INTO :L_VPD_CNT
  FROM DUAL;
END;
/


VAR L_CURRENT_BEST1 number;
EXEC :L_CURRENT_BEST1 := -1;
VAR L_CURRENT_BEST1_TIME number;
EXEC :L_CURRENT_BEST1_TIME := NULL;


set head off
DELETE PLAN_TABLE ;
COMMIT;


INSERT INTO PLAN_TABLE 
(ID, STATEMENT_ID, PLAN_ID, PARENT_ID, DEPTH, POSITION, CARDINALITY, BYTES, PARTITION_ID, OBJECT_NODE, OBJECT_OWNER, COST, OBJECT_TYPE)
WITH
p AS ( select sql_id, plan_hash_value, max(cost) cost from (
       SELECT sql_id, plan_hash_value, max(cost) cost FROM gv$sql_plan       WHERE sql_id = :L_SQL_ID group by sql_id, plan_hash_value  UNION
       SELECT sql_id, plan_hash_value, max(cost) cost FROM dba_hist_sql_plan WHERE sql_id = :L_SQL_ID
       AND DBID = :L_DBID group by sql_id, plan_hash_value )
       group by sql_id, plan_hash_value       ),
m AS (
SELECT sql_id, plan_hash_value,
       SUM(elapsed_time)/greatest(sum(executions),1) avg_et_secs,
       SUM(cpu_time)/greatest(sum(executions),1) avg_cpu_secs,
       round(sum(rows_processed)/greatest(sum(executions),1)) avg_rows_processed,
       round(SUM(buffer_gets)/greatest(SUM(executions),1)) avg_bfgs,
       round(SUM(DISK_READS)/greatest(SUM(executions),1))  avg_disk,
       SUM(executions) total_exec,
       MAX(LAST_LOAD_TIME) LAST_LOAD_TIME,
       MAX(LAST_ACTIVE_TIME) LAST_ACTIVE_TIME
  FROM gv$sql
 WHERE sql_id = :L_SQL_ID
 --  AND executions > 0
 GROUP BY sql_id,plan_hash_value ),
a AS (
SELECT sql_id,plan_hash_value,
       SUM(elapsed_time_delta)/greatest(sum(executions_delta),1) avg_et_secs,
       SUM(cpu_time_delta)/greatest(sum(executions_delta),1) avg_cpu_secs,
       round(sum(rows_processed_delta)/greatest(sum(executions_delta),1)) avg_rows_processed ,
       round(SUM(buffer_gets_delta)/greatest(SUM(executions_delta),1)) avg_bfgs,
       round(SUM(DISK_READS_delta)/greatest(SUM(executions_delta),1))  avg_disk,
       SUM(executions_delta) total_exec,
       --MAX('-') LAST_LOAD_TIME,
       MAX(SNAP_ID)  SNAP_ID
  FROM dba_hist_sqlstat
 WHERE sql_id =  :L_SQL_ID
 --  AND executions_total > 0
   AND DBID = :L_DBID
   AND SNAP_ID BETWEEN :L_SNAP_ID - 720 AND :L_SNAP_ID
 GROUP BY sql_id,plan_hash_value ),
SSET AS (
SELECT p.sql_id, p.plan_hash_value, 
       NVL(m.avg_et_secs, a.avg_et_secs)   avg_et_secs,
       --ROUND(NVL(m.avg_et_secs, a.avg_et_secs)/1e6, 3)   avg_et_secs,
       NVL(m.avg_cpu_secs, a.avg_cpu_secs) avg_cpu_secs,
       --ROUND(NVL(m.avg_cpu_secs, a.avg_cpu_secs)/1e6, 3) avg_cpu_secs,
       ROUND(NVL(m.avg_rows_processed, a.avg_rows_processed)) avg_rows_processed,
       ROUND(NVL(m.avg_bfgs, a.avg_bfgs)) avg_bfgs,
       ROUND(NVL(m.avg_disk, a.avg_disk)) avg_disk,
       ROUND(NVL(m.total_exec, a.total_exec)) total_exec,
       NVL(TO_CHAR(m.LAST_LOAD_TIME), ' ') LAST_LOAD_TIME,
      -- NVL(TO_CHAR(m.LAST_ACTIVE_TIME), a.LAST_ACTIVE_TIME) LAST_ACTIVE_TIME,
       NVL( TO_CHAR(m.LAST_ACTIVE_TIME),
            (select max(END_INTERVAL_TIME) from dba_hist_snapshot
             where snap_id = a.snap_id AND DBID = :L_DBID and rownum = 1)
           ) LAST_ACTIVE_TIME,
       p.cost,
       DECODE(m.avg_et_secs,NULL,'AWR','MEM') SRC
  FROM p, m, a
 WHERE p.plan_hash_value = m.plan_hash_value(+)
   AND p.plan_hash_value = a.plan_hash_value(+)
 ORDER BY avg_et_secs NULLS LAST  ) ,
MAXROWS AS ( SELECT decode(MAX(avg_rows_processed),0,0,1) MAX_PROCCESSED, count(*) LAST_CNT  FROM SSET )
SELECT ROWNUM RWNM, SQL_ID, PLAN_HASH_VALUE, AVG_ET_SECS, avg_cpu_secs, AVG_ROWS_PROCESSED, AVG_BFGS,
                    avg_disk, total_exec, LAST_LOAD_TIME, LAST_ACTIVE_TIME,
                    COST, SRC
FROM ( SELECT SQL_ID, PLAN_HASH_VALUE, AVG_ET_SECS, avg_cpu_secs, AVG_ROWS_PROCESSED, AVG_BFGS,
              avg_disk, total_exec, LAST_LOAD_TIME, LAST_ACTIVE_TIME, COST, SRC
       FROM SSET S1  WHERE   AVG_ROWS_PROCESSED >= (SELECT MAX_PROCCESSED FROM MAXROWS)
       ORDER BY  AVG_ET_SECS, AVG_BFGS ) 
/



pro <table>
pro <tbody><tr>
pro <th>RWNM</th>
pro <th>PLAN_HASH_VALUE</th>
pro <th>AVG<br>Elapsed Time<br>(secs)</th>
pro <th>AVG<br>CPU Time<br>(secs)</th>
pro <th>AVG<br>Buffer Gets</th>
pro <th>AVG<br>Disk Reads</th>
pro <th>AVG<br>Number of Rows</th>
pro <th>Total Number<br>of Execution</th>
pro <th>MEMORY<br>LAST LOAD TIME</th>
pro <th>LAST ACTIVE TIME</th>
pro <th>Cost</th>
pro <th>Source</th>
pro </tr>

/*
SELECT ID RWNM, STATEMENT_ID SQL_ID, PLAN_ID PLAN_HASH_VALUE,
ROUND(PARENT_ID/1E6,3) AVG_ET_SECS, ROUND(DEPTH/1E6,3) avg_cpu_secs,
POSITION  AVG_ROWS_PROCESSED, CARDINALITY AVG_BFGS, BYTES avg_disk,
PARTITION_ID total_exec,
OBJECT_NODE LAST_LOAD_TIME, OBJECT_OWNER LAST_ACTIVE_TIME,
COST COST, OBJECT_TYPE SRC
FROM PLAN_TABLE
*/

SELECT CHR(10)||'<tr>'||CHR(10)||
'<td class="r">'||RWNM||'</td>'||CHR(10)||
'<td class="r">'||PLAN_HASH_VALUE||'</td>'||CHR(10)||
'<td class="r">'||avg_et_secs||'</td>'||CHR(10)||
'<td class="r">'||avg_CPU_secs||'</td>'||CHR(10)||
'<td class="r">'||AVG_BFGS||'</td>'||CHR(10)||
'<td class="r">'||avg_disk||'</td>'||CHR(10)||
'<td class="r">'||AVG_ROWS_PROCESSED||'</td>'||CHR(10)||
'<td class="r">'||total_exec||'</td>'||CHR(10)||
'<td class="r">'||LAST_LOAD_TIME||'</td>'||CHR(10)||
'<td class="r">'||LAST_ACTIVE_TIME||'</td>'||CHR(10)||
'<td class="r">'||COST||'</td>'||CHR(10)||
'<td class="r">'||SRC||'</td>'||CHR(10)||
'</TR>'
FROM  (
 SELECT RWNM, PLAN_HASH_VALUE,
  nvl(CASE
      WHEN AVG_ET_SECS >= 1e18 THEN ROUND(AVG_ET_SECS /1e18,1) || 'E'
      WHEN AVG_ET_SECS >= 1e15 THEN ROUND(AVG_ET_SECS /1e15,1) || 'P'
      WHEN AVG_ET_SECS >= 1e12 THEN ROUND(AVG_ET_SECS /1e12,1) || 'T'
      WHEN AVG_ET_SECS >= 1e9  THEN ROUND(AVG_ET_SECS / 1e9,1) || 'G'
      WHEN AVG_ET_SECS >= 1e6  THEN ROUND(AVG_ET_SECS / 1e6,1) || 'M'
      WHEN AVG_ET_SECS >= 1e3  THEN ROUND(AVG_ET_SECS / 1e3,1) || 'K'
      ELSE to_char(round(AVG_ET_SECS,2)) END, ' ')  AVG_ET_SECS,
  nvl(CASE
      WHEN AVG_CPU_SECS >= 1e18 THEN ROUND(AVG_CPU_SECS /1e18,1) || 'E'
      WHEN AVG_CPU_SECS >= 1e15 THEN ROUND(AVG_CPU_SECS /1e15,1) || 'P'
      WHEN AVG_CPU_SECS >= 1e12 THEN ROUND(AVG_CPU_SECS /1e12,1) || 'T'
      WHEN AVG_CPU_SECS >= 1e9  THEN ROUND(AVG_CPU_SECS / 1e9,1) || 'G'
      WHEN AVG_CPU_SECS >= 1e6  THEN ROUND(AVG_CPU_SECS / 1e6,1) || 'M'
      WHEN AVG_CPU_SECS >= 1e3  THEN ROUND(AVG_CPU_SECS / 1e3,1) || 'K'
      ELSE to_char(round(AVG_CPU_SECS,2)) END, ' ')  AVG_CPU_SECS,
  nvl(CASE
      WHEN AVG_BFGS >= 1e18 THEN ROUND(AVG_BFGS /1e18,1) || 'E'
      WHEN AVG_BFGS >= 1e15 THEN ROUND(AVG_BFGS /1e15,1) || 'P'                                
      WHEN AVG_BFGS >= 1e12 THEN ROUND(AVG_BFGS /1e12,1) || 'T'                                
      WHEN AVG_BFGS >= 1e9  THEN ROUND(AVG_BFGS / 1e9,1) || 'G'                                
      WHEN AVG_BFGS >= 1e6  THEN ROUND(AVG_BFGS / 1e6,1) || 'M'                                
      WHEN AVG_BFGS >= 1e3  THEN ROUND(AVG_BFGS / 1e3,1) || 'K'                                
      ELSE to_char(round(AVG_BFGS,2)) END, ' ') AVG_BFGS,
  nvl(CASE
      WHEN AVG_DISK >= 1e18 THEN ROUND(AVG_DISK /1e18,1) || 'E'
      WHEN AVG_DISK >= 1e15 THEN ROUND(AVG_DISK /1e15,1) || 'P'
      WHEN AVG_DISK >= 1e12 THEN ROUND(AVG_DISK /1e12,1) || 'T'
      WHEN AVG_DISK >= 1e9  THEN ROUND(AVG_DISK / 1e9,1) || 'G'
      WHEN AVG_DISK >= 1e6  THEN ROUND(AVG_DISK / 1e6,1) || 'M'
      WHEN AVG_DISK >= 1e3  THEN ROUND(AVG_DISK / 1e3,1) || 'K'
      ELSE to_char(round(AVG_DISK,2)) END, ' ') AVG_disk,
  nvl(CASE
      WHEN AVG_ROWS_PROCESSED >= 1e18 THEN ROUND(AVG_ROWS_PROCESSED /1e18,1) || 'E'
      WHEN AVG_ROWS_PROCESSED >= 1e15 THEN ROUND(AVG_ROWS_PROCESSED /1e15,1) || 'P'                                
      WHEN AVG_ROWS_PROCESSED >= 1e12 THEN ROUND(AVG_ROWS_PROCESSED /1e12,1) || 'T'                                
      WHEN AVG_ROWS_PROCESSED >= 1e9  THEN ROUND(AVG_ROWS_PROCESSED / 1e9,1) || 'G'                                
      WHEN AVG_ROWS_PROCESSED >= 1e6  THEN ROUND(AVG_ROWS_PROCESSED / 1e6,1) || 'M'                                
      WHEN AVG_ROWS_PROCESSED >= 1e3  THEN ROUND(AVG_ROWS_PROCESSED / 1e3,1) || 'K'                                
      ELSE to_char(round(AVG_ROWS_PROCESSED,2)) END, ' ') AVG_ROWS_PROCESSED,
  nvl(CASE
      WHEN total_exec >= 1e18 THEN ROUND(total_exec /1e18,1) || 'E'
      WHEN total_exec >= 1e15 THEN ROUND(total_exec /1e15,1) || 'P'                                
      WHEN total_exec >= 1e12 THEN ROUND(total_exec /1e12,1) || 'T'                                
      WHEN total_exec >= 1e9  THEN ROUND(total_exec / 1e9,1) || 'G'
      WHEN total_exec >= 1e6  THEN ROUND(total_exec / 1e6,1) || 'M'                                
      WHEN total_exec >= 1e3  THEN ROUND(total_exec / 1e3,1) || 'K'                                
      ELSE to_char(round(total_exec,2)) END, ' ') total_exec,
  LAST_LOAD_TIME, LAST_ACTIVE_TIME,
    nvl(CASE
      WHEN COST >= 1e18 THEN ROUND(COST /1e18,1) || 'E'
      WHEN COST >= 1e15 THEN ROUND(COST /1e15,1) || 'P'                                
      WHEN COST >= 1e12 THEN ROUND(COST /1e12,1) || 'T'                                
      WHEN COST >= 1e9  THEN ROUND(COST / 1e9,1) || 'G'
      WHEN COST >= 1e6  THEN ROUND(COST / 1e6,1) || 'M'                                
      WHEN COST >= 1e3  THEN ROUND(COST / 1e3,1) || 'K'                                
      ELSE to_char(round(COST,2)) END, ' ') COST,
  SRC
FROM
(
SELECT ID RWNM, STATEMENT_ID SQL_ID, PLAN_ID PLAN_HASH_VALUE,
ROUND(PARENT_ID/1E6,3) AVG_ET_SECS, ROUND(DEPTH/1E6,3) avg_cpu_secs,
CARDINALITY AVG_BFGS, BYTES avg_disk,
POSITION  AVG_ROWS_PROCESSED, PARTITION_ID total_exec,
OBJECT_NODE LAST_LOAD_TIME, OBJECT_OWNER LAST_ACTIVE_TIME,
COST COST, OBJECT_TYPE SRC
FROM PLAN_TABLE 
ORDER BY ID ) )
/

VAR L_LAST_RWNM NUMBER
VAR L_CURRENT_BEST_BFG   NUMBER
VAR L_CURRENT_BEST1_BFG  NUMBER
VAR L_CURRENT_WORST1_BFG NUMBER


BEGIN  SELECT COUNT(*) INTO :L_LAST_RWNM FROM PLAN_TABLE ; END;
/
BEGIN SELECT PLAN_ID phv, PARENT_ID et, CARDINALITY bfg INTO :L_CURRENT_BEST,  :L_CURRENT_BEST_TIME,  :L_CURRENT_BEST_BFG   FROM PLAN_TABLE WHERE ID = 1 ; END;
/
BEGIN IF(:L_LAST_RWNM > 1) THEN SELECT PLAN_ID phv, PARENT_ID et, CARDINALITY bfg INTO :L_CURRENT_BEST1, :L_CURRENT_BEST1_TIME, :L_CURRENT_BEST1_BFG  FROM PLAN_TABLE WHERE ID = 2 ; END IF; END;
/
BEGIN IF(:L_LAST_RWNM > 1) THEN SELECT PLAN_ID phv, PARENT_ID et, CARDINALITY bfg INTO :L_CURRENT_WORST1,:L_CURRENT_WORST1_TIME,:L_CURRENT_WORST1_BFG FROM PLAN_TABLE WHERE ID = :L_LAST_RWNM AND :L_LAST_RWNM >=2; END IF; END;
/
BEGIN :L_COUNT := :L_LAST_RWNM; END ;
/

PRO </tbody>
PRO </TABLE>

PROMPT <DETAILS>
PROMPT <SUMMARY><BLUE>HINT SUGGESTION FROM BETTER PLAN.</BLUE></SUMMARY>
PROMPT
--select ' Note. The sql_id, '||:L_SQL_ID||' is working under <blue>'||:L_SQL_GROUP||'</blue>.' from dual ;
select ' The hint is from phv '||:L_CURRENT_BEST||decode(:L_CURRENT_WORST1, :L_CURRENT_BEST1,'', ' or '||:L_CURRENT_BEST1)||', if there is some suggestion' from dual;

--20210303
insert into plan_table (PLAN_ID,REMARKS)
SELECT  /*+ opt_param('parallel_execution_enabled', 'false') */
 1,  SUBSTR(EXTRACTVALUE(VALUE(d), '/hint'), 1, 4000) hintS
FROM  ( select /*+ LEADING(F,S) */ S.OTHER_XML
        from  ( SELECT STATEMENT_ID SQL_ID, PLAN_ID PLAN_HASH_VALUE FROM PLAN_TABLE WHERE ID = 1 AND OBJECT_TYPE = 'MEM' 
                and :L_CURRENT_BEST_TIME*2 < :L_CURRENT_WORST1_TIME and :L_CURRENT_BEST_BFG < :L_CURRENT_WORST1_BFG ) F, gv$sql_plan S
        WHERE  F.SQL_ID  = S.SQL_ID AND F.PLAN_HASH_VALUE = S.PLAN_HASH_VALUE
        AND S.OTHER_XML IS NOT NULL AND ROWNUM = 1 ) S,
      TABLE(XMLSEQUENCE(EXTRACT(XMLTYPE(S.OTHER_XML), '/*/outline_data/hint'))) d
where ( SUBSTR(EXTRACTVALUE(VALUE(d), '/hint'), 1, 4000) like 'LEADING%'
    or  SUBSTR(EXTRACTVALUE(VALUE(d), '/hint'), 1, 4000) like 'USE_NL%'
    or  SUBSTR(EXTRACTVALUE(VALUE(d), '/hint'), 1, 4000) like 'USE_HASH%'
    or  SUBSTR(EXTRACTVALUE(VALUE(d), '/hint'), 1, 4000) like 'PUSH_%'
    or  SUBSTR(EXTRACTVALUE(VALUE(d), '/hint'), 1, 4000) like 'INDEX%' )
UNION ALL
SELECT  /*+ opt_param('parallel_execution_enabled', 'false') */
 1,  SUBSTR(EXTRACTVALUE(VALUE(d), '/hint'), 1, 4000) hintS
FROM  ( select /*+ LEADING(F,S) */ S.OTHER_XML
        from  ( SELECT STATEMENT_ID SQL_ID, PLAN_ID PLAN_HASH_VALUE FROM PLAN_TABLE WHERE ID = 1 AND OBJECT_TYPE = 'AWR'
        and :L_CURRENT_BEST_TIME*2 < :L_CURRENT_WORST1_TIME  and :L_CURRENT_BEST_BFG < :L_CURRENT_WORST1_BFG ) F, DBA_HIST_SQL_PLAN S
        WHERE  F.SQL_ID  = S.SQL_ID AND F.PLAN_HASH_VALUE = S.PLAN_HASH_VALUE
        AND S.OTHER_XML IS NOT NULL AND ROWNUM = 1 ) S,
      TABLE(XMLSEQUENCE(EXTRACT(XMLTYPE(S.OTHER_XML), '/*/outline_data/hint'))) d
where ( SUBSTR(EXTRACTVALUE(VALUE(d), '/hint'), 1, 4000) like 'LEADING%'
    or  SUBSTR(EXTRACTVALUE(VALUE(d), '/hint'), 1, 4000) like 'USE_NL%'
    or  SUBSTR(EXTRACTVALUE(VALUE(d), '/hint'), 1, 4000) like 'USE_HASH%'
    or  SUBSTR(EXTRACTVALUE(VALUE(d), '/hint'), 1, 4000) like 'PUSH_%'
    or  SUBSTR(EXTRACTVALUE(VALUE(d), '/hint'), 1, 4000) like 'INDEX%' )
MINUS
SELECT  /*+ opt_param('parallel_execution_enabled', 'false') */
 1,  SUBSTR(EXTRACTVALUE(VALUE(d), '/hint'), 1, 4000) hintS
FROM  ( select /*+ LEADING(F,S) */ S.OTHER_XML
        from  ( SELECT STATEMENT_ID SQL_ID, PLAN_ID PLAN_HASH_VALUE FROM PLAN_TABLE WHERE ID = :L_LAST_RWNM AND OBJECT_TYPE = 'MEM'
        and :L_CURRENT_BEST_TIME*2 < :L_CURRENT_WORST1_TIME and :L_CURRENT_BEST_BFG < :L_CURRENT_WORST1_BFG ) F, gv$sql_plan S
        WHERE  F.SQL_ID  = S.SQL_ID AND F.PLAN_HASH_VALUE = S.PLAN_HASH_VALUE
        AND S.OTHER_XML IS NOT NULL AND ROWNUM = 1 ) S,
      TABLE(XMLSEQUENCE(EXTRACT(XMLTYPE(S.OTHER_XML), '/*/outline_data/hint'))) d
where ( SUBSTR(EXTRACTVALUE(VALUE(d), '/hint'), 1, 4000) like 'LEADING%'
    or  SUBSTR(EXTRACTVALUE(VALUE(d), '/hint'), 1, 4000) like 'USE_NL%'
    or  SUBSTR(EXTRACTVALUE(VALUE(d), '/hint'), 1, 4000) like 'USE_HASH%'
    or  SUBSTR(EXTRACTVALUE(VALUE(d), '/hint'), 1, 4000) like 'PUSH_%'
    or  SUBSTR(EXTRACTVALUE(VALUE(d), '/hint'), 1, 4000) like 'INDEX%' )
MINUS
SELECT  /*+ opt_param('parallel_execution_enabled', 'false') */
 1,  SUBSTR(EXTRACTVALUE(VALUE(d), '/hint'), 1, 4000) hintS
FROM  ( select /*+ LEADING(F,S) */ S.OTHER_XML
        from  ( SELECT STATEMENT_ID SQL_ID, PLAN_ID PLAN_HASH_VALUE FROM PLAN_TABLE WHERE ID = :L_LAST_RWNM AND OBJECT_TYPE = 'AWR'
        and :L_CURRENT_BEST_TIME*2 < :L_CURRENT_WORST1_TIME  and :L_CURRENT_BEST_BFG < :L_CURRENT_WORST1_BFG ) F, DBA_HIST_SQL_PLAN S
        WHERE  F.SQL_ID  = S.SQL_ID AND F.PLAN_HASH_VALUE = S.PLAN_HASH_VALUE
        AND S.OTHER_XML IS NOT NULL AND ROWNUM = 1 ) S,
      TABLE(XMLSEQUENCE(EXTRACT(XMLTYPE(S.OTHER_XML), '/*/outline_data/hint'))) d
where ( SUBSTR(EXTRACTVALUE(VALUE(d), '/hint'), 1, 4000) like 'LEADING%'
    or  SUBSTR(EXTRACTVALUE(VALUE(d), '/hint'), 1, 4000) like 'USE_NL%'
    or  SUBSTR(EXTRACTVALUE(VALUE(d), '/hint'), 1, 4000) like 'USE_HASH%'
    or  SUBSTR(EXTRACTVALUE(VALUE(d), '/hint'), 1, 4000) like 'PUSH_%'
    or  SUBSTR(EXTRACTVALUE(VALUE(d), '/hint'), 1, 4000) like 'INDEX%' )
/

insert into plan_table (PLAN_ID,REMARKS)
SELECT  /*+ opt_param('parallel_execution_enabled', 'false') */
 2,  SUBSTR(EXTRACTVALUE(VALUE(d), '/hint'), 1, 4000) hintS
FROM  ( select /*+ LEADING(F,S) */ S.OTHER_XML
        from  ( SELECT STATEMENT_ID SQL_ID, PLAN_ID PLAN_HASH_VALUE FROM PLAN_TABLE WHERE ID = 2 AND OBJECT_TYPE = 'MEM'
        and :L_CURRENT_BEST1_TIME*2 < :L_CURRENT_WORST1_TIME and :L_CURRENT_BEST1_BFG < :L_CURRENT_WORST1_BFG ) F, gv$sql_plan S
        WHERE  F.SQL_ID  = S.SQL_ID AND F.PLAN_HASH_VALUE = S.PLAN_HASH_VALUE
        AND S.OTHER_XML IS NOT NULL AND ROWNUM = 1 ) S,
      TABLE(XMLSEQUENCE(EXTRACT(XMLTYPE(S.OTHER_XML), '/*/outline_data/hint'))) d
where ( SUBSTR(EXTRACTVALUE(VALUE(d), '/hint'), 1, 4000) like 'LEADING%'
    or  SUBSTR(EXTRACTVALUE(VALUE(d), '/hint'), 1, 4000) like 'USE_NL%'
    or  SUBSTR(EXTRACTVALUE(VALUE(d), '/hint'), 1, 4000) like 'USE_HASH%'
    or  SUBSTR(EXTRACTVALUE(VALUE(d), '/hint'), 1, 4000) like 'PUSH_%'
    or  SUBSTR(EXTRACTVALUE(VALUE(d), '/hint'), 1, 4000) like 'INDEX%' )
UNION ALL
SELECT  /*+ opt_param('parallel_execution_enabled', 'false') */
 2,  SUBSTR(EXTRACTVALUE(VALUE(d), '/hint'), 1, 4000) hintS
FROM  ( select /*+ LEADING(F,S) */ S.OTHER_XML
        from  ( SELECT STATEMENT_ID SQL_ID, PLAN_ID PLAN_HASH_VALUE FROM PLAN_TABLE WHERE ID = 2 AND OBJECT_TYPE = 'AWR'
        and :L_CURRENT_BEST1_TIME*2 < :L_CURRENT_WORST1_TIME and :L_CURRENT_BEST1_BFG < :L_CURRENT_WORST1_BFG ) F, DBA_HIST_SQL_PLAN S
        WHERE  F.SQL_ID  = S.SQL_ID AND F.PLAN_HASH_VALUE = S.PLAN_HASH_VALUE
        AND S.OTHER_XML IS NOT NULL AND ROWNUM = 1 ) S,
      TABLE(XMLSEQUENCE(EXTRACT(XMLTYPE(S.OTHER_XML), '/*/outline_data/hint'))) d
where ( SUBSTR(EXTRACTVALUE(VALUE(d), '/hint'), 1, 4000) like 'LEADING%'
    or  SUBSTR(EXTRACTVALUE(VALUE(d), '/hint'), 1, 4000) like 'USE_NL%'
    or  SUBSTR(EXTRACTVALUE(VALUE(d), '/hint'), 1, 4000) like 'USE_HASH%'
    or  SUBSTR(EXTRACTVALUE(VALUE(d), '/hint'), 1, 4000) like 'PUSH_%'
    or  SUBSTR(EXTRACTVALUE(VALUE(d), '/hint'), 1, 4000) like 'INDEX%' )
MINUS
SELECT  /*+ opt_param('parallel_execution_enabled', 'false') */
 2,  SUBSTR(EXTRACTVALUE(VALUE(d), '/hint'), 1, 4000) hintS
FROM  ( select /*+ LEADING(F,S) */ S.OTHER_XML
        from  ( SELECT STATEMENT_ID SQL_ID, PLAN_ID PLAN_HASH_VALUE FROM PLAN_TABLE WHERE ID = :L_LAST_RWNM AND OBJECT_TYPE = 'MEM'
        and :L_CURRENT_BEST1_TIME*2 < :L_CURRENT_WORST1_TIME and :L_CURRENT_BEST1_BFG < :L_CURRENT_WORST1_BFG ) F, gv$sql_plan S
        WHERE  F.SQL_ID  = S.SQL_ID AND F.PLAN_HASH_VALUE = S.PLAN_HASH_VALUE
        AND S.OTHER_XML IS NOT NULL AND ROWNUM = 1 ) S,
      TABLE(XMLSEQUENCE(EXTRACT(XMLTYPE(S.OTHER_XML), '/*/outline_data/hint'))) d
where ( SUBSTR(EXTRACTVALUE(VALUE(d), '/hint'), 1, 4000) like 'LEADING%'
    or  SUBSTR(EXTRACTVALUE(VALUE(d), '/hint'), 1, 4000) like 'USE_NL%'
    or  SUBSTR(EXTRACTVALUE(VALUE(d), '/hint'), 1, 4000) like 'USE_HASH%'
    or  SUBSTR(EXTRACTVALUE(VALUE(d), '/hint'), 1, 4000) like 'PUSH_%'
    or  SUBSTR(EXTRACTVALUE(VALUE(d), '/hint'), 1, 4000) like 'INDEX%' )
MINUS
SELECT  /*+ opt_param('parallel_execution_enabled', 'false') */
 2,  SUBSTR(EXTRACTVALUE(VALUE(d), '/hint'), 1, 4000) hintS
FROM  ( select /*+ LEADING(F,S) */ S.OTHER_XML
        from  ( SELECT STATEMENT_ID SQL_ID, PLAN_ID PLAN_HASH_VALUE FROM PLAN_TABLE WHERE ID = :L_LAST_RWNM AND OBJECT_TYPE = 'AWR'
        and :L_CURRENT_BEST1_TIME*2 < :L_CURRENT_WORST1_TIME and :L_CURRENT_BEST1_BFG < :L_CURRENT_WORST1_BFG ) F, DBA_HIST_SQL_PLAN S
        WHERE  F.SQL_ID  = S.SQL_ID AND F.PLAN_HASH_VALUE = S.PLAN_HASH_VALUE
        AND S.OTHER_XML IS NOT NULL AND ROWNUM = 1 ) S,
      TABLE(XMLSEQUENCE(EXTRACT(XMLTYPE(S.OTHER_XML), '/*/outline_data/hint'))) d
where ( SUBSTR(EXTRACTVALUE(VALUE(d), '/hint'), 1, 4000) like 'LEADING%'
    or  SUBSTR(EXTRACTVALUE(VALUE(d), '/hint'), 1, 4000) like 'USE_NL%'
    or  SUBSTR(EXTRACTVALUE(VALUE(d), '/hint'), 1, 4000) like 'USE_HASH%'
    or  SUBSTR(EXTRACTVALUE(VALUE(d), '/hint'), 1, 4000) like 'PUSH_%'
    or  SUBSTR(EXTRACTVALUE(VALUE(d), '/hint'), 1, 4000) like 'INDEX%' )
/

with h1 as ( select count(*) cnt from plan_table where plan_id = 1 ),
     h2 as ( select count(*) cnt from plan_table where plan_id = 2 )
select  p.REMARKS
from plan_table p, h1, h2
where plan_id =
     (case when h1.cnt < h2.cnt  and h1.cnt < 7        then 1
           when h1.cnt > h2.cnt  and h2.cnt < 7        then 2
           when h1.cnt > 7       and h2.cnt > 7        then 0
      end)
/


PROMPT </DETAILS>

--20210514

PROMPT <DETAILS>
PROMPT <SUMMARY><BLUE>HISTOGRAM SUGGESTION FROM GV$SQL_PLAN_MONIOTR.</BLUE></SUMMARY>
PROMPT

select distinct cmd from (
 select --table_name, COLUMN_COMBINATION,
 case
  when instr(COLUMN_COMBINATION,',') = 0 then
  'execute fnd_stats_seed.load_histogram_cols(action=>''INSERT'',tabname=>'''||upper(table_name)||''',colname=>'''||COLUMN_COMBINATION||''');'
  else
  'execute fnd_stats_seed.load_histogram_cols(action=>''INSERT'',tabname=>'''||upper(table_name)||''',colname=>''('||COLUMN_COMBINATION||')'');'
  end as cmd
 from ( select TABLE_NAME, substr(SYS_CONNECT_BY_PATH(COLUMN_NAME, ','),2) COLUMN_COMBINATION
  from
  (
   select ic.table_name, ic.index_name , ic.column_name, count(*) OVER ( partition by ic.INDEX_NAME ) cnt, COLUMN_POSITION seq
   from
   ( select distinct PLAN_OBJECT_OWNER, PLAN_OBJECT_NAME
     from   gv$sql_plan_monitor
     where  sql_id = :L_SQL_ID
     and    PLAN_OBJECT_TYPE = 'INDEX'
     and    PLAN_OBJECT_OWNER like 'FUSION%'
     and (  PLAN_CARDINALITY * STARTS * 10 < OUTPUT_ROWS
        or  PLAN_CARDINALITY * STARTS / 10 > OUTPUT_ROWS )
   )  o,
     dba_ind_columns ic,
     dba_indexes i
   where ic.index_name = o.PLAN_OBJECT_NAME
   and   ic.INDEX_OWNER = o.PLAN_OBJECT_OWNER
   and   i.index_name = o.plan_object_name
   and   i.owner = o.plan_object_owner
   and   i.distinct_keys < 200
  )
  where seq=cnt
  start with seq=1 connect by prior seq+1=seq and prior INDEX_NAME = INDEX_NAME )
order by table_name,COLUMN_COMBINATION   )
/

PROMPT </DETAILS>

set head on

-- 20210302
-- SQL PLAN COMPARISON AND GENERATE HINT END

pro </pre><a name="PHV_ANALYSIS"></a><h2>PHV level Analysis</h2><pre>


VAR L_PRINT_OUTPUT_RATIO VARCHAR2(200);
VAR L_TABLE_NAME   VARCHAR2(100);
VAR L_TABLE_ROWS   NUMBER;
VAR L_1STO_ID      NUMBER;
VAR L_VALUE_RECOMMEND VARCHAR2(1000);

begin
  select count(*) into :SQL_FROM_SPM from gv$sql_plan_monitor where sql_id = :L_SQL_ID and rownum = 1;

  IF ( :SQL_FROM_SPM = 0 and :SQL_FROM_MEM = 0 ) THEN
      DBMS_OUTPUT.PUT_LINE('As the SQL_ID, '||:L_SQL_ID||' was not available from V$SQL_PLAN_MONITOR, SMA could not perform analysis. ');
      DBMS_OUTPUT.PUT_LINE('In order to get this information, execute the issue SQL in the flow and get the sma output again while the SQL is in memory.');
      null;
  END IF;
  IF ( :SQL_FROM_MEM = 0 and :SQL_FROM_MEM = 1 ) THEN
      DBMS_OUTPUT.PUT_LINE('.');
      DBMS_OUTPUT.PUT_LINE('<blue>Action Item : OPERATION TEAM</BLUE>');
      DBMS_OUTPUT.PUT_LINE('As the SQL_ID, '||:L_SQL_ID||' was not available from V$SQL_PLAN, SMA could not provide necessary information in Suggestion.');
      DBMS_OUTPUT.PUT_LINE('In order to get this information, execute the issue SQL and get SMA output again while the SQL is in memory.');
      null;
  END IF;
  IF ( :SQL_FROM_AWR = 1 ) THEN
    --  DBMS_OUTPUT.PUT_LINE('SQL HISTORY DATA IS AVAILABLE');
        null;
  END IF;


end;
/

-- if :SQL_FROM_MEM = 3 then there is no data in sql_plan_monitor.
-- if :SQL_FROM_MEM = 4 then there is    data in sql_plan_monitor.

DECLARE

function CHECK_TABLE_STATS(p_object_owner varchar2, p_object_name varchar2, p_object_type varchar2)
return varchar2 as  L_STALE_STATS varchar2(3);
begin
    L_STALE_STATS := 'NO';
    select TS.stale_stats INTO L_STALE_STATS
    from  dba_tab_statistics TS
    where p_object_name = TS.TABLE_name
    and   p_object_owner = TS.owner ;
    return L_STALE_STATS;
    EXCEPTION  WHEN OTHERS THEN return L_STALE_STATS;
end;

function CHECK_INDEX_STATS(p_object_owner varchar2, p_object_name varchar2, p_object_type varchar2)
return varchar2 as  L_STALE_STATS varchar2(3);
begin
    L_STALE_STATS := 'NO';
    select IDS.stale_stats INTO L_STALE_STATS
    from  dba_IND_statistics IDS
    where p_object_name = IDS.INDEX_name
    and   p_object_owner = IDS.owner;
    return L_STALE_STATS;
    EXCEPTION  WHEN OTHERS THEN return L_STALE_STATS;
end;

function CHECK_SQL_HASH_GTT (p_KEY varchar2, p_SQL_ID varchar2, p_PLAN_HASH_VALUE varchar2)
return NUMBER as  L_GTT NUMBER;
begin
     select count(1) into L_GTT
     from   gv$sql_plan_monitor spm
     where  spm.key = p_key
     and    spm.sql_id = p_sql_id
     and    spm.sql_plan_hash_value = p_plan_hash_value
     and    spm.plan_object_type in ('TABLE (TEMP)','PROCEDURE')
     and    rownum = 1 ;
     return L_GTT ;
     EXCEPTION  WHEN OTHERS THEN return L_GTT;
end;

BEGIN
  --DBMS_OUTPUT.PUT_LINE('SQL PLAN SECTION');
   IF ( :SQL_FROM_SPM = 1 ) THEN      -- v3
        :L_PRV_KEY := 0;
        :L_PRV_PHV := 0;
        :L_PRV_OID := 0;
        :L_PRV_ID  := 0;
        :L_PRV_NR  := 0;
        :L_PLAN_HASH_VALUE1 := 0;
        :L_PLAN_HASH_VALUE2 := 0;
        :L_PLAN_HASH_VALUE  := 0;
        :L_PX := 0;
-- 20201010 need to fix --
     FOR SM IN (
        SELECT qry.*, ROWNUM RN FROM (
        SELECT /*+ no_parallel opt_param('parallel_execution_enabled', 'false') */ *
        FROM
              (SELECT  KEY, INST_ID,SID,SESSION_SERIAL#,USERNAME, MODULE, ACTION,
               SQL_ID, sm1.SQL_PLAN_HASH_VALUE,
               BINDS_XML, OTHER_XML,
               round(elapsed_time/1000000,3) elaps_s, round(cpu_time/1000000,3) cpu_s,
               sign(cpu_time - elapsed_time *0.9) CPU_CHK,
               round(user_io_wait_time/1000000,3) iowait_s,
               round((cluster_wait_time+application_wait_time+plsql_exec_time+java_exec_time)/1000000,3) other_s,
               round((cluster_wait_time)/1000000,3) cluster_wait_time_s,
               round((application_wait_time)/1000000,3) application_wait_time_s,
               round((plsql_exec_time)/1000000,3) plsql_exec_time_s,
               round((java_exec_time)/1000000,3)  java_exec_time_s,
               physical_read_requests R_IOPS,
               physical_read_bytes,
               round(physical_read_bytes/1000000,3) R_MB,
               physical_write_bytes,
               round(physical_write_bytes/1000000,3) W_MB,
               PX_SERVERS_ALLOCATED PX
              ,status, error_number, error_facility, error_message, substr(error_message,1,20) serror
              ,SQL_EXEC_START MSQL_EXEC_START
              ,TO_CHAR(SQL_EXEC_START,'YYYY-MM-DD HH24:MI:SS')  START_TIME
              ,TO_CHAR(FIRST_REFRESH_TIME,'YYYY-MM-DD HH24:MI:SS') FIRST_REFRESH_TIME
              ,TO_CHAR(LAST_REFRESH_TIME,'YYYY-MM-DD HH24:MI:SS')  LAST_REFRESH_TIME
              ,SQL_EXEC_ID
              ,MKEY
              ,MPROCESS_NAME
              ,PROCESS_NAME
              ,SERVICE_NAME
/*v3*/        ,FORCE_MATCHING_SIGNATURE
/*sma19c 20200521 */
              ,REPORT_ID
              ,RM_CONSUMER_GROUP,ECID,IS_ADAPTIVE_PLAN,IS_FINAL_PLAN
              ,( select nvl(min(sq.child_number),0) child_number
               from gv$sql sq
               where sm.inst_id             = sq.inst_id(+)
               and   sm.sql_id              = sq.sql_id(+)
               and   sm.SQL_PLAN_HASH_VALUE = sq.plan_hash_value(+) )  child_number
              FROM   GV$SQL_MONITOR SM,
                     (SELECT SQL_PLAN_HASH_VALUE, SQL_EXEC_ID MSQL_EXEC_ID, SQL_ID MSQL_ID, SM1.KEY  MKEY, SM1.PROCESS_NAME MPROCESS_NAME,
                             SQL_EXEC_START MSQL_EXEC_START
                             --LAST_REFRESH_TIME MLAST_REFRESH_TIME
                      FROM   gv$sql_monitor SM1
                      WHERE SM1.SQL_ID  = :L_SQL_ID
                      AND   (sm1.SQL_PLAN_HASH_VALUE, SM1.SQL_EXEC_START
/*V3*/                       -- SM1.FIRST_REFRESH_TIME  --, sm1.SQL_EXEC_ID
                             ) IN (
                             select SQL_PLAN_HASH_VALUE, MAX_SQL_EXEC_START
                             --max_FIRST_REFRESH_TIME  --, max_SQL_EXEC_ID
                             from (
                             select m1.SQL_PLAN_HASH_VALUE, MAX(m1.SQL_EXEC_START) MAX_SQL_EXEC_START
                             --max(m1.FIRST_REFRESH_TIME) max_FIRST_REFRESH_TIME
                             --, max(m1.SQL_EXEC_ID) max_SQL_EXEC_ID
                             from   gv$sql_monitor m1
                             where  m1.sql_id = :L_SQL_ID
                             and    m1.ERROR_NUMBER IS NOT NULL
                             group by m1.SQL_PLAN_HASH_VALUE )
                              )
                      AND   SUBSTR(SM1.PROCESS_NAME,1,1) IN ( 'j','o','m','s')
                      AND   SM1.ERROR_NUMBER IS NOT NULL ) SM1
              WHERE   SM1.MSQL_EXEC_ID = SM.SQL_EXEC_ID(+)
              AND     SM1.MSQL_ID  = SM.SQL_ID(+)
              AND     SM1.MSQL_EXEC_START = SM.SQL_EXEC_START(+)
--              AND     SM1.MLAST_REFRESH_TIME = SM.MLAST_REFRESH_TIME(+)
              AND     SM1.SQL_PLAN_HASH_VALUE = SM.SQL_PLAN_HASH_VALUE(+)
              ORDER BY --SM.LAST_REFRESH_TIME DESC,
              SM.SQL_EXEC_START DESC, SM.SQL_EXEC_ID DESC, SM.PROCESS_NAME )
              WHERE ( ( ROWNUM < (SELECT VALUE FROM V$PARAMETER WHERE NAME = 'parallel_max_servers') and (PX > 1 or process_name like 'p0%' ) )
                   or ( ROWNUM <= 3 and (PX is null or process_name not like 'p0%' ) ) )
              UNION ALL
              SELECT /*+ no_parallel opt_param('parallel_execution_enabled', 'false') */ * FROM
              (SELECT  KEY, INST_ID,SID,SESSION_SERIAL#,USERNAME, MODULE, ACTION,
               SQL_ID, sm1.SQL_PLAN_HASH_VALUE,
               BINDS_XML, OTHER_XML,
               round(elapsed_time/1000000,3) elaps_s, round(cpu_time/1000000,3) cpu_s,
               sign(cpu_time - elapsed_time *0.9) CPU_CHK,
               round(user_io_wait_time/1000000,3) iowait_s,
               round((cluster_wait_time+application_wait_time+plsql_exec_time+java_exec_time)/1000000,3) other_s,
               round((cluster_wait_time)/1000000,3) cluster_wait_time_s,
               round((application_wait_time)/1000000,3) application_wait_time_s,
               round((plsql_exec_time)/1000000,3) plsql_exec_time_s,
               round((java_exec_time)/1000000,3)  java_exec_time_s,
               physical_read_requests R_IOPS,
               physical_read_bytes,
               round(physical_read_bytes/1000000,3) R_MB,
               physical_write_bytes,
               round(physical_write_bytes/1000000,3) W_MB,
               PX_SERVERS_ALLOCATED PX
              ,status, error_number, error_facility, error_message, substr(error_message,1,20) serror
              ,SQL_EXEC_START MSQL_EXEC_START
              ,TO_CHAR(SQL_EXEC_START,'YYYY-MM-DD HH24:MI:SS')  START_TIME
              ,TO_CHAR(FIRST_REFRESH_TIME,'YYYY-MM-DD HH24:MI:SS') FIRST_REFRESH_TIME
              ,TO_CHAR(LAST_REFRESH_TIME,'YYYY-MM-DD HH24:MI:SS')   LAST_REFRESH_TIME
              ,SQL_EXEC_ID
              ,MKEY
              ,MPROCESS_NAME
              ,PROCESS_NAME
              ,SERVICE_NAME
/*v3*/        ,FORCE_MATCHING_SIGNATURE
/*sma19c 20200521 */
              ,REPORT_ID
              ,RM_CONSUMER_GROUP,ECID,IS_ADAPTIVE_PLAN,IS_FINAL_PLAN
              ,( select nvl(min(sq.child_number),0) child_number
               from gv$sql sq
               where sm.inst_id             = sq.inst_id(+)
               and   sm.sql_id              = sq.sql_id(+)
               and   sm.SQL_PLAN_HASH_VALUE = sq.plan_hash_value(+) )  child_number
              FROM   GV$SQL_MONITOR SM,
                     (SELECT SQL_PLAN_HASH_VALUE, SQL_EXEC_ID MSQL_EXEC_ID, SQL_ID MSQL_ID, SM1.KEY  MKEY, SM1.PROCESS_NAME MPROCESS_NAME,
                             SQL_EXEC_START MSQL_EXEC_START
                             --LAST_REFRESH_TIME MLAST_REFRESH_TIME
                      FROM   gv$sql_monitor SM1
                      WHERE SM1.SQL_ID  = :L_SQL_ID
                      AND   (sm1.SQL_PLAN_HASH_VALUE, SM1.SQL_EXEC_START
                            --SM1.FIRST_REFRESH_TIME, sm1.SQL_EXEC_ID
                            ) IN (
                             select SQL_PLAN_HASH_VALUE, MAX_SQL_EXEC_START
                             -- max_FIRST_REFRESH_TIME, max_SQL_EXEC_ID
                             from (
                             select m1.SQL_PLAN_HASH_VALUE, MAX(m1.SQL_EXEC_START) MAX_SQL_EXEC_START
                             --max(m1.FIRST_REFRESH_TIME) max_FIRST_REFRESH_TIME
                             --, max(m1.SQL_EXEC_ID) max_SQL_EXEC_ID
                             from   gv$sql_monitor m1
                             where  m1.sql_id = :L_SQL_ID
                             and    m1.ERROR_NUMBER IS NULL
                             group by m1.SQL_PLAN_HASH_VALUE )
                              )
                      AND   SUBSTR(SM1.PROCESS_NAME,1,1) IN ( 'j','o','m','s')
                      AND   SM1.ERROR_NUMBER IS NULL ) SM1
              WHERE   SM1.MSQL_EXEC_ID = SM.SQL_EXEC_ID(+)
              AND     SM1.MSQL_ID  = SM.SQL_ID(+)
              AND     SM1.MSQL_EXEC_START = SM.SQL_EXEC_START(+)
              AND   :L_SQLHC_MIN_FLAG < 15  /* limits */
--              AND     SM1.MLAST_REFRESH_TIME = SM.MLAST_REFRESH_TIME(+)
              AND     SM1.SQL_PLAN_HASH_VALUE = SM.SQL_PLAN_HASH_VALUE(+)
              ORDER BY --SM.LAST_REFRESH_TIME DESC,
              SM.SQL_EXEC_START DESC, SM.SQL_EXEC_ID DESC, SM.PROCESS_NAME )
              WHERE ( ( ROWNUM <= (SELECT VALUE FROM V$PARAMETER WHERE NAME = 'parallel_max_servers') and (PX > 1 or process_name like 'p0%' ) )
                   or ( ROWNUM <= 3 and (PX is null or process_name not like 'p0%' ) ) )
            )  qry
-- sma19c
            order by qry.PROCESS_NAME
            )
     LOOP
           :L_PLAN_HASH_VALUE  := SM.SQL_PLAN_HASH_VALUE;
/*v3*/     IF ( :SQL_FROM_MEM = 0 AND SM.RN <= 2 ) THEN
              :L_PLAN_HASH_VALUE2 := :L_PLAN_HASH_VALUE1;
              :L_PLAN_HASH_VALUE1  := SM.SQL_PLAN_HASH_VALUE;
           END IF;
           IF ( SM.PX > 1 or SM.process_name like 'p0%' ) THEN :L_PX := 1; END IF;
           :L_FORCE_MATCHING_SIGNATURE := SM.FORCE_MATCHING_SIGNATURE;

/* LAST_LOAD_TIME */
                  SELECT nvl( (SELECT TO_DATE(LAST_LOAD_TIME,'YYYY-MM-DD HH24:MI:SS') LAST_LOAD_TIME
                               FROM ( SELECT LAST_LOAD_TIME  LAST_LOAD_TIME
                               --FROM ( SELECT TO_char(LAST_LOAD_TIME,'YYYY-MM-DD HH24:MI:SS')  LAST_LOAD_TIME
                                      FROM GV$SQL
                                      WHERE SQL_ID = :L_SQL_ID
                                      AND PLAN_HASH_VALUE = :L_PLAN_HASH_VALUE
                                      AND INST_ID = SM.INST_ID
                                    --AND TO_CHAR(LAST_LOAD_TIME,'YYYY-MM-DD HH24:MI:SS') <= SM.START_TIME ),
                                      AND TO_DATE(LAST_LOAD_TIME,'YYYY-MM-DD HH24:MI:SS') <= TO_DATE(SM.START_TIME,'YYYY-MM-DD HH24:MI:SS')
                                      ORDER BY 1 DESC
                                    )
                               WHERE ROWNUM = 1 ) ,
                               nvl( (SELECT MAX(sample_time) LAST_LOAD_TIME
                                     FROM GV$ACTIVE_SESSION_HISTORY
                                     WHERE SQL_ID = :L_SQL_ID
                                     AND SQL_PLAN_HASH_VALUE = :L_PLAN_HASH_VALUE
                                     AND INST_ID = SM.INST_ID
                                     AND IN_HARD_PARSE = 'Y'
                                     AND TO_CHAR(SAMPLE_TIME,'YYYY-MM-DD HH24:MI:SS') <= SM.START_TIME ),
                                     nvl( (SELECT MAX(sample_time) LAST_LOAD_TIME
                                           FROM DBA_HIST_ACTIVE_SESS_HISTORY
                                           WHERE SQL_ID = :L_SQL_ID
                                           AND SQL_PLAN_HASH_VALUE = :L_PLAN_HASH_VALUE
                                           AND DBID = :L_DBID
                                           --2020922
                                           AND SNAP_ID BETWEEN :L_SNAP_ID - 720 AND :L_SNAP_ID
                                           AND INSTANCE_NUMBER = SM.INST_ID
                                           AND IN_HARD_PARSE = 'Y'
                                           AND TO_CHAR(SAMPLE_TIME,'YYYY-MM-DD HH24:MI:SS') <= SM.START_TIME )
                                          , to_date('1000-01-01 00:00:01','YYYY-MM-DD HH24:MI:SS')
                                        )
                                  )
                              )
                  INTO :L_last_load_time
                  FROM DUAL;
                  :L_WHERE_LOG := 'TEST ESTIMATION'||:L_last_load_time;

                  IF ( to_date(:L_last_load_time,'YYYY-MM-DD HH24:MI:SS') = to_date('1000-01-01 00:00:01','YYYY-MM-DD HH24:MI:SS') ) THEN
                       :L_last_load_time := SM.START_TIME;
                       :L_last_load_time_CORRECT := 'NO';
                  ELSE
                       :L_last_load_time_CORRECT := 'YES';
                  END IF;

       DBMS_OUTPUT.PUT_LINE('ADJ_last_load_time: '||:L_last_load_time||' correct:'||:L_last_load_time_correct);

/* LAST_LOAD_TIME */

      DBMS_OUTPUT.PUT_LINE('+');
      --DBMS_OUTPUT.PUT_LINE('+'||sm.key);

      :L_WHERE_LOG := 'before ADJ_PROCESSED_ROWS';
      with drv as (
        select /*+ no_parallel opt_param('parallel_execution_enabled', 'false') */ GSPM.key,
        case
        when GSPM.plan_operation = 'SELECT STATEMENT' then
       (select  decode(S1.plan_operation||'-'||S1.plan_options,
               'FILTER-'  ,S1.plan_line_id+1,
               'SORT-GROUP BY',S1.plan_line_id+1,
               'SORT-GROUP BY STOPKEY',S1.plan_line_id+1,
               'SORT-ORDER BY',S1.plan_line_id+1,
               'SORT-ORDER BY STOPKEY',S1.plan_line_id+1,
               'SORT-AGGREGATE',S1.plan_line_id+1,
               'HASH-UNIQUE',S1.plan_line_id+1,
               'VIEW-',S1.plan_line_id+1,
               S1.plan_line_id)  plan_line_id
        from GV$SQL_plan_monitor S1 WHERE S1.key = GSPM.KEY
        and S1.plan_line_id =
           (select max(S.plan_line_id) plan_line_id
            FROM GV$SQL_plan_monitor S WHERE  S.key = GSPM.KEY
            and ( (S.plan_parent_id = 0)
               or (S.plan_parent_id is null and Plan_line_id = 0)))   -- parallel query has null on plan_parent_id
        )
        when GSPM.plan_operation = 'INSERT STATEMENT' then
       (select max(I.plan_line_id) plan_line_id
        FROM GV$SQL_plan_monitor I WHERE  I.key = GSPM.KEY and I.plan_parent_id = 1)
        when GSPM.plan_operation = 'UPDATE STATEMENT' then
       (select min(U.plan_line_id) plan_line_id
        FROM GV$SQL_plan_monitor U WHERE  U.key = GSPM.KEY and U.plan_parent_id = 1)
        when GSPM.plan_operation = 'DELETE STATEMENT' then
       (select min(D.plan_line_id) plan_line_id
        FROM GV$SQL_plan_monitor D WHERE  D.key = GSPM.KEY and D.plan_parent_id = 1)
        when GSPM.plan_operation = 'MERGE STATEMENT' then
       (select min(M.plan_line_id) plan_line_id
        FROM GV$SQL_plan_monitor M WHERE  M.key = GSPM.KEY and M.plan_parent_id = 1)
        end plan_line_id
        from  GV$SQL_plan_monitor GSPM
        WHERE  GSPM.key = SM.KEY and GSPM.plan_line_id = 0
      )
      select max(output_rows) INTO :L_ADJ_PROCESSED_ROW
      from GV$SQL_plan_monitor spm,  drv
      where spm.key = drv.key
      and   spm.plan_line_id between drv.plan_line_id and drv.plan_line_id + 4;
      :L_WHERE_LOG := 'after ADJ_PROCESSED_ROWS';

--      DBMS_OUTPUT.PUT_LINE('ADJ_PROCESSED_ROWS: '||:L_ADJ_PROCESSED_ROW);

      IF (SM.ERROR_NUMBER IS NOT NULL) THEN
         DBMS_OUTPUT.PUT_LINE('***************************************************************************************');
         DBMS_OUTPUT.PUT_LINE('<a name="PHV'||SM.SQL_PLAN_HASH_VALUE||'"></a>'||'PHV: '||SM.SQL_PLAN_HASH_VALUE||', ADAP_PLAN:'||sm.IS_ADAPTIVE_PLAN||', FANAL_PLAN:'||sm.IS_FINAL_PLAN||', REPORT_ID:'||sm.REPORT_ID);
         DBMS_OUTPUT.PUT_LINE('KEY:'||SM.KEY||', SQL_EXEC_ID:'||SM.SQL_EXEC_ID||', SID:'||SM.SID||', INST_ID:'||SM.INST_ID||' PX_SERVERS_ALLOCATED:'||SM.PX);
         DBMS_OUTPUT.PUT_LINE('MODULE: '||SM.MODULE||', ACTION:'||SM.ACTION||', PROCESS:'||SM.process_name||', SERVICE:'||SM.SERVICE_NAME);
         DBMS_OUTPUT.PUT_LINE('ELAPS(SEC):'||SM.ELAPS_S||', CPU(SEC):'||SM.CPU_S||', PL/SQL(SEC):'||SM.PLSQL_EXEC_TIME_S||', ERROR:<RED>'||SM.ERROR_NUMBER||'</RED>, WHEN: '||SM.START_TIME);
         DBMS_OUTPUT.PUT_LINE('CONSUMER_GROUP:'||SM.RM_CONSUMER_GROUP||', ECID:'||SM.ECID);
         DBMS_OUTPUT.PUT_LINE('ADJ_PROCESSED_ROWS:'||:L_ADJ_PROCESSED_ROW||' READ(M):'||SM.R_MB||' WRITE(M):'||SM.W_MB||' STATUS:'||SM.STATUS);
         DBMS_OUTPUT.PUT_LINE('***************************************************************************************');
         :issue_error := 1;  /* error */
       --  IF(SM.PX > 1 or SM.process_name like 'p0%' )  THEN :SQL_FROM_SPM := 0; END IF;
      ELSE
         DBMS_OUTPUT.PUT_LINE('***************************************************************************************');
         DBMS_OUTPUT.PUT_LINE('<a name="PHV'||SM.SQL_PLAN_HASH_VALUE||'"></a>'||'PHV: '||SM.SQL_PLAN_HASH_VALUE||', ADAP_PLAN:'||sm.IS_ADAPTIVE_PLAN||', FANAL_PLAN:'||sm.IS_FINAL_PLAN||', REPORT_ID:'||sm.REPORT_ID);
         DBMS_OUTPUT.PUT_LINE('KEY:'||SM.KEY||', SQL_EXEC_ID:'||SM.SQL_EXEC_ID||', SID:'||SM.SID||', INST_ID:'||SM.INST_ID||' PX_SERVERS_ALLOCATED:'||SM.PX);
         DBMS_OUTPUT.PUT_LINE('MODULE: '||SM.MODULE||', ACTION:'||SM.ACTION||', PROCESS:'||SM.process_name||', SERVICE:'||SM.SERVICE_NAME);
         DBMS_OUTPUT.PUT_LINE('ELAPS(SEC):'||SM.ELAPS_S||', CPU(SEC):'||SM.CPU_S||', PL/SQL(SEC):'||SM.PLSQL_EXEC_TIME_S||', WHEN: '||SM.START_TIME);
         DBMS_OUTPUT.PUT_LINE('CONSUMER_GROUP:'||SM.RM_CONSUMER_GROUP||', ECID:'||SM.ECID);
         DBMS_OUTPUT.PUT_LINE('ADJ_PROCESSED_ROWS:'||:L_ADJ_PROCESSED_ROW||' READ(M):'||SM.R_MB||' WRITE(M):'||SM.W_MB||' STATUS:'||SM.STATUS);
         DBMS_OUTPUT.PUT_LINE('***************************************************************************************');
       --  IF(SM.PX > 1 or SM.process_name like 'p0%' )  THEN :SQL_FROM_SPM := 0; END IF;
      END IF;
      IF ( SM.CPU_CHK = 1 and sm.plsql_exec_time_s*2 > sm.cpu_s ) THEN
          DBMS_OUTPUT.PUT_LINE('<blue>Action Item : DEVELOPMENT TEAM</BLUE>');
          DBMS_OUTPUT.PUT_LINE('=>Suggestion: Check the sql is using too excessive PL/SQL call');
      END IF;
      IF ( SM.CPU_CHK = 1 and sm.java_exec_time_s*2 > sm.cpu_s ) THEN
          DBMS_OUTPUT.PUT_LINE('<blue>Action Item : DEVELOPMENT TEAM</BLUE>');
          DBMS_OUTPUT.PUT_LINE('=>Suggestion: Check the sql is using too excessive Java call');
      END IF;
--20180130
      IF ( SM.ERROR_NUMBER IS NOT NULL ) THEN
          DBMS_OUTPUT.PUT_LINE('* Analysis');
          DBMS_OUTPUT.PUT_LINE('=>Issue Category: <RED>ERROR</RED> (ORA-'||SM.ERROR_NUMBER||')');
          DBMS_OUTPUT.PUT_LINE('+ Facility: '||SM.error_facility);
          DBMS_OUTPUT.PUT_LINE('+ Message: '||SM.error_message);
      END IF;
/* 20200529 */
      IF ( SM.ERROR_NUMBER = 40 ) THEN   -- 40 :  Reduce the complexity of the update or query,
          DBMS_OUTPUT.PUT_LINE('<blue>Action Item : DEVELOPMENT TEAM</BLUE>');
          DBMS_OUTPUT.PUT_LINE('=>Suggestion: The Resource Manager SWITCH_TIME limit was exceeded.');
          DBMS_OUTPUT.PUT_LINE('=>Suggestion: Reduce the complexity of the update or query');
          :error_from_sm := 1;
      END IF;
      IF ( SM.ERROR_NUMBER = 1013 ) THEN
          DBMS_OUTPUT.PUT_LINE('<blue>Action Item : DEVELOPMENT TEAM</BLUE>');
          DBMS_OUTPUT.PUT_LINE('=>Suggestion: If user killed the sql due to long running of '||sm.elaps_s||' seconds, Need to tune the sql.');
          :error_from_sm := 1;
      END IF;
      IF ( SM.ERROR_NUMBER = 1403 ) THEN
          DBMS_OUTPUT.PUT_LINE('<blue>Action Item : DEVELOPMENT TEAM</BLUE>');
          DBMS_OUTPUT.PUT_LINE('=>Suggestion: There was no data from the objects which may be due to end of fetch. Change the code.');
      END IF;
      IF ( SM.ERROR_NUMBER = 1427 ) THEN
          DBMS_OUTPUT.PUT_LINE('<blue>Action Item : DEVELOPMENT TEAM</BLUE>');
          DBMS_OUTPUT.PUT_LINE('=>Suggestion: Single-row subquery returns more than one row. Change the code');
      END IF;
      IF ( SM.ERROR_NUMBER = 1555 ) THEN   -- snapshot
          DBMS_OUTPUT.PUT_LINE('<blue>Action Item : DEVELOPMENT TEAM/OPERATION TEAM</BLUE>');
          DBMS_OUTPUT.PUT_LINE('=>Suggestion1: Check the plan is optimized and then check Undo_Retention time is correctly set to POD size');
          DBMS_OUTPUT.PUT_LINE('=>Suggestion2: Find snapshot old object and find any program calling DML at the same time');
          DBMS_OUTPUT.PUT_LINE('=>Suggestion3: Check undo tablespace size and its file size with PSR DB');
          :error_from_sm := 1;
      END IF;
      IF ( SM.ERROR_NUMBER = 1652 ) THEN   -- unable to extend temp segment
          DBMS_OUTPUT.PUT_LINE('<blue>Action Item : DEVELOPMENT TEAM/OPERATION TEAM</BLUE>');
          DBMS_OUTPUT.PUT_LINE('=>Suggestion1: Check the plan is optimized and then have the sql treat reasonable volume of data.');
          DBMS_OUTPUT.PUT_LINE('=>Suggestion2: Check temp tablespace size and its file size with PSR DB');
          :error_from_sm := 1;
      END IF;
      IF ( SM.ERROR_NUMBER = 1722 ) THEN
          DBMS_OUTPUT.PUT_LINE('<blue>Action Item : DEVELOPMENT TEAM/PSR</BLUE>');
          DBMS_OUTPUT.PUT_LINE('=>Suggestion: The sql can meet invalid number error due to join order. Get the outline hint and apply it to the sql.');
          DBMS_OUTPUT.PUT_LINE('=>Suggestion: And test it in the local environment if the issue can be reproduced');
      END IF;
      IF ( SM.ERROR_NUMBER = 6531 ) THEN
          DBMS_OUTPUT.PUT_LINE('<blue>Action Item : DEVELOPMENT TEAM</BLUE>');
          DBMS_OUTPUT.PUT_LINE('=>Suggestion: An element or member function of a nested table or varray was referenced (where an initialized collection is needed)');
          DBMS_OUTPUT.PUT_LINE('=>Suggestion: without the collection having been initialized. Initialize the collection');
      END IF;
      IF ( SM.ERROR_NUMBER = 10260 ) THEN   -- 56720: I/O data limit exceeded - call aborted
          DBMS_OUTPUT.PUT_LINE('<blue>Action Item : DEVELOPMENT TEAM</BLUE>');
          DBMS_OUTPUT.PUT_LINE('=>Suggestion: Check the plan is optimized and then Check pga_aggregate_limit or limit size (%s) of the PGA heap set by event 10261');
          :error_from_sm := 1;
      END IF;
      IF ( SM.ERROR_NUMBER = 12048 ) THEN
          DBMS_OUTPUT.PUT_LINE('<blue>Action Item : DEVELOPMENT TEAM/OPERATION TEAM</BLUE>');
          DBMS_OUTPUT.PUT_LINE('=>Suggestion: Error encountered while refreshing materialized view. Get the trace.');
          DBMS_OUTPUT.PUT_LINE('=>Suggestion: Examine the other messages on the stack to find the refresh problem');
      END IF;
      IF ( SM.ERROR_NUMBER = 56720 ) THEN   -- 56720: I/O data limit exceeded - call aborted
          DBMS_OUTPUT.PUT_LINE('<blue>Action Item : DEVELOPMENT TEAM/OPERATION TEAM</BLUE>');
          DBMS_OUTPUT.PUT_LINE('=>Suggestion: The Resource Manager SWITCH_IO_MEGABYTES limit was exceeded.');
          DBMS_OUTPUT.PUT_LINE('=>Suggestion: Check the plan is optimized and use selective bind input if needed');
          :error_from_sm := 1;
      END IF;

--      DBMS_OUTPUT.PUT_LINE('++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++');
--      DBMS_OUTPUT.PUT_LINE('+++++++The treatment will be added according to the error+++++++');
--      DBMS_OUTPUT.PUT_LINE('++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++');

----------------------
      :L_BIND_LOG := 'ON';
      :L_NOTE_LOG := 'ON';
      IF(SM.BINDS_XML IS NOT NULL) THEN
        :L_WHERE_LOG := 'BIND SECTION';
        FOR I IN (
                 SELECT ROWNUM ROW_NUM, NAME, POS, DTYD, DTYSTR, VALUE
                 FROM (
                  SELECT --+ opt_param('parallel_execution_enabled', 'false')
                       EXTRACTVALUE(VALUE(OXML), '/bind/@name') name,
                       EXTRACTVALUE(VALUE(OXML), '/bind/@pos') pos,
                       EXTRACTVALUE(VALUE(OXML), '/bind/@dty') dtyD,
                       EXTRACTVALUE(VALUE(OXML), '/bind/@dtystr') dtystr,
                       EXTRACTVALUE(VALUE(OXML), '/bind') value
                  FROM TABLE(XMLSEQUENCE(EXTRACT(XMLTYPE(SM.BINDS_XML), '/binds/bind'))) OXML
                  ORDER BY TO_NUMBER(EXTRACTVALUE(VALUE(OXML), '/bind/@pos'))
                  )
                 )
        LOOP
          :L_VALUE_RECOMMEND := null;
          :L_WHERE_LOG := 'BIND SECTION WITHIN LOOP'||I.VALUE;
     --     IF (I.NAME IS NOT NULL) THEN
     --       IF (I.ROW_NUM = 1) THEN
     --           DBMS_OUTPUT.PUT_LINE('<details>');
     --           DBMS_OUTPUT.PUT_LINE('<summary><blue>Bind Information</blue></summary>');
     --       END IF;
     --       DBMS_OUTPUT.PUT_LINE(' POSITION=>'||I.POS||' ,NAME=>'||I.NAME||' ,DATA_TYPE('||I.DTYD||')=>'||I.DTYSTR||' ,VALUE=>'||I.VALUE);
     --     END IF;
          IF( INSTR(I.VALUE,'%') <= 5 and INSTR(I.VALUE,'%') >= 1) THEN :L_VALUE_RECOMMEND := ' => Please use selective bind input'; END IF;
          IF ( :L_VALUE_RECOMMEND IS NOT NULL ) THEN
            DBMS_OUTPUT.PUT_LINE('* Analysis');
            DBMS_OUTPUT.PUT_LINE('* The bind variable, '||I.NAME||' was used with "<RED>'||I.VALUE||'</RED>".');
            DBMS_OUTPUT.PUT_LINE('=>Issue Category: <RED>Blind input or unselective input</RED>');  :issue_blind_input := 1;
            DBMS_OUTPUT.PUT_LINE('<blue>Action Item : OPERATION TEAM</BLUE>');
            DBMS_OUTPUT.PUT_LINE('=>Suggestion: Use more selective bind input');
          --  DBMS_OUTPUT.PUT_LINE('.');
            :L_VALUE_RECOMMEND := null;
          END IF;
        END LOOP;
     --   DBMS_OUTPUT.PUT_LINE('</details>');
      END IF;
----------------------
      :L_WHERE_LOG := 'SPM CURSOR START';
      :L_PPV_MESSAGE := 0;
      :L_MJ_STALE_OBJ_STATUS := 0;
      :L_1ST_OPR_STATUS := 0;
      :L_NEXT_MO := 0;

      :l_as5 := 0;
      :l_as4 := 0;
      :l_as3 := 0;
      :l_as2 := 0;
      :l_as1 := 0;

      :l_wc5 := 0;
      :l_wc4 := 0;
      :l_wc3 := 0;
      :l_wc2 := 0;
      :l_wc1 := 0;
      :l_wc  := 0;

      :l_occ5 := 0;
      :l_occ4 := 0;
      :l_occ3 := 0;
      :l_occ2 := 0;
      :l_occ1 := 0;
      :l_occ  := 0;
      :l_co5 := 0;
      :l_co4 := 0;
      :l_co3 := 0;
      :l_co2 := 0;
      :l_co1 := 0;
      :l_mo5 := 0;
      :l_mo4 := 0;
      :l_mo3 := 0;
      :l_mo2 := 0;
      :l_mo1 := 0;

      :L_PRV_ALIAS := null ;
      :L_PRV_OBJECT_TYPE := null ;
      :L_PRV_OBJECT_OWNER := null ;
      :L_PRV_NR := 0; -- jseo

 :L_CUR_NR  := 0 ;
 :L_CUR_KEY := 0 ;
 :L_CUR_PHV := 0 ;
 :L_CUR_OID := 0 ;

 :L_PRV_KEY  := 0 ;
 :L_PRV_PHV  := 0 ;
 :L_PRV_ID   := 0 ;
 :L_PRV_OID  := 0 ;
 :L_PRV_PID  := 0 ;
 :L_PRV_NR   := 0 ;
 :L_PRV_OBJECT       := null ;
 :L_PRV_OBJECT_OWNER := null ;
 :L_PRV_OPERATION    := null ;
 :L_PRV_QBLOCK       := null ;
 :L_PRV_ALIAS        := null ;
 :L_PRV_OBJECT_TYPE  := null ;

 :L_PPRV_KEY        := 0 ;
 :L_PPRV_PHV        := 0 ;
 :L_PPRV_ID         := 0 ;
 :L_PPRV_OID        := 0 ;
 :L_PPRV_PID        := 0 ;
 :L_PPRV_NR         := 0 ;
 :L_PPRV_OBJECT      := null ;
 :L_PPRV_OBJECT_OWNER := null ;
 :L_PPRV_OPERATION   := null ;
 :L_PPRV_QBLOCK      := null ;
 :L_PPRV_ALIAS       := null ;
 :L_PPRV_OBJECT_TYPE := null ;

 :L_PRV_CARDINALITY  := 0 ;
 :L_NEXT_MO          := 0 ;
 :L_PR               := null ;
 :L_PW               := null ;
 :L_PGA              := null ;
 :L_TEMP             := null ;
 :L_TABLE_NAME       := null ;

 :L_TITLE :=0;
 
/* 20200804 FP COL STATS BEGIN */
 :L_CUR_OBJECT_OWNER  := NULL;
 :L_CUR_OBJECT_NAME   := NULL;
 :L_CUR_OBJECT_ALIAS  := NULL;
 :L_FILTER_PREDICATES := NULL;
/* 20200804 FP COL STATS BEGIN */

 /*
 :issue_blind_input := 0;
 :issue_blind_query := 0;
 :issue_inac_card_estim := 0;
 :issue_cbo := 0;
 :issue_error := 0;
 :issue_improper_index := 0;
 :issue_MJ_CP := 0;
 :issue_blind_condition := 0;
 :issue_stats := 0;
 :issue_throw_away := 0;
*/
-- 2018/06/26
      :L_ROWCNT := -1;
-- 20201010 need to fix
    IF (  (:SQL_FROM_SPM = 1  or SM.PX > 1 or SM.process_name like 'p0%') AND :L_SQLHC_MIN_FLAG < 15  /* limits */ ) THEN
      FOR SPM IN (
        with
        sql_plan as (
        select INST_ID,
        CON_ID, --11i
        KEY,STATUS,FIRST_REFRESH_TIME,LAST_REFRESH_TIME,FIRST_CHANGE_TIME,LAST_CHANGE_TIME,REFRESH_COUNT,SID,PROCESS_NAME,
        SQL_ID,SQL_EXEC_START,SQL_EXEC_ID,SQL_PLAN_HASH_VALUE,SQL_CHILD_ADDRESS,
        -- to support parallel child plan
        NVL(PLAN_PARENT_ID,M1.MPLAN_PARENT_ID) PLAN_PARENT_ID,
        PLAN_LINE_ID,PLAN_OPERATION,PLAN_OPTIONS,PLAN_OBJECT_OWNER,PLAN_OBJECT_NAME,PLAN_OBJECT_TYPE,
        -- to support parallel child plan
        decode(PLAN_PARENT_ID,null,MPLAN_DEPTH,PLAN_DEPTH) PLAN_DEPTH,
        decode(PLAN_PARENT_ID,null,MPLAN_POSITION,PLAN_POSITION) PLAN_POSITION,
        PLAN_COST,PLAN_CARDINALITY,PLAN_BYTES,PLAN_TIME,PLAN_PARTITION_START,PLAN_PARTITION_STOP,PLAN_CPU_COST,PLAN_IO_COST,PLAN_TEMP_SPACE,
        STARTS,OUTPUT_ROWS,
        IO_INTERCONNECT_BYTES,PHYSICAL_READ_REQUESTS,PHYSICAL_READ_BYTES,PHYSICAL_WRITE_REQUESTS,PHYSICAL_WRITE_BYTES,
        WORKAREA_MEM,WORKAREA_MAX_MEM,WORKAREA_TEMPSEG,WORKAREA_MAX_TEMPSEG,
--        OTHERSTAT_GROUP_ID,
--        OTHERSTAT_1_ID,OTHERSTAT_1_TYPE,OTHERSTAT_1_VALUE,OTHERSTAT_2_ID,OTHERSTAT_2_TYPE,OTHERSTAT_2_VALUE,OTHERSTAT_3_ID,OTHERSTAT_3_TYPE,OTHERSTAT_3_VALUE,
--        OTHERSTAT_4_ID,OTHERSTAT_4_TYPE,OTHERSTAT_4_VALUE,OTHERSTAT_5_ID,OTHERSTAT_5_TYPE,OTHERSTAT_5_VALUE,OTHERSTAT_6_ID,OTHERSTAT_6_TYPE,OTHERSTAT_6_VALUE,
--        OTHERSTAT_7_ID,OTHERSTAT_7_TYPE,OTHERSTAT_7_VALUE,OTHERSTAT_8_ID,OTHERSTAT_8_TYPE,OTHERSTAT_8_VALUE,OTHERSTAT_9_ID,OTHERSTAT_9_TYPE,OTHERSTAT_9_VALUE,
--        OTHERSTAT_10_ID,OTHERSTAT_10_TYPE,OTHERSTAT_10_VALUE,OTHER_XML,
        PLAN_OPERATION_INACTIVE, --11i
        plan_operation||' '||plan_options||' - '||plan_object_owner||'.'||plan_object_name  operation,
     --   lpad(' ',plan_depth)||plan_operation||' '||plan_options||' - '||plan_object_owner||'.'||plan_object_name  operation,
        round(physical_read_bytes/1000000,5)  R_MB,       -- I/O ERROR and Snapshot ERROR
        round(physical_write_bytes/1000000,5) W_MB,       -- I/O ERROR and Snapshot ERROR
        round(workarea_MAX_mem/1000000,5)     PGA_MB,     -- PGA HEAP SIZE
        round(workarea_MAX_tempseg/1000000,5) TEMP_MB,    -- UNAV EXTEND TEMP SPACE
        --physical_read_bytes  R_MB,       -- I/O ERROR and Snapshot ERROR
        --physical_write_bytes W_MB,       -- I/O ERROR and Snapshot ERROR
        --workarea_mem         PGA_MB,     -- PGA HEAP SIZE
        --workarea_tempseg     TEMP_MB,    -- UNAV EXTEND TEMP SPACE
        round(((last_change_time-first_change_time)*60*60*24)+1)  opr_time  -- operation time
        FROM   GV$SQL_PLAN_MONITOR  m ,
        -- to support parallel child plan
               (SELECT PLAN_PARENT_ID MPLAN_PARENT_ID,PLAN_DEPTH MPLAN_DEPTH, PLAN_POSITION MPLAN_POSITION,
                       KEY MKEY, SQL_ID MSQL_ID, SQL_PLAN_HASH_VALUE MSQL_PLAN_HASH_VALUE,
                       SQL_EXEC_ID MSQL_EXEC_ID, PLAN_LINE_ID MPLAN_LINE_ID
                FROM   GV$SQL_PLAN_MONITOR ) m1
        WHERE  M.SQL_ID = SM.SQL_ID AND M.KEY = SM.KEY and m.SQL_PLAN_HASH_VALUE = sm.SQL_PLAN_HASH_VALUE
        AND    M1.MKEY = SM.MKEY
        AND    m.SQL_ID = M1.MSQL_ID AND m.SQL_PLAN_HASH_VALUE = M1.MSQL_PLAN_HASH_VALUE
        AND    m.SQL_EXEC_ID = M1.MSQL_EXEC_ID  AND M.PLAN_LINE_ID = M1.MPLAN_LINE_ID
        )
       ,parent_child as (
        select
        INST_ID,
        CON_ID,--11i
        KEY,STATUS,FIRST_REFRESH_TIME,LAST_REFRESH_TIME,FIRST_CHANGE_TIME,LAST_CHANGE_TIME,REFRESH_COUNT,SID,PROCESS_NAME,
        SQL_ID,SQL_EXEC_START,SQL_EXEC_ID,SQL_PLAN_HASH_VALUE,SQL_CHILD_ADDRESS,
        PLAN_PARENT_ID,PLAN_LINE_ID,PLAN_OPERATION,PLAN_OPTIONS,PLAN_OBJECT_OWNER,PLAN_OBJECT_NAME,PLAN_OBJECT_TYPE,PLAN_DEPTH,PLAN_POSITION,
        PLAN_COST,PLAN_CARDINALITY,PLAN_BYTES,PLAN_TIME,PLAN_PARTITION_START,PLAN_PARTITION_STOP,PLAN_CPU_COST,PLAN_IO_COST,PLAN_TEMP_SPACE,
        STARTS,OUTPUT_ROWS,
        IO_INTERCONNECT_BYTES,PHYSICAL_READ_REQUESTS,PHYSICAL_READ_BYTES,PHYSICAL_WRITE_REQUESTS,PHYSICAL_WRITE_BYTES,
        WORKAREA_MEM,WORKAREA_MAX_MEM,WORKAREA_TEMPSEG,WORKAREA_MAX_TEMPSEG,
        --OTHERSTAT_GROUP_ID,OTHER_XML,
        PLAN_OPERATION_INACTIVE,--11i
        operation, R_MB, W_MB, PGA_MB, TEMP_MB, OPR_TIME
        from  sql_plan
        start with plan_line_id = 0  and sql_plan_hash_value = sm.sql_plan_hash_value and key = sm.key
        connect by prior plan_line_id = plan_parent_id
               and prior sql_plan_hash_value = sm.sql_plan_hash_value
               and prior key = sm.key
        order  siblings by plan_line_id desc
        )
        , execution_order as (
        select
        INST_ID,
        CON_ID,--11i
        KEY,STATUS,FIRST_REFRESH_TIME,LAST_REFRESH_TIME,FIRST_CHANGE_TIME,LAST_CHANGE_TIME,REFRESH_COUNT,SID,PROCESS_NAME,
        SQL_ID,SQL_EXEC_START,SQL_EXEC_ID,SQL_PLAN_HASH_VALUE,SQL_CHILD_ADDRESS,
        PLAN_PARENT_ID,PLAN_LINE_ID,PLAN_OPERATION,PLAN_OPTIONS,PLAN_OBJECT_OWNER,PLAN_OBJECT_NAME,PLAN_OBJECT_TYPE,PLAN_DEPTH,PLAN_POSITION,
        PLAN_COST,PLAN_CARDINALITY,PLAN_BYTES,PLAN_TIME,PLAN_PARTITION_START,PLAN_PARTITION_STOP,PLAN_CPU_COST,PLAN_IO_COST,PLAN_TEMP_SPACE,
        STARTS,OUTPUT_ROWS,
        IO_INTERCONNECT_BYTES,PHYSICAL_READ_REQUESTS,PHYSICAL_READ_BYTES,PHYSICAL_WRITE_REQUESTS,PHYSICAL_WRITE_BYTES,
        WORKAREA_MEM,WORKAREA_MAX_MEM,WORKAREA_TEMPSEG,WORKAREA_MAX_TEMPSEG,
        --OTHERSTAT_GROUP_ID,OTHER_XML,PLAN_OPERATION_INACTIVE,
        operation, R_MB, W_MB, PGA_MB, TEMP_MB, OPR_TIME,
        row_number() over (partition by sql_plan_hash_value order by rownum desc) as oid
        , max(plan_line_id) over (partition by sql_plan_hash_value) as maxid
--        , ( select nvl(min(sq.child_number),0) child_number
--               from gv$sql sq
--               where pc.inst_id             = sq.inst_id(+)
--               and   pc.sql_id              = sq.sql_id(+)
--               and   pc.SQL_PLAN_HASH_VALUE = sq.plan_hash_value(+) )  child_number
        from   parent_child pc
        where  PLAN_OPERATION_INACTIVE = 0   --11i
        )
        , execution_plan as ( select
        eo.INST_ID,
        eo.CON_ID,--11i
        eo.KEY,eo.STATUS,eo.FIRST_REFRESH_TIME,eo.LAST_REFRESH_TIME,eo.FIRST_CHANGE_TIME,eo.LAST_CHANGE_TIME,eo.REFRESH_COUNT,eo.SID,eo.PROCESS_NAME,
        eo.SQL_ID,eo.SQL_EXEC_START,eo.SQL_EXEC_ID,eo.SQL_PLAN_HASH_VALUE,eo.SQL_CHILD_ADDRESS,
        eo.PLAN_PARENT_ID,eo.PLAN_LINE_ID,eo.PLAN_OPERATION,eo.PLAN_OPTIONS,eo.PLAN_OBJECT_OWNER,eo.PLAN_OBJECT_NAME,eo.PLAN_OBJECT_TYPE,eo.PLAN_DEPTH,PLAN_POSITION,
        eo.PLAN_COST,eo.PLAN_CARDINALITY,eo.PLAN_BYTES,eo.PLAN_TIME,eo.PLAN_PARTITION_START,eo.PLAN_PARTITION_STOP,eo.PLAN_CPU_COST,eo.PLAN_IO_COST,eo.PLAN_TEMP_SPACE,
        eo.STARTS,eo.OUTPUT_ROWS,
        eo.IO_INTERCONNECT_BYTES,eo.PHYSICAL_READ_REQUESTS,eo.PHYSICAL_READ_BYTES,eo.PHYSICAL_WRITE_REQUESTS,eo.PHYSICAL_WRITE_BYTES,
        eo.WORKAREA_MEM,eo.WORKAREA_MAX_MEM,eo.WORKAREA_TEMPSEG,eo.WORKAREA_MAX_TEMPSEG,
        --eo.OTHERSTAT_GROUP_ID,eo.OTHER_XML,eo.PLAN_OPERATION_INACTIVE,
        eo.operation, eo.R_MB, eo.W_MB, eo.PGA_MB, eo.TEMP_MB, eo.OPR_TIME, eo.oid
        , sp.access_predicates
        , sp.filter_predicates
        , sp.QBLOCK_NAME
        , sp.OBJECT_ALIAS
        , sp.SEARCH_COLUMNS     -- new
--        , sp.object#            -- new
        , nvl(sp.object#, (select do.object_id from dba_objects do where do.object_name = eo.PLAN_OBJECT_NAME
                           and do.owner = eo.PLAN_OBJECT_OWNER and eo.PLAN_OBJECT_TYPE like do.object_type||'%'  and rownum = 1) ) object#  -- 20180913
        from  execution_order eo,
              gv$sql_plan     sp
        where eo.inst_id             = sp.inst_id(+)
        and   eo.plan_line_id        = sp.id(+)
        and   eo.sql_id              = sp.sql_id(+)
        and   eo.SQL_PLAN_HASH_VALUE = sp.plan_hash_value(+)
        and   sm.child_number = sp.child_number(+) )  --- modified
--        and   eo.child_number = sp.child_number(+) )  --- here is the problem.
        , JOIN_ONE as (
        select p.INST_ID,
        p.CON_ID,--11i
        p.KEY,p.STATUS,p.FIRST_REFRESH_TIME,p.LAST_REFRESH_TIME,p.FIRST_CHANGE_TIME,p.LAST_CHANGE_TIME,p.REFRESH_COUNT,
        p.SID,p.PROCESS_NAME,
        p.SQL_ID,p.SQL_EXEC_START,p.SQL_EXEC_ID,p.SQL_PLAN_HASH_VALUE,p.SQL_CHILD_ADDRESS,
        p.PLAN_PARENT_ID,p.PLAN_LINE_ID,p.PLAN_OPERATION,p.PLAN_OPTIONS,p.PLAN_OBJECT_OWNER,p.PLAN_OBJECT_NAME,p.PLAN_OBJECT_TYPE,p.PLAN_DEPTH,p.PLAN_POSITION,
        p.PLAN_COST,p.PLAN_CARDINALITY,p.PLAN_BYTES,p.PLAN_TIME,p.PLAN_PARTITION_START,p.PLAN_PARTITION_STOP,p.PLAN_CPU_COST,p.PLAN_IO_COST,p.PLAN_TEMP_SPACE,
        p.STARTS,p.OUTPUT_ROWS,
        p.IO_INTERCONNECT_BYTES,p.PHYSICAL_READ_REQUESTS,p.PHYSICAL_READ_BYTES,p.PHYSICAL_WRITE_REQUESTS,p.PHYSICAL_WRITE_BYTES,
        p.WORKAREA_MEM,p.WORKAREA_MAX_MEM,p.WORKAREA_TEMPSEG,p.WORKAREA_MAX_TEMPSEG,
        --p.OTHERSTAT_GROUP_ID,p.OTHER_XML,p.PLAN_OPERATION_INACTIVE,
        p.operation, p.R_MB, p.W_MB, p.PGA_MB, p.TEMP_MB, p.OPR_TIME, p.oid,
        null EVENT, 0 CURRENT_OBJ#, 0 SNAP_COUNT, 0 WAITS_COUNT, 0 ON_CPU_COUNT,
        0 IN_HARD_PARSE_COUNT, 0 IN_PARSE_COUNT,
        0 SELF_BLOCKING_COUNT,0 BLOCKING_SESSION_COUNT
        , p.access_predicates
        , p.filter_predicates
        , p.QBLOCK_NAME
        , p.OBJECT_ALIAS
        , p.SEARCH_COLUMNS     -- new
        , p.object#            -- new
        , decode(J.plan_operation,'FILTER','NESTED','CONNECT BY','NESTED','CONNECT BY BUMP','NESTED','COUNT','NESTED',J.plan_operation)  JOIN_METHOD
        , J.OUTPUT_ROWS   JOIN_OUTPUT_ROWS
        from execution_plan P, execution_plan J
        where P.INST_ID = J.INST_ID(+) and P.sql_id = J.sql_id(+) and P.key = J.key(+)  and P.PLAN_PARENT_ID = J.PLAN_LINE_ID(+)
        and   J.plan_operation(+) in ('HASH JOIN', 'NESTED LOOPS','MERGE JOIN','FILTER','CONNECT BY','CONNECT BY BUMP','COUNT')
        order by p.key, p.PLAN_LINE_ID )
        -----------------------------
        , RUN_TIME_PLAN as (
        select p.INST_ID,
        p.CON_ID,--11i
        p.KEY,p.STATUS,p.FIRST_REFRESH_TIME,p.LAST_REFRESH_TIME,p.FIRST_CHANGE_TIME,p.LAST_CHANGE_TIME,p.REFRESH_COUNT,p.SID,p.PROCESS_NAME,
        p.SQL_ID,p.SQL_EXEC_START,p.SQL_EXEC_ID,p.SQL_PLAN_HASH_VALUE,p.SQL_CHILD_ADDRESS,
        p.PLAN_PARENT_ID,p.PLAN_LINE_ID,p.PLAN_OPERATION,p.PLAN_OPTIONS,p.PLAN_OBJECT_OWNER,p.PLAN_OBJECT_NAME,p.PLAN_OBJECT_TYPE,p.PLAN_DEPTH,p.PLAN_POSITION,
        p.PLAN_COST,p.PLAN_CARDINALITY,p.PLAN_BYTES,p.PLAN_TIME,p.PLAN_PARTITION_START,p.PLAN_PARTITION_STOP,p.PLAN_CPU_COST,p.PLAN_IO_COST,p.PLAN_TEMP_SPACE,
        p.STARTS,p.OUTPUT_ROWS,
        p.IO_INTERCONNECT_BYTES,p.PHYSICAL_READ_REQUESTS,p.PHYSICAL_READ_BYTES,p.PHYSICAL_WRITE_REQUESTS,p.PHYSICAL_WRITE_BYTES,
        p.WORKAREA_MEM,p.WORKAREA_MAX_MEM,p.WORKAREA_TEMPSEG,p.WORKAREA_MAX_TEMPSEG,
        --p.OTHERSTAT_GROUP_ID,p.OTHER_XML,p.PLAN_OPERATION_INACTIVE,
        p.operation, p.R_MB, p.W_MB, p.PGA_MB, p.TEMP_MB, p.OPR_TIME, p.oid,
        p.EVENT, p.CURRENT_OBJ#, p.SNAP_COUNT, P.WAITS_COUNT, P.ON_CPU_COUNT,
         P.IN_HARD_PARSE_COUNT, P.IN_PARSE_COUNT,
         p.SELF_BLOCKING_COUNT, p.BLOCKING_SESSION_COUNT
        , p.access_predicates
        , p.filter_predicates
        , p.QBLOCK_NAME
        , p.OBJECT_ALIAS
        , p.SEARCH_COLUMNS  -- new
        , p.object#         -- new
        , NVL(P.JOIN_METHOD,J.JOIN_METHOD) JOIN_METHOD
        , NVL(P.JOIN_OUTPUT_ROWS, J.OUTPUT_ROWS) JOIN_OUTPUT_ROWS
        from JOIN_ONE P, JOIN_ONE J
        where P.INST_ID = J.INST_ID(+) and P.sql_id = J.sql_id(+) and P.key = J.key(+)  and P.PLAN_PARENT_ID = J.PLAN_LINE_ID(+)
        order by p.key, p.PLAN_LINE_ID )
--        , FSTO as (
--        SELECT OID, (SELECT OID FROM RUN_TIME_PLAN WHERE PLAN_LINE_ID = 0) MXID
--        FROM (SELECT MIN(OID) OID
--              FROM RUN_TIME_PLAN
--              WHERE PLAN_LINE_ID > (SELECT MAX(PLAN_LINE_ID) FROM RUN_TIME_PLAN WHERE PLAN_PARENT_ID = 0) )
--        )
        , FSTO as (
        SELECT nvl(OID,1) OID, (SELECT max(OID) FROM RUN_TIME_PLAN WHERE 0 = PLAN_LINE_ID) MXID
        FROM (SELECT MIN(OID) OID
              FROM RUN_TIME_PLAN
              WHERE PLAN_LINE_ID > (SELECT MAX(PLAN_LINE_ID) FROM RUN_TIME_PLAN
                                    WHERE  PLAN_PARENT_ID = (
                                    SELECT DECODE(PLAN_OPERATION,'LOAD TABLE CONVENTIONAL',1,0)
                                    FROM RUN_TIME_PLAN WHERE PLAN_LINE_ID IN
                                    (SELECT MIN(PLAN_LINE_ID)
                                     FROM RUN_TIME_PLAN WHERE  PLAN_PARENT_ID = 0)))
              )
        )
        , MOD_RUN_TIME_PLAN AS (
        select R.*, NVL(DECODE( SIGN(R.OID - F.OID), -1,F.MXID-F.OID+R.OID,
                                                             0,1,
                                                             1,decode(r.PLAN_LINE_ID, 0, r.oid, R.OID-F.OID+1) )
                       ,DECODE( R.PLAN_LINE_ID,0,2,1,1 )
                                                             ) MO
        from RUN_TIME_PLAN R, FSTO F
/*      select R.*, DECODE( SIGN(R.OID - F.OID), -1,F.MXID-F.OID+R.OID,
                                                             0,1,
                                                             1,decode(r.PLAN_LINE_ID, 0, r.oid, R.OID-F.OID+1) ) MO
        from RUN_TIME_PLAN R, FSTO F */
        )
--- print for scalar SQL  --
        select 'EXEO' TP, ROWNUM RN,  R.*
        from (select * from MOD_RUN_TIME_PLAN
        order by KEY, MO ) R
        UNION ALL
--- TOP 5 IO OPERATIONS --
        SELECT 'IO'   TP, ROWNUM RN, R.*
        FROM
             (SELECT * FROM MOD_RUN_TIME_PLAN WHERE
              PLAN_OBJECT_TYPE IS NOT NULL AND
             (OUTPUT_ROWS > :L_ACCESS_RATIO*:L_ACCESS_RATIO*:L_ACCESS_RATIO*:L_ACCESS_RATIO*:L_ACCESS_RATIO*:L_ACCESS_RATIO
              OR R_MB IS NOT NULL OR W_MB IS NOT NULL OR PGA_MB IS NOT NULL OR TEMP_MB IS NOT NULL
              )
              ORDER BY KEY, NVL(OUTPUT_ROWS,0)/1000000+NVL(R_MB,0)+NVL(W_MB,0)+NVL(PGA_MB,0)+NVL(TEMP_MB,0) DESC) R
        WHERE ROWNUM <= 5
        UNION ALL
        -- ASH SNAP-SHOT COUNT --   Refer wait event and snapshot count.
        SELECT 'ASH' TP, ROWNUM RN, A.*
        from (select
              p.INST_ID,
              p.CON_ID,--11i
              p.KEY,p.STATUS,p.FIRST_REFRESH_TIME,p.LAST_REFRESH_TIME,p.FIRST_CHANGE_TIME,p.LAST_CHANGE_TIME,
              p.REFRESH_COUNT,p.SID,p.PROCESS_NAME,
              p.SQL_ID,p.SQL_EXEC_START,p.SQL_EXEC_ID,p.SQL_PLAN_HASH_VALUE,p.SQL_CHILD_ADDRESS,
              p.PLAN_PARENT_ID,p.PLAN_LINE_ID,p.PLAN_OPERATION,p.PLAN_OPTIONS,p.PLAN_OBJECT_OWNER, --p.PLAN_OBJECT_NAME,
             (select object_name from dba_objects where object_id = ash.CURRENT_OBJ#)  PLAN_OBJECT_NAME,
              p.PLAN_OBJECT_TYPE,
              p.PLAN_DEPTH,p.PLAN_POSITION,p.PLAN_COST,p.PLAN_CARDINALITY,p.PLAN_BYTES,p.PLAN_TIME,p.PLAN_PARTITION_START,p.PLAN_PARTITION_STOP,
              p.PLAN_CPU_COST,p.PLAN_IO_COST,p.PLAN_TEMP_SPACE, p.STARTS,p.OUTPUT_ROWS,
              p.IO_INTERCONNECT_BYTES,p.PHYSICAL_READ_REQUESTS,p.PHYSICAL_READ_BYTES,p.PHYSICAL_WRITE_REQUESTS,p.PHYSICAL_WRITE_BYTES,
              p.WORKAREA_MEM,p.WORKAREA_MAX_MEM,p.WORKAREA_TEMPSEG,p.WORKAREA_MAX_TEMPSEG,
              --p.OTHERSTAT_GROUP_ID, p.OTHER_XML,p.PLAN_OPERATION_INACTIVE,--11i
              p.operation, p.R_MB, p.W_MB, p.PGA_MB, p.TEMP_MB, p.OPR_TIME, p.oid,
              ash.EVENT, ash.CURRENT_OBJ#, ash.SNAP_COUNT,
              ash.WAITS_COUNT, ash.ON_CPU_COUNT,  ASH.IN_HARD_PARSE_COUNT, ASH.IN_PARSE_COUNT,
              ash.SELF_BLOCKING_COUNT, ash.BLOCKING_SESSION_COUNT
              , p.access_predicates
              , p.filter_predicates
              , p.QBLOCK_NAME
              , p.OBJECT_ALIAS
              , p.SEARCH_COLUMNS   -- new
              , p.object#          -- new
              , P.JOIN_METHOD
              , P.JOIN_OUTPUT_ROWS
              , p.mo
               FROM
                    (SELECT INST_ID, SQL_ID,
                            SQL_PLAN_HASH_VALUE,
                            SQL_PLAN_LINE_ID SQL_PLAN_LINE_ID, EVENT, CURRENT_OBJ#, SC.SNAP_COUNT,
                     round((WAITS_COUNT/GREATEST(SC.SNAP_COUNT,1)) *100,2) WAITS_COUNT,
                     round((ON_CPU_COUNT/GREATEST(SC.SNAP_COUNT,1))*100,2) ON_CPU_COUNT,
                   --  round((IN_HARD_PARSE/GREATEST(SC.SNAP_COUNT,1)) *100,2) IN_HARD_PARSE_COUNT,   /* JINSOO */
                     round((IN_HARD_PARSE/GREATEST(IN_PARSE,1)) *100,2) IN_HARD_PARSE_COUNT,   /* JINSOO */
                     round((IN_PARSE/GREATEST(SC.SNAP_COUNT,1))*100,2)       IN_PARSE_COUNT,
                     --WAITS_COUNT, ON_CPU_COUNT,   --20180430
                     SELF_BLOCKING_COUNT, BLOCKING_SESSION_COUNT
                     FROM
                         (SELECT COUNT(*) SNAP_COUNT
                          FROM GV$ACTIVE_SESSION_HISTORY ASH
                          WHERE ASH.INST_ID = SM.INST_ID
                          AND   ASH.SQL_ID  = SM.SQL_ID
                          AND   ASH.SQL_PLAN_HASH_VALUE = SM.SQL_PLAN_HASH_VALUE
                          AND   ASH.SESSION_ID      = SM.SID             -- NOT MANY ROWS --
                          AND   ASH.SESSION_SERIAL# = SM.SESSION_SERIAL# -- NOT MANY ROWS --
                          --AND   ASH.EVENT IS NOT NULL                      -- PICK ONLY WAITS except CPU --
                          GROUP BY ASH.INST_ID, ASH.SQL_ID,
                          --ASH.SESSION_ID,
                          ASH.SQL_PLAN_HASH_VALUE
                         ) SC,
                         (SELECT ASH.INST_ID, ASH.SQL_ID, ASH.SQL_PLAN_HASH_VALUE, ASH.SQL_PLAN_LINE_ID,
                          NVL(ASH.EVENT, ASH.SESSION_STATE) EVENT, ASH.CURRENT_OBJ# ,
                          COUNT(*) SNAP_COUNT,
                          -- COUNT(DISTINCT ASH.SESSION_ID) SESSION_COUNT,
                          -- COUNT(DISTINCT ASH.BLOCKING_SESSION) BLOCKING_SESSION_COUNT,
                          SUM(DECODE(IN_HARD_PARSE,'Y',1,0))          IN_HARD_PARSE,
                          SUM(DECODE(IN_PARSE,'Y',1,0))               IN_PARSE,
                          SUM(DECODE(ASH.EVENT,NULL,0,1))             WAITS_COUNT,
                          SUM(DECODE(ASH.SESSION_STATE,'ON CPU',1,0)) ON_CPU_COUNT,
                          COUNT(DISTINCT DECODE(ASH.BLOCKING_SESSION,ASH.SESSION_ID,ASH.BLOCKING_SESSION,null)) SELF_BLOCKING_COUNT,
                          COUNT(DISTINCT DECODE(ASH.BLOCKING_SESSION,ASH.SESSION_ID,null,ASH.BLOCKING_SESSION)) BLOCKING_SESSION_COUNT
                          FROM GV$ACTIVE_SESSION_HISTORY ASH
                          WHERE ASH.INST_ID = SM.INST_ID
                          AND   ASH.SQL_ID  = SM.SQL_ID
                          AND   ASH.SQL_PLAN_HASH_VALUE = SM.SQL_PLAN_HASH_VALUE
                          --20180329
                          AND   ASH.SESSION_ID      = SM.SID             -- NOT MANY ROWS --
                          AND   ASH.SESSION_SERIAL# = SM.SESSION_SERIAL# -- NOT MANY ROWS --
                          --AND   ASH.EVENT IS NOT NULL                      -- PICK ONLY WAITS except CPU --
                          GROUP BY ASH.INST_ID, ASH.SQL_ID,
                          --ASH.SESSION_ID,
                          ASH.SQL_PLAN_HASH_VALUE, ASH.SQL_PLAN_LINE_ID,
                          NVL(ASH.EVENT, ASH.SESSION_STATE), ASH.CURRENT_OBJ#
                          ORDER BY 7 DESC )
                     WHERE ROWNUM < 6
                     AND ( round((WAITS_COUNT/GREATEST(SC.SNAP_COUNT,1)) *100,2) > 19.9
                        OR round((ON_CPU_COUNT/GREATEST(SC.SNAP_COUNT,1))*100,2) > 19.9
                        --OR round((IN_HARD_PARSE/GREATEST(SC.SNAP_COUNT,1)) *100,2) > 19.9
                        OR round((IN_PARSE/GREATEST(SC.SNAP_COUNT,1))*100,2) > 19.9
                         )
                     AND   SC.SNAP_COUNT > 1 ) ASH,
                    mod_RUN_TIME_PLAN P
               WHERE  ASH.INST_ID = P.INST_ID(+)
               AND    ASH.SQL_ID  = P.SQL_ID(+)
               AND    ASH.SQL_PLAN_HASH_VALUE = P.SQL_PLAN_HASH_VALUE(+)
               AND    ASH.SQL_PLAN_LINE_ID    = P.PLAN_LINE_ID(+)  --20180430 important
               ORDER BY P.KEY, ASH.IN_PARSE_COUNT+ASH.WAITS_COUNT+ASH.on_CPU_COUNT desc) a
        UNION ALL
        select 'PRNT' TP, ROWNUM RN, p.*
        from (select
        p.INST_ID,
        p.CON_ID,--11i
        p.KEY,p.STATUS,p.FIRST_REFRESH_TIME,p.LAST_REFRESH_TIME,p.FIRST_CHANGE_TIME,p.LAST_CHANGE_TIME,p.REFRESH_COUNT,p.SID,p.PROCESS_NAME,
        p.SQL_ID,p.SQL_EXEC_START,p.SQL_EXEC_ID,p.SQL_PLAN_HASH_VALUE,p.SQL_CHILD_ADDRESS,
        p.PLAN_PARENT_ID,p.PLAN_LINE_ID,p.PLAN_OPERATION,p.PLAN_OPTIONS,p.PLAN_OBJECT_OWNER,p.PLAN_OBJECT_NAME,p.PLAN_OBJECT_TYPE,p.PLAN_DEPTH,p.PLAN_POSITION,
        p.PLAN_COST,p.PLAN_CARDINALITY,p.PLAN_BYTES,p.PLAN_TIME,p.PLAN_PARTITION_START,p.PLAN_PARTITION_STOP,p.PLAN_CPU_COST,p.PLAN_IO_COST,p.PLAN_TEMP_SPACE,
        p.STARTS, round(p.OUTPUT_ROWS) OUTPUT_ROWS,
--        p.STARTS, round(p.OUTPUT_ROWS/decode(p.starts,null,1,0,1,p.starts)) OUTPUT_ROWS,
        p.IO_INTERCONNECT_BYTES,p.PHYSICAL_READ_REQUESTS,p.PHYSICAL_READ_BYTES,p.PHYSICAL_WRITE_REQUESTS,p.PHYSICAL_WRITE_BYTES,
        p.WORKAREA_MEM,
        p.WORKAREA_MAX_MEM WORKAREA_MAX_MEM,
        p.WORKAREA_TEMPSEG,
        p.WORKAREA_MAX_TEMPSEG,
        --p.OTHERSTAT_GROUP_ID,p.OTHER_XML,p.PLAN_OPERATION_INACTIVE,
        p.operation, p.R_MB, p.W_MB, p.PGA_MB, p.TEMP_MB, p.OPR_TIME, p.oid,
        p.EVENT, p.CURRENT_OBJ#, p.SNAP_COUNT, P.WAITS_COUNT, P.ON_CPU_COUNT, 
        P.IN_HARD_PARSE_COUNT, P.IN_PARSE_COUNT, p.SELF_BLOCKING_COUNT, p.BLOCKING_SESSION_COUNT
        , p.access_predicates
        , p.filter_predicates
        , p.QBLOCK_NAME
        , p.OBJECT_ALIAS
        , p.SEARCH_COLUMNS    -- new
        , p.object#           -- new
        , p.JOIN_METHOD
        , p.JOIN_OUTPUT_ROWS
        , p.mo
        from MOD_RUN_TIME_PLAN p
        order by p.SQL_PLAN_HASH_VALUE, p.key, p.PLAN_LINE_ID
         ) p
-- MAJ PREDICATES STARTS
        UNION ALL
        select 'MPRDC' TP, ROWNUM RN, p.*
        from (select
        p.INST_ID,
        p.CON_ID,--11i
        p.KEY,p.STATUS,p.FIRST_REFRESH_TIME,p.LAST_REFRESH_TIME,p.FIRST_CHANGE_TIME,p.LAST_CHANGE_TIME,p.REFRESH_COUNT,p.SID,p.PROCESS_NAME,
        p.SQL_ID,p.SQL_EXEC_START,p.SQL_EXEC_ID,p.SQL_PLAN_HASH_VALUE,p.SQL_CHILD_ADDRESS,
        p.PLAN_PARENT_ID,p.PLAN_LINE_ID,p.PLAN_OPERATION,p.PLAN_OPTIONS,p.PLAN_OBJECT_OWNER,p.PLAN_OBJECT_NAME,p.PLAN_OBJECT_TYPE,p.PLAN_DEPTH,p.PLAN_POSITION,
        p.PLAN_COST,p.PLAN_CARDINALITY,p.PLAN_BYTES,p.PLAN_TIME,p.PLAN_PARTITION_START,p.PLAN_PARTITION_STOP,p.PLAN_CPU_COST,p.PLAN_IO_COST,p.PLAN_TEMP_SPACE,
        p.STARTS, round(p.OUTPUT_ROWS) OUTPUT_ROWS,
--        p.STARTS, round(p.OUTPUT_ROWS/decode(p.starts,null,1,0,1,p.starts)) OUTPUT_ROWS,
        p.IO_INTERCONNECT_BYTES,p.PHYSICAL_READ_REQUESTS,p.PHYSICAL_READ_BYTES,p.PHYSICAL_WRITE_REQUESTS,p.PHYSICAL_WRITE_BYTES,
        p.WORKAREA_MEM,
        p.WORKAREA_MAX_MEM WORKAREA_MAX_MEM,
        p.WORKAREA_TEMPSEG,
        p.WORKAREA_MAX_TEMPSEG,
        --p.OTHERSTAT_GROUP_ID,p.OTHER_XML,p.PLAN_OPERATION_INACTIVE,
        p.operation, p.R_MB, p.W_MB, p.PGA_MB, p.TEMP_MB, p.OPR_TIME, p.oid,
        p.EVENT, p.CURRENT_OBJ#, p.SNAP_COUNT, P.WAITS_COUNT, P.ON_CPU_COUNT,
        P.IN_HARD_PARSE_COUNT, P.IN_PARSE_COUNT, p.SELF_BLOCKING_COUNT, p.BLOCKING_SESSION_COUNT
        , p.access_predicates
        , p.filter_predicates
        , p.QBLOCK_NAME
        , p.OBJECT_ALIAS
        , p.SEARCH_COLUMNS    -- new
        , p.object#           -- new
        , p.JOIN_METHOD
        , p.JOIN_OUTPUT_ROWS
        , p.mo
        from MOD_RUN_TIME_PLAN p
        --WHERE :SQL_FROM_MEM = 1
        order by p.SQL_PLAN_HASH_VALUE, p.key, p.PLAN_LINE_ID
        ) p
-- MAJ PREDICATES END
-- PREDICATES STARTS
        UNION ALL
        select 'PRDC' TP, ROWNUM RN, p.*
        from (select
        p.INST_ID,
        p.CON_ID,--11i
        p.KEY,p.STATUS,p.FIRST_REFRESH_TIME,p.LAST_REFRESH_TIME,p.FIRST_CHANGE_TIME,p.LAST_CHANGE_TIME,p.REFRESH_COUNT,p.SID,p.PROCESS_NAME,
        p.SQL_ID,p.SQL_EXEC_START,p.SQL_EXEC_ID,p.SQL_PLAN_HASH_VALUE,p.SQL_CHILD_ADDRESS,
        p.PLAN_PARENT_ID,p.PLAN_LINE_ID,p.PLAN_OPERATION,p.PLAN_OPTIONS,p.PLAN_OBJECT_OWNER,p.PLAN_OBJECT_NAME,p.PLAN_OBJECT_TYPE,p.PLAN_DEPTH,p.PLAN_POSITION,
        p.PLAN_COST,p.PLAN_CARDINALITY,p.PLAN_BYTES,p.PLAN_TIME,p.PLAN_PARTITION_START,p.PLAN_PARTITION_STOP,p.PLAN_CPU_COST,p.PLAN_IO_COST,p.PLAN_TEMP_SPACE,
        p.STARTS, round(p.OUTPUT_ROWS) OUTPUT_ROWS,
--        p.STARTS, round(p.OUTPUT_ROWS/decode(p.starts,null,1,0,1,p.starts)) OUTPUT_ROWS,
        p.IO_INTERCONNECT_BYTES,p.PHYSICAL_READ_REQUESTS,p.PHYSICAL_READ_BYTES,p.PHYSICAL_WRITE_REQUESTS,p.PHYSICAL_WRITE_BYTES,
        p.WORKAREA_MEM,
        p.WORKAREA_MAX_MEM WORKAREA_MAX_MEM,
        p.WORKAREA_TEMPSEG,
        p.WORKAREA_MAX_TEMPSEG,
        --p.OTHERSTAT_GROUP_ID,p.OTHER_XML,p.PLAN_OPERATION_INACTIVE,
        p.operation, p.R_MB, p.W_MB, p.PGA_MB, p.TEMP_MB, p.OPR_TIME, p.oid,
        p.EVENT, p.CURRENT_OBJ#, p.SNAP_COUNT, P.WAITS_COUNT, P.ON_CPU_COUNT,
        P.IN_HARD_PARSE_COUNT, P.IN_PARSE_COUNT, p.SELF_BLOCKING_COUNT, p.BLOCKING_SESSION_COUNT
        , p.access_predicates
        , p.filter_predicates
        , p.QBLOCK_NAME
        , p.OBJECT_ALIAS
        , p.SEARCH_COLUMNS    -- new
        , p.object#           -- new
        , p.JOIN_METHOD
        , p.JOIN_OUTPUT_ROWS
        , p.mo
        from MOD_RUN_TIME_PLAN p
        --WHERE :SQL_FROM_MEM = 1
        order by p.SQL_PLAN_HASH_VALUE, p.key, p.PLAN_LINE_ID
        ) p
-- PREDICATES END
        UNION ALL
/*20180420*/ -- LINE PRINT
--        select 'LPRNT' TP, ROWNUM RN,  P.*
--        from (select * from MOD_RUN_TIME_PLAN
--        order by KEY, MO ) P
-- LINE PRINT START
        select 'LPRNT' TP, ROWNUM RN,  P.*
        from (select
        p.INST_ID,
        p.CON_ID,--11i
        p.KEY,p.STATUS,p.FIRST_REFRESH_TIME,p.LAST_REFRESH_TIME,p.FIRST_CHANGE_TIME,p.LAST_CHANGE_TIME,p.REFRESH_COUNT,p.SID,p.PROCESS_NAME,
        p.SQL_ID,p.SQL_EXEC_START,p.SQL_EXEC_ID,p.SQL_PLAN_HASH_VALUE,p.SQL_CHILD_ADDRESS,
        p.PLAN_PARENT_ID,p.PLAN_LINE_ID,p.PLAN_OPERATION,p.PLAN_OPTIONS,p.PLAN_OBJECT_OWNER,
        p.PLAN_OBJECT_NAME,
        p.PLAN_OBJECT_TYPE,p.PLAN_DEPTH,p.PLAN_POSITION,
        p.PLAN_COST,p.PLAN_CARDINALITY,p.PLAN_BYTES,p.PLAN_TIME,p.PLAN_PARTITION_START,p.PLAN_PARTITION_STOP,p.PLAN_CPU_COST,p.PLAN_IO_COST,p.PLAN_TEMP_SPACE,
        p.STARTS, round(p.OUTPUT_ROWS) OUTPUT_ROWS,
--        p.STARTS, round(p.OUTPUT_ROWS/decode(p.starts,null,1,0,1,p.starts)) OUTPUT_ROWS,
        p.IO_INTERCONNECT_BYTES,p.PHYSICAL_READ_REQUESTS,p.PHYSICAL_READ_BYTES,p.PHYSICAL_WRITE_REQUESTS,p.PHYSICAL_WRITE_BYTES,
        p.WORKAREA_MEM,p.WORKAREA_MAX_MEM,p.WORKAREA_TEMPSEG,p.WORKAREA_MAX_TEMPSEG,
        --p.OTHERSTAT_GROUP_ID,p.OTHER_XML,p.PLAN_OPERATION_INACTIVE,
        p.operation, p.R_MB, p.W_MB, p.PGA_MB, p.TEMP_MB, p.OPR_TIME, p.oid,
        p.EVENT, p.CURRENT_OBJ#, p.SNAP_COUNT, P.WAITS_COUNT, P.ON_CPU_COUNT, 
        P.IN_HARD_PARSE_COUNT, P.IN_PARSE_COUNT, p.SELF_BLOCKING_COUNT, p.BLOCKING_SESSION_COUNT
        , p.access_predicates
        , p.filter_predicates
        , p.QBLOCK_NAME
        , p.OBJECT_ALIAS
        , p.SEARCH_COLUMNS    -- new
        , p.object#           -- new
        , p.JOIN_METHOD
        , p.JOIN_OUTPUT_ROWS
        , p.mo
        from MOD_RUN_TIME_PLAN p
        where (
        (  p.PLAN_OBJECT_OWNER is not null and p.PLAN_OBJECT_NAME is not null )
        OR p.WORKAREA_MAX_MEM IS NOT NULL
        OR p.WORKAREA_MAX_TEMPSEG IS NOT NULL
              )
        order by p.KEY, p.MO ) P
-- LINE PRINT END
        )  -- spm query finished.
      LOOP
        :L_WHERE_LOG   := SPM.TP||' '||SPM.RN;
        :L_CUR_KEY := SPM.KEY;
        :L_CUR_PHV := SPM.SQL_PLAN_HASH_VALUE;
        :L_CUR_OID := SPM.MO;
        :L_CUR_NR  := SPM.OUTPUT_ROWS;

        /* 1st operation : no CARDINALITY or 10+% gap ESTIMATION */
        IF( SPM.TP = 'EXEO' AND SPM.MO =1 ) THEN       -- need to check each qblock driving condition
        :L_WHERE_LOG := 'EXEO 1STO';
            --20180119
            -- high volume data
            ---START
--20180819
        --     IF(SPM.OUTPUT_ROWS * 0.30 > SPM.JOIN_OUTPUT_ROWS ) THEN
        --         :L_NEXT_MO := SPM.MO + 1;
        --     END IF;
             IF (SPM.MO =1 AND SPM.PLAN_CARDINALITY IS NULL AND SPM.PLAN_OPERATION NOT IN ('DOMAIN INDEX')
                 AND SUBSTR(SPM.PROCESS_NAME,1,1) NOT IN ('p') )  THEN
                  :L_1ST_OPR_STATUS := 1;
                  :L_WHERE_LOG := 'EXEO 1ST OPR NO CARDINALITY';
                  DBMS_OUTPUT.PUT_LINE('Note (<a href="#PHV'||SPM.SQL_PLAN_HASH_VALUE||SPM.KEY||SPM.MO||'">ID:'||spm.PLAN_LINE_ID||
                  '</a>) 1st Operation has no cardinality estimation.');
             END IF;
/* when high volume data in 1st opr, check gtt or pl/sql table starts */
             IF (   ( SPM.OUTPUT_ROWS > 500   AND :L_ACCESS_RATIO  =  5 )
                 OR ( SPM.OUTPUT_ROWS > 1500  AND :L_ACCESS_RATIO  =  7 )
                 OR ( SPM.OUTPUT_ROWS > 50000 AND :L_ACCESS_RATIO >= 10 ) ) THEN
                 -- ONLINE  5*100 =   500  WHEN ONLINE, IT STARTS FROM  500
                 -- BATCH 500*100 = 50000  WHEN BATCH, IT STARTS FROM 50000
                  :L_1ST_OPR_STATUS := 4;
                IF ( SPM.PLAN_OBJECT_TYPE LIKE 'INDEX%' OR SPM.PLAN_OBJECT_TYPE like 'TABLE%' ) THEN
                  --  DBMS_OUTPUT.PUT_LINE('1ST Operation) ID:'||LPAD('    ',4-LENGTH(SPM.plan_line_id))||SPM.plan_line_id||' OID:'||LPAD('    ',4-LENGTH(SPM.MO))||:L_CUR_OID);
                  --  DBMS_OUTPUT.PUT_LINE('=>Suggestion: Check if the 1st driving condition made the SQL returned too many rows ('||SPM.OUTPUT_ROWS||' at '||SPM.plan_line_id')');
                    :l_co5 := :l_co4;
                    :l_co4 := :l_co3;
                    :l_co3 := :l_co2;
                    :l_co2 := :l_co1;
                    :l_co1 := spm.mo;

-- GTT or PL/SQL table
                   IF ( CHECK_SQL_HASH_GTT(SPM.KEY,SPM.SQL_ID,SPM.SQL_PLAN_HASH_VALUE) = 1 ) THEN
                     :L_WHERE_LOG := 'GTT CHECK';
                     FOR K IN (
                       SELECT ROWNUM RN, SPM1.PLAN_LINE_ID, SPM1.PLAN_CARDINALITY, SPM1.OUTPUT_ROWS,
                       DECODE(SPM1.PLAN_OBJECT_TYPE,'PROCEDURE','PL/SQL TALBE',SPM1.PLAN_OBJECT_NAME) PLAN_OBJECT_NAME
                       FROM   GV$SQL_PLAN_MONITOR SPM1
                       WHERE  SPM1.KEY = SPM.KEY
                       AND    SPM1.SQL_ID = SPM.SQL_ID
                       AND    SPM1.SQL_PLAN_HASH_VALUE = SPM.SQL_PLAN_HASH_VALUE
                       AND    SPM1.PLAN_OBJECT_TYPE IN ('TABLE (TEMP)','PROCEDURE')
                       AND    SPM1.PLAN_CARDINALITY <> SPM1.OUTPUT_ROWS
                       --AND    SPM1.OUTPUT_ROWS > DECODE(:L_ACCESS_RATIO,5,100, 10000)
                       ORDER BY SPM1.KEY, SPM1.PLAN_LINE_ID )
                     LOOP
                       IF (K.RN = 1) THEN
                     --     DBMS_OUTPUT.PUT_LINE('# The SQL used GTT or PL/SQL table whose cardinality was incorrectly estimated.');
                     --     DBMS_OUTPUT.PUT_LINE('Note. The incorrect cardinality estimation on GTT or PL/SQL table can make overall sub-optimized-plan.');
                     --     DBMS_OUTPUT.PUT_LINE('*** Fix this issue first of all.***');
                            null;
                       END IF;
                     --  DBMS_OUTPUT.PUT_LINE(' At the plan line id:'||k.PLAN_LINE_ID||', the cardinality of '||k.PLAN_OBJECT_NAME
                     --  ||' was estimated as '||k.PLAN_CARDINALITY
                     --  ||' but actual number of output rows was '||k.OUTPUT_ROWS||'.');
                     --  DBMS_OUTPUT.PUT_LINE(' If there is any fix_control issue, follow the suggestion on FIX_CONTROL SECTION.');
                     --  DBMS_OUTPUT.PUT_LINE(' If there is NO fix_control issue, flush sql_id, '||spm.sql_id||' under all nodes.');
                       IF(  ( :L_ACCESS_RATIO = 5 and K.OUTPUT_ROWS > 5000 )  /*v3  100->5000*/
                          or( :L_ACCESS_RATIO > 5 and K.OUTPUT_ROWS > 100000 ) )
                         THEN
                         DBMS_OUTPUT.PUT_LINE('* Analysis');
                         DBMS_OUTPUT.PUT_LINE('=>Issue Category: <RED>Blind operation</RED>'); :issue_blind_query := 1;
                         DBMS_OUTPUT.PUT_LINE('<blue>Action Item : DEVELOPMENT TEAM/OPERATION TEAM</BLUE>');
                         DBMS_OUTPUT.PUT_LINE('=>Suggestion: Use reasonable volume of data in WITH/GTT/PLSQL Table, '||k.PLAN_OBJECT_NAME||' for (<a href="#PHV'||SPM.SQL_PLAN_HASH_VALUE
                         ||SPM.KEY||SPM.MO||'">ID:'||spm.PLAN_LINE_ID||'</a>).');
                         DBMS_OUTPUT.PUT_LINE('.');
                       ELSIF ( K.PLAN_OBJECT_NAME = 'TABLE (TEMP)'
                           AND ( K.PLAN_CARDINALITY = 1
                              or ( SPM.OUTPUT_ROWS = 0 AND ABS(SPM.PLAN_CARDINALITY - SPM.OUTPUT_ROWS) > (:L_ACCESS_RATIO*2/100) )
                              or ( SPM.OUTPUT_ROWS > 0 AND ABS(SPM.PLAN_CARDINALITY - SPM.OUTPUT_ROWS)/SPM.OUTPUT_ROWS > (:L_ACCESS_RATIO*2/100) )
                              ) )
                         THEN
                         DBMS_OUTPUT.PUT_LINE('* Analysis');
                         DBMS_OUTPUT.PUT_LINE('=>Issue Category: <RED>CBO</RED>'); :issue_cbo := 1;
                         DBMS_OUTPUT.PUT_LINE('<blue>Action Item : DEVELOPMENT TEAM/OPERATION TEAM</BLUE>');
                         DBMS_OUTPUT.PUT_LINE('=>Suggestion: Check if opt_param(''_fix_control'',''13905599:on'') hint helps with PSR team. '||k.PLAN_OBJECT_NAME||' for (<a href="#PHV'||SPM.SQL_PLAN_HASH_VALUE
                         ||SPM.KEY||SPM.MO||'">ID:'||spm.PLAN_LINE_ID||'</a>).');
                         DBMS_OUTPUT.PUT_LINE('+');
                         DBMS_OUTPUT.PUT_LINE('=>Open sqlhc_<date>_<time>_'||:l_sql_id||'_14_executable_script.sql within the sqlhc.zip file');
                         DBMS_OUTPUT.PUT_LINE('=>Make it run-able with small modification and run it under the issue environment.');
                         DBMS_OUTPUT.PUT_LINE('=>Add opt_param(''_fix_control'',''13905599:on'') in the issue SQL');
                         DBMS_OUTPUT.PUT_LINE('$sqlplus / as sysdba');
                         IF ( :L_PDB <> 'NOPDB' ) THEN
                               DBMS_OUTPUT.PUT_LINE('SQL><blue>'||:L_PDB||'</blue>');
                         END IF;
                         DBMS_OUTPUT.PUT_LINE('SQL>start sqlhc_<date>_<time>_'||:l_sql_id||'_14_executable_script.sql');
                         DBMS_OUTPUT.PUT_LINE('Review the execution plan');
                         DBMS_OUTPUT.PUT_LINE('If the plan is good, apply the sql patch as below');
                         DBMS_OUTPUT.PUT_LINE('+');
                         DBMS_OUTPUT.PUT_LINE('=>How to setup SQL PATCH and flush SQL');
                         DBMS_OUTPUT.PUT_LINE('$sqlplus / as sysdba');
                         IF ( :L_PDB <> 'NOPDB' ) THEN
                               DBMS_OUTPUT.PUT_LINE('SQL><blue>'||:L_PDB||'</blue>');
                         END IF;
                         DBMS_OUTPUT.PUT_LINE('SQL>start coe_gen_sql_patch.sql');
                         DBMS_OUTPUT.PUT_LINE('1st parameter : '||:L_SQL_ID);
                         DBMS_OUTPUT.PUT_LINE('2nd parameter : '||'opt_param(''_fix_control'',''13905599:on'')');
                         DBMS_OUTPUT.PUT_LINE('3rd parameter : '||'BUG_<BUGNO>_'||:L_SQL_ID);
                         DBMS_OUTPUT.PUT_LINE('=>How to flush sql : execute flushsql under all nodes');
                         DBMS_OUTPUT.PUT_LINE('SQL>start flushsql.sql');
                         DBMS_OUTPUT.PUT_LINE('1st parameter : '||:L_SQL_ID);
                         DBMS_OUTPUT.PUT_LINE('.');
                       END IF;
                     END LOOP;
                   ELSE
                         DBMS_OUTPUT.PUT_LINE('* Analysis');
                         IF ( SPM.access_predicates IS NOT NULL ) THEN
                            DBMS_OUTPUT.PUT_LINE('* (<a href="#PHV'||SPM.SQL_PLAN_HASH_VALUE||SPM.KEY||SPM.MO||'">ID:'||spm.PLAN_LINE_ID||'</a>) 1st Operation AP:' ||SUBSTR(SPM.access_predicates,  1,120));
                           -- DBMS_OUTPUT.PUT_LINE('* (ID:'||spm.PLAN_LINE_ID||') 1st Operation AP:' ||SUBSTR(SPM.access_predicates,  1,120));
                            DBMS_OUTPUT.PUT_LINE(SUBSTR(SPM.access_predicates,121,240));
                            DBMS_OUTPUT.PUT_LINE(SUBSTR(SPM.access_predicates,241,360));
                         END IF;
                         IF ( SPM.filter_predicates IS NOT NULL ) THEN
                            DBMS_OUTPUT.PUT_LINE('* (<a href="#PHV'||SPM.SQL_PLAN_HASH_VALUE||SPM.KEY||SPM.MO||'">ID:'||spm.PLAN_LINE_ID||'</a>) 1st Operation FP:' ||SUBSTR(SPM.filter_predicates,  1,120));
                            DBMS_OUTPUT.PUT_LINE(SUBSTR(SPM.filter_predicates,121,240));
                            DBMS_OUTPUT.PUT_LINE(SUBSTR(SPM.filter_predicates,241,360));
                         END IF;
                         IF( SPM.PLAN_OBJECT_TYPE = 'INDEX (DOMAIN)') THEN
                             DBMS_OUTPUT.PUT_LINE('* (<a href="#PHV'||SPM.SQL_PLAN_HASH_VALUE||SPM.KEY||SPM.MO||'">ID:'||spm.PLAN_LINE_ID||'</a>) 1st Operation returned '||SPM.OUTPUT_ROWS||' rows.');
                             DBMS_OUTPUT.PUT_LINE('=>Issue Category: <RED>Blind input or unselective input</RED>'); :issue_blind_input := 1;
                             DBMS_OUTPUT.PUT_LINE('<blue>Action Item : DEVELOPMENT TEAM/OPERATION TEAM</BLUE>');
                             DBMS_OUTPUT.PUT_LINE('=>Suggestion: Use more selective input for the domain index, '||SPM.PLAN_OBJECT_NAME||' (<a href="#PHV'||SPM.SQL_PLAN_HASH_VALUE||SPM.KEY||SPM.MO||'">ID:'||spm.PLAN_LINE_ID||'</a>).');
                             DBMS_OUTPUT.PUT_LINE('.');
                         ELSIF (SPM.PLAN_OBJECT_TYPE = 'INDEX' AND SPM.PLAN_OPERATION = 'INDEX' AND INSTR(SPM.ACCESS_PREDICATES,' LIKE ')<>0 ) THEN
                             DBMS_OUTPUT.PUT_LINE('* (<a href="#PHV'||SPM.SQL_PLAN_HASH_VALUE||SPM.KEY||SPM.MO||'">ID:'||spm.PLAN_LINE_ID||'</a>) 1st Operation returned '||SPM.OUTPUT_ROWS||' rows.');
                             DBMS_OUTPUT.PUT_LINE('=>Issue Category: <RED>Blind input or unselective input</RED>'); :issue_blind_input := 1;
                             DBMS_OUTPUT.PUT_LINE('<blue>Action Item : DEVELOPMENT TEAM/OPERATION TEAM</BLUE>');
                             DBMS_OUTPUT.PUT_LINE('=>Suggestion: Use more selective input for the index with LIKE operation at '||SPM.PLAN_OBJECT_NAME||' (<a href="#PHV'||SPM.SQL_PLAN_HASH_VALUE||SPM.KEY||SPM.MO||'">ID:'||spm.PLAN_LINE_ID||'</a>).');
                             DBMS_OUTPUT.PUT_LINE('.');
--V3
                         ELSIF (:L_ADJ_PROCESSED_ROW * :L_ACCESS_RATIO/100 < SPM.OUTPUT_ROWS
                                   AND SPM.PLAN_OPTIONS LIKE '%FULL%'
                                   AND SPM.PLAN_OBJECT_TYPE LIKE 'TABLE%'
                                   AND SPM.PLAN_CARDINALITY <> 1 ) THEN
                             DBMS_OUTPUT.PUT_LINE('* (<a href="#PHV'||SPM.SQL_PLAN_HASH_VALUE||SPM.KEY||SPM.MO||'">ID:'||spm.PLAN_LINE_ID
                             ||'</a>) 1st Operation returned '||SPM.OUTPUT_ROWS||' rows.');
                             DBMS_OUTPUT.PUT_LINE('=>Issue Category: <RED>Unselective condition or input</RED>');
                             :issue_blind_condition := 1;
                             --DBMS_OUTPUT.PUT_LINE('=>Suggestion: If you think the 1st Operation returned too many rows, make it selective.');
                             DBMS_OUTPUT.PUT_LINE('<blue>Action Item : DEVELOPMENT TEAM</BLUE>');
                             DBMS_OUTPUT.PUT_LINE('=>Suggestion: Check if the 1st Operation can use more selective condition.');
                             DBMS_OUTPUT.PUT_LINE('.');
                         END IF;
                   END IF;
                END IF;
             END IF;
/* when high volume data in 1st opr, check gtt or pl/sql table ends */
--- 1st opr end
        END IF;  -- end of 1st operation check.

/*********************************************************************************************************************************/
/* CHECK 0 STATS START */
/* CHECK 0 STATS END */

/* from 1ST opr stats check starts */
--             IF (SPM.TP = 'EXEO' AND SPM.MO >= 1 AND SPM.PLAN_OPTIONS in ('FULL','STORAGE FULL')
--                 AND SPM.PLAN_CARDINALITY <> SPM.OUTPUT_ROWS
--                 AND SPM.OUTPUT_ROWS > 1
--                 AND ABS(SPM.PLAN_CARDINALITY - SPM.OUTPUT_ROWS)/SPM.OUTPUT_ROWS > (:L_ACCESS_RATIO*2/100) ) THEN
-- round(SPM.OUTPUT_ROWS/decode(SPM.STARTS,null,1,0,1,SPM.STARTS)/decode(T.NUM_ROWS,null,1,0,1,T.NUM_ROWS),2)*100
/*
14
13----------
12 Y    EXEC 12
11
10 Y
09----------
08

MAX(SAMPLE_TIME)
SAMPLE_TIME <= SMP.FIRST_REFRESH_TIME + 1/86400
*/

        IF (SPM.TP = 'EXEO' AND SPM.MO >= 1
            AND ( SPM.PLAN_CARDINALITY = 1 or ( SPM.PLAN_OPTIONS LIKE '%FULL%' ) )
            AND  SPM.OUTPUT_ROWS > 1 AND SPM.PLAN_OBJECT_NAME IS NOT NULL)
           THEN
                 -- ONLINE 5*2/100 = 10%+ WHEN ONLINE, IT START FROM 10%+
                 -- BATCH 10*2/100 = 20%+ WHEN BATCH, IT STARTS FROM 20%+
                  :L_1ST_OPR_STATUS := 3;
                  :L_WHERE_LOG := 'EXEO 1ST OPR 10%+ GAP ESTIMATION';
                  /*exeo 1*/
                  /*
                  SELECT nvl( (SELECT TO_DATE(LAST_LOAD_TIME,'YYYY-MM-DD HH24:MI:SS') LAST_LOAD_TIME
                               FROM ( SELECT LAST_LOAD_TIME  LAST_LOAD_TIME
                               --FROM ( SELECT TO_char(LAST_LOAD_TIME,'YYYY-MM-DD HH24:MI:SS')  LAST_LOAD_TIME
                                      FROM GV$SQL
                                      WHERE SQL_ID = :L_SQL_ID
                                      AND PLAN_HASH_VALUE = :L_PLAN_HASH_VALUE
                                      AND INST_ID = SM.INST_ID
                                    --AND TO_CHAR(LAST_LOAD_TIME,'YYYY-MM-DD HH24:MI:SS') <= SM.START_TIME ),
                                      AND TO_DATE(LAST_LOAD_TIME,'YYYY-MM-DD HH24:MI:SS') <= TO_DATE(SM.START_TIME,'YYYY-MM-DD HH24:MI:SS')
                                      ORDER BY 1 DESC
                                    )
                               WHERE ROWNUM = 1 ) ,
                               nvl( (SELECT MAX(sample_time) LAST_LOAD_TIME
                                     FROM GV$ACTIVE_SESSION_HISTORY
                                     WHERE SQL_ID = :L_SQL_ID
                                     AND SQL_PLAN_HASH_VALUE = :L_PLAN_HASH_VALUE
                                     AND INST_ID = SM.INST_ID
                                     AND IN_HARD_PARSE = 'Y'
                                     AND TO_CHAR(SAMPLE_TIME,'YYYY-MM-DD HH24:MI:SS') <= SM.START_TIME ),
                                     nvl( (SELECT MAX(sample_time) LAST_LOAD_TIME
                                           FROM DBA_HIST_ACTIVE_SESS_HISTORY
                                           WHERE SQL_ID = :L_SQL_ID
                                           AND SQL_PLAN_HASH_VALUE = :L_PLAN_HASH_VALUE
                                           AND INSTANCE_NUMBER = SM.INST_ID
                                           AND IN_HARD_PARSE = 'Y'
                                           AND TO_CHAR(SAMPLE_TIME,'YYYY-MM-DD HH24:MI:SS') <= SM.START_TIME )
                                          , to_date('1000-01-01 00:00:01','YYYY-MM-DD HH24:MI:SS')
                                        )
                                  )
                              )
                  INTO :L_last_load_time
                  FROM DUAL;
                  :L_WHERE_LOG := 'TEST ESTIMATION'||:L_last_load_time;
                  IF ( to_date(:L_last_load_time,'YYYY-MM-DD HH24:MI:SS') = to_date('1000-01-01 00:00:01','YYYY-MM-DD HH24:MI:SS') ) THEN
                       :L_last_load_time := SM.START_TIME;
                       :L_last_load_time_CORRECT := 'NO';
                  END IF;

                  DBMS_OUTPUT.PUT_LINE('ADJ_last_load_time: '||:L_last_load_time||' correct:'||:L_last_load_time_correct);
                  */
                  /*exeo 1*/
                  IF ( SPM.PLAN_OBJECT_TYPE LIKE 'TABLE%' and spm.object# is not null
                      AND to_date(:L_last_load_time,'YYYY-MM-DD HH24:MI:SS') <> to_date('1000-01-01 00:00:01','YYYY-MM-DD HH24:MI:SS') ) THEN

                       :L_WHERE_LOG := 'EXEO 1ST OPR 10%+ GAP ESTIMATION on table';

                       select ROWCNT, to_char(ANALYZETIME,'YYYY-MON-DD HH24:MI:SS'), FLAGS
                       into :L_ROWCNT, :L_ANALYZETIME, :L_FLAGS
                       from (
                        select h.rowcnt ROWCNT,  h.ANALYZETIME ANALYZETIME, NVL(TO_CHAR(FLAGS),'REAL_TIME_STATS') FLAGS
/* sma19c realtime : savtime : 01-DEC-00 01.00.00.000000 AM +00:00 OR FLAGS IS NULL */
                        from   SYS.WRI$_OPTSTAT_TAB_HISTORY h
                        where  h.OBJ# = spm.object#
                        and    to_date(h.ANALYZETIME,'YYYY-MM-DD HH24:MI:SS') <= to_date(:L_last_load_time,'YYYY-MM-DD HH24:MI:SS')
                        union all
                        select  t.num_rows, t.LAST_ANALYZED ANALYZETIME, 'CURRENT_STATS' FLAGS
                        from dba_tables t
                        where t.table_name  = spm.PLAN_OBJECT_NAME
                        and   t.owner       = spm.PLAN_OBJECT_OWNER
                        and   t.temporary <> 'Y'
                        --and   o.object_id = spm.object#
                        and   to_date(t.LAST_ANALYZED,'YYYY-MM-DD HH24:MI:SS') <= to_date(:L_last_load_time,'YYYY-MM-DD HH24:MI:SS')
                        union all
/* 20200713 */          select -1, sysdate-100000, 'NONE' FLAGS from dual
                        order by 2 desc
                       )
                       where rownum = 1;
                  ELSIF ( SPM.PLAN_OBJECT_TYPE LIKE 'INDEX%' and spm.object# is not null
                         AND to_date(:L_last_load_time,'YYYY-MM-DD HH24:MI:SS') <> to_date('1000-01-01 00:00:01','YYYY-MM-DD HH24:MI:SS') )
                  THEN
                      :L_WHERE_LOG := 'EXEO 1ST OPR 10%+ GAP ESTIMATION on index';
/*20180411*/           select ROWCNT, TO_CHAR(ANALYZETIME,'YYYY-MON-DD HH24:MI:SS'), FLAGS
                              into :L_ROWCNT, :L_ANALYZETIME, :L_FLAGS
                       from (
                        select h.rowcnt ROWCNT, h.ANALYZETIME ANALYZETIME, NVL(TO_CHAR(FLAGS),'REAL_TIME_STATS') FLAGS
                        from  SYS.WRI$_OPTSTAT_IND_HISTORY h
                        where h.OBJ# = spm.object#
                        and   to_date(h.ANALYZETIME,'YYYY-MM-DD HH24:MI:SS') <=   to_date(:L_last_load_time,'YYYY-MM-DD HH24:MI:SS')
                        union all
                        select  i.num_rows, i.LAST_ANALYZED ANALYZETIME, 'CURRENT_STATS' FLAGS
                        from dba_indexes i
                        where i.index_name =  spm.PLAN_OBJECT_NAME
                        and   i.owner      =  spm.PLAN_OBJECT_OWNER
                        and   i.temporary <> 'Y'
                        --and   o.object_id = spm.object#
                        and  to_date(i.LAST_ANALYZED,'YYYY-MM-DD HH24:MI:SS') <=  to_date(:L_last_load_time,'YYYY-MM-DD HH24:MI:SS')
                        union all
                        select -1, sysdate-100000, 'NONE' FLAGS from dual   --20200714
                        order by 2 desc
                        )
                       where rownum = 1;
                  END IF;
/* v3 nostat(:l_rowcnt=-1), output_row > 0,
AND SPM.MO >= 1  AND SPM.PLAN_CARDINALITY = 1   AND  SPM.OUTPUT_ROWS > 1   */

--           DBMS_OUTPUT.PUT_LINE('* test '||spm.PLAN_OBJECT_NAME||'-'||:L_ROWCNT);

                  IF (:L_FLAGS = 'REAL_TIME_STATS') THEN
                       DBMS_OUTPUT.PUT_LINE('+ '||SPM.PLAN_OBJECT_NAME||' <blue>used a real time stats</blue> on '||:L_ANALYZETIME||' (<a href="#PHV'||SPM.SQL_PLAN_HASH_VALUE||SPM.KEY||SPM.MO||'">ID:'||spm.PLAN_LINE_ID||'</a>).');
                  END IF;
                  IF( :L_FLAGS <> 'REAL_TIME_STATS' AND :L_ROWCNT = -1 AND spm.PLAN_OBJECT_TYPE LIKE 'INDEX%' and spm.object# is not null ) THEN
                      DBMS_OUTPUT.PUT_LINE('* Analysis');
                      DBMS_OUTPUT.PUT_LINE('* (<a href="#PHV'||SPM.SQL_PLAN_HASH_VALUE||SPM.KEY||SPM.MO||'">ID:'||spm.PLAN_LINE_ID||
                      '</a>) The operation had inaccurate cardinality estimation. (CARD vs ROWS : '||SPM.PLAN_CARDINALITY
                      ||'*'||SPM.STARTS||' vs '||SPM.OUTPUT_ROWS||')');
                      IF( :L_last_load_time_CORRECT = 'NO' ) THEN
                         DBMS_OUTPUT.PUT_LINE('+ Could not find exact hard parsing time. But when the sql was executed on '||sm.start_time||',');
                      END IF;
                      DBMS_OUTPUT.PUT_LINE('+ '||SPM.PLAN_OBJECT_NAME||' had <RED>NO STATIC STATS</RED> (ID:'||spm.PLAN_LINE_ID||').');
                      DBMS_OUTPUT.PUT_LINE('=>Issue Category: <RED>Cardinality estimation*</RED>'); :issue_inac_card_estim := 1;
                      DBMS_OUTPUT.PUT_LINE('<blue>Action Item : DEVELOPMENT TEAM/OPERATION TEAM/PSR</BLUE>');
                      DBMS_OUTPUT.PUT_LINE('=>Suggestion: Check if dynamic sampling was working properly');
                      DBMS_OUTPUT.PUT_LINE('=>Suggestion: Check if the sql borrowed the existing plan (PHV) in memory');
                      DBMS_OUTPUT.PUT_LINE('=>Suggestion: Work how '||SPM.PLAN_OBJECT_NAME||' can have correct stats at the run-time');
                  /*v3 20190429*/
                      DBMS_OUTPUT.PUT_LINE('=>Suggestion: Check if the join method, '||SPM.JOIN_METHOD||' was decided by any hint as well.');
                  END IF;
                  IF( :L_FLAGS <> 'REAL_TIME_STATS' AND :L_ROWCNT > -1
                      AND :error_from_sm = 0
                      AND to_date(:L_last_load_time,'YYYY-MM-DD HH24:MI:SS') <> to_date('1000-01-01 00:00:01','YYYY-MM-DD HH24:MI:SS')
                      --AND sign(to_date(:L_last_load_time,'YYYY-MM-DD HH24:MI:SS') - TO_Date(:L_ANALYZETIME,'YYYY-MON-DD HH24:MI:SS')) > 1
                      ) then

                    IF ( :L_ROWCNT = 0 ) THEN

                      DBMS_OUTPUT.PUT_LINE('* Analysis');
                      DBMS_OUTPUT.PUT_LINE('* (<a href="#PHV'||SPM.SQL_PLAN_HASH_VALUE||SPM.KEY||SPM.MO||'">ID:'||spm.PLAN_LINE_ID||
                      '</a>) The operation had inaccurate cardinality estimation. (CARD vs ROWS : '||SPM.PLAN_CARDINALITY
                      ||'*'||SPM.STARTS||' vs '||SPM.OUTPUT_ROWS||')');
                      IF( :L_last_load_time_CORRECT = 'NO' ) THEN
                         DBMS_OUTPUT.PUT_LINE('+ Could not find exact hard parsing time. But when the sql was executed on '||sm.start_time||',');
                      END IF;
                      DBMS_OUTPUT.PUT_LINE('+ '||SPM.PLAN_OBJECT_NAME||' had <RED>'||:L_ROWCNT||'</RED> as a statistics row on '||:L_ANALYZETIME||' (ID:'||spm.PLAN_LINE_ID||').');
                      DBMS_OUTPUT.PUT_LINE('=>Issue Category: <RED>Cardinality estimation*</RED>'); :issue_inac_card_estim := 1;
                      DBMS_OUTPUT.PUT_LINE('<blue>Action Item : DEVELOPMENT TEAM/OPERATION TEAM</BLUE>');
                      DBMS_OUTPUT.PUT_LINE('=>Suggestion: If the program always deletes all rows before it finishes, delete stats and use dynamic statistics');
                      IF ( spm.PLAN_OBJECT_TYPE LIKE 'TABLE%' and spm.PLAN_OBJECT_NAME = upper(spm.PLAN_OBJECT_NAME) ) THEN
                           DBMS_OUTPUT.PUT_LINE('=>i.e. <blue>EXEC DBMS_STATS.DELETE_TABLE_STATS('''||spm.PLAN_OBJECT_OWNER||''','''||spm.PLAN_OBJECT_NAME||''');</blue>');
                      ELSIF ( spm.PLAN_OBJECT_TYPE LIKE 'TABLE%' and spm.PLAN_OBJECT_NAME = lower(spm.PLAN_OBJECT_NAME) ) THEN
                           DBMS_OUTPUT.PUT_LINE('=>i.e. <blue>EXEC DBMS_STATS.DELETE_TABLE_STATS('''||spm.PLAN_OBJECT_OWNER||''',''"'||spm.PLAN_OBJECT_NAME||'"'');</blue>');
                      ELSIF ( spm.PLAN_OBJECT_TYPE LIKE 'INDEX%' ) THEN
                           SELECT NVL( (
                                  SELECT TABLE_NAME
                                  FROM DBA_INDEXES
                                  WHERE INDEX_NAME = spm.PLAN_OBJECT_NAME AND OWNER = spm.PLAN_OBJECT_OWNER ),
                                  'N/A' )
                           INTO :L_TABLE_NAME
                           FROM DUAL ;
                           IF ( :L_TABLE_NAME <> 'N/A' AND  :L_TABLE_NAME = UPPER(:L_TABLE_NAME) ) THEN
                             DBMS_OUTPUT.PUT_LINE('=>i.e. <blue>EXEC DBMS_STATS.DELETE_TABLE_STATS('''||spm.PLAN_OBJECT_OWNER||''','''|| :L_TABLE_NAME||''');</blue>');
                           ELSIF ( :L_TABLE_NAME <> 'N/A' AND  :L_TABLE_NAME = LOWER(:L_TABLE_NAME) ) THEN
                             DBMS_OUTPUT.PUT_LINE('=>i.e. <blue>EXEC DBMS_STATS.DELETE_TABLE_STATS('''||spm.PLAN_OBJECT_OWNER||''',''"'|| :L_TABLE_NAME||'"'');</blue>');
                           END IF;
                      END IF;
-- for v3.  ADD STAT WARNING
                      DBMS_OUTPUT.PUT_LINE('=>Suggestion: If any program never deletes all rows before it finishes, gather stats');
                      IF ( spm.PLAN_OBJECT_TYPE LIKE 'TABLE%' and spm.PLAN_OBJECT_NAME = UPPER(spm.PLAN_OBJECT_NAME) ) THEN
                           DBMS_OUTPUT.PUT_LINE('=>i.e. <blue>EXEC DBMS_STATS.GATHER_TABLE_STATS('''||spm.PLAN_OBJECT_OWNER||''','''||spm.PLAN_OBJECT_NAME||''',NO_INVALIDATE=>FALSE);</blue>');
                      ELSIF ( spm.PLAN_OBJECT_TYPE LIKE 'TABLE%' and spm.PLAN_OBJECT_NAME = LOWER(spm.PLAN_OBJECT_NAME) ) THEN
                           DBMS_OUTPUT.PUT_LINE('=>i.e. <blue>EXEC DBMS_STATS.GATHER_TABLE_STATS('''||spm.PLAN_OBJECT_OWNER||''',''"'||spm.PLAN_OBJECT_NAME||'"'',NO_INVALIDATE=>FALSE);</blue>');
                      ELSIF ( spm.PLAN_OBJECT_TYPE LIKE 'INDEX%' ) THEN
                           SELECT NVL( (
                                  SELECT TABLE_NAME
                                  FROM DBA_INDEXES
                                  WHERE INDEX_NAME = spm.PLAN_OBJECT_NAME AND OWNER = spm.PLAN_OBJECT_OWNER ),
                                  'N/A' )
                           INTO :L_TABLE_NAME
                           FROM DUAL ;
                           IF ( :L_TABLE_NAME <> 'N/A' AND :L_TABLE_NAME = UPPER(:L_TABLE_NAME) ) THEN
                             DBMS_OUTPUT.PUT_LINE('=>i.e. <blue>EXEC DBMS_STATS.GATHER_TABLE_STATS('''||spm.PLAN_OBJECT_OWNER||''','''|| :L_TABLE_NAME||''',NO_INVALIDATE=>FALSE);</blue>');
                           ELSIF ( :L_TABLE_NAME <> 'N/A' AND :L_TABLE_NAME = LOWER(:L_TABLE_NAME) ) THEN
                             DBMS_OUTPUT.PUT_LINE('=>i.e. <blue>EXEC DBMS_STATS.GATHER_TABLE_STATS('''||spm.PLAN_OBJECT_OWNER||''',''"'|| :L_TABLE_NAME||'"'',NO_INVALIDATE=>FALSE);</blue>');
                           END IF;
                      END IF;
/*v3 change logic */
                  ELSIF ( :L_FLAGS <> 'REAL_TIME_STATS' AND   :L_ROWCNT > 0 AND
                            ( SPM.OUTPUT_ROWS < :L_ROWCNT*0.7 or SPM.OUTPUT_ROWS > :L_ROWCNT*1.3 )  AND
                            ( SPM.PLAN_OPTIONS LIKE '%FULL%'  /* or  SPM.PLAN_OPERATION = 'INDEX' ) */
                              or SPM.PLAN_OBJECT_TYPE = 'INDEX'   /* except unique index scan */    )  AND
                            ( (   SPM.MO > 1 AND ( SPM.JOIN_METHOD = 'NESTED LOOPS' or SPM.JOIN_METHOD IS NULL )   -- jseo
                                  AND  :error_from_sm = 0 and SPM.OUTPUT_ROWS > :L_ACCESS_RATIO*:L_ACCESS_RATIO*:L_ACCESS_RATIO*:L_ACCESS_RATIO
                                  and :L_PRV_CARDINALITY <> 1                 /* suspect the previous operation */
                                  and spm.output_rows <> spm.JOIN_OUTPUT_ROWS /* best filtering */
                               )
                              OR (SPM.MO = 1)
                            )
/* 20200611*/               and ( SPM.OUTPUT_ROWS * SPM.STARTS <> SPM.OUTPUT_ROWS )
/* 20200625*/               and ( SPM.PLAN_CARDINALITY * SPM.STARTS <> SPM.OUTPUT_ROWS )
/* 20200625*/               and ( SPM.PLAN_CARDINALITY * SPM.STARTS < SPM.OUTPUT_ROWS*0.95 OR SPM.PLAN_CARDINALITY * SPM.STARTS > SPM.OUTPUT_ROWS*1.05 )
                          ) THEN
                      DBMS_OUTPUT.PUT_LINE('* Analysis');
                      DBMS_OUTPUT.PUT_LINE('* (<a href="#PHV'||SPM.SQL_PLAN_HASH_VALUE||SPM.KEY||SPM.MO||'">ID:'||spm.PLAN_LINE_ID||
                      '</a>) The operation had inaccurate cardinality estimation. (CARD vs ROWS : '||SPM.PLAN_CARDINALITY
                      ||'*'||SPM.STARTS||' vs '||SPM.OUTPUT_ROWS||')');
                      IF( :L_last_load_time_CORRECT = 'NO' ) THEN
                         DBMS_OUTPUT.PUT_LINE('+ Could not find exact hard parsing time. But when the sql was executed on '||sm.start_time||',');
                      END IF;
                      DBMS_OUTPUT.PUT_LINE('+ '||SPM.PLAN_OBJECT_NAME||' had <BLUE>'||:L_ROWCNT||'</BLUE> as a statistics row on '||:L_ANALYZETIME||' (ID:'||spm.PLAN_LINE_ID||').');
                      DBMS_OUTPUT.PUT_LINE('=>Issue Category: <RED>Cardinality estimation**</RED>'); :issue_inac_card_estim := 1;
                      DBMS_OUTPUT.PUT_LINE('<blue>Action Item : DEVELOPMENT TEAM/PSR</BLUE>');
                      DBMS_OUTPUT.PUT_LINE('=>Suggestion: Check stats on '||:L_ANALYZETIME||' Consider of gathering stats on right time.');
                      --DBMS_OUTPUT.PUT_LINE('=>Suggestion: Check related condition, bind peeked value, function constant/bind, embedded hint and etc, if needed.');
                      --DBMS_OUTPUT.PUT_LINE('=>Suggestion: Check if Adaptive Cursor Sharing is working properly.');
                      /*v3*/
                      DBMS_OUTPUT.PUT_LINE('=>Suggestion: Check if the join method, '||spm.join_method||' was decided by any hint as well.');
                      if (:L_ROWCNT = 1 ) then
                        DBMS_OUTPUT.PUT_LINE('=>Suggestion: Check if function constant is used');
                        DBMS_OUTPUT.PUT_LINE('=>Suggestion: Check if the bind input is out of range from low value to high value');
                        DBMS_OUTPUT.PUT_LINE('=>Suggestion: Check if the bind input is in the histogram');
                      end if;
                      IF ( SPM.access_predicates IS NOT NULL
                           AND ( SUBSTR(SPM.access_predicates,2) LIKE '%(%'
                             OR  UPPER(SPM.access_predicates) LIKE '%ROWNUM%'
                             OR  UPPER(SPM.access_predicates) LIKE '% OR %'
                             OR  UPPER(SPM.access_predicates) LIKE '%/*+%' )
                         ) THEN
                           DBMS_OUTPUT.PUT_LINE('+ (OID:'||SPM.MO||') AP:' ||SUBSTR(SPM.access_predicates,  1,120));
                           DBMS_OUTPUT.PUT_LINE(SUBSTR(SPM.access_predicates,121,240));
                           DBMS_OUTPUT.PUT_LINE(SUBSTR(SPM.access_predicates,241,360));
                      END IF;
                      IF ( SPM.filter_predicates IS NOT NULL
                           AND ( SUBSTR(SPM.filter_predicates,2) LIKE '%(%'
                             OR  UPPER(SPM.filter_predicates) LIKE '%ROWNUM%'
                             OR  UPPER(SPM.filter_predicates) LIKE '% OR %'
                             OR  UPPER(SPM.filter_predicates) LIKE '%/*+%' )
                         ) THEN
                           DBMS_OUTPUT.PUT_LINE('+ (OID:'||SPM.MO||') FP:' ||SUBSTR(SPM.filter_predicates,  1,120));
                           DBMS_OUTPUT.PUT_LINE(SUBSTR(SPM.filter_predicates,121,240));
                           DBMS_OUTPUT.PUT_LINE(SUBSTR(SPM.filter_predicates,241,360));
                      END IF;
                      DBMS_OUTPUT.PUT_LINE('.');  --jjj
                    END IF;
                  END IF;
                  IF (:issue_inac_card_estim = 1) THEN
                    :l_co5 := :l_co4;
                    :l_co4 := :l_co3;
                    :l_co3 := :l_co2;
                    :l_co2 := :l_co1;
                    :l_co1 := spm.mo;
                  END IF;
        END IF ;
/* from 2nd opr stats check ends */


/* SMA19C 20200514   20200529
   WHEN SORT ORDER BY STOPKEY, PROVIDE THE SUGGESTION TO ELIMINATE SORT ORDER BY STOPKEY
 */
        IF (SPM.TP = 'EXEO' AND SPM.MO >= 1 AND SPM.PLAN_OPERATION = 'SORT' AND SPM.PLAN_OPTIONS = 'ORDER BY STOPKEY' AND :L_PRV_NR*0.30 > SPM.OUTPUT_ROWS ) THEN
           DBMS_OUTPUT.PUT_LINE('* Analysis');
           DBMS_OUTPUT.PUT_LINE('* (<a href="#PHV'||SPM.SQL_PLAN_HASH_VALUE||SPM.KEY||SPM.MO||'">ID:'||spm.PLAN_LINE_ID||'</a>)SORT ORDER BY STOPKEY ('||:L_PRV_NR||' => '||SPM.OUTPUT_ROWS||')');
           DBMS_OUTPUT.PUT_LINE('=>Issue Category: <RED>Throw-away********</RED>'); :issue_throw_away := 1;
           DBMS_OUTPUT.PUT_LINE('<blue>Action Item : DEVELOPMENT TEAM</BLUE>');
           if (:issue_error = 1) then
             DBMS_OUTPUT.PUT_LINE('=>Note: Since the sql met the error, the throw-away issue might not be correct.');
           end if;
           DBMS_OUTPUT.PUT_LINE('=>Suggestion1: ');
           DBMS_OUTPUT.PUT_LINE('+=> Modify ORDER BY CLAUSE only with columns in one index. And in the WHERE CLAUSE, modify the access predicates columns of the same index');
           DBMS_OUTPUT.PUT_LINE('+=> And then check if SORTING operation is gone in the execution plan.');
           DBMS_OUTPUT.PUT_LINE('=>Suggestion2: ');
           DBMS_OUTPUT.PUT_LINE('+=> If Suggestion1 is not possible, the sql needs more selective condition');
           DBMS_OUTPUT.PUT_LINE('.');
        END IF;

/*
  new throw-away logic.
  - object throw away
  - join throw away
  - view throw away

*/
        IF ( SPM.TP = 'EXEO'  AND SPM.MO >= 1
             AND
/* 1*/       (  (:L_PRV_NR*0.30 > SPM.OUTPUT_ROWS and :L_PRV_OBJECT_TYPE LIKE 'INDEX%' and SPM.PLAN_OBJECT_TYPE like 'TABLE%' and SPM.JOIN_METHOD = 'NESTED LOOPS' AND :L_PRV_PID <> SPM.PLAN_PARENT_ID)
/* 1-1*/     OR (:L_PRV_NR*0.30 > SPM.OUTPUT_ROWS and :L_PRV_OBJECT_TYPE LIKE 'INDEX%' and SPM.PLAN_OBJECT_TYPE like 'TABLE%' and SPM.JOIN_METHOD IS NULL
                  AND SPM.MO =2 AND :L_PRV_PID <> SPM.PLAN_PARENT_ID )
/* 2*/       OR (:L_PRV_NR*0.30 > SPM.OUTPUT_ROWS and :L_PRV_OBJECT_TYPE LIKE 'INDEX%' and :L_PRV_OPERATION LIKE 'INDEX%' and SPM.PLAN_OBJECT_TYPE like 'TABLE%' and SPM.JOIN_METHOD = 'NESTED LOOPS'
                  AND :L_PRV_PID <> SPM.PLAN_PARENT_ID )
/* 3*/       OR (:L_PRV_NR*0.30 > SPM.OUTPUT_ROWS and :L_PRV_OPERATION = 'NESTED LOOPS' and SPM.PLAN_OBJECT_TYPE like 'TABLE%' and SPM.JOIN_METHOD = 'NESTED LOOPS')
/* 4*/       OR (:L_PPRV_NR*0.30 > SPM.OUTPUT_ROWS and :L_PPRV_OBJECT_TYPE LIKE 'INDEX%' and SPM.PLAN_OBJECT_TYPE like 'TABLE%' and SPM.JOIN_METHOD = 'NESTED LOOPS'
                 AND :L_PRV_OPERATION = 'NESTED LOOPS' /*AND :L_PPRV_QBLOCK = SPM.QBLOCK_NAME*/ )
/* 5*/       OR (:L_PPRV_NR*0.30 > SPM.OUTPUT_ROWS and SPM.PLAN_OBJECT_TYPE like 'TABLE%' and SPM.JOIN_METHOD = 'NESTED LOOPS' AND :L_PRV_OPERATION = 'NESTED LOOPS'
                 /*AND :L_PPRV_QBLOCK = SPM.QBLOCK_NAME*/ )
/* 6*/       OR (:L_PRV_NR*0.30 > SPM.OUTPUT_ROWS and :L_PRV_OBJECT_TYPE LIKE 'INDEX%' and SPM.PLAN_OBJECT_TYPE like 'TABLE%' AND SPM.JOIN_METHOD = 'HASH JOIN'
                  AND :L_PRV_PID <> SPM.PLAN_PARENT_ID )
             )
             AND ( ( :L_ACCESS_RATIO =5 AND :L_PRV_NR > 1000 ) OR ( :L_ACCESS_RATIO >5 AND :L_PRV_NR > 50000 ) )
           )
        THEN
              DBMS_OUTPUT.PUT_LINE('* Analysis');
              DBMS_OUTPUT.PUT_LINE('* (<a href="#PHV'||SPM.SQL_PLAN_HASH_VALUE||SPM.KEY||SPM.MO||'">ID:'||spm.PLAN_LINE_ID||'</a>) The number of rows are reduced from <RED>'
              ||:L_PRV_NR||'</RED> to <RED>'||SPM.OUTPUT_ROWS||'</RED>.');
              :issue_throw_away := 1;
             IF (SPM.access_predicates IS NOT NULL OR SPM.filter_predicates IS NOT NULL) THEN
                 -- DBMS_OUTPUT.PUT_LINE('At OID:'||:L_NEXT_MO);
                  IF ( SPM.access_predicates IS NOT NULL ) THEN
                      DBMS_OUTPUT.PUT_LINE('+ (OID:'||SPM.MO||') AP:' ||SUBSTR(SPM.access_predicates,  1,120));
                      DBMS_OUTPUT.PUT_LINE(SUBSTR(SPM.access_predicates,121,240));
                      DBMS_OUTPUT.PUT_LINE(SUBSTR(SPM.access_predicates,241,360));
                  END IF;
                  IF ( SPM.filter_predicates IS NOT NULL ) THEN
                      DBMS_OUTPUT.PUT_LINE('+ (OID:'||SPM.MO||') FP:' ||SUBSTR(SPM.filter_predicates,  1,120));
                      DBMS_OUTPUT.PUT_LINE(SUBSTR(SPM.filter_predicates,121,240));
                      DBMS_OUTPUT.PUT_LINE(SUBSTR(SPM.filter_predicates,241,360));
                  END IF;
              END IF;
/* 20200804 FP COLUMN STATS BEGIN */
              IF (SPM.PLAN_OBJECT_TYPE like 'TABLE%' AND SPM.filter_predicates IS NOT NULL ) THEN NULL;

                 :L_CUR_OBJECT_OWNER  := SPM.PLAN_OBJECT_OWNER;
                 :L_CUR_OBJECT_NAME   := SPM.PLAN_OBJECT_NAME;
                 :L_CUR_OBJECT_ALIAS  := SPM.OBJECT_ALIAS;
                 :L_FILTER_PREDICATES := SPM.filter_predicates;

                 FOR SFP IN ( select
                      --        OBJECT_NAME, OBJECT_ALIAS,
                              tc_name, NUM_DISTINCT, ROUND((NUM_ROWS-NUM_NULLS)/GREATEST(NUM_DISTINCT,1),2) ROW_PER_VALUE,
                              NUM_ROWS-NUM_NULLS NUM_ROWS, NUM_NULLS, HISTOGRAM,
                      --        P1, instr(fp, ' ', p1, 1)-P1  P1E, P2, instr(fp, ' ', p2, 1)-P2 P2E,
                              substr(fp, p1, decode( SIGN(instr(fp, ' ', p1, 1)-P1), -1,1000, 0,1000, instr(fp, ' ', p1, 1)-P1 ))  ttoken1
                      --        DECODE( P2,0,NULL,
                      --                DECODE( SIGN(P1+instr(fp, ' ', p1, 1)-P1 -P2-instr(fp, ' ', p2, 1)+P2),0, NULL,-1,NULL,
                      --                        substr(fp, p2, decode( SIGN(instr(fp, ' ', p2, 1)-P2), -1,1000, 0,1000, instr(fp, ' ', p2, 1)-P2 ))))  ttoken2,
                      --        FP
                              from (
                                select object_name, OBJECT_ALIAS, tc_name, tc_size, fp_size,
                                  instr(fp, tc_name, 1) p1, instr(fp, tc_name, instr(fp, tc_name, 1)+1) p2,
                                  --instr(fp, tc_name, (instr(fp, tc_name, 1)+1)+1) p3,
                                  NUM_DISTINCT, NUM_ROWS, NUM_NULLS, HISTOGRAM,
                                  fp
                                from (
                                    select :L_CUR_OBJECT_NAME object_name, SUBSTR(:L_CUR_OBJECT_ALIAS,1,INSTR(:L_CUR_OBJECT_ALIAS,'@',1)-1) OBJECT_ALIAS ,
                                    tc.column_name tc_name, length(tc.column_name) tc_size,
                                    length(replace(:L_FILTER_PREDICATES,'"','')) fp_size,
                                    replace(:L_FILTER_PREDICATES,'"','') fp,
                                    TC.NUM_DISTINCT, T.NUM_ROWS, TC.NUM_NULLS, TC.HISTOGRAM
                                    from  dba_tab_columns tc  , DBA_TABLES T
                                    where :L_CUR_OBJECT_NAME = tc.table_name
                                    and   :L_CUR_OBJECT_OWNER = tc.owner
                                    and   T.TABLE_name = tc.table_name
                                    and   T.owner = tc.owner
                                    and  ( :L_FILTER_PREDICATES like '%"'||SUBSTR(:L_CUR_OBJECT_ALIAS,1,INSTR(:L_CUR_OBJECT_ALIAS,'@',1)-1)||'"."'||tc.column_name||'"%'
                                    or :L_FILTER_PREDICATES like '%"'||tc.column_name||'"%' )
                             ))
                             order by ROUND((NUM_ROWS-NUM_NULLS)/GREATEST(NUM_DISTINCT,1),2)
                            )
                 LOOP
                     DBMS_OUTPUT.PUT_LINE(sfp.tc_name||' has '||sfp.row_per_value||' row(s) per value ('||sfp.num_distinct||' ndvs), '||sfp.num_rows||' not null rows, '
                     ||sfp.num_nulls||' null rows and '||sfp.histogram||' histogram. The column is used in sample predicates ('||sfp.ttoken1||')' );
                 END LOOP;
              END IF;
/* 20200804 FP COLUMN STATS END   */
              DBMS_OUTPUT.PUT_LINE('=>Issue Category: <RED>Throw-away*</RED>'); :issue_throw_away := 1;
              DBMS_OUTPUT.PUT_LINE('<blue>Action Item : DEVELOPMENT TEAM/PSR</BLUE>');
           if (:issue_error = 1) then
             DBMS_OUTPUT.PUT_LINE('=>Note: Since the sql met the error, the throw-away issue might not be correct.');
           end if;
              DBMS_OUTPUT.PUT_LINE('=>Suggestion: 0. Check if wrong index was selected due to wrong join order or some hint or histogram or etc');
              DBMS_OUTPUT.PUT_LINE('=>Suggestion: 1. Find which column condition(s) mostly reduced the number of rows at (OID:'||SPM.MO||')');
              IF ( :L_PRV_OBJECT_TYPE LIKE 'INDEX%'  ) THEN
                 DBMS_OUTPUT.PUT_LINE('=>Suggestion: 2. And discuss appending the column(s) into '||:L_PRV_OBJECT||' with PSR DB team, if needed.');
                /*
                 select nvl((select substr(SYS_CONNECT_BY_PATH(COLUMN_NAME, ','),2) COLUMN_COMBINATION
                  from (select  INDEX_NAME, COLUMN_NAME, count(*) OVER ( partition by INDEX_NAME ) cnt, COLUMN_POSITION seq
                        from  DBA_IND_COLUMNS
                        where INDEX_OWNER = :L_PRV_OBJECT_OWNER
                        and   INDEX_NAME  = :L_PRV_OBJECT )
                  where   seq=cnt
                  start with   seq=1
                  connect by prior   seq+1=seq and prior INDEX_NAME = INDEX_NAME), 'N/A' )  into :L_COLUMN_COMBINATION
                FROM DUAL ; */

              BEGIN
                 select nvl((SELECT INDEX_TYPE FROM DBA_INDEXES WHERE OWNER = :L_PRV_OBJECT_OWNER  AND INDEX_NAME = :L_PRV_OBJECT ), 'N/A' )
                 into :L_INDEX_TYPE
                 FROM DUAL ;
                 :L_COLUMN_EXPRESSION := null ;
              IF ( :L_INDEX_TYPE <> 'N/A' ) THEN
                 FOR IDX IN (
                --SMA19C 20191203
                               select  IC.COLUMN_NAME, IC.COLUMN_POSITION, TC.HISTOGRAM
                               from  DBA_IND_COLUMNS IC, DBA_TAB_COLS TC
                               where IC.INDEX_OWNER = :L_PRV_OBJECT_OWNER
                               and   IC.INDEX_NAME  = :L_PRV_OBJECT
                               and   TC.OWNER       = IC.TABLE_OWNER
                               and   TC.TABLE_NAME  = IC.TABLE_NAME
                               and   TC.COLUMN_NAME = IC.COLUMN_NAME
                               order by  IC.COLUMN_POSITION  )
                 LOOP
                    IF ( IDX.COLUMN_NAME LIKE 'SYS_%$' and :L_INDEX_TYPE LIKE 'FUNC%' ) THEN
                      SELECT A.COLUMN_EXPRESSION INTO :L_COLUMN_EXPRESSION
                      FROM  DBA_IND_EXPRESSIONS A
                      where A.INDEX_OWNER = :L_PRV_OBJECT_OWNER
                      and   A.INDEX_NAME  = :L_PRV_OBJECT
                      AND   A.COLUMN_POSITION = IDX.COLUMN_POSITION ;
                    END IF;
                    IF ( IDX.COLUMN_POSITION = 1 AND IDX.COLUMN_NAME LIKE 'SYS_%$'  and :L_INDEX_TYPE LIKE 'FUNC%') THEN
                       :L_COLUMN_COMBINATION :=  :L_COLUMN_EXPRESSION;
                    ELSIF ( IDX.COLUMN_POSITION = 1 AND IDX.COLUMN_NAME NOT LIKE 'SYS_%$' ) THEN
                      :L_COLUMN_COMBINATION :=  IDX.COLUMN_NAME;
                    ELSIF ( IDX.COLUMN_POSITION > 1 AND IDX.COLUMN_NAME LIKE 'SYS_%$'  and :L_INDEX_TYPE LIKE 'FUNC%') THEN
                      :L_COLUMN_COMBINATION := :L_COLUMN_COMBINATION||','||:L_COLUMN_EXPRESSION;
                    ELSIF ( IDX.COLUMN_POSITION > 1 AND  IDX.COLUMN_NAME NOT LIKE 'SYS_%$' ) THEN
                      :L_COLUMN_COMBINATION := :L_COLUMN_COMBINATION||','||IDX.COLUMN_NAME;
                    END IF ;
                --SMA19C 20191203
                    IF ( IDX.HISTOGRAM <> 'NONE' AND IDX.COLUMN_NAME LIKE 'SYS_%$' and :L_INDEX_TYPE LIKE 'FUNC%' ) THEN
                      DBMS_OUTPUT.PUT_LINE('=>Note: '||:L_COLUMN_EXPRESSION||'('||IDX.COLUMN_NAME||') has '||IDX.HISTOGRAM||' histogram');
                    ELSIF ( IDX.HISTOGRAM <> 'NONE' AND :L_INDEX_TYPE NOT LIKE 'FUNC%' ) THEN
                      DBMS_OUTPUT.PUT_LINE('=>Note: '||IDX.COLUMN_NAME||' has '||IDX.HISTOGRAM||' histogram');
                    END IF ;
                 END LOOP;
                IF ( :L_COLUMN_COMBINATION IS NOT NULL ) THEN
                  DBMS_OUTPUT.PUT_LINE('=>Note: '||:L_PRV_OBJECT||' has ('||:L_COLUMN_COMBINATION||')');
                  :L_COLUMN_COMBINATION := NULL;   -- V2.6
                END IF ;
              END IF;
              END;
              ELSIF ( :L_PPRV_OBJECT_TYPE LIKE 'INDEX%' and SPM.PLAN_OBJECT_TYPE like 'TABLE%' ) THEN
                 DBMS_OUTPUT.PUT_LINE('=>Suggestion: 2. And discuss appending the column(s) into '||:L_PPRV_OBJECT||' with PSR DB team, if needed.');
                 /*
                 select nvl((select substr(SYS_CONNECT_BY_PATH(COLUMN_NAME, ','),2) COLUMN_COMBINATION
                  from (select  INDEX_NAME, COLUMN_NAME, count(*) OVER ( partition by INDEX_NAME ) cnt, COLUMN_POSITION seq
                        from  DBA_IND_COLUMNS
                        where INDEX_OWNER = :L_PPRV_OBJECT_OWNER
                        and   INDEX_NAME  = :L_PPRV_OBJECT )
                  where   seq=cnt
                  start with   seq=1
                  connect by prior   seq+1=seq and prior INDEX_NAME = INDEX_NAME), 'N/A' )  into :L_COLUMN_COMBINATION
                FROM DUAL ;
                */
              BEGIN
                 select nvl((SELECT INDEX_TYPE FROM DBA_INDEXES WHERE OWNER = :L_PPRV_OBJECT_OWNER  AND INDEX_NAME = :L_PPRV_OBJECT ), 'N/A' )
                 into :L_INDEX_TYPE
                 FROM DUAL ;
                 :L_COLUMN_EXPRESSION := null ;
              IF ( :L_INDEX_TYPE <> 'N/A' ) THEN
                 FOR IDX IN (
                 --SMA19C 20191203
                               select  IC.COLUMN_NAME, IC.COLUMN_POSITION, TC.HISTOGRAM
                               from  DBA_IND_COLUMNS IC, DBA_TAB_COLS TC
                               where IC.INDEX_OWNER = :L_PPRV_OBJECT_OWNER
                               and   IC.INDEX_NAME  = :L_PPRV_OBJECT
                               and   TC.OWNER       = IC.TABLE_OWNER
                               and   TC.TABLE_NAME  = IC.TABLE_NAME
                               and   TC.COLUMN_NAME = IC.COLUMN_NAME
                               order by  IC.COLUMN_POSITION   )
                 LOOP
                    IF ( IDX.COLUMN_NAME LIKE 'SYS_%$' and :L_INDEX_TYPE LIKE 'FUNC%' ) THEN
                      SELECT A.COLUMN_EXPRESSION INTO :L_COLUMN_EXPRESSION
                      FROM  DBA_IND_EXPRESSIONS A
                      where A.INDEX_OWNER = :L_PPRV_OBJECT_OWNER
                      and   A.INDEX_NAME  = :L_PPRV_OBJECT
                      AND   A.COLUMN_POSITION = IDX.COLUMN_POSITION ;
                    END IF;
                    IF ( IDX.COLUMN_POSITION = 1 AND IDX.COLUMN_NAME LIKE 'SYS_%$'  and :L_INDEX_TYPE LIKE 'FUNC%') THEN
                       :L_COLUMN_COMBINATION :=  :L_COLUMN_EXPRESSION;
                    ELSIF ( IDX.COLUMN_POSITION = 1 AND IDX.COLUMN_NAME NOT LIKE 'SYS_%$' ) THEN
                      :L_COLUMN_COMBINATION :=  IDX.COLUMN_NAME;
                    ELSIF ( IDX.COLUMN_POSITION > 1 AND IDX.COLUMN_NAME LIKE 'SYS_%$'  and :L_INDEX_TYPE LIKE 'FUNC%') THEN
                      :L_COLUMN_COMBINATION := :L_COLUMN_COMBINATION||','||:L_COLUMN_EXPRESSION;
                    ELSIF ( IDX.COLUMN_POSITION > 1 AND  IDX.COLUMN_NAME NOT LIKE 'SYS_%$' ) THEN
                      :L_COLUMN_COMBINATION := :L_COLUMN_COMBINATION||','||IDX.COLUMN_NAME;
                    END IF ;
                 --SMA19C 20191203
                    IF ( IDX.HISTOGRAM <> 'NONE' AND IDX.COLUMN_NAME LIKE 'SYS_%$' and :L_INDEX_TYPE LIKE 'FUNC%' ) THEN
                      DBMS_OUTPUT.PUT_LINE('=>Note: '||:L_COLUMN_EXPRESSION||'('||IDX.COLUMN_NAME||') has '||IDX.HISTOGRAM||' histogram');
                    ELSIF ( IDX.HISTOGRAM <> 'NONE' AND :L_INDEX_TYPE NOT LIKE 'FUNC%' ) THEN
                      DBMS_OUTPUT.PUT_LINE('=>Note: '||IDX.COLUMN_NAME||' has '||IDX.HISTOGRAM||' histogram');
                    END IF ;
                 END LOOP;
                IF ( :L_COLUMN_COMBINATION IS NOT NULL ) THEN
                  DBMS_OUTPUT.PUT_LINE('=>Note: '||:L_PPRV_OBJECT||' has ('||:L_COLUMN_COMBINATION||')');
                  :L_COLUMN_COMBINATION := NULL;   --V2.6
                END IF ;
              END IF;
              END;
              ELSIF (:L_PPRV_NR*0.30 > SPM.OUTPUT_ROWS and SPM.PLAN_OBJECT_TYPE like 'TABLE%' and SPM.JOIN_METHOD = 'NESTED LOOPS' AND :L_PRV_OPERATION = 'NESTED LOOPS') THEN
                 DBMS_OUTPUT.PUT_LINE('=>Suggestion: 2. And discuss creating an index including the column(s) or modifying condition to use the existing index with PSR DB team, if needed.');
              END IF ;
              DBMS_OUTPUT.PUT_LINE('.');

                    :l_co5 := :l_co4;
                    :l_co4 := :l_co3;
                    :l_co3 := :l_co2;
                    :l_co2 := :l_co1;
                    :l_co1 := spm.mo;

        END IF;
        IF ( SPM.TP = 'EXEO'  AND SPM.MO > 1
             AND
/* 6-1*/        (:L_PRV_NR*0.10 > SPM.OUTPUT_ROWS
/* 6-2*/          AND ( :L_PRV_OBJECT_TYPE LIKE 'INDEX%'  OR :L_PRV_OBJECT_TYPE LIKE 'TABLE%' )
                  AND SPM.PLAN_OBJECT_TYPE like 'TABLE%'
                  AND SPM.JOIN_METHOD = 'HASH JOIN'
                  AND :L_PRV_PID = SPM.PLAN_PARENT_ID )
             AND ( ( :L_ACCESS_RATIO =5 AND :L_PRV_NR > 1000 ) OR ( :L_ACCESS_RATIO >5 AND :L_PRV_NR > 50000 ) )
--V3
             AND SPM.OUTPUT_ROWS >= spm.join_output_rows
           )
        THEN
              DBMS_OUTPUT.PUT_LINE('* Analysis');
              DBMS_OUTPUT.PUT_LINE('* (<a href="#PHV'||SPM.SQL_PLAN_HASH_VALUE||SPM.KEY||SPM.MO||'">ID:'||spm.PLAN_LINE_ID
              ||'</a>) The number of rows are reduced from <RED>'||:L_PRV_NR||'</RED> to <RED>'||SPM.OUTPUT_ROWS||'</RED>.');
        --      :issue_throw_away := 1;
             IF (SPM.access_predicates IS NOT NULL OR SPM.filter_predicates IS NOT NULL) THEN
                 -- DBMS_OUTPUT.PUT_LINE('At OID:'||:L_NEXT_MO);
                  IF ( SPM.access_predicates IS NOT NULL ) THEN
                      DBMS_OUTPUT.PUT_LINE('+ (OID:'||SPM.MO||') AP:' ||SUBSTR(SPM.access_predicates,  1,120));
                      DBMS_OUTPUT.PUT_LINE(SUBSTR(SPM.access_predicates,121,240));
                      DBMS_OUTPUT.PUT_LINE(SUBSTR(SPM.access_predicates,241,360));
                  END IF;
                  IF ( SPM.filter_predicates IS NOT NULL ) THEN
                      DBMS_OUTPUT.PUT_LINE('+ (OID:'||SPM.MO||') FP:' ||SUBSTR(SPM.filter_predicates,  1,120));
                      DBMS_OUTPUT.PUT_LINE(SUBSTR(SPM.filter_predicates,121,240));
                      DBMS_OUTPUT.PUT_LINE(SUBSTR(SPM.filter_predicates,241,360));
                  END IF;
              END IF;
/* 20200804 FP COLUMN STATS BEGIN */
              IF (SPM.PLAN_OBJECT_TYPE like 'TABLE%' AND SPM.filter_predicates IS NOT NULL ) THEN NULL;

                 :L_CUR_OBJECT_OWNER  := SPM.PLAN_OBJECT_OWNER;
                 :L_CUR_OBJECT_NAME   := SPM.PLAN_OBJECT_NAME;
                 :L_CUR_OBJECT_ALIAS  := SPM.OBJECT_ALIAS;
                 :L_FILTER_PREDICATES := SPM.filter_predicates;

                 FOR SFP IN ( select
                      --        OBJECT_NAME, OBJECT_ALIAS,
                              tc_name, NUM_DISTINCT, ROUND((NUM_ROWS-NUM_NULLS)/GREATEST(NUM_DISTINCT,1),2) ROW_PER_VALUE,
                              NUM_ROWS-NUM_NULLS NUM_ROWS, NUM_NULLS, HISTOGRAM,
                      --        P1, instr(fp, ' ', p1, 1)-P1  P1E, P2, instr(fp, ' ', p2, 1)-P2 P2E,
                              substr(fp, p1, decode( SIGN(instr(fp, ' ', p1, 1)-P1), -1,1000, 0,1000, instr(fp, ' ', p1, 1)-P1 ))  ttoken1
                      --        DECODE( P2,0,NULL,
                      --                DECODE( SIGN(P1+instr(fp, ' ', p1, 1)-P1 -P2-instr(fp, ' ', p2, 1)+P2),0, NULL,-1,NULL,
                      --                        substr(fp, p2, decode( SIGN(instr(fp, ' ', p2, 1)-P2), -1,1000, 0,1000, instr(fp, ' ', p2, 1)-P2 ))))  ttoken2,
                      --        FP
                              from (
                                select object_name, OBJECT_ALIAS, tc_name, tc_size, fp_size,
                                  instr(fp, tc_name, 1) p1, instr(fp, tc_name, instr(fp, tc_name, 1)+1) p2,
                                  --instr(fp, tc_name, (instr(fp, tc_name, 1)+1)+1) p3,
                                  NUM_DISTINCT, NUM_ROWS, NUM_NULLS, HISTOGRAM,
                                  fp
                                from (
                                    select :L_CUR_OBJECT_NAME object_name, SUBSTR(:L_CUR_OBJECT_ALIAS,1,INSTR(:L_CUR_OBJECT_ALIAS,'@',1)-1) OBJECT_ALIAS ,
                                    tc.column_name tc_name, length(tc.column_name) tc_size,
                                    length(replace(:L_FILTER_PREDICATES,'"','')) fp_size,
                                    replace(:L_FILTER_PREDICATES,'"','') fp,
                                    TC.NUM_DISTINCT, T.NUM_ROWS, TC.NUM_NULLS, TC.HISTOGRAM
                                    from  dba_tab_columns tc  , DBA_TABLES T
                                    where :L_CUR_OBJECT_NAME = tc.table_name
                                    and   :L_CUR_OBJECT_OWNER = tc.owner
                                    and   T.TABLE_name = tc.table_name
                                    and   T.owner = tc.owner
                                    and  ( :L_FILTER_PREDICATES like '%"'||SUBSTR(:L_CUR_OBJECT_ALIAS,1,INSTR(:L_CUR_OBJECT_ALIAS,'@',1)-1)||'"."'||tc.column_name||'"%'
                                    or :L_FILTER_PREDICATES like '%"'||tc.column_name||'"%' )
                             ))
                             order by ROUND((NUM_ROWS-NUM_NULLS)/GREATEST(NUM_DISTINCT,1),2)
                            )
                 LOOP
                     DBMS_OUTPUT.PUT_LINE(sfp.tc_name||' has '||sfp.row_per_value||' row(s) per value ('||sfp.num_distinct||' ndvs), '||sfp.num_rows||' not null rows, '
                     ||sfp.num_nulls||' null rows and '||sfp.histogram||' histogram. The column is used in sample predicates ('||sfp.ttoken1||')' );
                 END LOOP;
              END IF;
/* 20200804 FP COLUMN STATS END   */
              DBMS_OUTPUT.PUT_LINE('=>Issue Category: <RED>Throw-away**</RED>'); :issue_throw_away := 1;
--V3
          --  :L_NEXT_MO := SPM.MO + 1;
          --    DBMS_OUTPUT.PUT_LINE('=>Suggestion: 1. Find which column condition(s) mostly reduced the number of rows at (OID:'||:L_NEXT_MO||')');
              DBMS_OUTPUT.PUT_LINE('<blue>Action Item : DEVELOPMENT TEAM</BLUE>');
           if (:issue_error = 1) then
             DBMS_OUTPUT.PUT_LINE('=>Note: Since the sql met the error, the throw-away issue might not be correct.');
           end if;
              DBMS_OUTPUT.PUT_LINE('=>Suggestion: 1. Find which column condition(s) mostly reduced the number of rows at (ID:'||spm.PLAN_LINE_ID||')');
              DBMS_OUTPUT.PUT_LINE('=>Suggestion: 2. And discuss an index creation on '||SPM.PLAN_OBJECT_NAME||' with PSR DB team, if needed.');

                    :l_co5 := :l_co4;
                    :l_co4 := :l_co3;
                    :l_co3 := :l_co2;
                    :l_co2 := :l_co1;
                    :l_co1 := spm.mo;

        END IF;
        /* V3 : This is not reducing after hash join.. it happens before hash join.
        IF ( SPM.TP = 'EXEO'  AND SPM.MO = :L_NEXT_MO AND SPM.PLAN_OPERATION = 'HASH JOIN'
             AND ( :L_PPRV_OBJECT_TYPE LIKE 'INDEX%'  OR :L_PPRV_OBJECT_TYPE LIKE 'TABLE%' )
             AND ( :L_PRV_OBJECT_TYPE  LIKE 'TABLE%' ) ) THEN
              IF (SPM.access_predicates IS NOT NULL OR SPM.filter_predicates IS NOT NULL) THEN
                 -- DBMS_OUTPUT.PUT_LINE('At OID:'||:L_NEXT_MO);
                  IF ( SPM.access_predicates IS NOT NULL ) THEN
                      DBMS_OUTPUT.PUT_LINE('+ (OID:'||SPM.MO||') AP:' ||SUBSTR(SPM.access_predicates,  1,120));
                      DBMS_OUTPUT.PUT_LINE(SUBSTR(SPM.access_predicates,121,240));
                      DBMS_OUTPUT.PUT_LINE(SUBSTR(SPM.access_predicates,241,360));
                  END IF;
                  IF ( SPM.filter_predicates IS NOT NULL ) THEN
                      DBMS_OUTPUT.PUT_LINE('+ (OID:'||SPM.MO||') FP:' ||SUBSTR(SPM.filter_predicates,  1,120));
                      DBMS_OUTPUT.PUT_LINE(SUBSTR(SPM.filter_predicates,121,240));
                      DBMS_OUTPUT.PUT_LINE(SUBSTR(SPM.filter_predicates,241,360));
                  END IF;
                  DBMS_OUTPUT.PUT_LINE('.');
              END IF;
              :L_NEXT_MO := 0;
        END IF ;
        */
        IF ( SPM.TP = 'EXEO'  AND SPM.MO > 1
             AND
/* 7*/       (  (:L_PRV_NR*0.10 > SPM.OUTPUT_ROWS and :L_PRV_OBJECT_TYPE LIKE 'TABLE%' AND SPM.PLAN_OPERATION = 'HASH JOIN' AND :L_PPRV_OBJECT_TYPE LIKE 'INDEX%')
/* 8*/       OR (:L_PRV_NR*0.10 > SPM.OUTPUT_ROWS and :L_PRV_OBJECT_TYPE LIKE 'INDEX%' AND SPM.PLAN_OPERATION = 'HASH JOIN')
/* 9*/       OR (:L_PRV_NR*0.10 > SPM.OUTPUT_ROWS and :L_PRV_OBJECT_TYPE LIKE 'TABLE%' AND SPM.PLAN_OPERATION = 'HASH JOIN' AND :L_PPRV_OBJECT_TYPE LIKE 'TABLE%')
             )
             AND ( ( :L_ACCESS_RATIO =5 AND :L_PRV_NR > 1000 ) OR ( :L_ACCESS_RATIO >5 AND :L_PRV_NR > 50000 ) )
           )
        THEN
              DBMS_OUTPUT.PUT_LINE('* Analysis');
              DBMS_OUTPUT.PUT_LINE('* (<a href="#PHV'||SPM.SQL_PLAN_HASH_VALUE||SPM.KEY||SPM.MO||'">ID:'||spm.PLAN_LINE_ID||'</a>) The number of rows are reduced from <RED>'
              ||:L_PRV_NR||'</RED> to <RED>'||SPM.OUTPUT_ROWS||'</RED>.');
              :issue_throw_away := 1;
             IF (SPM.access_predicates IS NOT NULL OR SPM.filter_predicates IS NOT NULL) THEN
                 -- DBMS_OUTPUT.PUT_LINE('At OID:'||:L_NEXT_MO);
                  IF ( SPM.access_predicates IS NOT NULL ) THEN
                      DBMS_OUTPUT.PUT_LINE('+ (OID:'||SPM.MO||') AP:' ||SUBSTR(SPM.access_predicates,  1,120));
                      DBMS_OUTPUT.PUT_LINE(SUBSTR(SPM.access_predicates,121,240));
                      DBMS_OUTPUT.PUT_LINE(SUBSTR(SPM.access_predicates,241,360));
                  END IF;
                  IF ( SPM.filter_predicates IS NOT NULL ) THEN
                      DBMS_OUTPUT.PUT_LINE('+ (OID:'||SPM.MO||') FP:' ||SUBSTR(SPM.filter_predicates,  1,120));
                      DBMS_OUTPUT.PUT_LINE(SUBSTR(SPM.filter_predicates,121,240));
                      DBMS_OUTPUT.PUT_LINE(SUBSTR(SPM.filter_predicates,241,360));
                  END IF;
              END IF;
/* 20200804 FP COLUMN STATS BEGIN */
              IF (SPM.PLAN_OBJECT_TYPE like 'TABLE%') THEN NULL; END IF;
/* 20200804 FP COLUMN STATS END   */
              DBMS_OUTPUT.PUT_LINE('=>Issue Category: <RED>Throw-away***</RED>'); :issue_throw_away := 1;
--v3
              DBMS_OUTPUT.PUT_LINE('<blue>Action Item : DEVELOPMENT TEAM</BLUE>');
           if (:issue_error = 1) then
             DBMS_OUTPUT.PUT_LINE('=>Note: Since the sql met the error, the throw-away issue might not be correct.');
           end if;
              DBMS_OUTPUT.PUT_LINE('=>Suggestion: 0. Check if HASH join was performed due to hint usage or function usage or etc');
              DBMS_OUTPUT.PUT_LINE('=>Suggestion: 1. Find which column condition(s) mostly reduced the number of rows at (OID:'||SPM.MO||')');
              IF ( :L_PPRV_OBJECT_TYPE LIKE 'INDEX%'  AND :L_PRV_OBJECT_TYPE LIKE 'TABLE%' ) THEN
                 DBMS_OUTPUT.PUT_LINE('=>Suggestion: 2. And discuss appending the column(s) into '||:L_PPRV_OBJECT||' with PSR DB team, if needed.');
                 /*
                 select nvl((select substr(SYS_CONNECT_BY_PATH(COLUMN_NAME, ','),2) COLUMN_COMBINATION
                  from (select  INDEX_NAME, COLUMN_NAME, count(*) OVER ( partition by INDEX_NAME ) cnt, COLUMN_POSITION seq
                        from  DBA_IND_COLUMNS
                        where INDEX_OWNER = :L_PPRV_OBJECT_OWNER
                        and   INDEX_NAME  = :L_PPRV_OBJECT )
                  where   seq=cnt
                  start with   seq=1
                  connect by prior   seq+1=seq and prior INDEX_NAME = INDEX_NAME), 'N/A' )  into :L_COLUMN_COMBINATION
                FROM DUAL ;
                */
              BEGIN
                 select nvl((SELECT INDEX_TYPE FROM DBA_INDEXES WHERE OWNER = :L_PPRV_OBJECT_OWNER  AND INDEX_NAME = :L_PPRV_OBJECT ), 'N/A' )  into :L_INDEX_TYPE
                 FROM DUAL ;
                 :L_COLUMN_EXPRESSION := null ;
              IF (:L_INDEX_TYPE <> 'N/A' ) THEN
                 FOR IDX IN (  
                --SMA19C 20191203
                               select  IC.COLUMN_NAME, IC.COLUMN_POSITION, TC.HISTOGRAM
                               from  DBA_IND_COLUMNS IC, DBA_TAB_COLS TC
                               where IC.INDEX_OWNER = :L_PPRV_OBJECT_OWNER
                               and   IC.INDEX_NAME  = :L_PPRV_OBJECT
                               and   TC.OWNER       = IC.TABLE_OWNER
                               and   TC.TABLE_NAME  = IC.TABLE_NAME
                               and   TC.COLUMN_NAME = IC.COLUMN_NAME
                               order by  IC.COLUMN_POSITION   )
                 LOOP
                    IF ( IDX.COLUMN_NAME LIKE 'SYS_%$' and :L_INDEX_TYPE LIKE 'FUNC%' ) THEN
                      SELECT A.COLUMN_EXPRESSION INTO :L_COLUMN_EXPRESSION
                      FROM  DBA_IND_EXPRESSIONS A
                      where A.INDEX_OWNER = :L_PPRV_OBJECT_OWNER
                      and   A.INDEX_NAME  = :L_PPRV_OBJECT
                      AND   A.COLUMN_POSITION = IDX.COLUMN_POSITION ;
                    END IF;
                    IF ( IDX.COLUMN_POSITION = 1 AND IDX.COLUMN_NAME LIKE 'SYS_%$'  and :L_INDEX_TYPE LIKE 'FUNC%') THEN
                       :L_COLUMN_COMBINATION :=  :L_COLUMN_EXPRESSION;
                    ELSIF ( IDX.COLUMN_POSITION = 1 AND IDX.COLUMN_NAME NOT LIKE 'SYS_%$' ) THEN
                      :L_COLUMN_COMBINATION :=  IDX.COLUMN_NAME;
                    ELSIF ( IDX.COLUMN_POSITION > 1 AND IDX.COLUMN_NAME LIKE 'SYS_%$'  and :L_INDEX_TYPE LIKE 'FUNC%') THEN
                      :L_COLUMN_COMBINATION := :L_COLUMN_COMBINATION||','||:L_COLUMN_EXPRESSION;
                    ELSIF ( IDX.COLUMN_POSITION > 1 AND  IDX.COLUMN_NAME NOT LIKE 'SYS_%$'  ) THEN
                      :L_COLUMN_COMBINATION := :L_COLUMN_COMBINATION||','||IDX.COLUMN_NAME;
                    END IF ;
                --SMA19C 20191203
                    IF ( IDX.HISTOGRAM <> 'NONE' AND IDX.COLUMN_NAME LIKE 'SYS_%$' and :L_INDEX_TYPE LIKE 'FUNC%' ) THEN
                      DBMS_OUTPUT.PUT_LINE('=>Note: '||:L_COLUMN_EXPRESSION||'('||IDX.COLUMN_NAME||') has '||IDX.HISTOGRAM||' histogram');
                    ELSIF ( IDX.HISTOGRAM <> 'NONE' AND :L_INDEX_TYPE NOT LIKE 'FUNC%' ) THEN
                      DBMS_OUTPUT.PUT_LINE('=>Note: '||IDX.COLUMN_NAME||' has '||IDX.HISTOGRAM||' histogram');
                    END IF ;
                 END LOOP;
                IF ( :L_COLUMN_COMBINATION IS NOT NULL ) THEN
                  DBMS_OUTPUT.PUT_LINE('=>Note: '||:L_PPRV_OBJECT||' has ('||:L_COLUMN_COMBINATION||')');
                  :L_COLUMN_COMBINATION := NULL;
                END IF ;
              END IF;
              END;
              ELSIF ( :L_PRV_OBJECT_TYPE LIKE 'INDEX%' ) THEN
                 DBMS_OUTPUT.PUT_LINE('=>Suggestion: 2. And discuss appending the column(s) into '||:L_PRV_OBJECT||' with PSR DB team, if needed.');
                 /*
                 select nvl((select substr(SYS_CONNECT_BY_PATH(COLUMN_NAME, ','),2) COLUMN_COMBINATION
                  from (select  INDEX_NAME, COLUMN_NAME, count(*) OVER ( partition by INDEX_NAME ) cnt, COLUMN_POSITION seq
                        from  DBA_IND_COLUMNS
                        where INDEX_OWNER = :L_PRV_OBJECT_OWNER
                        and   INDEX_NAME  = :L_PRV_OBJECT )
                  where   seq=cnt
                  start with   seq=1
                  connect by prior   seq+1=seq and prior INDEX_NAME = INDEX_NAME), 'N/A' )  into :L_COLUMN_COMBINATION
                FROM DUAL ;
                */
              BEGIN
                 select nvl((SELECT INDEX_TYPE FROM DBA_INDEXES WHERE OWNER = :L_PRV_OBJECT_OWNER  AND INDEX_NAME = :L_PRV_OBJECT ), 'N/A' )  into :L_INDEX_TYPE
                 FROM DUAL ;
                 :L_COLUMN_EXPRESSION := null ;
              IF (:L_INDEX_TYPE <> 'N/A' ) THEN
                 FOR IDX IN (  
                --SMA19C 20191203
                               select  IC.COLUMN_NAME, IC.COLUMN_POSITION, TC.HISTOGRAM
                               from  DBA_IND_COLUMNS IC, DBA_TAB_COLS TC
                               where IC.INDEX_OWNER = :L_PRV_OBJECT_OWNER
                               and   IC.INDEX_NAME  = :L_PRV_OBJECT
                               and   TC.OWNER       = IC.TABLE_OWNER
                               and   TC.TABLE_NAME  = IC.TABLE_NAME
                               and   TC.COLUMN_NAME = IC.COLUMN_NAME
                               order by  IC.COLUMN_POSITION  )
                 LOOP
                    IF ( IDX.COLUMN_NAME LIKE 'SYS_%$' and :L_INDEX_TYPE LIKE 'FUNC%' ) THEN
                      SELECT A.COLUMN_EXPRESSION INTO :L_COLUMN_EXPRESSION
                      FROM  DBA_IND_EXPRESSIONS A
                      where A.INDEX_OWNER = :L_PRV_OBJECT_OWNER
                      and   A.INDEX_NAME  = :L_PRV_OBJECT
                      AND   A.COLUMN_POSITION = IDX.COLUMN_POSITION ;
                    END IF;
                    IF ( IDX.COLUMN_POSITION = 1 AND IDX.COLUMN_NAME LIKE 'SYS_%$'  and :L_INDEX_TYPE LIKE 'FUNC%') THEN
                       :L_COLUMN_COMBINATION :=  :L_COLUMN_EXPRESSION;
                    ELSIF ( IDX.COLUMN_POSITION = 1 AND IDX.COLUMN_NAME NOT LIKE 'SYS_%$' ) THEN
                      :L_COLUMN_COMBINATION :=  IDX.COLUMN_NAME;
                    ELSIF ( IDX.COLUMN_POSITION > 1 AND IDX.COLUMN_NAME LIKE 'SYS_%$'  and :L_INDEX_TYPE LIKE 'FUNC%') THEN
                      :L_COLUMN_COMBINATION := :L_COLUMN_COMBINATION||','||:L_COLUMN_EXPRESSION;
                    ELSIF ( IDX.COLUMN_POSITION > 1 AND  IDX.COLUMN_NAME NOT LIKE 'SYS_%$'  ) THEN
                      :L_COLUMN_COMBINATION := :L_COLUMN_COMBINATION||','||IDX.COLUMN_NAME;
                    END IF ;
                --SMA19C 20191203
                    IF ( IDX.HISTOGRAM <> 'NONE' AND IDX.COLUMN_NAME LIKE 'SYS_%$' and :L_INDEX_TYPE LIKE 'FUNC%' ) THEN
                      DBMS_OUTPUT.PUT_LINE('=>Note: '||:L_COLUMN_EXPRESSION||'('||IDX.COLUMN_NAME||') has '||IDX.HISTOGRAM||' histogram');
                    ELSIF ( IDX.HISTOGRAM <> 'NONE' AND :L_INDEX_TYPE NOT LIKE 'FUNC%' ) THEN
                      DBMS_OUTPUT.PUT_LINE('=>Note: '||IDX.COLUMN_NAME||' has '||IDX.HISTOGRAM||' histogram');
                    END IF ;
                 END LOOP;
                IF ( :L_COLUMN_COMBINATION IS NOT NULL ) THEN
                  DBMS_OUTPUT.PUT_LINE('=>Note: '||:L_PPRV_OBJECT||' has ('||:L_COLUMN_COMBINATION||')');
                  :L_COLUMN_COMBINATION := NULL;
                END IF ;
              END IF;
              END;
              ELSIF (:L_PRV_OBJECT_TYPE LIKE 'TABLE%' AND :L_PPRV_OBJECT_TYPE LIKE 'TABLE%' ) THEN
                 DBMS_OUTPUT.PUT_LINE('=>Suggestion: 2. And discuss creating an index including the column(s) or modifying condition to use the existing index with PSR DB team, if needed.');
              END IF ;
              DBMS_OUTPUT.PUT_LINE('.');

                    :l_co5 := :l_co4;
                    :l_co4 := :l_co3;
                    :l_co3 := :l_co2;
                    :l_co2 := :l_co1;
                    :l_co1 := spm.mo;
        END IF;
        /*  view throw-away starts 20180303 */
        IF  ( SPM.TP = 'EXEO' AND SPM.MO > 1
/* 10*/       AND SPM.PLAN_OPERATION = 'VIEW'  AND SPM.OUTPUT_ROWS <= 0.34*NVL(:L_PRV_NR ,1)
              AND :L_PRV_OPERATION = 'UNION-ALL' AND :L_PRV_OBJECT_TYPE IS NULL
             --AND SPM.OUTPUT_ROWS > 10 * :L_ACCESS_RATIO * :L_ACCESS_RATIO
             --AND (   SM.physical_read_bytes < SPM.physical_read_bytes*10 OR SM.physical_write_bytes < SPM.physical_write_bytes*10 )
             AND ( ( :L_ACCESS_RATIO =5 AND :L_PRV_NR > 1000 ) OR ( :L_ACCESS_RATIO >5 AND :L_PRV_NR > 50000 ) )
             ) THEN   -- 10+% heavy operation with 30+% throw-away
            :L_WHERE_LOG := 'EXEO VIEW THROW-AWAY';

              DBMS_OUTPUT.PUT_LINE('* Analysis');
              DBMS_OUTPUT.PUT_LINE('* (<a href="#PHV'||SPM.SQL_PLAN_HASH_VALUE||SPM.KEY||SPM.MO||'">ID:'||spm.PLAN_LINE_ID||'</a>) The number of rows are reduced from <RED>'
              ||:L_PRV_NR||'</RED> to <RED>'||SPM.OUTPUT_ROWS||'</RED>.');
              :issue_throw_away := 1;

                  IF (  SPM.FILTER_PREDICATES IS NOT NULL AND SPM.QBLOCK_NAME IS NOT NULL
                     ) THEN
                      DBMS_OUTPUT.PUT_LINE('+ FP:' ||SUBSTR(SPM.filter_predicates,  1,120));
                      DBMS_OUTPUT.PUT_LINE(SUBSTR(SPM.filter_predicates,121,240));
                      DBMS_OUTPUT.PUT_LINE(SUBSTR(SPM.filter_predicates,241,360));
                      if (sm.error_number is null) then
                        DBMS_OUTPUT.PUT_LINE('=>Issue Category: <RED>Throw-away****</RED>'); :issue_throw_away := 1;
                        DBMS_OUTPUT.PUT_LINE('<blue>Action Item : DEVELOPMENT TEAM/PSR</BLUE>');
           if (:issue_error = 1) then
             DBMS_OUTPUT.PUT_LINE('=>Note: Since the sql met the error, the throw-away issue might not be correct.');
           end if;
                        DBMS_OUTPUT.PUT_LINE('=>Suggestion: Check how above condition(s) reduced the number of rows and try to relocate condition(s) from (<a href="#PHV'||SPM.SQL_PLAN_HASH_VALUE||SPM.KEY||SPM.MO||'">ID:'||spm.PLAN_LINE_ID||'</a>)');
                      elsif (sm.error_number is not null) then
                        DBMS_OUTPUT.PUT_LINE('=>Issue Category: <RED>Error</RED>');  :issue_error := 1;
                        DBMS_OUTPUT.PUT_LINE('<blue>Action Item : DEVELOPMENT TEAM/PSR</BLUE>');
           if (:issue_error = 1) then
             DBMS_OUTPUT.PUT_LINE('=>Note: Since the sql met the error, the throw-away issue might not be correct.');
           end if;
                        DBMS_OUTPUT.PUT_LINE('=>Suggestion: Check if it was due to error'||sm.error_number);
                        DBMS_OUTPUT.PUT_LINE('If this was not due to error, Check how above condition(s) reduced the number of rows and try to relocate condition(s) from (<a href="#PHV'||SPM.SQL_PLAN_HASH_VALUE||SPM.KEY||SPM.MO||'">ID:'||spm.PLAN_LINE_ID||'</a>)');
                        DBMS_OUTPUT.PUT_LINE('.');
                      end if;
                  ELSE
                      if (sm.error_number is null) then
                        DBMS_OUTPUT.PUT_LINE('=>Issue Category: <RED>Throw-away*****</RED>'); :issue_throw_away := 1;
                        DBMS_OUTPUT.PUT_LINE('<blue>Action Item : DEVELOPMENT TEAM/PSR</BLUE>');
           if (:issue_error = 1) then
             DBMS_OUTPUT.PUT_LINE('=>Note: Since the sql met the error, the throw-away issue might not be correct.');
           end if;
                        DBMS_OUTPUT.PUT_LINE('=>Suggestion: Check how the condition(s) reduced the number of rows and try to relocate condition(s) from (<a href="#PHV'||SPM.SQL_PLAN_HASH_VALUE||SPM.KEY||SPM.MO||'">ID:'||spm.PLAN_LINE_ID||'</a>)');
                        DBMS_OUTPUT.PUT_LINE('.');
                      elsif (sm.error_number is not null) then
                        DBMS_OUTPUT.PUT_LINE('=>Issue Category: <RED>Error</RED>');  :issue_error := 1;
                        DBMS_OUTPUT.PUT_LINE('<blue>Action Item : DEVELOPMENT TEAM/PSR</BLUE>');
           if (:issue_error = 1) then
             DBMS_OUTPUT.PUT_LINE('=>Note: Since the sql met the error, the throw-away issue might not be correct.');
           end if;
                        DBMS_OUTPUT.PUT_LINE('=>Suggestion: Check if it was due to error'||sm.error_number);
                        DBMS_OUTPUT.PUT_LINE('If this was not due to error, Check how the condition(s) reduced the number of rows and try to relocate condition(s) from (<a href="#PHV'||SPM.SQL_PLAN_HASH_VALUE||SPM.KEY||SPM.MO||'">ID:'||spm.PLAN_LINE_ID||'</a>)');
                        DBMS_OUTPUT.PUT_LINE('.');
                      end if;
                  END IF;
                    :l_co5 := :l_co4;
                    :l_co4 := :l_co3;
                    :l_co3 := :l_co2;
                    :l_co2 := :l_co1;
                    :l_co1 := spm.mo;
        END IF ;
        /*  view throw-away ends */
        /* DATA CARTESIAN PRODUCT => 1000 * 1000 WRONG CE OR DATA DISTRIBUTION ISSUE => It will be detected in IO */
        --:L_1ST_MJC := 0;
        --:L_2ND_MJC := 0;
/*********************************************************************************************************************************/
/* merge join start */
        IF ( SPM.TP = 'EXEO' AND (SPM.PLAN_OPERATION = 'MERGE JOIN' OR SPM.JOIN_METHOD = 'MERGE JOIN')
             AND SPM.PLAN_OPERATION NOT IN ('BUFFER','UNION-ALL')
             AND SPM.OUTPUT_ROWS > 1 ) THEN
               :L_WHERE_LOG := 'EXEO MERGE JOIN';
               :L_MJ_STALE_OBJ := NULL;
               IF (CHECK_TABLE_STATS(SPM.PLAN_OBJECT_OWNER,SPM.PLAN_OBJECT_NAME,SPM.PLAN_OBJECT_TYPE) = 'YES'
                   AND SPM.PLAN_OBJECT_TYPE IN ('TABLE')) THEN
                 :L_MJ_STALE_OBJ := ' (Stale Stats: YES)';
                 :L_MJ_STALE_OBJ_STATUS := 1;
               ELSIF (CHECK_INDEX_STATS(SPM.PLAN_OBJECT_OWNER,SPM.PLAN_OBJECT_NAME,SPM.PLAN_OBJECT_TYPE) = 'YES'
                   AND SPM.PLAN_OBJECT_TYPE IN ('INDEX')) THEN
                 :L_MJ_STALE_OBJ := ' (Stale Stats: YES)';
                 :L_MJ_STALE_OBJ_STATUS := 1;
               ELSIF (SPM.PLAN_OPERATION in ('MERGE JOIN','VIEW')) THEN
                 :L_MJ_STALE_OBJ := NULL;
               ELSIF (SPM.PLAN_OBJECT_NAME IS NOT NULL) THEN
                 :L_MJ_STALE_OBJ := ' (Stale Stats: NO)';
               END IF;
                   DBMS_OUTPUT.PUT_LINE('* Analysis');
                   DBMS_OUTPUT.PUT_LINE('* (<a href="#PHV'||SPM.SQL_PLAN_HASH_VALUE||SPM.KEY||SPM.MO||'">ID:'||spm.PLAN_LINE_ID||'</a>)'||rPAD('    ',4-LENGTH(SPM.plan_line_id))
                   ||' MergeJoin at '||nvl(SPM.PLAN_OBJECT_NAME,SPM.PLAN_OPERATION)||:L_MJ_STALE_OBJ||' => '||SPM.OUTPUT_ROWS );
               IF ( SPM.MO = 1 ) THEN  :L_1ST_OPR_STATUS := :L_1ST_OPR_STATUS + 0.1;  END IF;

               IF ( SPM.PLAN_OPERATION = 'MERGE JOIN' AND ( SPM.JOIN_METHOD <> 'MERGE JOIN' OR SPM.JOIN_METHOD IS NULL ) ) THEN
                  IF (    :L_MJ_STALE_OBJ_STATUS = 1 AND :L_1ST_OPR_STATUS in (1.1,3.1)
                    AND ( :L_3RD_MJC < SPM.OUTPUT_ROWS OR :L_2ND_MJC < SPM.OUTPUT_ROWS OR :L_1ST_MJC < SPM.OUTPUT_ROWS ) ) THEN
                     DBMS_OUTPUT.PUT_LINE('=>Issue Category: <RED>Merge Join with Cartesian Product</RED>'); :issue_MJ_CP := 1;
                     DBMS_OUTPUT.PUT_LINE('<blue>Action Item : DEVELOPMENT TEAM/PSR</BLUE>');
                     DBMS_OUTPUT.PUT_LINE('=>Suggestion: Check if MJ was happened due to stale stats, missing join condition and wrong 1ST Operation');
--20200626
                     DBMS_OUTPUT.PUT_LINE('<a href="https://apex.oraclecorp.com/pls/apex/f?p=28906" target="_blank"><blue>Please use SQL PARSER to find Missing-Join</blue></a>');

                     DBMS_OUTPUT.PUT_LINE('.');
                  ELSIF ( :L_MJ_STALE_OBJ_STATUS = 1 AND :L_1ST_OPR_STATUS IN (0,0.1)
                    AND ( :L_3RD_MJC < SPM.OUTPUT_ROWS OR :L_2ND_MJC < SPM.OUTPUT_ROWS OR :L_1ST_MJC < SPM.OUTPUT_ROWS ) ) THEN
                     DBMS_OUTPUT.PUT_LINE('=>Issue Category: <RED>Merge Join with Cartesian Product</RED>'); :issue_MJ_CP := 1;
                     DBMS_OUTPUT.PUT_LINE('<blue>Action Item : DEVELOPMENT TEAM/PSR</BLUE>');
--20200626
                     DBMS_OUTPUT.PUT_LINE('=>Suggestion: Check if MJ was happened due to stale stats and <blue>missing join condition</blue>');
                     DBMS_OUTPUT.PUT_LINE('<a href="https://apex.oraclecorp.com/pls/apex/f?p=28906" target="_blank"><blue>Please use SQL PARSER to find Missing-Join</blue></a>');
                     DBMS_OUTPUT.PUT_LINE('.');
                  ELSIF ( :L_MJ_STALE_OBJ_STATUS = 0 AND :L_1ST_OPR_STATUS in (1.1,3.1)
                    AND ( :L_3RD_MJC < SPM.OUTPUT_ROWS OR :L_2ND_MJC < SPM.OUTPUT_ROWS OR :L_1ST_MJC < SPM.OUTPUT_ROWS ) ) THEN
                     DBMS_OUTPUT.PUT_LINE('=>Issue Category: <RED>Merge Join with Cartesian Product</RED>'); :issue_MJ_CP := 1;
                     DBMS_OUTPUT.PUT_LINE('<blue>Action Item : DEVELOPMENT TEAM/PSR</BLUE>');
                     DBMS_OUTPUT.PUT_LINE('=>Suggestion: Check if MJ was happened due to missing join condition and wrong 1ST Operation');
--20200626
                     DBMS_OUTPUT.PUT_LINE('<a href="https://apex.oraclecorp.com/pls/apex/f?p=28906" target="_blank"><blue>Please use SQL PARSER to find Missing-Join</blue></a>');
                     DBMS_OUTPUT.PUT_LINE('.');
                  ELSIF ( :L_MJ_STALE_OBJ_STATUS = 0 AND :L_1ST_OPR_STATUS IN (0,0.1)
                    AND ( :L_3RD_MJC < SPM.OUTPUT_ROWS OR :L_2ND_MJC < SPM.OUTPUT_ROWS OR :L_1ST_MJC < SPM.OUTPUT_ROWS ) ) THEN
                     DBMS_OUTPUT.PUT_LINE('=>Issue Category: <RED>Merge Join with Cartesian Product</RED>'); :issue_MJ_CP := 1;
                     DBMS_OUTPUT.PUT_LINE('<blue>Action Item : DEVELOPMENT TEAM/PSR</BLUE>');
--20200626
                     DBMS_OUTPUT.PUT_LINE('=>Suggestion: Check if MJ was happened due to <blue>missing join condition</blue>');
                     DBMS_OUTPUT.PUT_LINE('<a href="https://apex.oraclecorp.com/pls/apex/f?p=28906" target="_blank"><blue>Please use SQL PARSER to find Missing-Join</blue></a>');
                     DBMS_OUTPUT.PUT_LINE('.');
                  ELSIF ( :L_MJ_STALE_OBJ_STATUS = 0 AND SPM.OUTPUT_ROWS = :L_1ST_MJC * :L_2ND_MJC ) THEN
                     DBMS_OUTPUT.PUT_LINE('=>Issue Category: <RED>Merge Join with Cartesian Product</RED>'); :issue_MJ_CP := 1;
                     DBMS_OUTPUT.PUT_LINE('<blue>Action Item : DEVELOPMENT TEAM/PSR</BLUE>');
                     DBMS_OUTPUT.PUT_LINE('=>Suggestion: Check if there is any missing join condition or data Cartesian Product');
--20200626
                     DBMS_OUTPUT.PUT_LINE('<a href="https://apex.oraclecorp.com/pls/apex/f?p=28906" target="_blank"><blue>Please use SQL PARSER to find Missing-Join</blue></a>');
                     DBMS_OUTPUT.PUT_LINE('.');
                  ELSIF ( :L_MJ_STALE_OBJ_STATUS = 0  AND (:L_1ST_MJC * :L_2ND_MJC) > SPM.OUTPUT_ROWS
                     AND :L_2ND_MJC < SPM.OUTPUT_ROWS AND :L_1ST_MJC < SPM.OUTPUT_ROWS ) THEN
                     DBMS_OUTPUT.PUT_LINE('=>Issue Category: <RED>Merge Join with Cartesian Product</RED>'); :issue_MJ_CP := 1;
                     DBMS_OUTPUT.PUT_LINE('<blue>Action Item : DEVELOPMENT TEAM/PSR</BLUE>');
                     DBMS_OUTPUT.PUT_LINE('=>Suggestion: Check if there is data Cartesian Product (i.e. unselective col by unselective col)');
                     DBMS_OUTPUT.PUT_LINE('.');
                  ELSIF ( :L_MJ_STALE_OBJ_STATUS = 0  --AND SPM.JOIN_METHOD IS NULL
                     AND (:L_3RD_MJC > SPM.OUTPUT_ROWS OR :L_2ND_MJC > SPM.OUTPUT_ROWS OR :L_1ST_MJC > SPM.OUTPUT_ROWS) ) THEN
                     DBMS_OUTPUT.PUT_LINE('=>Suggestion: suggestion is N/A on this Merge Join');
                     DBMS_OUTPUT.PUT_LINE('.');
                    :l_co4 := :l_co5;
                    :l_co3 := :l_co4;
                    :l_co2 := :l_co3;
                    :l_co1 := :l_co2;
                  ELSE
                      null;
                  END IF;
                  null;
               END IF;
                   --  DBMS_OUTPUT.PUT_LINE('NUM OF MJ'||:L_2ND_MJC||'->'||:L_1ST_MJC||'->'||SPM.OUTPUT_ROWS);
                  :L_3RD_MJC := :L_2ND_MJC;
                  :L_2ND_MJC := :L_1ST_MJC;
                  :L_1ST_MJC := SPM.OUTPUT_ROWS;
                    :l_co5 := :l_co4;
                    :l_co4 := :l_co3;
                    :l_co3 := :l_co2;
                    :l_co2 := :l_co1;
                    :l_co1 := spm.mo;
        END IF;
/*********************************************************************************************************************************/
/* merge join end */
/* CARDINALITY ESTIMATION => COLUMN GROUP STATS OR HISTOGRAM */
/* AS INCORRECT ESTIMATION CAN BE HAPPENED TOO FREQUENTLY, STOP THIS LOGIC 20190117 */
/* domain and skip index with first_rows. */
        -- table() function
        IF ( SPM.TP = 'EXEO'
            AND :error_from_sm = 0
            AND SPM.PLAN_OBJECT_NAME IS NOT NULL AND SPM.PLAN_OPERATION = 'COLLECTION ITERATOR'
            AND SPM.PLAN_OBJECT_TYPE = 'PROCEDURE'  AND SPM.PLAN_CARDINALITY = 8168 AND SPM.OUTPUT_ROWS <> 8168 ) THEN
            DBMS_OUTPUT.PUT_LINE('* Analysis');
            DBMS_OUTPUT.PUT_LINE('* (<a href="#PHV'||SPM.SQL_PLAN_HASH_VALUE||SPM.KEY||SPM.MO||'">ID:'||spm.PLAN_LINE_ID||'</a>) TABLE() funtion cardinality was not estimated properly');
            --DBMS_OUTPUT.PUT_LINE('=>Issue Category: Default estimation'); :error_from_sm := 1;
            DBMS_OUTPUT.PUT_LINE('+ Default estimation was used.');
            DBMS_OUTPUT.PUT_LINE('=>Issue Category: <RED>Cardinality estimation****</RED>'); :issue_inac_card_estim := 1;
            DBMS_OUTPUT.PUT_LINE('<blue>Action Item : OPERATION TEAM</BLUE>');
            DBMS_OUTPUT.PUT_LINE('=>Suggestion: Check there is any Suggestion in ENVIRONMENT NOTE.');
            DBMS_OUTPUT.PUT_LINE('.');
            :L_PPV_MESSAGE := 1;    --20180322
        END IF;
        /* GTT CARDINALITY CHECK IS PERFORMED WHEN 1ST OPR IS NOT GOOD => CHECK FIX_CONTROL OR FLUSH SQL */
        IF ( SPM.TP = 'EXEO' AND SPM.PLAN_OBJECT_TYPE IN ('TABLE (TEMP)','PROCEDURE') AND
            (( SPM.OUTPUT_ROWS > 100    AND :L_ACCESS_RATIO  = 5 ) OR
             ( SPM.OUTPUT_ROWS > 10000  AND :L_ACCESS_RATIO >= 7 )  )
             AND SPM.JOIN_METHOD = 'NESTED LOOPS' ) THEN
          --  DBMS_OUTPUT.PUT_LINE('EXEO LV_GTT) ID:'||LPAD('    ',4-LENGTH(SPM.plan_line_id))||SPM.plan_line_id
          --  ||' OID:'||LPAD('    ',4-LENGTH(SPM.MO))||:L_CUR_OID||' at '||SPM.PLAN_OBJECT_NAME);
          --  DBMS_OUTPUT.PUT_LINE(SPM.PLAN_OBJECT_NAME||' has '||spm.output_rows||' rows)');
            DBMS_OUTPUT.PUT_LINE('* Analysis');
            DBMS_OUTPUT.PUT_LINE('=>Issue Category: <RED>Blind operation</RED>'); :issue_blind_query := 1;
            DBMS_OUTPUT.PUT_LINE('<blue>Action Item : DEVELOPMENT TEAM</BLUE>');
            DBMS_OUTPUT.PUT_LINE('=>Suggestion: Check '||SPM.PLAN_OBJECT_NAME||' has right size of volume data (<a href="#PHV'||SPM.SQL_PLAN_HASH_VALUE||SPM.KEY||SPM.MO||'">ID:'||spm.PLAN_LINE_ID||'</a>).');
            DBMS_OUTPUT.PUT_LINE('.');
            NULL;
        END IF;
        /* VPD */
        IF ( SPM.TP = 'EXEO' ) THEN NULL;
        END IF;
        /* ONE SIDE BOUND NON-EQUAL CONDITION */
        IF ( SPM.TP = 'EXEO' ) THEN NULL;
        END IF;
/* NON MERGEABLE VIEW START : PUSH PREDICATES */
        IF ( SPM.TP = 'EXEO' AND SPM.PLAN_OPERATION = 'HASH JOIN' AND SPM.PLAN_OPTIONS IS NULL AND :L_PRV_OPERATION = 'VIEW'
             AND :L_PRV_NR > SPM.OUTPUT_ROWS ) THEN
             -- DBMS_OUTPUT.PUT_LINE('check object_name : '||:L_PRV_OBJECT||:L_PRV_QBLOCK);
             --  IF ( :L_PRV_OBJECT IS NOT NULL AND :L_PPV_MESSAGE = 0 ) THEN   --20190822
           IF ( :L_PRV_OBJECT IS NOT NULL and :L_PRV_OBJECT not like 'index$_join$%' AND :L_PPV_MESSAGE = 0 ) THEN   --20190822
                    DBMS_OUTPUT.PUT_LINE('* Analysis');
                    DBMS_OUTPUT.PUT_LINE('* (<a href="#PHV'||SPM.SQL_PLAN_HASH_VALUE||SPM.KEY||SPM.MO||'">ID:'||spm.PLAN_LINE_ID||'</a>) Check if pushing predicates into the view, '||:L_PRV_OBJECT||' is not working at ID:'||:L_PRV_ID||'.');
                    DBMS_OUTPUT.PUT_LINE('=>Issue Category: Suspicious <RED>CBO issue</RED>');
                    :issue_cbo := 1;
                    DBMS_OUTPUT.PUT_LINE('<blue>Action Item : DEVELOPMENT TEAM/OPERATION TEAM/PSR TEAM</BLUE>');
                    --DBMS_OUTPUT.PUT_LINE('=>Suggestion: Check if there is any suggestion in ENVIRONMENT NOTE.');
                    DBMS_OUTPUT.PUT_LINE('=>Suggestion: ');

--sma19c 20200217
                    IF ( :L_SQL_PROFILE IS NOT NULL ) THEN
                     DBMS_OUTPUT.PUT_LINE('+ Check if the sql profile, <RED>'||:L_SQL_PROFILE||'</RED> is affecting before do the following action items');
                    END IF;
                    IF ( :L_SQL_PATCH IS NOT NULL ) THEN
                     DBMS_OUTPUT.PUT_LINE('+ Check if the sql patch, <RED>'||:L_SQL_PATCH||'</RED> is affecting before do the following action items');
                    END IF;
                    IF (  :L_SQL_PLAN_BASELINE IS NOT NULL ) THEN
                     DBMS_OUTPUT.PUT_LINE('+ Check if the sql plan baseline, <RED>'||:L_SQL_PLAN_BASELINE||'</RED> is affecting before do the following action items');
                    END IF;

                    DBMS_OUTPUT.PUT_LINE('+ Check if the sql can use PUSH PREDICATES with the following hint in the local environment');
                    DBMS_OUTPUT.PUT_LINE('+ OPT_PARAM(''_optimizer_cost_based_transformation'',''off'')');
                    DBMS_OUTPUT.PUT_LINE('+ Check if the sql has just one level or multiple levels when the above hint doesn''t work');
                    DBMS_OUTPUT.PUT_LINE('+ 1. If the sql has just one level, we can use <blue>PUSH_PRED('||:L_PRV_ALIAS||')</blue>');
                    DBMS_OUTPUT.PUT_LINE('+ 2. If the sql has multiple levels, the query block name can be changed when push predicates starts to work');
                    DBMS_OUTPUT.PUT_LINE('+ 3. We need to provide the query block name into PUSH_PRED(<RED>@qblock</RED> '||:L_PRV_ALIAS||') for the sqlpatch');
                    DBMS_OUTPUT.PUT_LINE('+ <BLUE>STEP 1</BLUE> : How to find query block in the local?');
                    DBMS_OUTPUT.PUT_LINE('+   Find the local environment having same level of code line that the issue (customer) environment has');
                    DBMS_OUTPUT.PUT_LINE('+   Open one editor like SQL DEVELOPER and copy/paste the sql statement');
                    DBMS_OUTPUT.PUT_LINE('+   And place <blue>PUSH_PRED('||:L_PRV_ALIAS||'</blue>) in the right query block having <blue>'||:L_PRV_OBJECT||'</blue>.');
                    DBMS_OUTPUT.PUT_LINE('+   And run explain plan against the sql having the hint, get Query_Block_Name from PLAN_TABLE.QBLOCK_NAME');

                   -- DBMS_OUTPUT.PUT_LINE('+ OPT_PARAM(''_optimizer_push_pred_cost_based'',''false'')');
                   -- DBMS_OUTPUT.PUT_LINE('+ OPT_PARAM(''_optimizer_squ_bottomup'',''false'')');
                         --
                         DBMS_OUTPUT.PUT_LINE('+ <BLUE>STEP 2</BLUE> : How to test it');
                         DBMS_OUTPUT.PUT_LINE('+   Open sqlhc_<date>_<time>_'||:l_sql_id||'_14_executable_script.sql within the sqlhc.zip file');
                         DBMS_OUTPUT.PUT_LINE('+   Make it run-able with small modification and run it under the issue environment.');
                         DBMS_OUTPUT.PUT_LINE('+   Change -OUTLINE and -ALIAS with +OUTLINE and +ALIAS each');
                         DBMS_OUTPUT.PUT_LINE('+   Add OPT_PARAM(''_optimizer_cost_based_transformation'',''off'') in the issue SQL');
                         DBMS_OUTPUT.PUT_LINE('+   Or add PUSH_PRED('||:L_PRV_ALIAS||') in the right place of the sql');
                         DBMS_OUTPUT.PUT_LINE('+   Save the file');

                         DBMS_OUTPUT.PUT_LINE('+   <blue>How to execute the test script</blue>');
                         DBMS_OUTPUT.PUT_LINE('$sqlplus / as sysdba');
                         IF ( :L_PDB <> 'NOPDB' ) THEN
                               DBMS_OUTPUT.PUT_LINE('SQL><blue>'||:L_PDB||'</blue>');
                         END IF;
                         DBMS_OUTPUT.PUT_LINE('SQL>start sqlhc_<date>_<time>_'||:l_sql_id||'_14_executable_script.sql');
                         DBMS_OUTPUT.PUT_LINE('+ Review the execution plan');
                         DBMS_OUTPUT.PUT_LINE('+ If the plan is good, search with "<blue>PUSH_PRED(</blue> or <blue>'||:L_PRV_ALIAS||'</blue>" in the OUTLINE and get the Query_Block_Name');
                         --
                         DBMS_OUTPUT.PUT_LINE('+');
--sma19c 20200217
                         DBMS_OUTPUT.PUT_LINE('+ <blue>How to setup SQL PATCH and flush SQL</blue> only when the above test was performed good');
                         DBMS_OUTPUT.PUT_LINE('$sqlplus / as sysdba');
                         IF ( :L_PDB <> 'NOPDB' ) THEN
                               DBMS_OUTPUT.PUT_LINE('SQL><blue>'||:L_PDB||'</blue>');
                         END IF;
                         DBMS_OUTPUT.PUT_LINE('SQL>start coe_gen_sql_patch.sql');
                         DBMS_OUTPUT.PUT_LINE('1st parameter : '||:L_SQL_ID);
                         DBMS_OUTPUT.PUT_LINE('2nd parameter : '||'OPT_PARAM(''_optimizer_cost_based_transformation'',''off'')');
                         DBMS_OUTPUT.PUT_LINE('Or');
                         DBMS_OUTPUT.PUT_LINE('2nd parameter : PUSH_PRED(<blue>@Query_Block_Name</blue> '||:L_PRV_ALIAS||')');
                         DBMS_OUTPUT.PUT_LINE('3rd parameter : '||'BUG(BUGNO)_'||:L_SQL_ID);
                         DBMS_OUTPUT.PUT_LINE('<BLUE></BLUE>');
                         DBMS_OUTPUT.PUT_LINE('Note. In 2nd parameter, <blue>@Query_Block_Name</blue> should be replaced with @Qname from <BLUE>STEP 1</BLUE> or <BLUE>STEP 2</BLUE>. If the sql has one level, no need @Query_Block_Name');
                         DBMS_OUTPUT.PUT_LINE('<blue></blue>');
                         DBMS_OUTPUT.PUT_LINE('+ <blue>How to flush sql : execute flushsql under all nodes</blue>');
                         DBMS_OUTPUT.PUT_LINE('SQL>start flushsql.sql');
                         DBMS_OUTPUT.PUT_LINE('1st parameter : '||:L_SQL_ID);
                         DBMS_OUTPUT.PUT_LINE('<BLUE></BLUE>');
                         DBMS_OUTPUT.PUT_LINE('One RCA : JPPD does not work for multi level complex union all view' );
                         DBMS_OUTPUT.PUT_LINE('It''s RDBMS FIX : <BLUE>BUG-18969167 QKSFM_JPPD_18969167 "enhance JPPD index heuristic for set query blocks"</BLUE>' );
                   :L_PPV_MESSAGE := 1;
           ELSIF ( :L_PRV_OBJECT IS NULL AND :L_PPV_MESSAGE = 0 ) THEN
                    DBMS_OUTPUT.PUT_LINE('* Analysis');
                    DBMS_OUTPUT.PUT_LINE('* (<a href="#PHV'||SPM.SQL_PLAN_HASH_VALUE||SPM.KEY||SPM.MO||'">ID:'||spm.PLAN_LINE_ID||'</a>) Check if push predicates into the view is not working at ID:'||:L_PRV_ID||'.');
                    DBMS_OUTPUT.PUT_LINE('=>Issue Category: Suspicious <RED>CBO issue</RED>');
                    :issue_cbo := 1;
                    DBMS_OUTPUT.PUT_LINE('<blue>Action Item : DEVELOPMENT TEAM/OPERATION TEAM/PSR</BLUE>');
                    DBMS_OUTPUT.PUT_LINE('=>Suggestion: Check if there is any suggestion in ENVIRONMENT NOTE');
                    DBMS_OUTPUT.PUT_LINE('=>Suggestion: Check if the following hint has PUSH PREDICATES worked with PSR DB team');
                    --DBMS_OUTPUT.PUT_LINE('+ OPT_PARAM(''_optimizer_cost_based_transformation'',''off'')');
                    DBMS_OUTPUT.PUT_LINE('+ PUSH_PRED(@qblock object_name@alias)');
                    DBMS_OUTPUT.PUT_LINE('.');
                   -- DBMS_OUTPUT.PUT_LINE('+ OPT_PARAM(''_optimizer_push_pred_cost_based'',''false'')');
                   -- DBMS_OUTPUT.PUT_LINE('+ OPT_PARAM(''_optimizer_squ_bottomup'',''false'')');
                         DBMS_OUTPUT.PUT_LINE('+');
                         DBMS_OUTPUT.PUT_LINE('=>Open sqlhc_<date>_<time>_'||:l_sql_id||'_14_executable_script.sql within the sqlhc.zip file');
                         DBMS_OUTPUT.PUT_LINE('=>Make it run-able with small modification and run it under the issue environment.');
                         --DBMS_OUTPUT.PUT_LINE('=>Add OPT_PARAM(''_optimizer_cost_based_transformation'',''off'') in the issue SQL');
                         DBMS_OUTPUT.PUT_LINE('=>Add PUSH_PRED(@qblock object_name@alias)');
                         DBMS_OUTPUT.PUT_LINE('$sqlplus / as sysdba');
                         IF ( :L_PDB <> 'NOPDB' ) THEN
                               DBMS_OUTPUT.PUT_LINE('SQL><blue>'||:L_PDB||'</blue>');
                         END IF;
                         DBMS_OUTPUT.PUT_LINE('SQL>start sqlhc_<date>_<time>_'||:l_sql_id||'_14_executable_script.sql');
                         DBMS_OUTPUT.PUT_LINE('Review the execution plan');
                         DBMS_OUTPUT.PUT_LINE('If the plan is good, apply the sql patch as below');
                         DBMS_OUTPUT.PUT_LINE('+');
                         DBMS_OUTPUT.PUT_LINE('=>How to setup SQL PATCH and flush SQL');
                         DBMS_OUTPUT.PUT_LINE('$sqlplus / as sysdba');
                         IF ( :L_PDB <> 'NOPDB' ) THEN
                               DBMS_OUTPUT.PUT_LINE('SQL><blue>'||:L_PDB||'</blue>');
                         END IF;
                         DBMS_OUTPUT.PUT_LINE('SQL>start coe_gen_sql_patch.sql');
                         DBMS_OUTPUT.PUT_LINE('1st parameter : '||:L_SQL_ID);
                         DBMS_OUTPUT.PUT_LINE('2nd parameter : '||'OPT_PARAM(''_optimizer_cost_based_transformation'',''off'')');
                         DBMS_OUTPUT.PUT_LINE('Or');
                         DBMS_OUTPUT.PUT_LINE('2nd parameter : '||'PUSH_PRED(@QBLOCK VIEW_NAME@ALIAS');
                         DBMS_OUTPUT.PUT_LINE('3rd parameter : '||'BUG_<BUGNO>_'||:L_SQL_ID);
                         DBMS_OUTPUT.PUT_LINE('=>How to flush sql : execute flushsql under all nodes');
                         DBMS_OUTPUT.PUT_LINE('SQL>start flushsql.sql');
                         DBMS_OUTPUT.PUT_LINE('1st parameter : '||:L_SQL_ID);
                    :L_PPV_MESSAGE := 1;
           END IF;
                    :l_co5 := :l_co4;
                    :l_co4 := :l_co3;
                    :l_co3 := :l_co2;
                    :l_co2 := :l_co1;
                    :l_co1 := spm.mo;
        END IF;
/* NON MERGEABLE VIEW END : PUSH PREDICATES */

        IF ( SPM.TP = 'EXEO' ) THEN
      --    DBMS_OUTPUT.PUT_LINE(spm.mo||'=>'||:L_PRV_ALIAS||':'||SPM.OBJECT_ALIAS||':::'||:L_PRV_QBLOCK||':'||SPM.QBLOCK_NAME);
         :L_PPRV_KEY    := :L_PRV_KEY;
         :L_PPRV_PHV    := :L_PRV_PHV;
         :L_PPRV_ID     := :L_PRV_ID;
         :L_PPRV_PID    := :L_PRV_PID;
         :L_PPRV_NR     := :L_PRV_NR;
         :L_PPRV_OBJECT_TYPE  := :L_PRV_OBJECT_TYPE;
         :L_PPRV_OBJECT := :L_PRV_OBJECT;
         :L_PPRV_OPERATION := :L_PRV_OPERATION;
         :L_PPRV_QBLOCK := :L_PRV_QBLOCK;
         :L_PPRV_ALIAS  := :L_PRV_ALIAS;

         :L_PRV_KEY     := SPM.KEY;
         :L_PRV_PHV     := SPM.SQL_PLAN_HASH_VALUE;
         :L_PRV_ID      := SPM.PLAN_LINE_ID;
         :L_PRV_PID     := SPM.PLAN_PARENT_ID;
         :L_PRV_NR      := SPM.OUTPUT_ROWS;
         :L_PRV_OBJECT_TYPE  := SPM.PLAN_OBJECT_TYPE;
         :L_PRV_OBJECT  := SPM.PLAN_OBJECT_NAME;
         :L_PRV_OPERATION := SPM.PLAN_OPERATION;
         :L_PRV_QBLOCK  := SPM.QBLOCK_NAME;
         :L_PRV_ALIAS   := SPM.OBJECT_ALIAS;
         :L_PRV_CARDINALITY := SPM.PLAN_CARDINALITY;

         :L_PPRV_OBJECT_OWNER := :L_PRV_OBJECT_OWNER;
         :L_PRV_OBJECT_OWNER  := SPM.PLAN_OBJECT_OWNER;


        END IF;
/* IO start */
        IF ( SPM.TP = 'IO' ) THEN   --- access dba_tables and check 10% or not.
/*
      DBMS_OUTPUT.PUT_LINE('IO TEST PHV:'||SPM.SQL_PLAN_HASH_VALUE||', KEY:'||SPM.KEY||' MO:'||SPM.MO||' PID:'||spm.PLAN_LINE_ID
                           ||',R_MB:'||SPM.R_MB||',W_MB:'||SPM.W_MB||',PGA:'||SPM.PGA_MB||',TEMP:'||SPM.TEMP_MB);
*/
           IF ( SPM.PLAN_OBJECT_TYPE LIKE 'INDEX%' ) THEN
              :L_WHERE_LOG := 'IO INDEX B '||SPM.PLAN_OBJECT_OWNER||'.'||SPM.PLAN_OBJECT_NAME;

              SELECT NVL(
              (SELECT  D.TABLE_NAME
               FROM  DBA_INDEXES D
               WHERE D.INDEX_NAME = SPM.PLAN_OBJECT_NAME
               AND   D.OWNER = SPM.PLAN_OBJECT_OWNER
               AND   ROWNUM = 1),'N/A') INTO :L_TABLE_NAME
              FROM DUAL  ;

              IF (:L_TABLE_NAME <> 'N/A') THEN
               SELECT /*+ LEADING(D,T,I) USE_NL(T,I) PUSH_PRED(T) PUSH_PRED(I) */ round(SPM.OUTPUT_ROWS/decode(SPM.STARTS,null,1,0,1,SPM.STARTS)/
               decode(T.NUM_ROWS,null,1,0,1,T.NUM_ROWS),2)*100,
               T.NUM_ROWS,  T.TABLE_NAME, I.STALE_STATS, T.STALE_STATS
               INTO  :L_PRINT_OUTPUT_RATIO, :L_TABLE_ROWS, :L_TABLE_NAME, :L_IND_STALE_STATS, :L_TAB_STALE_STATS
               FROM  DBA_INDEXES D,
                     DBA_IND_STATISTICS I,
                     DBA_TAB_STATISTICS T
               WHERE D.TABLE_OWNER = T.OWNER(+) AND D.TABLE_NAME = T.TABLE_NAME(+)
               AND   D.OWNER = I.OWNER(+) AND D.INDEX_NAME = I.INDEX_NAME(+)
               AND   D.INDEX_NAME = SPM.PLAN_OBJECT_NAME
               AND   D.OWNER = SPM.PLAN_OBJECT_OWNER
               AND   ROWNUM = 1 ;
              END IF;

              :L_WHERE_LOG := 'IO INDEX A';
           --   DBMS_OUTPUT.PUT_LINE(SPM.PLAN_OBJECT_NAME||'-'||SPM.PLAN_OBJECT_OWNER||'-'||:L_PRINT_OUTPUT_RATIO||:L_TABLE_NAME);
           --   DBMS_OUTPUT.PUT_LINE(SPM.PLAN_OBJECT_NAME||'- search columns : '||SPM.SEARCH_COLUMNS);
              IF ( SPM.STARTS > 0 )   THEN
                -- low output_rows retuened with high reads  each join trial should not require 10000+ bytes   2018.02.07
                IF ( (SPM.SEARCH_COLUMNS > 1 AND ROUND(SPM.PHYSICAL_READ_BYTES) > 10000*SPM.STARTS AND SPM.JOIN_METHOD = 'NESTED') OR
                     (SPM.SEARCH_COLUMNS > 1 AND SPM.OUTPUT_ROWS > 0 AND ROUND(SPM.PHYSICAL_READ_BYTES) > 10000*SPM.OUTPUT_ROWS
                      AND SPM.JOIN_METHOD = 'HASH JOIN') OR
                     (SPM.SEARCH_COLUMNS > 1 AND SPM.OUTPUT_ROWS = 0 AND ROUND(SPM.PHYSICAL_READ_BYTES) > 1000000
                      AND SPM.JOIN_METHOD = 'HASH JOIN')
                   ) THEN
                   DBMS_OUTPUT.PUT_LINE('* Analysis');
                   DBMS_OUTPUT.PUT_LINE('* (<a href="#PHV'||SPM.SQL_PLAN_HASH_VALUE||SPM.KEY||SPM.MO||'">ID:'||spm.PLAN_LINE_ID||'</a>) The index column order of '||spm.PLAN_OBJECT_NAME
                    ||' does not seem to be good for the condition.');
                    IF (  SPM.access_predicates IS NOT NULL ) THEN
                      DBMS_OUTPUT.PUT_LINE('+ AP:' ||SUBSTR(SPM.access_predicates,  1,120));
                      DBMS_OUTPUT.PUT_LINE(SUBSTR(SPM.access_predicates,121,240));
                      DBMS_OUTPUT.PUT_LINE(SUBSTR(SPM.access_predicates,241,360));
                    END IF;
                    IF ( SPM.filter_predicates IS NOT NULL ) THEN
                      DBMS_OUTPUT.PUT_LINE('+ FP:' ||SUBSTR(SPM.filter_predicates,  1,120));
                      DBMS_OUTPUT.PUT_LINE(SUBSTR(SPM.filter_predicates,121,240));
                      DBMS_OUTPUT.PUT_LINE(SUBSTR(SPM.filter_predicates,241,360));
                    END IF;
                    IF ( :L_IND_STALE_STATS = 'YES' ) THEN
                      DBMS_OUTPUT.PUT_LINE('=>Issue Category: <RED>Stats</RED>'); :issue_stats := 1;
                      DBMS_OUTPUT.PUT_LINE('<blue>Action Item : OPERATION TEAM</BLUE>');
                      DBMS_OUTPUT.PUT_LINE('=>Suggestion: Gather Table Stats on '||SPM.PLAN_OBJECT_OWNER||'.'||:L_TABLE_NAME||'.');
                      IF (:L_TABLE_NAME = UPPER(:L_TABLE_NAME)) THEN
                        DBMS_OUTPUT.PUT_LINE('=>i.e. <BLUE>EXEC DBMS_STATS.GATHER_TABLE_STATS('''||spm.PLAN_OBJECT_OWNER||''','''||:L_TABLE_NAME||''',NO_INVALIDATE=>FALSE);</BLUE>');
                      ELSIF (:L_TABLE_NAME = LOWER(:L_TABLE_NAME)) THEN
                        DBMS_OUTPUT.PUT_LINE('=>i.e. <BLUE>EXEC DBMS_STATS.GATHER_TABLE_STATS('''||spm.PLAN_OBJECT_OWNER||''',''"'||:L_TABLE_NAME||'"'',NO_INVALIDATE=>FALSE);</BLUE>');
                      END IF;
                      DBMS_OUTPUT.PUT_LINE('.');
                 END IF;
                    IF ( :L_IND_STALE_STATS = 'NO' ) THEN
                      DBMS_OUTPUT.PUT_LINE('=>Issue Category: <RED>Index and column condition</RED>'); :issue_improper_index := 1;
                      DBMS_OUTPUT.PUT_LINE('<blue>Action Item : DEVELOPMENT TEAM/PSR</BLUE>');
                      DBMS_OUTPUT.PUT_LINE('=>Suggestion: If there is good index for the condition, check histogram with PSR DB team.');
                      DBMS_OUTPUT.PUT_LINE('=>Suggestion: If there is no good index for the condition, change the condition or consider new index.');
                      DBMS_OUTPUT.PUT_LINE('.');
                    END IF;
                END IF;
                -- unselective condition.
                IF ( (:L_PRINT_OUTPUT_RATIO >= :L_ACCESS_RATIO OR SPM.OUTPUT_ROWS/SPM.STARTS > :L_ACCESS_RATIO*100)
                     AND SPM.PLAN_OPTIONS NOT IN ('UNIQUE SCAN')
                     AND :L_PRV_CARDINALITY <> 1
                     AND SPM.MO NOT IN (:l_mo5,:l_mo4,:l_mo3,:l_mo2,:l_mo1)
/*20180412*/         AND SPM.MO > 1
                   )  THEN
              --    DBMS_OUTPUT.PUT_LINE('IO) ID:'||LPAD('    ',4-LENGTH(SPM.plan_line_id))||SPM.plan_line_id
              --    ||' OID:'||LPAD('    ',4-LENGTH(SPM.MO))||:L_CUR_OID
              --    ||' It required '||SPM.R_MB||' MB Reads -'||SPM.W_MB||' MB Writes -'||SPM.PGA_MB||' MB PGA -'||SPM.TEMP_MB||' MB Temp');

                  IF ( (SPM.access_predicates IS NOT NULL OR SPM.filter_predicates IS NOT NULL)
                     ) THEN
                      DBMS_OUTPUT.PUT_LINE('* Analysis');
                      DBMS_OUTPUT.PUT_LINE('* (<a href="#PHV'||SPM.SQL_PLAN_HASH_VALUE||SPM.KEY||SPM.MO||'">ID:'
                      ||spm.PLAN_LINE_ID||'</a>) The following condition is not so selective');
                  END IF ;
                  IF (  SPM.access_predicates IS NOT NULL
                     ) THEN
                      DBMS_OUTPUT.PUT_LINE('+ AP:' ||SUBSTR(SPM.access_predicates,  1,120));
                      DBMS_OUTPUT.PUT_LINE(SUBSTR(SPM.access_predicates,121,240));
                      DBMS_OUTPUT.PUT_LINE(SUBSTR(SPM.access_predicates,241,360));
                  END IF;
                  IF ( SPM.filter_predicates IS NOT NULL
                     ) THEN
                      DBMS_OUTPUT.PUT_LINE('+ FP:' ||SUBSTR(SPM.filter_predicates,  1,120));
                      DBMS_OUTPUT.PUT_LINE(SUBSTR(SPM.filter_predicates,121,240));
                      DBMS_OUTPUT.PUT_LINE(SUBSTR(SPM.filter_predicates,241,360));
                  END IF;
            --      DBMS_OUTPUT.PUT_LINE(' The operation(s) read avg '||round(SPM.OUTPUT_ROWS/SPM.STARTS,2)
            --      ||' (= '||SPM.OUTPUT_ROWS||'/'||SPM.STARTS||' = OUTPUT_ROWS/STARTS)'
            --      ||' rows per join or 1st driving.');
            --      DBMS_OUTPUT.PUT_LINE(' This figure is around '||:L_PRINT_OUTPUT_RATIO||'% of data from '
            --      ||SPM.PLAN_OBJECT_OWNER||'.'||SPM.PLAN_OBJECT_NAME||'.');
          --- check_stale_stats
                  /*
                  SELECT nvl( (SELECT TO_DATE(LAST_LOAD_TIME,'YYYY-MM-DD HH24:MI:SS') LAST_LOAD_TIME
                               FROM ( SELECT LAST_LOAD_TIME
                               --FROM ( SELECT TO_char(LAST_LOAD_TIME,'YYYY-MM-DD HH24:MI:SS')  LAST_LOAD_TIME
                                      FROM GV$SQL
                                      WHERE SQL_ID = :L_SQL_ID
                                      AND PLAN_HASH_VALUE = :L_PLAN_HASH_VALUE
                                      AND INST_ID = SM.INST_ID
                                    --AND TO_CHAR(LAST_LOAD_TIME,'YYYY-MM-DD HH24:MI:SS') <= SM.START_TIME ),
                                      AND TO_DATE(LAST_LOAD_TIME,'YYYY-MM-DD HH24:MI:SS') <= TO_DATE(SM.START_TIME,'YYYY-MM-DD HH24:MI:SS')
                                      ORDER BY 1 DESC
                                    )
                               WHERE ROWNUM = 1 ) ,
                               nvl( (SELECT MAX(sample_time) LAST_LOAD_TIME
                                     FROM GV$ACTIVE_SESSION_HISTORY
                                     WHERE SQL_ID = :L_SQL_ID
                                     AND SQL_PLAN_HASH_VALUE = :L_PLAN_HASH_VALUE
                                     AND INST_ID = SM.INST_ID
                                     AND IN_HARD_PARSE = 'Y'
                                     AND TO_CHAR(SAMPLE_TIME,'YYYY-MM-DD HH24:MI:SS') <= SM.START_TIME ),
                                     nvl( (SELECT MAX(sample_time) LAST_LOAD_TIME
                                           FROM DBA_HIST_ACTIVE_SESS_HISTORY
                                           WHERE SQL_ID = :L_SQL_ID
                                           AND SQL_PLAN_HASH_VALUE = :L_PLAN_HASH_VALUE
                                           AND INSTANCE_NUMBER = SM.INST_ID
                                           AND IN_HARD_PARSE = 'Y'
                                           AND TO_CHAR(SAMPLE_TIME,'YYYY-MM-DD HH24:MI:SS') <= SM.START_TIME )
                                          , to_date('1000-01-01 00:00:01','YYYY-MM-DD HH24:MI:SS')
                                        )
                                  )
                              )
                  INTO :L_last_load_time
                  FROM DUAL ;

                  IF ( to_date(:L_last_load_time,'YYYY-MM-DD HH24:MI:SS') = to_date('1000-01-01 00:00:01','YYYY-MM-DD HH24:MI:SS') ) THEN
                       :L_last_load_time := SM.START_TIME;
                       :L_last_load_time_CORRECT := 'NO';
                  END IF;
                  */
                  IF ( (   (SPM.PLAN_CARDINALITY = 0 AND ABS(SPM.OUTPUT_ROWS-SPM.PLAN_CARDINALITY) > :L_ACCESS_RATIO*0.03)
                        OR (SPM.PLAN_CARDINALITY > 0 AND ABS(SPM.OUTPUT_ROWS-SPM.PLAN_CARDINALITY)/SPM.PLAN_CARDINALITY > :L_ACCESS_RATIO*0.03)
                       )
                       AND ( ( SPM.PLAN_OPTIONS NOT LIKE 'UNIQUE%' AND SPM.PLAN_OBJECT_TYPE LIKE 'INDEX%')
                          OR ( :L_PRV_CARDINALITY <> 1 AND :L_PRV_OBJECT_TYPE LIKE 'INDEX%' AND SPM.PLAN_OBJECT_TYPE LIKE 'TABLE%' ) )
                       AND SPM.MO > 1 and spm.object# is not null
                       AND to_date(:L_last_load_time,'YYYY-MM-DD HH24:MI:SS') <> to_date('1000-01-01 00:00:01','YYYY-MM-DD HH24:MI:SS')
                       AND :error_from_sm = 0
                     )
                       THEN
/*20180411*/           select ROWCNT, TO_CHAR(ANALYZETIME,'YYYY-MON-DD HH24:MI:SS')
                              into :L_ROWCNT, :L_ANALYZETIME
                       from (
                        select h.rowcnt ROWCNT, h.ANALYZETIME ANALYZETIME
                        from  SYS.WRI$_OPTSTAT_IND_HISTORY h
                        where h.OBJ# = spm.object#
                        and   to_date(h.ANALYZETIME,'YYYY-MM-DD HH24:MI:SS') <=  to_date(:L_last_load_time,'YYYY-MM-DD HH24:MI:SS')
                        union all
                        select  i.num_rows, i.LAST_ANALYZED ANALYZETIME
                        from dba_indexes i
                        where i.index_name =  spm.PLAN_OBJECT_NAME
                        and   i.owner      =  spm.PLAN_OBJECT_OWNER
                        --and   o.object_id = spm.object#
                        and  to_date(i.LAST_ANALYZED,'YYYY-MM-DD HH24:MI:SS') <= to_date(:L_last_load_time,'YYYY-MM-DD HH24:MI:SS')
                        union all
                        select -1, sysdate-100000 from dual
                        order by 2 desc
                        )
                       where rownum = 1;
                    DBMS_OUTPUT.PUT_LINE('* (<a href="#PHV'||SPM.SQL_PLAN_HASH_VALUE||SPM.KEY||SPM.MO||'">ID:'||spm.PLAN_LINE_ID
                    ||'</a>) The Operation had inaccurate cardinality estimation. (CARD vs ROWS : '||SPM.PLAN_CARDINALITY||'*'||SPM.STARTS||' vs '||SPM.OUTPUT_ROWS||')');
                    IF (:L_ROWCNT > -1
                        AND to_date(:L_last_load_time,'YYYY-MM-DD HH24:MI:SS') <> to_date('1000-01-01 00:00:01','YYYY-MM-DD HH24:MI:SS'))
                       THEN
                       DBMS_OUTPUT.PUT_LINE('+ '||SPM.PLAN_OBJECT_NAME||' had '||:L_ROWCNT||' as a statistics row on '||:L_ANALYZETIME||' (ID:'||spm.PLAN_LINE_ID||').');
                    END IF;
                    IF ( :L_ROWCNT = 0 ) THEN
                       DBMS_OUTPUT.PUT_LINE('<blue>Action Item : DEVELOPMENT TEAM/OPERATION TEAM</BLUE>');
                       DBMS_OUTPUT.PUT_LINE('=>Suggestion: If the program always deletes all rows before it finishes, delete stats and use dynamic statistics');
                       IF( :L_TABLE_NAME = UPPER(:L_TABLE_NAME) ) THEN
                          DBMS_OUTPUT.PUT_LINE('=>i.e. <blue>EXEC DBMS_STATS.DELETE_TABLE_STATS('''||spm.PLAN_OBJECT_OWNER||''','''||:L_TABLE_NAME||''');</blue>');
                       ELSIF( :L_TABLE_NAME = LOWER(:L_TABLE_NAME) ) THEN
                          DBMS_OUTPUT.PUT_LINE('=>i.e. <blue>EXEC DBMS_STATS.DELETE_TABLE_STATS('''||spm.PLAN_OBJECT_OWNER||''',''"'||:L_TABLE_NAME||'"'');</blue>');
                       END IF;
--V3
                       DBMS_OUTPUT.PUT_LINE('=>Suggestion: If any program never deletes all rows before it finishes, gather stats');
                       IF( :L_TABLE_NAME = UPPER(:L_TABLE_NAME) ) THEN
                          DBMS_OUTPUT.PUT_LINE('=>i.e. <blue>EXEC DBMS_STATS.GATHER_TABLE_STATS('''||spm.PLAN_OBJECT_OWNER||''','''||:L_TABLE_NAME||''',NO_INVALIDATE=>FALSE);</blue>');
                       ELSIF( :L_TABLE_NAME = LOWER(:L_TABLE_NAME) ) THEN
                          DBMS_OUTPUT.PUT_LINE('=>i.e. <blue>EXEC DBMS_STATS.GATHER_TABLE_STATS('''||spm.PLAN_OBJECT_OWNER||''',''"'||:L_TABLE_NAME||'"'',NO_INVALIDATE=>FALSE);</blue>');
                       END IF;
                       DBMS_OUTPUT.PUT_LINE('.');
                    ELSIF (:L_IND_STALE_STATS = 'NO' AND :L_ROWCNT > 0
                           AND :error_from_sm = 0
                       ) THEN
                       DBMS_OUTPUT.PUT_LINE('=>Issue Category: <RED>Cardinality estimation*****</RED>'); :issue_inac_card_estim := 1;
                       DBMS_OUTPUT.PUT_LINE('<blue>Action Item : DEVELOPMENT TEAM/PSR</BLUE>');
                       DBMS_OUTPUT.PUT_LINE('=>Suggestion: Check stats on '||:L_ANALYZETIME);
                       DBMS_OUTPUT.PUT_LINE('=>Suggestion: Check related condition, bind peeked value, function constant/bind, embedded hint and etc, if needed.');
                       IF ( SPM.access_predicates IS NOT NULL
                           AND ( SUBSTR(SPM.access_predicates,2) LIKE '%(%'
                             OR  UPPER(SPM.access_predicates) LIKE '%ROWNUM%'
                             OR  UPPER(SPM.access_predicates) LIKE '% OR %'
                             OR  UPPER(SPM.access_predicates) LIKE '%/*+%' )
                         ) THEN
                           DBMS_OUTPUT.PUT_LINE('+ (OID:'||SPM.MO||') AP:' ||SUBSTR(SPM.access_predicates,  1,120));
                           DBMS_OUTPUT.PUT_LINE(SUBSTR(SPM.access_predicates,121,240));
                           DBMS_OUTPUT.PUT_LINE(SUBSTR(SPM.access_predicates,241,360));
                       END IF;
                       IF ( SPM.filter_predicates IS NOT NULL
                           AND ( SUBSTR(SPM.access_predicates,2) LIKE '%(%'
                             OR  UPPER(SPM.filter_predicates) LIKE '%ROWNUM%'
                             OR  UPPER(SPM.filter_predicates) LIKE '% OR %'
                             OR  UPPER(SPM.filter_predicates) LIKE '%/*+%' )
                         ) THEN
                           DBMS_OUTPUT.PUT_LINE('+ (OID:'||SPM.MO||') FP:' ||SUBSTR(SPM.filter_predicates,  1,120));
                           DBMS_OUTPUT.PUT_LINE(SUBSTR(SPM.filter_predicates,121,240));
                           DBMS_OUTPUT.PUT_LINE(SUBSTR(SPM.filter_predicates,241,360));
                       END IF;
                       DBMS_OUTPUT.PUT_LINE('.');
                    ELSIF ( :L_IND_STALE_STATS = 'YES' AND :L_ROWCNT > 0 ) THEN
                          DBMS_OUTPUT.PUT_LINE('=>Issue Category: <RED>Stats</RED>'); :issue_stats := 1;
                          DBMS_OUTPUT.PUT_LINE('<blue>Action Item : OPERATION TEAM</BLUE>');
                          DBMS_OUTPUT.PUT_LINE('=>Suggestion: Gather Table Stats on '||SPM.PLAN_OBJECT_OWNER||'.'||:L_TABLE_NAME||'.');
                          IF( :L_TABLE_NAME = UPPER(:L_TABLE_NAME) ) THEN
                               DBMS_OUTPUT.PUT_LINE('=>i.e. <blue>EXEC DBMS_STATS.GATHER_TABLE_STATS('''||spm.PLAN_OBJECT_OWNER||''','''||:L_TABLE_NAME||''',NO_INVALIDATE=>FALSE);</blue>');
                          ELSIF( :L_TABLE_NAME = LOWER(:L_TABLE_NAME) ) THEN
                               DBMS_OUTPUT.PUT_LINE('=>i.e. <blue>EXEC DBMS_STATS.GATHER_TABLE_STATS('''||spm.PLAN_OBJECT_OWNER||''',''"'||:L_TABLE_NAME||'"'',NO_INVALIDATE=>FALSE);</blue>');
                          END IF;
                          DBMS_OUTPUT.PUT_LINE('.');
                    END IF;
                  END IF;
                  IF (:L_PRINT_OUTPUT_RATIO > 100 and spm.starts = 1 and :L_TAB_STALE_STATS = 'NO') THEN
                     DBMS_OUTPUT.PUT_LINE('=>Issue Category: <RED>Stats</RED>'); :issue_stats := 1;
                     DBMS_OUTPUT.PUT_LINE('<blue>Action Item : PSR');
                     DBMS_OUTPUT.PUT_LINE('=>Suggestion: Check if current stats of '||:L_TABLE_NAME||' is correct.');
                     DBMS_OUTPUT.PUT_LINE('.');
                  END IF;
                  --DBMS_OUTPUT.PUT_LINE('The % figure is too high.');
                  IF( SPM.PLAN_OBJECT_TYPE = 'INDEX (DOMAIN)') THEN
                   --   DBMS_OUTPUT.PUT_LINE('* Analysis');
                      DBMS_OUTPUT.PUT_LINE('* High I/O operation was on '||SPM.PLAN_OBJECT_NAME||' (<a href="#PHV'||SPM.SQL_PLAN_HASH_VALUE||SPM.KEY||SPM.MO||'">ID:'||spm.PLAN_LINE_ID||'</a>).');
                      DBMS_OUTPUT.PUT_LINE('=>Issue Category: <RED>Blind input or unselective input</RED>'); :issue_blind_input := 1;
                      DBMS_OUTPUT.PUT_LINE('<blue>Action Item : DEVELOPMENT TEAM/OPERATION TEAM</BLUE>');
                      DBMS_OUTPUT.PUT_LINE('=>Suggestion: Use more selective input for the domain index, '||SPM.PLAN_OBJECT_NAME||' (<a href="#PHV'||SPM.SQL_PLAN_HASH_VALUE||SPM.KEY||SPM.MO||'">ID:'||spm.PLAN_LINE_ID||'</a>).');
/* SMA19C DOMAIN INDEX FRAGMENTATION CHECK METHOD START 20200408 */
                      DBMS_OUTPUT.PUT_LINE('=>Domain Index Fragmentation Check Method');
                      DBMS_OUTPUT.PUT_LINE('Ask Operation team to run the following step and get the return.');
                      DBMS_OUTPUT.PUT_LINE('create table output (result CLOB);');
                      DBMS_OUTPUT.PUT_LINE('declare');
                      DBMS_OUTPUT.PUT_LINE('  x clob := null;');
                      DBMS_OUTPUT.PUT_LINE('  begin');
                      DBMS_OUTPUT.PUT_LINE('    ctx_report.index_stats('''||SPM.PLAN_OBJECT_OWNER||'.'||SPM.PLAN_OBJECT_NAME||''',x);');
                      DBMS_OUTPUT.PUT_LINE('    insert into output values (x);');
                      DBMS_OUTPUT.PUT_LINE('    commit;');
                      DBMS_OUTPUT.PUT_LINE('    dbms_lob.freetemporary(x);');
                      DBMS_OUTPUT.PUT_LINE('  end;');
                      DBMS_OUTPUT.PUT_LINE('/');
                      DBMS_OUTPUT.PUT_LINE('set long 32000');
                      DBMS_OUTPUT.PUT_LINE('set head off');
                      DBMS_OUTPUT.PUT_LINE('set pagesize 10000');
                      DBMS_OUTPUT.PUT_LINE('select * from output;');
                      DBMS_OUTPUT.PUT_LINE('.');
/* SMA19C DOMAIN INDEX FRAGMENTATION CHECK METHOD END 20200408 */
                  ELSIF (SPM.PLAN_OBJECT_TYPE = 'INDEX' AND SPM.PLAN_OPERATION = 'INDEX' AND INSTR(SPM.ACCESS_PREDICATES,' LIKE ')<>0 ) THEN
                   --   DBMS_OUTPUT.PUT_LINE('* Analysis');
                      DBMS_OUTPUT.PUT_LINE('* High I/O operation was on '||SPM.PLAN_OBJECT_NAME||' (<a href="#PHV'||SPM.SQL_PLAN_HASH_VALUE||SPM.KEY||SPM.MO||'">ID:'||spm.PLAN_LINE_ID||'</a>).');
                      DBMS_OUTPUT.PUT_LINE('=>Issue Category: <RED>Blind input or unselective input</RED>'); :issue_blind_input := 1;
                      DBMS_OUTPUT.PUT_LINE('<blue>Action Item : DEVELOPMENT TEAM/OPERATION TEAM</BLUE>');
                      DBMS_OUTPUT.PUT_LINE('=>Suggestion: Use more selective input for the index with LIKE operation at '||SPM.PLAN_OBJECT_NAME||' (<a href="#PHV'||SPM.SQL_PLAN_HASH_VALUE||SPM.KEY||SPM.MO||'">ID:'||spm.PLAN_LINE_ID||'</a>).');
                      DBMS_OUTPUT.PUT_LINE('.');
                  ELSIF (SPM.PLAN_OBJECT_TYPE = 'INDEX' and SPM.OUTPUT_ROWS > SPM.JOIN_OUTPUT_ROWS * 20 ) THEN
                   --   DBMS_OUTPUT.PUT_LINE('* Analysis');
                      DBMS_OUTPUT.PUT_LINE('* High I/O operation was on '||SPM.PLAN_OBJECT_NAME||' (<a href="#PHV'||SPM.SQL_PLAN_HASH_VALUE||SPM.KEY||SPM.MO||'">ID:'||spm.PLAN_LINE_ID||'</a>).');
                      DBMS_OUTPUT.PUT_LINE('=>Issue Category: <RED>Throw-away******</RED>'); :issue_throw_away := 1;
                      DBMS_OUTPUT.PUT_LINE('<blue>Action Item : DEVELOPMENT TEAM/PSR</BLUE>');
           if (:issue_error = 1) then
             DBMS_OUTPUT.PUT_LINE('=>Note: Since the sql met the error, the throw-away issue might not be correct.');
           end if;
                      DBMS_OUTPUT.PUT_LINE('=>Suggestion: Use more proper indexed column condition at '||SPM.PLAN_OBJECT_NAME||' or its table (<a href="#PHV'||SPM.SQL_PLAN_HASH_VALUE||SPM.KEY||SPM.MO||'">ID:'||spm.PLAN_LINE_ID||'</a>).');
                      DBMS_OUTPUT.PUT_LINE('.');
                  ELSIF (SPM.PLAN_OBJECT_TYPE = 'INDEX' and SPM.OUTPUT_ROWS < SPM.JOIN_OUTPUT_ROWS * 20 ) THEN
                   --   DBMS_OUTPUT.PUT_LINE('* Analysis');
                      DBMS_OUTPUT.PUT_LINE('* High I/O operation was on '||SPM.PLAN_OBJECT_NAME||' (<a href="#PHV'||SPM.SQL_PLAN_HASH_VALUE||SPM.KEY||SPM.MO||'">ID:'||spm.PLAN_LINE_ID||'</a>).');
                      DBMS_OUTPUT.PUT_LINE('=>Issue Category: <RED>Blind operation</RED>'); :issue_blind_query := 1;
                      DBMS_OUTPUT.PUT_LINE('<blue>Action Item : DEVELOPMENT TEAM</BLUE>');
                      DBMS_OUTPUT.PUT_LINE('=>Suggestion: Use more selective indexed column condition at '||SPM.PLAN_OBJECT_NAME||' or its table (<a href="#PHV'||SPM.SQL_PLAN_HASH_VALUE||SPM.KEY||SPM.MO||'">ID:'||spm.PLAN_LINE_ID||'</a>).');
                      DBMS_OUTPUT.PUT_LINE('.');
                  END IF;
                --  DBMS_OUTPUT.PUT_LINE('****join method:'||SPM.JOIN_METHOD||']');
                --  DBMS_OUTPUT.PUT_LINE('++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++');
                  IF (:issue_blind_input = 1 OR :issue_blind_query = 1  OR :issue_inac_card_estim  = 1
                   OR :issue_improper_index = 1 OR :issue_stats = 1 OR :issue_throw_away = 1) THEN
                   :l_mo5 := :l_mo4;
                   :l_mo4 := :l_mo3;
                   :l_mo3 := :l_mo2;
                   :l_mo2 := :l_mo1;
                   :l_mo1 := spm.mo;
                  END IF;
                END IF;
              END IF;
             -- INDEX
             -- INDEX (CLUSTER)
             -- INDEX (DOMAIN)
             -- INDEX (UNIQUE)
           END IF;
             -- TABLE
           IF ( SPM.PLAN_OBJECT_TYPE LIKE 'TABLE%' ) THEN
              :L_WHERE_LOG := 'IO TABLE_B';
              --DBMS_OUTPUT.PUT_LINE('=>'||SPM.PLAN_OBJECT_OWNER||'.'||SPM.PLAN_OBJECT_NAME||'.'||SPM.OUTPUT_ROWS||'.'||SPM.STARTS);

              SELECT NVL(
              (SELECT  D.TABLE_NAME
               FROM  DBA_TABLES D
               WHERE D.TABLE_NAME = SPM.PLAN_OBJECT_NAME
               AND   D.OWNER = SPM.PLAN_OBJECT_OWNER
               AND   ROWNUM = 1),'N/A') INTO :L_TABLE_NAME
              FROM DUAL  ;

              IF (:L_TABLE_NAME <> 'N/A') THEN
                SELECT round(SPM.OUTPUT_ROWS/decode(SPM.STARTS,null,1,0,1,SPM.STARTS)/
                decode(T.NUM_ROWS,null,1,0,1,T.NUM_ROWS),2)*100, nvl(T.STALE_STATS,'N/A')
                INTO :L_PRINT_OUTPUT_RATIO, :L_TAB_STALE_STATS
                FROM DBA_TABLES D, DBA_TAB_STATISTICS T
                WHERE D.TABLE_NAME = SPM.PLAN_OBJECT_NAME AND D.OWNER = SPM.PLAN_OBJECT_OWNER
                AND   D.TABLE_NAME = T.TABLE_NAME(+) AND D.OWNER = T.OWNER(+)
                AND ROWNUM = 1 ;
              END IF;

              :L_WHERE_LOG := 'IO TABLE_A';
              IF (:L_PRINT_OUTPUT_RATIO >= :L_ACCESS_RATIO
                  OR (SPM.PLAN_OPTIONS LIKE 'FULL%' OR SPM.PLAN_OPTIONS LIKE 'STORAGE FULL%'))  THEN
                 -- DBMS_OUTPUT.PUT_LINE('IO) ID:'||LPAD('    ',4-LENGTH(SPM.plan_line_id))||SPM.plan_line_id
                 -- ||' OID:'||LPAD('    ',4-LENGTH(SPM.MO))||:L_CUR_OID
                 -- ||' It required '||SPM.R_MB||' MB Reads -'||SPM.W_MB||' MB Writes -'||SPM.PGA_MB||' MB PGA -'||SPM.TEMP_MB||' MB Temp');
--v3 added SPM.OUTPUT_ROWS > :L_ACCESS_RATIO*:L_ACCESS_RATIO*:L_ACCESS_RATIO*:L_ACCESS_RATIO
                  IF (:L_PRINT_OUTPUT_RATIO >= :L_ACCESS_RATIO and :L_PPV_MESSAGE = 0
                      and SPM.OUTPUT_ROWS > :L_ACCESS_RATIO*:L_ACCESS_RATIO*:L_ACCESS_RATIO*:L_ACCESS_RATIO) THEN
                       IF ( SPM.access_predicates IS NOT NULL OR SPM.filter_predicates IS NOT NULL ) THEN
                          DBMS_OUTPUT.PUT_LINE('* Analysis');
                          DBMS_OUTPUT.PUT_LINE('* (<a href="#PHV'||SPM.SQL_PLAN_HASH_VALUE||SPM.KEY||SPM.MO||'">ID:'||spm.PLAN_LINE_ID
                          ||'</a>) The following condition is not so selective.');
                       END IF;
                       IF ( SPM.access_predicates IS NOT NULL ) THEN
                          DBMS_OUTPUT.PUT_LINE('+ AP:' ||SUBSTR(SPM.access_predicates,  1,120));
                          DBMS_OUTPUT.PUT_LINE(SUBSTR(SPM.access_predicates,121,240));
                          DBMS_OUTPUT.PUT_LINE(SUBSTR(SPM.access_predicates,241,360));
                       END IF;
                       IF ( SPM.filter_predicates IS NOT NULL ) THEN
                          DBMS_OUTPUT.PUT_LINE('+ FP:' ||SUBSTR(SPM.filter_predicates,  1,120));
                          DBMS_OUTPUT.PUT_LINE(SUBSTR(SPM.filter_predicates,121,240));
                          DBMS_OUTPUT.PUT_LINE(SUBSTR(SPM.filter_predicates,241,360));
                       END IF;
                  /*
                  SELECT nvl( (SELECT TO_DATE(LAST_LOAD_TIME,'YYYY-MM-DD HH24:MI:SS') LAST_LOAD_TIME
                               FROM ( SELECT LAST_LOAD_TIME
                               --FROM ( SELECT TO_char(LAST_LOAD_TIME,'YYYY-MM-DD HH24:MI:SS')  LAST_LOAD_TIME
                                      FROM GV$SQL
                                      WHERE SQL_ID = :L_SQL_ID
                                      AND PLAN_HASH_VALUE = :L_PLAN_HASH_VALUE
                                      AND INST_ID = SM.INST_ID
                                    --AND TO_CHAR(LAST_LOAD_TIME,'YYYY-MM-DD HH24:MI:SS') <= SM.START_TIME ),
                                      AND TO_DATE(LAST_LOAD_TIME,'YYYY-MM-DD HH24:MI:SS') <= TO_DATE(SM.START_TIME,'YYYY-MM-DD HH24:MI:SS')
                                      ORDER BY 1 DESC
                                    )
                               WHERE ROWNUM = 1 ) ,
                               nvl( (SELECT MAX(sample_time) LAST_LOAD_TIME
                                     FROM GV$ACTIVE_SESSION_HISTORY
                                     WHERE SQL_ID = :L_SQL_ID
                                     AND SQL_PLAN_HASH_VALUE = :L_PLAN_HASH_VALUE
                                     AND INST_ID = SM.INST_ID
                                     AND IN_HARD_PARSE = 'Y'
                                     AND TO_CHAR(SAMPLE_TIME,'YYYY-MM-DD HH24:MI:SS') <= SM.START_TIME ),
                                     nvl( (SELECT MAX(sample_time) LAST_LOAD_TIME
                                           FROM DBA_HIST_ACTIVE_SESS_HISTORY
                                           WHERE SQL_ID = :L_SQL_ID
                                           AND SQL_PLAN_HASH_VALUE = :L_PLAN_HASH_VALUE
                                           AND INSTANCE_NUMBER = SM.INST_ID
                                           AND IN_HARD_PARSE = 'Y'
                                           AND TO_CHAR(SAMPLE_TIME,'YYYY-MM-DD HH24:MI:SS') <= SM.START_TIME )
                                          , to_date('1000-01-01 00:00:01','YYYY-MM-DD HH24:MI:SS')
                                        )
                                  )
                              )
                  INTO :L_last_load_time
                  FROM DUAL;

                  IF ( to_date(:L_last_load_time,'YYYY-MM-DD HH24:MI:SS') = to_date('1000-01-01 00:00:01','YYYY-MM-DD HH24:MI:SS') ) THEN
                       :L_last_load_time := SM.START_TIME;
                       :L_last_load_time_CORRECT := 'NO';
                  END IF;
                  */
                       IF( (  (SPM.PLAN_CARDINALITY = 0 AND ABS(SPM.OUTPUT_ROWS-SPM.PLAN_CARDINALITY) > :L_ACCESS_RATIO*0.03)
                           OR (SPM.PLAN_CARDINALITY > 0 AND ABS(SPM.OUTPUT_ROWS-SPM.PLAN_CARDINALITY)/SPM.PLAN_CARDINALITY > :L_ACCESS_RATIO*0.03)
                           )
                           AND SPM.MO > 1
                           AND spm.object# IS NOT NULL
                           AND :error_from_sm = 0
                           AND ( ( SPM.PLAN_OPTIONS NOT LIKE 'UNIQUE%' AND SPM.PLAN_OBJECT_TYPE LIKE 'INDEX%')
                              OR ( :L_PRV_CARDINALITY <> 1 AND :L_PRV_OBJECT_TYPE LIKE 'INDEX%' AND SPM.PLAN_OBJECT_TYPE LIKE 'TABLE%' ) )
                           AND to_date(:L_last_load_time,'YYYY-MM-DD HH24:MI:SS') <> to_date('1000-01-01 00:00:01','YYYY-MM-DD HH24:MI:SS')
                        )
                         THEN
                           :L_WHERE_LOG := 'IO TABLE_A1';
                           select ROWCNT, to_char(ANALYZETIME,'YYYY-MON-DD HH24:MI:SS'), FLAGS
                              into :L_ROWCNT, :L_ANALYZETIME, :L_FLAGS
                           from (
                           select h.rowcnt ROWCNT,  h.ANALYZETIME ANALYZETIME, NVL(TO_CHAR(H.FLAGS),'REAL_TIME_STATS') FLAGS
                           from   SYS.WRI$_OPTSTAT_TAB_HISTORY h
                           where  h.OBJ# = spm.object#
                           and    to_date(h.ANALYZETIME,'YYYY-MM-DD HH24:MI:SS') <=   to_date(:L_last_load_time,'YYYY-MM-DD HH24:MI:SS')
                           union all
                           select  t.num_rows, t.LAST_ANALYZED ANALYZETIME, 'CURRENT_STATS' FLAGS
                           from dba_tables t
                           where t.table_name  = spm.PLAN_OBJECT_NAME
                           and   t.owner       = spm.PLAN_OBJECT_OWNER
                           --and   o.object_id = spm.object#
                           and   to_date(t.LAST_ANALYZED,'YYYY-MM-DD HH24:MI:SS') <=   to_date(:L_last_load_time,'YYYY-MM-DD HH24:MI:SS')
                           union all
                           select -1, sysdate-100000, 'NONE' FLAGS from dual
                           order by 2 desc
                           )
                           where rownum = 1;
                           :L_WHERE_LOG := 'IO TABLE_A2';

                        IF (:L_FLAGS = 'REAL_TIME_STATS') THEN
                             DBMS_OUTPUT.PUT_LINE('+ '||SPM.PLAN_OBJECT_NAME||' <blue>used a real time stats</blue> on '||:L_ANALYZETIME||' (<a href="#PHV'||SPM.SQL_PLAN_HASH_VALUE||SPM.KEY||SPM.MO||'">ID:'||spm.PLAN_LINE_ID||'</a>).');
                        ELSIF(:L_FLAGS <> 'REAL_TIME_STATS') THEN
                           DBMS_OUTPUT.PUT_LINE('* (<a href="#PHV'||SPM.SQL_PLAN_HASH_VALUE||SPM.KEY||SPM.MO||'">ID:'||spm.PLAN_LINE_ID
                           ||'</a>) The Operation had inaccurate cardinality estimation. (CARD vs ROWS : '||SPM.PLAN_CARDINALITY||'*'||SPM.STARTS||' vs '||SPM.OUTPUT_ROWS||')');
                           if( :L_ROWCNT > -1
                               AND to_date(:L_last_load_time,'YYYY-MM-DD HH24:MI:SS') <> to_date('1000-01-01 00:00:01','YYYY-MM-DD HH24:MI:SS') )
                           then

                             IF( :L_last_load_time_CORRECT = 'NO' ) THEN
                                DBMS_OUTPUT.PUT_LINE('+ Could not find exact hard parsing time. But when the sql was executed on '||sm.start_time||',');
                             END IF;
                             DBMS_OUTPUT.PUT_LINE('+ '||SPM.PLAN_OBJECT_NAME||' had '||:L_ROWCNT||' as a statistics row on '||:L_ANALYZETIME||' (<a href="#PHV'||SPM.SQL_PLAN_HASH_VALUE||SPM.KEY||SPM.MO||'">ID:'||spm.PLAN_LINE_ID||'</a>).');

                           end if;
                           DBMS_OUTPUT.PUT_LINE('=>Issue Category: <RED>Cardinality estimation******</RED>'); :issue_inac_card_estim := 1;
                           DBMS_OUTPUT.PUT_LINE('<blue>Action Item : DEVELOPMENT TEAM/PSR</BLUE>');
                           DBMS_OUTPUT.PUT_LINE('=>Suggestion: Check stale stats, related condition, bind peeked value, function constant/bind, embedded hint and etc, if needed.');
                        END IF;
                      IF ( :L_FLAGS <> 'REAL_TIME_STATS' AND SPM.access_predicates IS NOT NULL
                           AND ( SUBSTR(SPM.access_predicates,2) LIKE '%(%'
                             OR  UPPER(SPM.access_predicates) LIKE '%ROWNUM%'
                             OR  UPPER(SPM.access_predicates) LIKE '% OR %'
                             OR  UPPER(SPM.access_predicates) LIKE '%/*+%' )
                         ) THEN
                           DBMS_OUTPUT.PUT_LINE('+ (OID:'||SPM.MO||') AP:' ||SUBSTR(SPM.access_predicates,  1,120));
                           DBMS_OUTPUT.PUT_LINE(SUBSTR(SPM.access_predicates,121,240));
                           DBMS_OUTPUT.PUT_LINE(SUBSTR(SPM.access_predicates,241,360));
                      END IF;
                      IF ( :L_FLAGS <> 'REAL_TIME_STATS' AND SPM.filter_predicates IS NOT NULL
                           AND ( SUBSTR(SPM.access_predicates,2) LIKE '%(%'
                             OR  UPPER(SPM.filter_predicates) LIKE '%ROWNUM%'
                             OR  UPPER(SPM.filter_predicates) LIKE '% OR %'
                             OR  UPPER(SPM.filter_predicates) LIKE '%/*+%' )
                         ) THEN
                           DBMS_OUTPUT.PUT_LINE('+ (OID:'||SPM.MO||') FP:' ||SUBSTR(SPM.filter_predicates,  1,120));
                           DBMS_OUTPUT.PUT_LINE(SUBSTR(SPM.filter_predicates,121,240));
                           DBMS_OUTPUT.PUT_LINE(SUBSTR(SPM.filter_predicates,241,360));
                      END IF;
                      DBMS_OUTPUT.PUT_LINE('.');  --jjj
                           IF ( :L_FLAGS <> 'REAL_TIME_STATS' AND :L_TAB_STALE_STATS = 'YES' ) THEN
                               DBMS_OUTPUT.PUT_LINE('=>Issue Category: <RED>Stats</RED>'); :issue_stats := 1;
                               DBMS_OUTPUT.PUT_LINE('<blue>Action Item : OPERATION TEAM</BLUE>');
                               DBMS_OUTPUT.PUT_LINE('=>Suggestion: Gather Table Stats on '||SPM.PLAN_OBJECT_OWNER||'.'||SPM.PLAN_OBJECT_NAME||'.');
                               IF ( :L_TABLE_NAME = UPPER(:L_TABLE_NAME) ) THEN
                                 DBMS_OUTPUT.PUT_LINE('=>i.e. <BLUE>EXEC DBMS_STATS.GATHER_TABLE_STATS('''||spm.PLAN_OBJECT_OWNER||''','''||:L_TABLE_NAME||''',NO_INVALIDATE=>FALSE);</BLUE>');
                               ELSIF ( :L_TABLE_NAME = LOWER(:L_TABLE_NAME) ) THEN
                                 DBMS_OUTPUT.PUT_LINE('=>i.e. <BLUE>EXEC DBMS_STATS.GATHER_TABLE_STATS('''||spm.PLAN_OBJECT_OWNER||''',''"'||:L_TABLE_NAME||'"'',NO_INVALIDATE=>FALSE);</BLUE>');
                               END IF;
                           END IF;
                       END IF ;
                    -- IF (SPM.PLAN_OPERATION = 'TABLE ACCESS' and SPM.PLAN_OPTIONS in ('FULL','STORAGE FULL')) THEN
                    -- WHEN NO JPPD ISSUE ONLY,
--V3
                       IF (:L_FLAGS <> 'REAL_TIME_STATS' AND :L_PPV_MESSAGE = 0
                            AND SPM.OUTPUT_ROWS > :L_ACCESS_RATIO*:L_ACCESS_RATIO*:L_ACCESS_RATIO*:L_ACCESS_RATIO )
                            THEN
                         IF (SPM.PLAN_OPERATION = 'TABLE ACCESS'
                             and (SPM.PLAN_OPTIONS LIKE 'FULL%' OR SPM.PLAN_OPTIONS LIKE 'STORAGE FULL%') ) THEN
                             DBMS_OUTPUT.PUT_LINE('* Analysis');
                             DBMS_OUTPUT.PUT_LINE('* (<a href="#PHV'||SPM.SQL_PLAN_HASH_VALUE||SPM.KEY||SPM.MO||'">ID:'||spm.PLAN_LINE_ID||'</a>) FULL Scan happened at '||SPM.PLAN_OBJECT_NAME||' with high I/Os.');
                             DBMS_OUTPUT.PUT_LINE('=>Issue Category: <RED>Blind operation</RED>'); :issue_blind_query := 1;
                             IF ( UPPER(TRIM(SUBSTR(:SQL_TEXT,1,6))) NOT IN ('CREATE','ALTER','DROP ','TRUNCA') ) THEN
                                  DBMS_OUTPUT.PUT_LINE('<blue>Action Item : DEVELOPMENT TEAM</BLUE>');
                                  DBMS_OUTPUT.PUT_LINE(SM.PX||'=>Suggestion: Use indexed column condition to avoid the table full scan at '||SPM.PLAN_OBJECT_NAME
                                  ||' (<a href="#PHV'||SPM.SQL_PLAN_HASH_VALUE||SPM.KEY||SPM.MO||'">ID:'||spm.PLAN_LINE_ID||'</a>).');
                                  DBMS_OUTPUT.PUT_LINE('.');
                             END IF;
                         ELSE
                             DBMS_OUTPUT.PUT_LINE('* Analysis');
                             DBMS_OUTPUT.PUT_LINE('* (<a href="#PHV'||SPM.SQL_PLAN_HASH_VALUE||SPM.KEY||SPM.MO||'">ID:'||spm.PLAN_LINE_ID||'</a>) The operation required high I/Os at '||SPM.PLAN_OBJECT_NAME||'.');
                             DBMS_OUTPUT.PUT_LINE('=>Issue Category: <RED>Blind operation</RED>'); :issue_blind_query := 1;
                             IF ( UPPER(TRIM(SUBSTR(:SQL_TEXT,1,6))) NOT IN ('CREATE','ALTER','DROP ','TRUNCA') ) THEN
                                 DBMS_OUTPUT.PUT_LINE('<blue>Action Item : DEVELOPMENT TEAM</BLUE>');
                                 DBMS_OUTPUT.PUT_LINE('=>Suggestion: Add more selective condition on '||SPM.PLAN_OBJECT_NAME||' (<a href="#PHV'||SPM.SQL_PLAN_HASH_VALUE||SPM.KEY||SPM.MO||'">ID:'||spm.PLAN_LINE_ID||'</a>).');
                                 DBMS_OUTPUT.PUT_LINE('.');
                             END IF;
                         END IF;
                       END IF;
                  END IF;
              --    DBMS_OUTPUT.PUT_LINE('****join method:'||SPM.JOIN_METHOD||']');
              --    DBMS_OUTPUT.PUT_LINE('++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++');
                IF (:issue_blind_query = 1 OR :issue_inac_card_estim = 1 OR :issue_stats = 1) THEN
                  :l_mo5 := :l_mo4;
                  :l_mo4 := :l_mo3;
                  :l_mo3 := :l_mo2;
                  :l_mo2 := :l_mo1;
                  :l_mo1 := spm.mo;
                END IF;
              END IF;
           END IF;
             -- TABLE (FIXED)
           IF ( SPM.PLAN_OBJECT_TYPE = 'TABLE (FIXED)' AND SPM.OUTPUT_ROWS > :L_ACCESS_RATIO*:L_ACCESS_RATIO*40000 ) THEN
                  DBMS_OUTPUT.PUT_LINE('* Analysis');
                  DBMS_OUTPUT.PUT_LINE('=>Issue Category: <RED>Blind operation</RED>'); :issue_blind_query := 1;
                  DBMS_OUTPUT.PUT_LINE('<blue>Action Item : DEVELOPMENT TEAM</BLUE>');
                  DBMS_OUTPUT.PUT_LINE('=>Suggestion: Add more selective condition to FIXED Object to reduce the number of rows'||' (<a href="#PHV'||SPM.SQL_PLAN_HASH_VALUE||SPM.KEY||SPM.MO||'">ID:'||spm.PLAN_LINE_ID||'</a>).');
                  DBMS_OUTPUT.PUT_LINE('.');
                  :l_mo5 := :l_mo4;
                  :l_mo4 := :l_mo3;
                  :l_mo3 := :l_mo2;
                  :l_mo2 := :l_mo1;
                  :l_mo1 := spm.mo;
           END IF;
             -- TABLE (TEMP)
           IF ( SPM.PLAN_OBJECT_TYPE = 'TABLE (TEMP)' AND SPM.PLAN_OBJECT_NAME LIKE 'SYS_TEMP%'
                  AND SPM.OUTPUT_ROWS > :L_ACCESS_RATIO*:L_ACCESS_RATIO*40000  ) THEN
                  DBMS_OUTPUT.PUT_LINE('* Analysis');
                  DBMS_OUTPUT.PUT_LINE('=>Issue Category: <RED>Blind operation</RED>'); :issue_blind_query := 1;
                  DBMS_OUTPUT.PUT_LINE('<blue>Action Item : DEVELOPMENT TEAM</BLUE>');
                  DBMS_OUTPUT.PUT_LINE('=>Suggestion: Add more selective condition to WITH QUERY BLOCK to reduce the number of rows'||' (<a href="#PHV'||SPM.SQL_PLAN_HASH_VALUE||SPM.KEY||SPM.MO||'">ID:'||spm.PLAN_LINE_ID||'</a>).');
                  DBMS_OUTPUT.PUT_LINE('.');
                  :l_mo5 := :l_mo4;
                  :l_mo4 := :l_mo3;
                  :l_mo3 := :l_mo2;
                  :l_mo2 := :l_mo1;
                  :l_mo1 := spm.mo;
           END IF;
        END IF; /* IO END */
/*  ASH START : ASH SNAP_COUNT AND WAIT expect ON-CPU */
        IF ( SPM.TP = 'ASH' ) THEN
             :L_WHERE_LOG := 'ASH';
             :l_as5 := :l_as4;
             :l_as4 := :l_as3;
             :l_as3 := :l_as2;
             :l_as2 := :l_as1;
             :l_as1 := spm.mo;
             :l_OCC5 := :l_OCC4;
             :l_OCC4 := :l_OCC3;
             :l_OCC3 := :l_OCC2;
             :l_OCC2 := :l_OCC1;
             :l_OCC1 := spm.ON_CPU_COUNT;
             :l_WC5 := :l_WC4;
             :l_WC4 := :l_WC3;
             :l_WC3 := :l_WC2;
             :l_WC2 := :l_WC1;
             :l_WC1 := spm.WAITS_COUNT;
           :L_WHERE_LOG := 'ASH';
/*
ash.SNAP_COUNT, ash.WAITS_COUNT, ash.ON_CPU_COUNT : 20180430
*/
--           DBMS_OUTPUT.PUT_LINE('* ASH snp_count: '  ||SPM.SNAP_COUNT||' w:'||spm.WAITS_COUNT||' cpu:'||spm.ON_CPU_COUNT);
           IF( SPM.RN = 1 )                      THEN
              null;
                 DBMS_OUTPUT.PUT_LINE('.') ;
                 DBMS_OUTPUT.PUT_LINE('Active Session History Information Section') ;
                 DBMS_OUTPUT.PUT_LINE('******************************************') ;
           END IF;

--   DBMS_OUTPUT.PUT_LINE(SPM.PLAN_OBJECT_NAME||'parse:'||SPM.IN_PARSE_COUNT||' hard:'||SPM.IN_HARD_PARSE_COUNT||' waits:'||SPM.WAITS_COUNT||' cpu:'||spm.ON_CPU_COUNT||' mo:'||spm.mo||' plan_line:'||spm.PLAN_LINE_ID);

           IF ( ( SPM.IN_HARD_PARSE_COUNT > 1 or SPM.IN_PARSE_COUNT > 1) AND SPM.MO IS NULL ) THEN
             DBMS_OUTPUT.PUT_LINE('* ASH: ('||SPM.IN_PARSE_COUNT||'%) Parse with '||SPM.IN_HARD_PARSE_COUNT||'% Hard Parse');
           END IF;
           IF ( SPM.ON_CPU_COUNT > 0 and SPM.PLAN_OBJECT_NAME is null and ( SPM.IN_HARD_PARSE_COUNT = 0 AND SPM.IN_PARSE_COUNT = 0 ) )   THEN  -- join --
--   DBMS_OUTPUT.PUT_LINE(SPM.PLAN_OBJECT_NAME||'parse:'||SPM.IN_PARSE_COUNT||' hard:'||SPM.IN_HARD_PARSE_COUNT||' waits:'||SPM.WAITS_COUNT||' cpu:'||spm.ON_CPU_COUNT||' mo:'||spm.mo||' plan_line:'||spm.PLAN_LINE_ID);
             DBMS_OUTPUT.PUT_LINE('* ASH: ('||SPM.ON_CPU_COUNT||'%) Session State was ON CPU on '||SPM.PLAN_OPERATION||' (<a href="#PHV'||SPM.SQL_PLAN_HASH_VALUE||SPM.KEY||SPM.MO||'">ID:'||spm.PLAN_LINE_ID||'</a>).');
             IF ( SPM.BLOCKING_SESSION_COUNT = 1 ) THEN
                DBMS_OUTPUT.PUT_LINE('+ Other Session was blocking with '||SPM.EVENT||' on '||SPM.PLAN_OBJECT_NAME||' (<a href="#PHV'||SPM.SQL_PLAN_HASH_VALUE||SPM.KEY||SPM.MO||'">ID:'||spm.PLAN_LINE_ID||'</a>).');
             END IF;
             IF ( SPM.BLOCKING_SESSION_COUNT > 1 ) THEN
                DBMS_OUTPUT.PUT_LINE('+ '||spm.BLOCKING_SESSION_COUNT||' sessions were blocking with '||SPM.EVENT||' on '||SPM.PLAN_OBJECT_NAME||' (<a href="#PHV'||SPM.SQL_PLAN_HASH_VALUE||SPM.KEY||SPM.MO||'">ID:'||spm.PLAN_LINE_ID||'</a>).');
             END IF;
             IF ( SPM.SELF_BLOCKING_COUNT >= 1 ) THEN
                DBMS_OUTPUT.PUT_LINE('+ Same session was blocking with '||SPM.EVENT||' on '||SPM.PLAN_OBJECT_NAME||' (<a href="#PHV'||SPM.SQL_PLAN_HASH_VALUE||SPM.KEY||SPM.MO||'">ID:'||spm.PLAN_LINE_ID||'</a>).');
             END IF;
           END IF;
           IF ( SPM.ON_CPU_COUNT > 0 and SPM.PLAN_OBJECT_NAME is not null and ( SPM.IN_HARD_PARSE_COUNT = 0 AND SPM.IN_PARSE_COUNT = 0 ) )   THEN  -- eliminate parsing --
             DBMS_OUTPUT.PUT_LINE('* ASH: ('||SPM.ON_CPU_COUNT||'%) Session State was ON CPU on '||SPM.PLAN_OBJECT_NAME||' (<a href="#PHV'||SPM.SQL_PLAN_HASH_VALUE||SPM.KEY||SPM.MO||'">ID:'||spm.PLAN_LINE_ID||'</a>).');
             IF ( SPM.BLOCKING_SESSION_COUNT = 1 ) THEN
                DBMS_OUTPUT.PUT_LINE('+ Other Session was blocking with '||SPM.EVENT||' on '||SPM.PLAN_OBJECT_NAME||' (<a href="#PHV'||SPM.SQL_PLAN_HASH_VALUE||SPM.KEY||SPM.MO||'">ID:'||spm.PLAN_LINE_ID||'</a>).');
             END IF;
             IF ( SPM.BLOCKING_SESSION_COUNT > 1 ) THEN
                DBMS_OUTPUT.PUT_LINE('+ '||spm.BLOCKING_SESSION_COUNT||' sessions were blocking with '||SPM.EVENT||' on '||SPM.PLAN_OBJECT_NAME||' (<a href="#PHV'||SPM.SQL_PLAN_HASH_VALUE||SPM.KEY||SPM.MO||'">ID:'||spm.PLAN_LINE_ID||'</a>).');
             END IF;
             IF ( SPM.SELF_BLOCKING_COUNT >= 1 ) THEN
                DBMS_OUTPUT.PUT_LINE('+ Same session was blocking with '||SPM.EVENT||' on '||SPM.PLAN_OBJECT_NAME||' (<a href="#PHV'||SPM.SQL_PLAN_HASH_VALUE||SPM.KEY||SPM.MO||'">ID:'||spm.PLAN_LINE_ID||'</a>).');
             END IF;
           END IF;
           IF ( SPM.WAITS_COUNT > 0 )   THEN
             DBMS_OUTPUT.PUT_LINE('* ASH: ('||SPM.WAITS_COUNT||'%) Event, '||SPM.EVENT||' was on '||SPM.PLAN_OBJECT_NAME||' (<a href="#PHV'||SPM.SQL_PLAN_HASH_VALUE||SPM.KEY||SPM.MO||'">ID:'||spm.PLAN_LINE_ID||'</a>).');
             IF ( SPM.BLOCKING_SESSION_COUNT = 1 ) THEN
             -- DBMS_OUTPUT.PUT_LINE('* ASH: ('||SPM.WAITS_COUNT||rPAD('~',5-LENGTH(SPM.WAITS_COUNT))||'%) Other Session was blocking with '||SPM.EVENT||' on '||SPM.PLAN_OBJECT_NAME||' (ID:'||SPM.PLAN_LINE_ID||').');
                DBMS_OUTPUT.PUT_LINE('+ Other Session was blocking with '||SPM.EVENT||' on '||SPM.PLAN_OBJECT_NAME||' (<a href="#PHV'||SPM.SQL_PLAN_HASH_VALUE||SPM.KEY||SPM.MO||'">ID:'||spm.PLAN_LINE_ID||'</a>).');
             END IF;
             IF ( SPM.BLOCKING_SESSION_COUNT > 1 ) THEN
                DBMS_OUTPUT.PUT_LINE('+ '||spm.BLOCKING_SESSION_COUNT||' sessions were blocking with '||SPM.EVENT||' on '||SPM.PLAN_OBJECT_NAME||' (<a href="#PHV'||SPM.SQL_PLAN_HASH_VALUE||SPM.KEY||SPM.MO||'">ID:'||spm.PLAN_LINE_ID||'</a>).');
             END IF;
             IF ( SPM.SELF_BLOCKING_COUNT >= 1 ) THEN
                DBMS_OUTPUT.PUT_LINE('+ Same session was blocking with '||SPM.EVENT||' on '||SPM.PLAN_OBJECT_NAME||' (<a href="#PHV'||SPM.SQL_PLAN_HASH_VALUE||SPM.KEY||SPM.MO||'">ID:'||spm.PLAN_LINE_ID||'</a>).');
             END IF;
-- sma19c 20200211 19C Scalable Sequence
             IF ( trim(SPM.EVENT) = 'enq: TX - index contention' and SPM.PLAN_OPERATION like 'LOAD TABLE%' and ( :L_SHORT_DB_VERSION LIKE '19%' or :L_SHORT_DB_VERSION LIKE '2%') ) THEN
                DBMS_OUTPUT.PUT_LINE('+ ('||SPM.WAITS_COUNT||'%) Event, '||SPM.EVENT||' -> <blue>Use Scalable Sequence</blue> for '||SPM.PLAN_OBJECT_NAME||' (<a href="#PHV'||SPM.SQL_PLAN_HASH_VALUE||SPM.KEY||SPM.MO||'">ID:'||spm.PLAN_LINE_ID||'</a>).');
             END IF;




           END IF;
        END IF;
/*  ASH END: ASH SNAP_COUNT AND WAIT expect ON-CPU */
        IF (SPM.TP = 'PRNT') THEN

             -- IF ( MOD(:L_COLOR,2) = 1 )    THEN :L_COLOR_TYPE := 'smac>';
             -- ELSIF ( MOD(:L_COLOR,2) = 0 ) THEN :L_COLOR_TYPE := 'smanc>';
             -- END IF;

          IF (SPM.RN = 1) THEN
              :L_WHERE_LOG := 'PRNT';
              DBMS_OUTPUT.PUT_LINE('+');
              DBMS_OUTPUT.PUT_LINE('RUNTIME PLAN SECTION');
              DBMS_OUTPUT.PUT_LINE('********************');
              DBMS_OUTPUT.PUT_LINE('[NOTE  Dot line(....)=>Expensive operation, C=>CHECK, I=>IO, W=>WAITS, P=>CPU]');
--              DBMS_OUTPUT.PUT_LINE('[PR=>PHYSICAL_READ_REQUESTS, PW=>PHYSICAL_WRITE_REQUESTS, PGA=>WORKAREA_MEMORY, TEMP=>WORKAREA_TEMPSEG]');
              DBMS_OUTPUT.PUT_LINE('--- --- --- ----------- --------------------------------------------------------------------------');
              DBMS_OUTPUT.PUT_LINE('CIWP ID  OID ROWS       ROW SOURCE FROM <blue>SQL_PLAN_MONITOR</blue>');
              DBMS_OUTPUT.PUT_LINE('---- --- --- ---------- --------------------------------------------------------------------------');
          END IF;
          IF (spm.PHYSICAL_READ_REQUESTS IS NULL or spm.PHYSICAL_READ_REQUESTS = 0) THEN :L_PR := NULL; ELSE :L_PR := ' PHY_READ:'||spm.PHYSICAL_READ_REQUESTS;  END IF;
          IF (spm.PHYSICAL_WRITE_REQUESTS IS NULL or spm.PHYSICAL_WRITE_REQUESTS=0) THEN :L_PW := NULL; ELSE :L_PW := ' PHY_WRT:'||spm.PHYSICAL_WRITE_REQUESTS; END IF;
          IF (spm.WORKAREA_MAX_MEM IS NULL or spm.WORKAREA_MAX_MEM=0)               THEN :L_PGA:= NULL; ELSE :L_PGA :='<RED> PGA:'||spm.PGA_MB||'M</RED>';    END IF;
          IF (spm.WORKAREA_MAX_TEMPSEG IS NULL or spm.WORKAREA_MAX_TEMPSEG=0)       THEN :L_TEMP:=NULL; ELSE :L_TEMP:='<RED> TEMP:'||spm.TEMP_MB||'M</RED>';  END IF;
--          IF (spm.WORKAREA_MAX_MEM IS NULL or spm.WORKAREA_MAX_MEM=0)               THEN :L_PGA:= NULL; ELSE :L_PGA :='<RED> PGA:'||spm.WORKAREA_MAX_MEM||'</RED>';    END IF;
--          IF (spm.WORKAREA_MAX_TEMPSEG IS NULL or spm.WORKAREA_MAX_TEMPSEG=0)       THEN :L_TEMP:=NULL; ELSE :L_TEMP:='<RED> TEMP:'||spm.WORKAREA_MAX_TEMPSEG||'</RED>';  END IF;
          IF ( spm.mo in (
               --:l_co1-2,:l_co2-2,:l_co3-2,:l_co4-2,:l_co5-2,
               :l_co1-1,:l_co2-1,:l_co3-1,:l_co4-1,:l_co5-1,
               :l_co1,  :l_co2,  :l_co3,  :l_co4,  :l_co5,
               :l_co1+1,:l_co2+1,:l_co3+1,:l_co4+1,:l_co5+1,
               --:l_co1+2,:l_co2+2,:l_co3+2,:l_co4+2,:l_co5+2,
               --:l_mo1-2,:l_mo2-2,:l_mo3-2,:l_mo4-2,:l_mo5-2,
               :l_mo1-1,:l_mo2-1,:l_mo3-1,:l_mo4-1,:l_mo5-1,
               :l_mo1,  :l_mo2,  :l_mo3,  :l_mo4,  :l_mo5,
               :l_mo1+1,:l_mo2+1,:l_mo3+1,:l_mo4+1,:l_mo5+1,
               --:l_mo1+2,:l_mo2+2,:l_mo3+2,:l_mo4+2,:l_mo5+2,
               --:l_as1-2,:l_as2-2,:l_as3-2,:l_as4-2,:l_as5-2,
               :l_as1-1,:l_as2-1,:l_as3-1,:l_as4-1,:l_as5-1,
               :l_as1,  :l_as2,  :l_as3,  :l_as4,  :l_as5,
               :l_as1+1,:l_as2+1,:l_as3+1,:l_as4+1,:l_as5+1
               --,:l_as1+2,:l_as2+2,:l_as3+2,:l_as4+2,:l_as5+2
                 ) ) THEN
              IF(spm.mo in (:l_co1,:l_co2,:l_co3,:l_co4,:l_co5)) THEN :l_CKmark  := 'C'; ELSE :l_CKmark  := '.';   END IF;
              IF(spm.mo in (:l_mo1,:l_mo2,:l_mo3,:l_mo4,:l_mo5)) THEN :l_IOmark  := 'I'; ELSE :l_IOmark  := '.';   END IF;
              IF(spm.mo = :l_as1 and :l_occ1 > 0)    THEN  :l_CPUmark := 'P';  :l_occ := :l_occ1;
              ELSIF(spm.mo = :l_as2 and :l_occ2 > 0) THEN  :l_CPUmark := 'P';  :l_occ := :l_occ2;
              ELSIF(spm.mo = :l_as3 and :l_occ3 > 0) THEN  :l_CPUmark := 'P';  :l_occ := :l_occ3;
              ELSIF(spm.mo = :l_as4 and :l_occ4 > 0) THEN  :l_CPUmark := 'P';  :l_occ := :l_occ4;
              ELSIF(spm.mo = :l_as5 and :l_occ5 > 0) THEN  :l_CPUmark := 'P';  :l_occ := :l_occ5;
              ELSE  :l_CPUmark := '.';  END IF;
              IF(spm.mo = :l_as1 and :l_wc1 > 0)     THEN  :l_WAmark := 'W';   :l_wc := :l_wc1;
              ELSIF(spm.mo = :l_as2 and :l_wc2 > 0)  THEN  :l_WAmark := 'W';   :l_wc := :l_wc2;
              ELSIF(spm.mo = :l_as3 and :l_wc3 > 0)  THEN  :l_WAmark := 'W';   :l_wc := :l_wc3;
              ELSIF(spm.mo = :l_as4 and :l_wc4 > 0)  THEN  :l_WAmark := 'W';   :l_wc := :l_wc4;
              ELSIF(spm.mo = :l_as5 and :l_wc5 > 0)  THEN  :l_WAmark := 'W';   :l_wc := :l_wc5;
              ELSE  :l_WAmark := '.';  END IF;

                 IF( (:l_CKmark = 'C' OR :l_IOmark = 'I' OR :l_WAmark = 'W' OR :l_CPUmark = 'P')
                      AND (TRIM(SPM.ACCESS_PREDICATES) IS NOT NULL OR TRIM(SPM.FILTER_PREDICATES) IS NOT NULL) ) THEN

-- DEBUG CODE
--         DBMS_OUTPUT.PUT_LINE('<a name="PHV'||SM.SQL_PLAN_HASH_VALUE||'"></a>'||'PHV: '||SM.SQL_PLAN_HASH_VALUE||', KEY:'||SM.KEY||', SQL_EXEC_ID:'||SM.SQL_EXEC_ID||', SID:'||SM.SID);
--        DBMS_OUTPUT.PUT_LINE('<a name="PHV'||SPM.SQL_PLAN_HASH_VALUE||SPM.KEY||SPM.MO||'"></a>'
--      p.KEY p.SQL_PLAN_HASH_VALUE p.mo

                     DBMS_OUTPUT.PUT_LINE(
                    '<a name="PHV'||SPM.SQL_PLAN_HASH_VALUE||SPM.KEY||SPM.MO||'"></a><RED>'||
                     :l_CKmark||:l_IOmark||:l_WAmark||:l_CPUmark||'.'||lPAD('...',3-LENGTH(SPM.PLAN_LINE_ID))||SPM.PLAN_LINE_ID
                     --||' p:'||lPAD('   ',4-LENGTH(SPM.pid))||SPM.pid
                     --||' o:'||LPAD('   ',4-LENGTH(SPM.oid))||SPM.oid
                     --||' mo:'||
                     --||'.'||LPAD('   ', 3-LENGTH(SPM.MXID))||SPM.MXID
                     ||'.'||LPAD('...', 3-LENGTH(SPM.MO))||SPM.MO
----20200727 fix (start)---------------------------------------------------------------------------------------------
--                   ||'.'||lpad('..........',10-length(SPM.output_rows))||SPM.output_rows
                     ||'.'||lpad('..........',10-length(nvl(CASE
         WHEN SPM.output_rows >= 1e18 THEN ROUND(SPM.output_rows / 1e18,1) || 'E'
         WHEN SPM.output_rows >= 1e15 THEN ROUND(SPM.output_rows / 1e15,1) || 'P'
         WHEN SPM.output_rows >= 1e12 THEN ROUND(SPM.output_rows / 1e12,1) || 'T'
         WHEN SPM.output_rows >= 1e9 THEN ROUND(SPM.output_rows / 1e9,1) || 'G'
         WHEN SPM.output_rows >= 1e6 THEN ROUND(SPM.output_rows / 1e6,1) || 'M'
         WHEN SPM.output_rows >= 1e3 THEN ROUND(SPM.output_rows / 1e3,1) || 'K'
         ELSE to_char(round(SPM.output_rows,2)) END, ' ')))||nvl(CASE
         WHEN SPM.output_rows >= 1e18 THEN ROUND(SPM.output_rows / 1e18,1) || 'E'
         WHEN SPM.output_rows >= 1e15 THEN ROUND(SPM.output_rows / 1e15,1) || 'P'
         WHEN SPM.output_rows >= 1e12 THEN ROUND(SPM.output_rows / 1e12,1) || 'T'
         WHEN SPM.output_rows >= 1e9 THEN ROUND(SPM.output_rows / 1e9,1) || 'G'
         WHEN SPM.output_rows >= 1e6 THEN ROUND(SPM.output_rows / 1e6,1) || 'M'
         WHEN SPM.output_rows >= 1e3 THEN ROUND(SPM.output_rows / 1e3,1) || 'K'
         ELSE to_char(round(SPM.output_rows,2)) END, ' ')
----20200727 fix (end  )---------------------------------------------------------------------------------------------
                     ||'.'|| LPAD('..............',spm.plan_depth,'.')||spm.OPERATION
                     ||'['||SPM.JOIN_METHOD||']'
                     --||'-cs:'||SPM.p_cost
                     ||' CDNT:'||SPM.plan_cardinality
                     ||:L_PR
                     ||:L_PW
                     ||:L_PGA
                     ||:L_TEMP
                     ||' JOR:'||spm.join_output_rows
                     ||'..[CPU:'||:l_occ||'%, WAITS:'||:l_wc||'%]'
                     --||' PR:'||spm.PHYSICAL_READ_REQUESTS
                     --||' PW:'||spm.PHYSICAL_WRITE_REQUESTS
                     --||' PGA:'||spm.WORKAREA_MEM
                     --||' TP:'||spm.WORKAREA_TEMPSEG
                     --||'-actrow:'||SPM.outp_rows||'-tm:'||spm.opr_time||'-st:'||SPM.starts
                     --||'-sc:'||spm.snap_count||'-Bksc:'||spm.BLOCKING_SESSION_COUNT
--                     ||'</RED>');
                     ||'</RED><a href="#PHVP'||SPM.SQL_PLAN_HASH_VALUE||SPM.KEY||SPM.MO||'"><blue>*predicates*</blue></a>');
                     
/* predicates just below operation
                IF (SPM.ACCESS_PREDICATES IS NOT NULL or SPM.FILTER_PREDICATES IS NOT NULL) THEN
                     DBMS_OUTPUT.PUT_LINE('<DETAILS><SUMMARY>Predicates</SUMMARY>');
                END IF;
                IF (SPM.ACCESS_PREDICATES IS NOT NULL) THEN
                   --DBMS_OUTPUT.PUT_LINE('ID: '||SPM.PLAN_LINE_ID||'A- '||SPM.ACCESS_PREDICATES);
                  IF( instr(substr(SPM.access_predicates,100),' ') = 0 ) THEN
                     DBMS_OUTPUT.PUT_LINE(
                     'ID: '||SPM.PLAN_LINE_ID||' Access - '||substr(SPM.access_predicates,1,
                     nvl(instr(substr(SPM.access_predicates,100),' ')+150-1,150)));
                  ELSE
                     DBMS_OUTPUT.PUT_LINE(
                     'ID: '||SPM.PLAN_LINE_ID||' Access - '||substr(SPM.access_predicates,1,
                     nvl(instr(substr(SPM.access_predicates,100),' ')+100-1,100)));
                     DBMS_OUTPUT.PUT_LINE(substr(SPM.access_predicates,instr(substr(SPM.access_predicates,100),' ')+100,
                     nvl(instr(substr(SPM.access_predicates,220),' ')+120-0,120)));
                     DBMS_OUTPUT.PUT_LINE(substr(SPM.access_predicates,instr(substr(SPM.access_predicates,220),' ')+220,
                     nvl(instr(substr(SPM.access_predicates,340),' ')+120-1,120)));
                     DBMS_OUTPUT.PUT_LINE(substr(SPM.access_predicates,instr(substr(SPM.access_predicates,340),' ')+340,
                     nvl(instr(substr(SPM.access_predicates,460),' ')+120-0,120)));
                  END IF;
                END IF;
                IF (SPM.FILTER_PREDICATES IS NOT NULL) THEN
                   --DBMS_OUTPUT.PUT_LINE('ID: '||SPM.PLAN_LINE_ID||'F- '||SPM.FILTER_PREDICATES);
                  IF( instr(substr(SPM.filter_predicates,100),' ') = 0 ) THEN
                     DBMS_OUTPUT.PUT_LINE(
                     'ID: '||SPM.PLAN_LINE_ID||' Access - '||substr(SPM.filter_predicates,1,
                     nvl(instr(substr(SPM.filter_predicates,100),' ')+150-1,150)));
                  ELSE
                     DBMS_OUTPUT.PUT_LINE(
                     'ID: '||SPM.PLAN_LINE_ID||' Filter - '||substr(SPM.filter_predicates,1,
                     nvl(instr(substr(SPM.filter_predicates,100),' ')+100-1,100)));
                     DBMS_OUTPUT.PUT_LINE(substr(SPM.filter_predicates,instr(substr(SPM.filter_predicates,100),' ')+100,
                     nvl(instr(substr(SPM.filter_predicates,220),' ')+120-0,120)));
                     DBMS_OUTPUT.PUT_LINE(substr(SPM.filter_predicates,instr(substr(SPM.filter_predicates,220),' ')+220,
                     nvl(instr(substr(SPM.filter_predicates,340),' ')+120-1,120)));
                     DBMS_OUTPUT.PUT_LINE(substr(SPM.filter_predicates,instr(substr(SPM.filter_predicates,340),' ')+340,
                     nvl(instr(substr(SPM.filter_predicates,460),' ')+120-0,120)));
                  END IF;
                END IF;
                IF (SPM.ACCESS_PREDICATES IS NOT NULL or SPM.FILTER_PREDICATES IS NOT NULL) THEN
                     DBMS_OUTPUT.PUT_LINE('</DETAILS>');
                END IF;
*/
                 ELSIF( (:l_CKmark = 'C' OR :l_IOmark = 'I' OR :l_WAmark = 'W' OR :l_CPUmark = 'P')
                      AND SPM.ACCESS_PREDICATES IS NULL AND SPM.FILTER_PREDICATES IS NULL ) THEN
                     DBMS_OUTPUT.PUT_LINE(
                    '<a name="PHV'||SPM.SQL_PLAN_HASH_VALUE||SPM.KEY||SPM.MO||'"></a><RED>'||
                     :l_CKmark||:l_IOmark||:l_WAmark||:l_CPUmark||'.'||lPAD('...',3-LENGTH(SPM.PLAN_LINE_ID))||SPM.PLAN_LINE_ID
                     --||' p:'||lPAD('   ',4-LENGTH(SPM.pid))||SPM.pid
                     --||' o:'||LPAD('   ',4-LENGTH(SPM.oid))||SPM.oid
                     --||' mo:'||
                     --||'.'||LPAD('   ', 3-LENGTH(SPM.MXID))||SPM.MXID
                     ||'.'||LPAD('...', 3-LENGTH(SPM.MO))||SPM.MO
--                     ||'.'||lpad('..........',10-length(SPM.output_rows))||SPM.output_rows
--sma19c20191211
                     ||'.'||lpad('..........',10-length(nvl(CASE
         WHEN SPM.output_rows >= 1e18 THEN ROUND(SPM.output_rows / 1e18,1) || 'E'
         WHEN SPM.output_rows >= 1e15 THEN ROUND(SPM.output_rows / 1e15,1) || 'P'
         WHEN SPM.output_rows >= 1e12 THEN ROUND(SPM.output_rows / 1e12,1) || 'T'
         WHEN SPM.output_rows >= 1e9 THEN ROUND(SPM.output_rows / 1e9,1) || 'G'
         WHEN SPM.output_rows >= 1e6 THEN ROUND(SPM.output_rows / 1e6,1) || 'M'
         WHEN SPM.output_rows >= 1e3 THEN ROUND(SPM.output_rows / 1e3,1) || 'K'
         ELSE to_char(round(SPM.output_rows,2)) END, ' ')))||nvl(CASE
         WHEN SPM.output_rows >= 1e18 THEN ROUND(SPM.output_rows / 1e18,1) || 'E'
         WHEN SPM.output_rows >= 1e15 THEN ROUND(SPM.output_rows / 1e15,1) || 'P'
         WHEN SPM.output_rows >= 1e12 THEN ROUND(SPM.output_rows / 1e12,1) || 'T'
         WHEN SPM.output_rows >= 1e9 THEN ROUND(SPM.output_rows / 1e9,1) || 'G'
         WHEN SPM.output_rows >= 1e6 THEN ROUND(SPM.output_rows / 1e6,1) || 'M'
         WHEN SPM.output_rows >= 1e3 THEN ROUND(SPM.output_rows / 1e3,1) || 'K'
         ELSE to_char(round(SPM.output_rows,2)) END, ' ')
                     ||'.'|| LPAD('..............',spm.plan_depth,'.')||spm.OPERATION
                     ||'['||SPM.JOIN_METHOD||']'
                     --||'-cs:'||SPM.p_cost
                     ||' CDNT:'||SPM.plan_cardinality
                     ||:L_PR
                     ||:L_PW
                     ||:L_PGA
                     ||:L_TEMP
                     ||' JOR:'||spm.join_output_rows
                     ||'..[CPU:'||:l_occ||'%, WAITS:'||:l_wc||'%]'
                     --||' PR:'||spm.PHYSICAL_READ_REQUESTS
                     --||' PW:'||spm.PHYSICAL_WRITE_REQUESTS
                     --||' PGA:'||spm.WORKAREA_MEM
                     --||' TP:'||spm.WORKAREA_TEMPSEG
                     --||'-actrow:'||SPM.outp_rows||'-tm:'||spm.opr_time||'-st:'||SPM.starts
                     --||'-sc:'||spm.snap_count||'-Bksc:'||spm.BLOCKING_SESSION_COUNT
                     ||'</RED>');
--                     ||'</RED><a href="#PHVP'||SPM.SQL_PLAN_HASH_VALUE||SPM.KEY||SPM.MO||'"><blue>*predicates*</blue></a>');
                     :l_CKmark := ' ';
                     :l_IOmark := ' ';
                     :l_WAmark := ' ';
                     :l_CPUmark:= ' ';
                     :l_occ := 0;
                     :l_wc  := 0;
                 ELSE
                     :l_CKmark := ':';
                     :l_IOmark := ' ';
                     :l_WAmark := ' ';
                     :l_CPUmark:= ' ';
                     :l_occ := 0;
                     :l_wc  := 0;
                     DBMS_OUTPUT.PUT_LINE(
                     '<a name="PHV'||SPM.SQL_PLAN_HASH_VALUE||SPM.KEY||SPM.MO||'"></a>'||
                     :l_CKmark||:l_IOmark||:l_WAmark||:l_CPUmark||' '||lPAD('   ',3-LENGTH(SPM.PLAN_LINE_ID))||SPM.PLAN_LINE_ID
                     --||' p:'||lPAD('   ',4-LENGTH(SPM.pid))||SPM.pid
                     --||' o:'||LPAD('   ',4-LENGTH(SPM.oid))||SPM.oid
                     --||' mo:'||
                     --||'.'||LPAD('   ', 3-LENGTH(SPM.MXID))||SPM.MXID
                     ||' '||LPAD('   ', 3-LENGTH(SPM.MO))||SPM.MO
--                     ||' '||lpad('          ',10-length(SPM.output_rows))||SPM.output_rows
--sma19c
                     ||' '||lpad('          ',10-length(nvl(CASE
         WHEN SPM.output_rows >= 1e18 THEN ROUND(SPM.output_rows / 1e18,1) || 'E'
         WHEN SPM.output_rows >= 1e15 THEN ROUND(SPM.output_rows / 1e15,1) || 'P'
         WHEN SPM.output_rows >= 1e12 THEN ROUND(SPM.output_rows / 1e12,1) || 'T'
         WHEN SPM.output_rows >= 1e9 THEN ROUND(SPM.output_rows / 1e9,1) || 'G'
         WHEN SPM.output_rows >= 1e6 THEN ROUND(SPM.output_rows / 1e6,1) || 'M'
         WHEN SPM.output_rows >= 1e3 THEN ROUND(SPM.output_rows / 1e3,1) || 'K'
         ELSE to_char(round(SPM.output_rows,2)) END, ' ')))||nvl(CASE
         WHEN SPM.output_rows >= 1e18 THEN ROUND(SPM.output_rows / 1e18,1) || 'E'
         WHEN SPM.output_rows >= 1e15 THEN ROUND(SPM.output_rows / 1e15,1) || 'P'
         WHEN SPM.output_rows >= 1e12 THEN ROUND(SPM.output_rows / 1e12,1) || 'T'
         WHEN SPM.output_rows >= 1e9 THEN ROUND(SPM.output_rows / 1e9,1) || 'G'
         WHEN SPM.output_rows >= 1e6 THEN ROUND(SPM.output_rows / 1e6,1) || 'M'
         WHEN SPM.output_rows >= 1e3 THEN ROUND(SPM.output_rows / 1e3,1) || 'K'
         ELSE to_char(round(SPM.output_rows,2)) END, ' ')
                     --||' d:'||LPAD('  ',2-LENGTH(SPM.PLAN_DEPTH))||SPM.PLAN_DEPTH
--                     ||'.'||SPM.operation
                     ||' '|| LPAD('          ',spm.plan_depth,' ')||spm.OPERATION
                     ||'['||SPM.JOIN_METHOD||']'
                     --||'-cs:'||SPM.p_cost
                     ||' CDNT:'||SPM.plan_cardinality
                     ||:L_PR
                     ||:L_PW
                     ||:L_PGA
                     ||:L_TEMP
                     ||' JOR:'||spm.join_output_rows
                     --||' PR:'||spm.PHYSICAL_READ_REQUESTS
                     --||' PW:'||spm.PHYSICAL_WRITE_REQUESTS
                     --||' PGA:'||spm.WORKAREA_MEM
                     --||' TP:'||spm.WORKAREA_TEMPSEG
                     --||'-actrow:'||SPM.outp_rows||'-tm:'||spm.opr_time||'-st:'||SPM.starts
                     --||'-sc:'||spm.snap_count||'-Bksc:'||spm.BLOCKING_SESSION_COUNT
                     );
                 END IF;
          ELSIF ( :L_PLAN_PRINT in ('P','S') ) THEN
              :l_CKmark := ' ';
              :l_IOmark := ' ';
              :l_WAmark := ' ';
              :l_CPUmark:= ' ';
              :l_occ := 0;
              :l_wc  := 0;
        --      IF ( MOD(SPM.RN,2) = 1 )    THEN :L_COLOR_TYPE := 'smac>';
        --      ELSIF ( MOD(SPM.RN,2) = 0 ) THEN :L_COLOR_TYPE := 'smanc>';
        --      END IF;
              DBMS_OUTPUT.PUT_LINE(
              '<a name="PHV'||SPM.SQL_PLAN_HASH_VALUE||SPM.KEY||SPM.MO||'"></a>'||
              ':    '||lPAD('   ',3-LENGTH(SPM.PLAN_LINE_ID))||SPM.PLAN_LINE_ID
              --||' p:'||lPAD('   ',4-LENGTH(SPM.pid))||SPM.pid
              --||' o:'||LPAD('   ',4-LENGTH(SPM.oid))||SPM.oid
              --||' mo:'||
              --||'.'||LPAD('   ', 3-LENGTH(SPM.MXID))||SPM.MXID
              ||:l_IOmark||LPAD('   ', 3-LENGTH(SPM.MO))||SPM.MO
--              ||:l_IOmark||lpad('          ',10-length(SPM.output_rows))||SPM.output_rows
--sma19c
              ||:l_IOmark||lpad('          ',10-length(nvl(CASE
         WHEN SPM.output_rows >= 1e18 THEN ROUND(SPM.output_rows / 1e18,1) || 'E'
         WHEN SPM.output_rows >= 1e15 THEN ROUND(SPM.output_rows / 1e15,1) || 'P'
         WHEN SPM.output_rows >= 1e12 THEN ROUND(SPM.output_rows / 1e12,1) || 'T'
         WHEN SPM.output_rows >= 1e9 THEN ROUND(SPM.output_rows / 1e9,1) || 'G'
         WHEN SPM.output_rows >= 1e6 THEN ROUND(SPM.output_rows / 1e6,1) || 'M'
         WHEN SPM.output_rows >= 1e3 THEN ROUND(SPM.output_rows / 1e3,1) || 'K'
         ELSE to_char(round(SPM.output_rows,2)) END, ' ')))||nvl(CASE
         WHEN SPM.output_rows >= 1e18 THEN ROUND(SPM.output_rows / 1e18,1) || 'E'
         WHEN SPM.output_rows >= 1e15 THEN ROUND(SPM.output_rows / 1e15,1) || 'P'
         WHEN SPM.output_rows >= 1e12 THEN ROUND(SPM.output_rows / 1e12,1) || 'T'
         WHEN SPM.output_rows >= 1e9 THEN ROUND(SPM.output_rows / 1e9,1) || 'G'
         WHEN SPM.output_rows >= 1e6 THEN ROUND(SPM.output_rows / 1e6,1) || 'M'
         WHEN SPM.output_rows >= 1e3 THEN ROUND(SPM.output_rows / 1e3,1) || 'K'
         ELSE to_char(round(SPM.output_rows,2)) END, ' ')
              --||' d:'||LPAD('  ',2-LENGTH(SPM.PLAN_DEPTH))||SPM.PLAN_DEPTH
              ||' '|| LPAD('          ',spm.plan_depth,' ')||spm.OPERATION
            --  ||:l_IOmark||SPM.operation
              ||'['||SPM.JOIN_METHOD||']'
              --||'-cs:'||SPM.p_cost
              ||' CDNT:'||SPM.plan_cardinality
              ||:L_PR
              ||:L_PW
              ||:L_PGA
              ||:L_TEMP
              ||' JOR:'||spm.join_output_rows
              --||' PR:'||spm.PHYSICAL_READ_REQUESTS
              --||' PW:'||spm.PHYSICAL_WRITE_REQUESTS
              --||' PGA:'||spm.WORKAREA_MEM
              --||' TP:'||spm.WORKAREA_TEMPSEG
              --||'-actrow:'||SPM.outp_rows||'-tm:'||spm.opr_time||'-st:'||SPM.starts
              --||'-sc:'||spm.snap_count||'-Bksc:'||spm.BLOCKING_SESSION_COUNT
              );
          END IF;
          :L_COLOR := :L_COLOR + 1;
        END IF;  /* PRNT ENDS */

-- 2018/11/20
-- when 1 cardinality and high number of returned row
-- need access predicate index column low-high value

        IF (SPM.TP = 'MPRDC') THEN
             IF (SPM.RN = 1) THEN
                DBMS_OUTPUT.PUT_LINE('+');
                DBMS_OUTPUT.PUT_LINE('Major Predicates Information (identified by operation id):');
                DBMS_OUTPUT.PUT_LINE('----------------------------------------------------------');
             END IF;
             IF ( SPM.MO IN (:l_co1,  :l_co2,  :l_co3,  :l_co4,  :l_co5,
                             :l_mo1,  :l_mo2,  :l_mo3,  :l_mo4,  :l_mo5,
                             :l_as1,  :l_as2,  :l_as3,  :l_as4,  :l_as5 ) )
               THEN
                IF (SPM.ACCESS_PREDICATES IS NOT NULL) THEN
                   --DBMS_OUTPUT.PUT_LINE('ID: '||SPM.PLAN_LINE_ID||'A- '||SPM.ACCESS_PREDICATES);
                  IF( instr(substr(SPM.access_predicates,100),' ') = 0 ) THEN
                     DBMS_OUTPUT.PUT_LINE(
                     '<a name="PHVP'||SPM.SQL_PLAN_HASH_VALUE||SPM.KEY||SPM.MO||'"></a>'||
                     '<RED>ID: '||SPM.PLAN_LINE_ID||' Access - </RED>'||substr(SPM.access_predicates,1,
                     nvl(instr(substr(SPM.access_predicates,100),' ')+150-1,150)));
                  ELSE
                     DBMS_OUTPUT.PUT_LINE(
                     '<a name="PHVP'||SPM.SQL_PLAN_HASH_VALUE||SPM.KEY||SPM.MO||'"></a>'||
                     '<RED>ID: '||SPM.PLAN_LINE_ID||' Access - </RED>'||substr(SPM.access_predicates,1,
                     nvl(instr(substr(SPM.access_predicates,100),' ')+100-1,100)));
                     DBMS_OUTPUT.PUT_LINE(substr(SPM.access_predicates,instr(substr(SPM.access_predicates,100),' ')+100,
                     nvl(instr(substr(SPM.access_predicates,220),' ')+120-0,120)));
                     DBMS_OUTPUT.PUT_LINE(substr(SPM.access_predicates,instr(substr(SPM.access_predicates,220),' ')+220,
                     nvl(instr(substr(SPM.access_predicates,340),' ')+120-1,120)));
                     DBMS_OUTPUT.PUT_LINE(substr(SPM.access_predicates,instr(substr(SPM.access_predicates,340),' ')+340,
                     nvl(instr(substr(SPM.access_predicates,460),' ')+120-0,120)));
                  END IF;
                END IF;
                IF (SPM.FILTER_PREDICATES IS NOT NULL) THEN
                   --DBMS_OUTPUT.PUT_LINE('ID: '||SPM.PLAN_LINE_ID||'F- '||SPM.FILTER_PREDICATES);
                  IF( instr(substr(SPM.filter_predicates,100),' ') = 0 ) THEN
                     DBMS_OUTPUT.PUT_LINE(
                     '<a name="PHVP'||SPM.SQL_PLAN_HASH_VALUE||SPM.KEY||SPM.MO||'"></a>'||
                     '<RED>ID: '||SPM.PLAN_LINE_ID||' Access - </RED>'||substr(SPM.filter_predicates,1,
                     nvl(instr(substr(SPM.filter_predicates,100),' ')+150-1,150)));
                  ELSE
                     DBMS_OUTPUT.PUT_LINE(
                     '<a name="PHVP'||SPM.SQL_PLAN_HASH_VALUE||SPM.KEY||SPM.MO||'"></a>'||
                     '<RED>ID: '||SPM.PLAN_LINE_ID||' Filter - </RED>'||substr(SPM.filter_predicates,1,
                     nvl(instr(substr(SPM.filter_predicates,100),' ')+100-1,100)));
                     DBMS_OUTPUT.PUT_LINE(substr(SPM.filter_predicates,instr(substr(SPM.filter_predicates,100),' ')+100,
                     nvl(instr(substr(SPM.filter_predicates,220),' ')+120-0,120)));
                     DBMS_OUTPUT.PUT_LINE(substr(SPM.filter_predicates,instr(substr(SPM.filter_predicates,220),' ')+220,
                     nvl(instr(substr(SPM.filter_predicates,340),' ')+120-1,120)));
                     DBMS_OUTPUT.PUT_LINE(substr(SPM.filter_predicates,instr(substr(SPM.filter_predicates,340),' ')+340,
                     nvl(instr(substr(SPM.filter_predicates,460),' ')+120-0,120)));
                  END IF;
                END IF;
             END IF;
        END IF;

        IF (SPM.TP = 'PRDC') THEN
--- bind information -----------------------
          IF(SM.BINDS_XML IS NOT NULL AND :L_BIND_LOG = 'ON' ) THEN
            :L_WHERE_LOG := 'BIND SECTION';
            FOR I IN (
                     SELECT ROWNUM ROW_NUM, NAME, POS, DTYD, DTYSTR, 
                     --2021/05/27
                     substr(VALUE,1,length(VALUE)/3+1)||rpad('***********************************', length(VALUE)*2/3) VALUE
                     FROM (
                      SELECT --+ opt_param('parallel_execution_enabled', 'false')
                           EXTRACTVALUE(VALUE(OXML), '/bind/@name') name,
                           EXTRACTVALUE(VALUE(OXML), '/bind/@pos') pos,
                           EXTRACTVALUE(VALUE(OXML), '/bind/@dty') dtyD,
                           EXTRACTVALUE(VALUE(OXML), '/bind/@dtystr') dtystr,
                           EXTRACTVALUE(VALUE(OXML), '/bind') value
                      FROM TABLE(XMLSEQUENCE(EXTRACT(XMLTYPE(SM.BINDS_XML), '/binds/bind'))) OXML
                      ORDER BY TO_NUMBER(EXTRACTVALUE(VALUE(OXML), '/bind/@pos'))
                      )
                     )
            LOOP
              :L_VALUE_RECOMMEND := null;
              :L_WHERE_LOG := 'BIND SECTION WITHIN LOOP'||I.VALUE;
              IF (I.NAME IS NOT NULL) THEN
                IF (I.ROW_NUM = 1) THEN
                    DBMS_OUTPUT.PUT_LINE('<details>');
                    DBMS_OUTPUT.PUT_LINE('<summary><blue>Bind Information</blue></summary>');
                END IF;
                DBMS_OUTPUT.PUT_LINE(' POSITION=>'||I.POS||' ,NAME=>'||I.NAME||' ,DATA_TYPE('||I.DTYD||')=>'||I.DTYSTR||' ,VALUE=>'||I.VALUE);
              END IF;
              IF( INSTR(I.VALUE,'%') <= 5 and INSTR(I.VALUE,'%') >= 1) THEN :L_VALUE_RECOMMEND := ' => Please use selective bind input'; END IF;
              IF ( :L_VALUE_RECOMMEND IS NOT NULL ) THEN
                DBMS_OUTPUT.PUT_LINE('* Analysis');
              --  DBMS_OUTPUT.PUT_LINE('* The bind variable, '||I.NAME||' was used with "'||I.VALUE||'".');
                DBMS_OUTPUT.PUT_LINE('=>Issue Category: <RED>Blind input or unselective input</RED>');  :issue_blind_input := 1;
                DBMS_OUTPUT.PUT_LINE('<blue>Action Item : DEVELOPMENT TEAM/OPERATION TEAM</BLUE>');
                DBMS_OUTPUT.PUT_LINE('=>Suggestion: Use more selective bind input');
              --  DBMS_OUTPUT.PUT_LINE('.');
                :L_VALUE_RECOMMEND := null;
              END IF;
            END LOOP;
            :L_BIND_LOG := 'OFF';
            DBMS_OUTPUT.PUT_LINE('</details>');
          END IF;
--------------------------

             IF (SPM.RN = 1) THEN
                -- DBMS_OUTPUT.PUT_LINE('+');
                DBMS_OUTPUT.PUT_LINE('<details>');
                DBMS_OUTPUT.PUT_LINE('<summary><blue>All Predicates Information</blue></summary>');
                DBMS_OUTPUT.PUT_LINE('Predicates Information (identified by operation id):');
                DBMS_OUTPUT.PUT_LINE('----------------------------------------------------');
             END IF;
             IF ( SPM.MO IN (:l_co1,  :l_co2,  :l_co3,  :l_co4,  :l_co5,
                             :l_mo1,  :l_mo2,  :l_mo3,  :l_mo4,  :l_mo5,
                             :l_as1,  :l_as2,  :l_as3,  :l_as4,  :l_as5 ) )
               THEN
                IF (SPM.ACCESS_PREDICATES IS NOT NULL) THEN
                   --DBMS_OUTPUT.PUT_LINE('ID: '||SPM.PLAN_LINE_ID||'A- '||SPM.ACCESS_PREDICATES);
                  IF( instr(substr(SPM.access_predicates,100),' ') = 0 ) THEN
                     DBMS_OUTPUT.PUT_LINE(
                     --'<a name="PHVP'||SPM.SQL_PLAN_HASH_VALUE||SPM.KEY||SPM.MO||'"></a>'||
                     '<RED>ID: '||SPM.PLAN_LINE_ID||' Access - </RED>'||substr(SPM.access_predicates,1,
                     nvl(instr(substr(SPM.access_predicates,100),' ')+150-1,150)));
                  ELSE
                     DBMS_OUTPUT.PUT_LINE(
                     --'<a name="PHVP'||SPM.SQL_PLAN_HASH_VALUE||SPM.KEY||SPM.MO||'"></a>'||
                     '<RED>ID: '||SPM.PLAN_LINE_ID||' Access - </RED>'||substr(SPM.access_predicates,1,
                     nvl(instr(substr(SPM.access_predicates,100),' ')+100-1,100)));
                     DBMS_OUTPUT.PUT_LINE(substr(SPM.access_predicates,instr(substr(SPM.access_predicates,100),' ')+100,
                     nvl(instr(substr(SPM.access_predicates,220),' ')+120-0,120)));
                     DBMS_OUTPUT.PUT_LINE(substr(SPM.access_predicates,instr(substr(SPM.access_predicates,220),' ')+220,
                     nvl(instr(substr(SPM.access_predicates,340),' ')+120-1,120)));
                     DBMS_OUTPUT.PUT_LINE(substr(SPM.access_predicates,instr(substr(SPM.access_predicates,340),' ')+340,
                     nvl(instr(substr(SPM.access_predicates,460),' ')+120-0,120)));
                  END IF;
                END IF;
                IF (SPM.FILTER_PREDICATES IS NOT NULL) THEN
                   --DBMS_OUTPUT.PUT_LINE('ID: '||SPM.PLAN_LINE_ID||'F- '||SPM.FILTER_PREDICATES);
                  IF( instr(substr(SPM.filter_predicates,100),' ') = 0 ) THEN
                     DBMS_OUTPUT.PUT_LINE(
                     --'<a name="PHVP'||SPM.SQL_PLAN_HASH_VALUE||SPM.KEY||SPM.MO||'"></a>'||
                     '<RED>ID: '||SPM.PLAN_LINE_ID||' Access - </RED>'||substr(SPM.filter_predicates,1,
                     nvl(instr(substr(SPM.filter_predicates,100),' ')+150-1,150)));
                  ELSE
                     DBMS_OUTPUT.PUT_LINE(
                     --'<a name="PHVP'||SPM.SQL_PLAN_HASH_VALUE||SPM.KEY||SPM.MO||'"></a>'||
                     '<RED>ID: '||SPM.PLAN_LINE_ID||' Filter - </RED>'||substr(SPM.filter_predicates,1,
                     nvl(instr(substr(SPM.filter_predicates,100),' ')+100-1,100)));
                     DBMS_OUTPUT.PUT_LINE(substr(SPM.filter_predicates,instr(substr(SPM.filter_predicates,100),' ')+100,
                     nvl(instr(substr(SPM.filter_predicates,220),' ')+120-0,120)));
                     DBMS_OUTPUT.PUT_LINE(substr(SPM.filter_predicates,instr(substr(SPM.filter_predicates,220),' ')+220,
                     nvl(instr(substr(SPM.filter_predicates,340),' ')+120-1,120)));
                     DBMS_OUTPUT.PUT_LINE(substr(SPM.filter_predicates,instr(substr(SPM.filter_predicates,340),' ')+340,
                     nvl(instr(substr(SPM.filter_predicates,460),' ')+120-0,120)));
                  END IF;
                END IF;
             ELSE
                IF (SPM.ACCESS_PREDICATES IS NOT NULL) THEN
                   --DBMS_OUTPUT.PUT_LINE('ID: '||SPM.PLAN_LINE_ID||'A- '||SPM.ACCESS_PREDICATES);
                  IF( instr(substr(SPM.access_predicates,100),' ') = 0 ) THEN
                     DBMS_OUTPUT.PUT_LINE(
                     'ID: '||SPM.PLAN_LINE_ID||' Access - '||substr(SPM.access_predicates,1,
                     nvl(instr(substr(SPM.access_predicates,100),' ')+150-1,150)));
                  ELSE
                     DBMS_OUTPUT.PUT_LINE(
                     'ID: '||SPM.PLAN_LINE_ID||' Access - '||substr(SPM.access_predicates,1,
                     nvl(instr(substr(SPM.access_predicates,100),' ')+100-1,100)));
                     DBMS_OUTPUT.PUT_LINE(substr(SPM.access_predicates,instr(substr(SPM.access_predicates,100),' ')+100,
                     nvl(instr(substr(SPM.access_predicates,220),' ')+120-0,120)));
                     DBMS_OUTPUT.PUT_LINE(substr(SPM.access_predicates,instr(substr(SPM.access_predicates,220),' ')+220,
                     nvl(instr(substr(SPM.access_predicates,340),' ')+120-1,120)));
                     DBMS_OUTPUT.PUT_LINE(substr(SPM.access_predicates,instr(substr(SPM.access_predicates,340),' ')+340,
                     nvl(instr(substr(SPM.access_predicates,460),' ')+120-0,120)));
                  END IF;
                END IF;
                IF (SPM.FILTER_PREDICATES IS NOT NULL) THEN
                   --DBMS_OUTPUT.PUT_LINE('ID: '||SPM.PLAN_LINE_ID||'F- '||SPM.FILTER_PREDICATES);
                  IF( instr(substr(SPM.filter_predicates,100),' ') = 0 ) THEN
                     DBMS_OUTPUT.PUT_LINE(
                     'ID: '||SPM.PLAN_LINE_ID||' Access - '||substr(SPM.filter_predicates,1,
                     nvl(instr(substr(SPM.filter_predicates,100),' ')+150-1,150)));
                  ELSE
                     DBMS_OUTPUT.PUT_LINE(
                     'ID: '||SPM.PLAN_LINE_ID||' Filter - '||substr(SPM.filter_predicates,1,
                     nvl(instr(substr(SPM.filter_predicates,100),' ')+100-1,100)));
                     DBMS_OUTPUT.PUT_LINE(substr(SPM.filter_predicates,instr(substr(SPM.filter_predicates,100),' ')+100,
                     nvl(instr(substr(SPM.filter_predicates,220),' ')+120-0,120)));
                     DBMS_OUTPUT.PUT_LINE(substr(SPM.filter_predicates,instr(substr(SPM.filter_predicates,220),' ')+220,
                     nvl(instr(substr(SPM.filter_predicates,340),' ')+120-1,120)));
                     DBMS_OUTPUT.PUT_LINE(substr(SPM.filter_predicates,instr(substr(SPM.filter_predicates,340),' ')+340,
                     nvl(instr(substr(SPM.filter_predicates,460),' ')+120-0,120)));
                  END IF;
                END IF;
             END IF;
        END IF;
        IF (SPM.TP = 'LPRNT' ) THEN
           IF ( :L_TITLE = 0 ) THEN
                 DBMS_OUTPUT.PUT_LINE('</details>');
                 DBMS_OUTPUT.PUT_LINE('<details>');
                 DBMS_OUTPUT.PUT_LINE('<summary><blue>Object List By Execution Order</blue></summary>');
                 DBMS_OUTPUT.PUT_LINE('---------------------------------------------------------------------------------------------------------------------------------------');
                 DBMS_OUTPUT.PUT_LINE('OBJECT_TYPE(OBJECT_NAME) [PR: PHYSICAL READ, PW: PHYSICAL WRITE, PGA:PGA_SIZE, TEMP: TEMP_SIZE] ->PROCESS ROW(#) [EXEC ID][BLOCK.ALIAS]');
                 DBMS_OUTPUT.PUT_LINE('---------------------------------------------------------------------------------------------------------------------------------------');
                 :L_TITLE := 1;
           END IF;

           IF( :L_PLAN_PRINT IN ('P','S') AND MOD(SPM.RN,2) =1) THEN
               IF (spm.WORKAREA_MAX_MEM IS NOT NULL OR  spm.WORKAREA_MAX_TEMPSEG IS NOT NULL ) THEN
                  DBMS_OUTPUT.PUT_LINE('<smac>=> '||SPM.PLAN_OPERATION||'('||SPM.PLAN_OBJECT_NAME||')'
                  ||'[PR:'||spm.PHYSICAL_READ_REQUESTS||', PW:'||spm.PHYSICAL_WRITE_REQUESTS||', <RED>PGA:'||spm.PGA_MB||'(M) TEMP:'||spm.TEMP_MB||'(M)</RED>]->'
                --  ||'[PR:'||spm.PHYSICAL_READ_REQUESTS||', PW:'||spm.PHYSICAL_WRITE_REQUESTS||', <RED>PGA:'||spm.WORKAREA_MAX_MEM||' TEMP:'||spm.WORKAREA_MAX_TEMPSEG||'</RED>]->'
                  ||spm.output_rows
                  ||' ['||SPM.MO||']'||'['||SPM.QBLOCK_NAME||'.'||SPM.OBJECT_ALIAS||']</smac>');
               ELSE
                   DBMS_OUTPUT.PUT_LINE('<smac>=> '||SPM.PLAN_OPERATION||'('||SPM.PLAN_OBJECT_NAME||')'
                  ||'[PR:'||spm.PHYSICAL_READ_REQUESTS||', PW:'||spm.PHYSICAL_WRITE_REQUESTS||', PGA:'||spm.PGA_MB||'(M) TEMP:'||spm.TEMP_MB||'(M)</RED>]->'
               --   ||'[PR:'||spm.PHYSICAL_READ_REQUESTS||', PW:'||spm.PHYSICAL_WRITE_REQUESTS||', PGA:'||spm.WORKAREA_MAX_MEM||' TEMP:'||spm.WORKAREA_MAX_TEMPSEG||']->'
                  ||spm.output_rows
                  ||' ['||SPM.MO||']'||'['||SPM.QBLOCK_NAME||'.'||SPM.OBJECT_ALIAS||']</smac>');
               END IF;
           ELSIF( :L_PLAN_PRINT IN ('P','S') AND MOD(SPM.RN,2) =0) THEN
               IF (spm.WORKAREA_MAX_MEM IS NOT NULL OR  spm.WORKAREA_MAX_TEMPSEG IS NOT NULL ) THEN
                  DBMS_OUTPUT.PUT_LINE('<smanc>=> '||SPM.PLAN_OPERATION||'('||SPM.PLAN_OBJECT_NAME||')'
                  ||'[PR:'||spm.PHYSICAL_READ_REQUESTS||', PW:'||spm.PHYSICAL_WRITE_REQUESTS||', <RED>PGA:'||spm.PGA_MB||'(M) TEMP:'||spm.TEMP_MB||'(M)</RED>]->'
                  ||spm.output_rows
                  ||' ['||SPM.MO||']'||'['||SPM.QBLOCK_NAME||'.'||SPM.OBJECT_ALIAS||']</smanc>');
               ELSE
                   DBMS_OUTPUT.PUT_LINE('<smanc>=> '||SPM.PLAN_OPERATION||'('||SPM.PLAN_OBJECT_NAME||')'
                  ||'[PR:'||spm.PHYSICAL_READ_REQUESTS||', PW:'||spm.PHYSICAL_WRITE_REQUESTS||', PGA:'||spm.PGA_MB||'(M) TEMP:'||spm.TEMP_MB||'(M)</RED>]->'
                  ||spm.output_rows
                  ||' ['||SPM.MO||']'||'['||SPM.QBLOCK_NAME||'.'||SPM.OBJECT_ALIAS||']</smanc>');
               END IF;
           ELSIF ( :L_PLAN_PRINT NOT IN ('P','S') AND spm.mo in (
               --:l_co1-2,:l_co2-2,:l_co3-2,:l_co4-2,:l_co5-2,
               :l_co1-1,:l_co2-1,:l_co3-1,:l_co4-1,:l_co5-1,
               :l_co1,:l_co2,:l_co3,:l_co4,:l_co5,
               :l_co1+1,:l_co2+1,:l_co3+1,:l_co4+1,:l_co5+1,
               --:l_co1+2,:l_co2+2,:l_co3+2,:l_co4+2,:l_co5+2,
               --:l_mo1-2,:l_mo2-2,:l_mo3-2,:l_mo4-2,:l_mo5-2,
               :l_mo1-1,:l_mo2-1,:l_mo3-1,:l_mo4-1,:l_mo5-1,
               :l_mo1,:l_mo2,:l_mo3,:l_mo4,:l_mo5,
               :l_mo1+1,:l_mo2+1,:l_mo3+1,:l_mo4+1,:l_mo5+1,
               --:l_mo1+2,:l_mo2+2,:l_mo3+2,:l_mo4+2,:l_mo5+2,
               --:l_as1-2,:l_as2-2,:l_as3-2,:l_as4-2,:l_as5-2,
               :l_as1-1,:l_as2-1,:l_as3-1,:l_as4-1,:l_as5-1,
               :l_as1,:l_as2,:l_as3,:l_as4,:l_as5,
               :l_as1+1,:l_as2+1,:l_as3+1,:l_as4+1,:l_as5+1
               --,:l_as1+2,:l_as2+2,:l_as3+2,:l_as4+2,:l_as5+2
                 ) ) THEN

               IF (spm.WORKAREA_MAX_MEM IS NOT NULL OR  spm.WORKAREA_MAX_TEMPSEG IS NOT NULL AND MOD(:L_COLOR,2) = 1 ) THEN
                  DBMS_OUTPUT.PUT_LINE('<smac>=> '||SPM.PLAN_OPERATION||'('||SPM.PLAN_OBJECT_NAME||')'
                  ||'[PR:'||spm.PHYSICAL_READ_REQUESTS||', PW:'||spm.PHYSICAL_WRITE_REQUESTS||', <RED>PGA:'||spm.PGA_MB||'(M) TEMP:'||spm.TEMP_MB||'(M)</RED>]->'
                  ||spm.output_rows
                  ||' ['||SPM.MO||']'||'['||SPM.QBLOCK_NAME||'.'||SPM.OBJECT_ALIAS||']</smac>');
               ELSIF (spm.WORKAREA_MAX_MEM IS NULL AND  spm.WORKAREA_MAX_TEMPSEG IS NULL AND MOD(:L_COLOR,2) = 1 ) THEN
                   DBMS_OUTPUT.PUT_LINE('<smac>=> '||SPM.PLAN_OPERATION||'('||SPM.PLAN_OBJECT_NAME||')'
                  ||'[PR:'||spm.PHYSICAL_READ_REQUESTS||', PW:'||spm.PHYSICAL_WRITE_REQUESTS||', PGA:'||spm.PGA_MB||'(M) TEMP:'||spm.TEMP_MB||'(M)</RED>]->'
                  ||spm.output_rows
                  ||' ['||SPM.MO||']'||'['||SPM.QBLOCK_NAME||'.'||SPM.OBJECT_ALIAS||']</smac>');
               ELSIF (spm.WORKAREA_MAX_MEM IS NOT NULL OR  spm.WORKAREA_MAX_TEMPSEG IS NOT NULL AND MOD(:L_COLOR,2) = 0 ) THEN
                  DBMS_OUTPUT.PUT_LINE('<smanc>=> '||SPM.PLAN_OPERATION||'('||SPM.PLAN_OBJECT_NAME||')'
                  ||'[PR:'||spm.PHYSICAL_READ_REQUESTS||', PW:'||spm.PHYSICAL_WRITE_REQUESTS||', <RED>PGA:'||spm.PGA_MB||'(M) TEMP:'||spm.TEMP_MB||'(M)</RED>]->'
                  ||spm.output_rows
                  ||' ['||SPM.MO||']'||'['||SPM.QBLOCK_NAME||'.'||SPM.OBJECT_ALIAS||']</smanc>');
               ELSIF (spm.WORKAREA_MAX_MEM IS NULL AND  spm.WORKAREA_MAX_TEMPSEG IS NULL AND MOD(:L_COLOR,2) = 0 ) THEN
                   DBMS_OUTPUT.PUT_LINE('<smanc>=> '||SPM.PLAN_OPERATION||'('||SPM.PLAN_OBJECT_NAME||')'
                  ||'[PR:'||spm.PHYSICAL_READ_REQUESTS||', PW:'||spm.PHYSICAL_WRITE_REQUESTS||', PGA:'||spm.PGA_MB||'(M) TEMP:'||spm.TEMP_MB||'(M)</RED>]->'
                  ||spm.output_rows
                  ||' ['||SPM.MO||']'||'['||SPM.QBLOCK_NAME||'.'||SPM.OBJECT_ALIAS||']</smanc>');
               END IF;
               :L_COLOR := :L_COLOR + 1;
           END IF;
        END IF;

      END LOOP;
     END IF ;  --SQL_FROM_SPM CHECK CONDITION ENDS
 /* 20180805 start */
 /* 20180805 end */
      DBMS_OUTPUT.PUT_LINE('</details>');
      DBMS_OUTPUT.PUT_LINE('</pre><a href="#PHV_ANALYSIS">Back to PHV level Analysis</a><pre>');
      DBMS_OUTPUT.PUT_LINE('</pre><a href="#top">Back to top</a><pre>');
      /* IMPORTANT */
     :error_from_sm := 0;
     END LOOP;
  END IF ;   /*  IF ( :SQL_FROM_SPM = 1 ) V3*/
     EXCEPTION  WHEN OTHERS THEN
     DBMS_OUTPUT.PUT_LINE('ERROR ON SQL PLAN MONITOR: '||SQLERRM||' => where '||:L_WHERE_LOG);
     :L_OTHER_XML := NULL;
END;
/

/* THERE IS NO DATA IN SQL_MONITOR but there is data in AWR_SQL_MONITOR.*/

BEGIN
   :L_WHERE_LOG := 'AWR SQL MONITOR';
   IF (  :SQL_FROM_SPM in (0,1)   ) THEN   -- 20190904 to get dba_hist_report_details always
     SELECT 1 INTO :SQL_FROM_AWR_SPM
     from  dba_hist_reports  dhr
     WHERE component_name='sqlmonitor'
     and   key1 = :l_sql_id
     AND DBID = :L_DBID
     --2020922
     AND SNAP_ID BETWEEN :L_SNAP_ID - 720 AND :L_SNAP_ID
     --AND   :SQL_FROM_SPM = 0
     AND   ROWNUM = 1 ;
   END IF ;
   EXCEPTION  WHEN OTHERS THEN
     --DBMS_OUTPUT.PUT_LINE('+');    --||SQLERRM);
     --DBMS_OUTPUT.PUT_LINE('There is no AWR SQL PLAN MONITOR information.');    --||SQLERRM);
     null;
END;
/
-- for test only
--exec  :SQL_FROM_AWR_SPM := 1;
--exec  :SQL_FROM_SPM := 0;

--prompt FOR SMA  and SQLHC
set echo off  FEED OFF verify off heading off LINESIZE 300 pagesize 0 TI OFF TIMI OFF SERVEROUT ON SIZE UNL;
spool run_sma_&&files_prefix..sql

select 'set long 10000000 longchunksize 10000000 LIN 500  trims on' from dual
where   :SQL_FROM_AWR_SPM = 1
AND     :SQL_FROM_SPM = 0
/
PROMPT PROMPT <DETAILS>
PROMPT PROMPT <SUMMARY><BLUE>AWR SQL MONITORING REPORT BY PACKAGE</BLUE></SUMMARY>
PROMPT PROMPT
select 'SELECT DBMS_AUTO_REPORT.REPORT_REPOSITORY_DETAIL(RID => '||report_id||', TYPE => ''text'') FROM dual;'
FROM ( SELECT  report_id
from dba_hist_reports
WHERE component_name='sqlmonitor'
and   key1 = :l_sql_id
AND  DBID = :L_DBID
--2020922
AND SNAP_ID BETWEEN :L_SNAP_ID - 720 AND :L_SNAP_ID
AND   :SQL_FROM_AWR_SPM = 1
AND   :SQL_FROM_SPM = 0
ORDER BY GENERATION_TIME DESC )
WHERE ROWNUM < 3
/
PROMPT PROMPT </DETAILS>
spool off
set trims on
-- FOR SMA AND SQLHC
SPOOL sma_&&files_prefix..sql3 APPEND

prompt +
start run_sma_&&files_prefix..sql
spool off
host rm -f run_sma_&&files_prefix..sql
rem for windows
host del -f  run_sma_&&files_prefix..sql


SPOOL sma_&&files_prefix..sql3 APPEND

/*
asm2p.sql start
*/

var L_REPORT_ID          NUMBER;
var L_INSTANCE_NUMBER    NUMBER;
var L_B_SNAP_ID          NUMBER;
var L_E_SNAP_ID          NUMBER;

begin
     FOR SM IN ( select report_id, INSTANCE_NUMBER,
                      ( select max(B.snap_id)
                        from dba_hist_snapshot B
                        where  B.DBID = :l_dbid
                        --2020922
                        AND B.SNAP_ID BETWEEN :L_SNAP_ID - 720 AND :L_SNAP_ID
                        and B.END_INTERVAL_TIME <= A.PERIOD_START_TIME
                        and B.instance_number = A.instance_number ) B_SNAP_ID,
                      ( select min(E.snap_id)
                        from dba_hist_snapshot E
                        where  E.DBID = :l_dbid
                        --2020922
                        AND E.SNAP_ID BETWEEN :L_SNAP_ID - 720 AND :L_SNAP_ID
                        and E.END_INTERVAL_TIME >= A.PERIOD_END_TIME
                        and E.instance_number = A.instance_number ) E_SNAP_ID
                 FROM ( SELECT  report_id, INSTANCE_NUMBER, PERIOD_START_TIME, PERIOD_END_TIME
                        FROM DBA_HIST_REPORTS
                        WHERE COMPONENT_NAME ='sqlmonitor'
                        AND   KEY1 = :l_sql_id
                        AND   DBID = :L_DBID
                        --2020922
                        AND   SNAP_ID BETWEEN :L_SNAP_ID - 720 AND :L_SNAP_ID
                        AND   :SQL_FROM_AWR_SPM = 1
                        --AND   :SQL_FROM_SPM = 0
                        ORDER BY GENERATION_TIME DESC ) A
                 WHERE ROWNUM < 2 )
      LOOP
           :L_REPORT_ID         := SM.REPORT_ID ;
           :L_INSTANCE_NUMBER   := SM.INSTANCE_NUMBER ;
           :L_B_SNAP_ID         := SM.B_SNAP_ID ;
           :L_E_SNAP_ID         := SM.E_SNAP_ID ;
      END LOOP;
      EXCEPTION  WHEN OTHERS THEN
           :L_REPORT_ID       := 0;
           :L_INSTANCE_NUMBER := 0;
end ;
/


prompt <details>
prompt <summary><blue>AWR SQL MONITORING REPORT BY SMA</blue></summary>

prompt Global Information
prompt ------------------------------


BEGIN
  FOR SM IN (
       select extractValue(value(d), '/target/rminfo/@rmcg')  RMCG,
       extractValue(value(d), '/target/program')  PROGRAM,
       extractValue(value(d), '/target/module')  MODULE,
       extractValue(value(d), '/target/action')  ACTION,
       extractValue(value(d), '/target/service')  SERVICE,
       extractValue(value(d), '/target/user')    USER_NAME,
       extractValue(value(d), '/target/status')  STATUS,
       extractValue(value(d), '/target/@instance_id')  INSTANCE_ID ,
       extractValue(value(d), '/target/@session_id')  SESSION_ID,
       extractValue(value(d), '/target/@session_serial')  SESSION_SERIAL ,
       nvl(extractValue(value(d), '/target/@sql_id'),:l_sql_id)  SQL_ID ,
       extractValue(value(d), '/target/@sql_plan_hash')  SQL_PLAN_HASH ,
       extractValue(value(d), '/target/adaptive_plan')  ADAPTIVE_PLAN,
       extractValue(value(d), '/target/adaptive_plan/@is_final')  IS_FINAL_PLAN,
       extractValue(value(d), '/target/@sql_exec_id')  SQL_EXEC_ID ,
       extractValue(value(d), '/target/@sql_exec_start')  SQL_EXEC_START ,
       extractValue(value(d), '/target/first_refresh_time')  FIRST_REFRESH_TIME ,
       extractValue(value(d), '/target/last_refresh_time')  LAST_REFRESH_TIME ,
       extractValue(value(d), '/target/duration')  DURATION
       --extractValue(value(d), '/target/sql_fulltext')  SQL_FULLTEXT,
       --extractValue(value(d), '/target/sql_fulltext/@is_full')  IS_FULLTEXT
       from  DBA_HIST_REPORTS_DETAILS c,
             TABLE(XMLSEQUENCE(EXTRACT(XMLTYPE(c.report), '/report/sql_monitor_report/target'))) D
       where c.DBID = :L_DBID  AND C.INSTANCE_NUMBER = :L_INSTANCE_NUMBER
       --2020922
       AND  C.SNAP_ID BETWEEN :L_SNAP_ID - 720 AND :L_SNAP_ID
       and  c.report_id = :L_REPORT_ID and  :L_REPORT_ID <> 0
       AND   :SQL_FROM_AWR_SPM = 1
       --AND   :SQL_FROM_SPM = 0
        )
  LOOP
      IF (SM.RMCG IS NOT NULL) THEN  if (:L_SQL_GROUP = 'DEFAULT') then :L_SQL_GROUP := SM.RMCG; end if;
                                           DBMS_OUTPUT.PUT_LINE('RM CONSUMP GROUP    : <blue>'||SM.RMCG||'</blue>'); END IF ;
      IF (SM.PROGRAM IS NOT NULL) THEN     DBMS_OUTPUT.PUT_LINE('PROGRAM             : '||SM.PROGRAM); END IF ;
      IF (SM.MODULE IS NOT NULL) THEN      DBMS_OUTPUT.PUT_LINE('MODULE/ACTION       : '||SM.MODULE||'/'||SM.ACTION); END IF ;
      IF (SM.SERVICE IS NOT NULL) THEN     DBMS_OUTPUT.PUT_LINE('SERVICE             : '||SM.SERVICE); END IF ;
      IF (SM.STATUS LIKE '%ERROR%') THEN   DBMS_OUTPUT.PUT_LINE('STATUS              : <RED>'||SM.STATUS||'</RED>');
                                    ELSE   DBMS_OUTPUT.PUT_LINE('STATUS              : <BLUE>'||SM.STATUS||'</BLUE>');
      END IF ;
      IF (SM.USER_NAME IS NOT NULL) THEN   DBMS_OUTPUT.PUT_LINE('USER_NAME           : '||SM.USER_NAME); END IF ;
      IF (SM.INSTANCE_ID IS NOT NULL) THEN DBMS_OUTPUT.PUT_LINE('INSTANCE_ID         : '||SM.INSTANCE_ID); END IF ;
      IF (SM.SESSION_ID IS NOT NULL) THEN  DBMS_OUTPUT.PUT_LINE('SESSION_ID          : '||SM.SESSION_ID); END IF ;
  IF (SM.SESSION_SERIAL IS NOT NULL) THEN  DBMS_OUTPUT.PUT_LINE('SESSION_SERIAL      : '||SM.SESSION_SERIAL); END IF ;
      IF (SM.SQL_ID IS NOT NULL) THEN      DBMS_OUTPUT.PUT_LINE('SQL_ID              : '||SM.SQL_ID); END IF ;
   IF (SM.SQL_PLAN_HASH IS NOT NULL) THEN  IF (:L_PLAN_HASH_VALUE_PROFILE IS NULL) THEN  :L_PLAN_HASH_VALUE_PROFILE := SM.SQL_PLAN_HASH; END IF;
                                           DBMS_OUTPUT.PUT_LINE('SQL_PLAN_HASH       : <blue>'||SM.SQL_PLAN_HASH||'</blue>');  END IF ;
   IF (SM.ADAPTIVE_PLAN IS NOT NULL) THEN  DBMS_OUTPUT.PUT_LINE('ADAPTIVE_PLAN       : '||SM.ADAPTIVE_PLAN||' (IS_FINAL_PLAN : '||SM.IS_FINAL_PLAN||')'); END IF ;
      IF (SM.SQL_EXEC_ID IS NOT NULL) THEN  DBMS_OUTPUT.PUT_LINE('SQL_EXEC_ID         : '||SM.SQL_EXEC_ID||' (SQL_EXEC_START : '||SM.SQL_EXEC_START||')'); END IF ;
      IF(SM.FIRST_REFRESH_TIME IS NOT NULL) THEN DBMS_OUTPUT.PUT_LINE('FIRST_REFRESH_TIME  : '||SM.FIRST_REFRESH_TIME); END IF ;
      IF(SM.FIRST_REFRESH_TIME IS NOT NULL) THEN DBMS_OUTPUT.PUT_LINE('LAST_REFRESH_TIME   : '||SM.LAST_REFRESH_TIME); END IF ;
      IF (SM.DURATION IS NOT NULL) THEN    DBMS_OUTPUT.PUT_LINE('DURATION            : '||SM.DURATION); END IF ;
-- sm19c20200504
      IF (:L_REPORT_ID <> 0)       THEN    DBMS_OUTPUT.PUT_LINE('REPORT_ID           : '||:L_REPORT_ID   ); END IF ;
-- sm19c20200504
  END LOOP ;
----------------------
  FOR SM IN (
   select
       extractValue(value(d), '/other_xml/info[@type="db_version"]')         db_version,
       extractValue(value(d), '/other_xml/info[@type="parse_schema"]')       parse_schema,
--sma19c
       extractValue(value(d), '/other_xml/info[@type="cardinality_feedback"]')  cardinality_feedback,
       extractValue(value(d), '/other_xml/info[@type="sql_profile"]')        sql_profile,
       --extractValue(value(d), '/other_xml/info[@type="sql_profile"@note=]')  sql_profile_note,
       extractValue(value(d), '/other_xml/info[@type="sql_patch"]')          sql_patch,
       --extractValue(value(d), '/other_xml/info[@type="sql_plan_baseline"]')  sql_plan_baseline
       extractValue(value(d), '/other_xml/info[@type="baseline"]')  sql_plan_baseline
       from  DBA_HIST_REPORTS_DETAILS c,
             TABLE(XMLSEQUENCE(EXTRACT(XMLTYPE(c.report), '/report/sql_monitor_report/plan/operation/other_xml'))) D
       where --c.report_id = 219089
             c.DBID = :L_DBID  AND C.INSTANCE_NUMBER = :L_INSTANCE_NUMBER
       --2020922
       AND   C.SNAP_ID BETWEEN :L_SNAP_ID - 720 AND :L_SNAP_ID
       and   c.report_id = :L_REPORT_ID and  :L_REPORT_ID <> 0
       AND   :SQL_FROM_AWR_SPM = 1
        )
  LOOP
      IF (SM.db_version IS NOT NULL)        THEN DBMS_OUTPUT.PUT_LINE('DB_VERSION          : '||SM.db_version); END IF ;
      IF (SM.parse_schema IS NOT NULL)      THEN DBMS_OUTPUT.PUT_LINE('PARSE_SCHEMA        : '||SM.parse_schema); END IF ;
      IF (SM.cardinality_feedback IS NOT NULL)
                                            THEN DBMS_OUTPUT.PUT_LINE('CARDINALITY_FEEDBACK: <BLUE>'||SM.cardinality_feedback||'</BLUE>'); END IF ;
      IF (SM.sql_profile IS NOT NULL)       THEN if (:L_SQL_PROFILE is null) then :L_SQL_PROFILE := SM.sql_profile; end if;
                                                 DBMS_OUTPUT.PUT_LINE('SQL_PROFILE         : <BLUE>'||SM.sql_profile||'</BLUE>'); END IF ;
      IF (SM.sql_patch IS NOT NULL)         THEN if (:L_SQL_PATCH is null) then :L_SQL_PATCH := SM.sql_PATCH; end if;
                                                 DBMS_OUTPUT.PUT_LINE('SQL_PATCH           : <BLUE>'||SM.sql_patch||'</BLUE>'); END IF ;
      IF (SM.sql_plan_baseline IS NOT NULL) THEN if (:L_SQL_plan_BASELINE is null) then :L_SQL_plan_BASELINE := SM.sql_plan_BASELINE; end if;
                                                 DBMS_OUTPUT.PUT_LINE('SQL_PLAN_BASELINE   : <BLUE>'||SM.sql_plan_baseline||'</BLUE>'); END IF ;
  END LOOP ;
----------------------
  FOR SM IN (
       select extractValue(value(d), '/parallel_info/@qc_instance_id') qc_instance_id,
       extractValue(value(d), '/parallel_info/@qc_session_id')  qc_session_id,
       extractValue(value(d), '/parallel_info/@is_cross_instance') is_cross_instance,
       extractValue(value(d), '/parallel_info/@dop')   dop,
       extractValue(value(d), '/parallel_info/@max_dop_instances') max_dop_instances,
       extractValue(value(d), '/parallel_info/@inst_count') inst_count,
       extractValue(value(d), '/parallel_info/@server_group_count') server_group_count,
       extractValue(value(d), '/parallel_info/@server_set_count') server_set_count
       from  DBA_HIST_REPORTS_DETAILS c,
             TABLE(XMLSEQUENCE(EXTRACT(XMLTYPE(c.report), '/report/sql_monitor_report/parallel_info'))) D
       where c.DBID = :L_DBID AND C.INSTANCE_NUMBER = :L_INSTANCE_NUMBER
       --2020922
       AND   C.SNAP_ID BETWEEN :L_SNAP_ID - 720 AND :L_SNAP_ID
       and   c.report_id = :L_REPORT_ID and  :L_REPORT_ID <> 0
       AND   :SQL_FROM_AWR_SPM = 1
       --AND   :SQL_FROM_SPM = 0
        )
  LOOP
--PARALL_INFO
      IF (SM.qc_instance_id IS NOT NULL) THEN     DBMS_OUTPUT.PUT_LINE('QC_INSTANCE_ID      : '||SM.qc_instance_id); END IF ;
      IF (SM.qc_session_id  IS NOT NULL) THEN     DBMS_OUTPUT.PUT_LINE('QC_SESSION_ID       : '||SM.qc_session_id); END IF ;
      IF (SM.is_cross_instance IS NOT NULL) THEN  DBMS_OUTPUT.PUT_LINE('IS_CROSS_INSTANCE   : '||SM.is_cross_instance); END IF ;
      IF (SM.dop IS NOT NULL) THEN                DBMS_OUTPUT.PUT_LINE('DOP                 : '||SM.DOP); END IF ;
      IF (SM.max_dop_instances IS NOT NULL) THEN  DBMS_OUTPUT.PUT_LINE('MAX_DOP_INSTANCES   : '||SM.max_dop_instances); END IF ;
      IF (SM.inst_count IS NOT NULL) THEN         DBMS_OUTPUT.PUT_LINE('INST_COUNT          : '||SM.inst_count); END IF ;
      IF (SM.server_group_count IS NOT NULL) THEN DBMS_OUTPUT.PUT_LINE('SERVER_GROUP_COUNT  : '||SM.server_group_count); END IF ;
      IF (SM.server_set_count IS NOT NULL) THEN   DBMS_OUTPUT.PUT_LINE('SERVER_SET_COUNT    : '||SM.server_set_count); END IF ;
  END LOOP ;
-------------------
-- sma19c 20200316 Number of dynamic scan tasks completed by thread
  FOR SM IN (
      select replace(substr(value(d),  instr(value(d),'type="')+6 ),'"/>','')  NO_OF_DYN_SCAN
      from  DBA_HIST_REPORTS_DETAILS c,
            TABLE(XMLSEQUENCE(EXTRACT(XMLTYPE(c.report), '/report/sql_monitor_report/plan_monitor/operation/rwsstats/metadata/stat'))) D
      where c.DBID = :L_DBID AND C.INSTANCE_NUMBER = :L_INSTANCE_NUMBER
      --2020922
      AND  C.SNAP_ID BETWEEN :L_SNAP_ID - 720 AND :L_SNAP_ID
      and   c.report_id = :L_REPORT_ID and  :L_REPORT_ID <> 0
      AND   :SQL_FROM_AWR_SPM = 1
      and   value(d) like '%Number of dynamic scan tasks completed by thread%'
      )
  LOOP
      IF (SM.NO_OF_DYN_SCAN IS NOT NULL) THEN     DBMS_OUTPUT.PUT_LINE('DYN_SCAN_THREAD_NO  : '||SM.NO_OF_DYN_SCAN); END IF ;
  END LOOP ;
-------------------
  EXCEPTION  WHEN OTHERS THEN
     --DBMS_OUTPUT.PUT_LINE('+');    --||SQLERRM);
     --DBMS_OUTPUT.PUT_LINE('There is no AWR SQL PLAN MONITOR information.');    --||SQLERRM);
     null;
END;
/

BEGIN
  FOR SM IN (
       select c.report_id,
       extractValue(value(d), '/error/@number')     ERROR_NUMBER,
       extractValue(value(d), '/error/@facility')  ERROR_FACILITY,
       extractValue(value(d), '/error')  ERROR_DESC
      -- extractValue(value(d), '/error/@facility="ORA"')  ERROR_DESC
       from  DBA_HIST_REPORTS_DETAILS c,
             TABLE(XMLSEQUENCE(EXTRACT(XMLTYPE(c.report), '/report/sql_monitor_report/error'))) D
       where c.DBID = :L_DBID AND C.INSTANCE_NUMBER = :L_INSTANCE_NUMBER
       --2020922
       AND C.SNAP_ID BETWEEN :L_SNAP_ID - 720 AND :L_SNAP_ID
       and   c.report_id = :L_REPORT_ID and  :L_REPORT_ID <> 0
       AND   :SQL_FROM_AWR_SPM = 1
       --AND   :SQL_FROM_SPM = 0
          )
  LOOP
      IF (SM.ERROR_NUMBER IS NOT NULL ) THEN   DBMS_OUTPUT.PUT_LINE('ERROR_NUMBER        : <RED>'||SM.ERROR_NUMBER||'</RED>');
/*20200708*/                                 if(:issue_error = 0) then  :issue_error := 1; end if;
      END IF;
      IF (SM.ERROR_FACILITY IS NOT NULL ) THEN DBMS_OUTPUT.PUT_LINE('ERROR_FACILITY      : <RED>'||SM.ERROR_FACILITY||'</RED>'); END IF;
      IF (SM.ERROR_DESC IS NOT NULL ) THEN DBMS_OUTPUT.PUT_LINE('ERROR_DESC          : <RED>'||SM.ERROR_DESC||'</RED>'); END IF;
  END LOOP;
  EXCEPTION  WHEN OTHERS THEN
     --DBMS_OUTPUT.PUT_LINE('+');    --||SQLERRM);
     null;
END;
/
prompt <blue></blue>
PROMPT Global SQL Stats
/*
   <stats type="monitor">
    <stat name="elapsed_time">157239120</stat>
    <stat name="cpu_time">2911558</stat>
    <stat name="user_io_wait_time">154323091</stat>
    <stat name="application_wait_time">4471</stat>
    <stat name="user_fetch_count">1</stat>
    <stat name="buffer_gets">467034</stat>
    <stat name="disk_reads">13825</stat>
    <stat name="read_reqs">13825</stat>
    <stat name="read_bytes">498712576</stat>
   </stats>
*/
col stat_name  format a30
col stat_value format a55

PROMPT ============================= ==================================
PROMPT STATS_NAME                    STATS_VALUE
PROMPT ============================= ==================================

with stats as (
select extractValue(value(d), '/stat/@name') stat_name ,
       extractValue(value(d), '/stat')       stat_value
from  DBA_HIST_REPORTS_DETAILS c,
      TABLE(XMLSEQUENCE(EXTRACT(XMLTYPE(c.report), '/report/sql_monitor_report/stats/stat'))) D
where c.DBID = :L_DBID AND C.INSTANCE_NUMBER = :L_INSTANCE_NUMBER
      --2020922
       AND C.SNAP_ID BETWEEN :L_SNAP_ID - 720 AND :L_SNAP_ID
       and   c.report_id = :L_REPORT_ID and  :L_REPORT_ID <> 0
       AND   :SQL_FROM_AWR_SPM = 1
       --AND   :SQL_FROM_SPM = 0
),
etime as  ( select stat_value from stats where stat_name = 'elapsed_time' )
select stat_name,
      (case when s.stat_name like '%time' and e.stat_value <= s.stat_value*3.33 and s.stat_name <> 'elapsed_time'
                 then '<RED>'||to_char(to_number(round(s.stat_value/1000000,3)),'999,999,999,999,999,999.999')||' secs</RED>'
            when s.stat_name like '%time' and e.stat_value >  s.stat_value*3.33 and s.stat_name <> 'elapsed_time'
                 then to_char(to_number(round(s.stat_value/1000000,3)),'999,999,999,999,999,999.999')||' secs'
            when s.stat_name = 'elapsed_time'
                 then to_char(to_number(round(s.stat_value/1000000,3)),'999,999,999,999,999,999.999')||' secs'
            when s.stat_name not like '%time'
                 then to_char(to_number(s.stat_value),'999,999,999,999,999,999,999') end) stat_value
from stats s,etime e
union all  select 'BEGIN_SNAP_ID' stat_name, to_char(:l_b_snap_id,'999999999999999999999999999') stat_value from dual where :SQL_FROM_AWR_SPM = 1
union all  select 'END_SNAP_ID'   stat_name, to_char(:l_e_snap_id,'999999999999999999999999999') stat_value from dual where :SQL_FROM_AWR_SPM = 1
/
prompt <blue></blue>

--20200817

pro <table>
pro <tbody><tr>
pro <th>SRC_DBNAME</th>
pro <th>SRC_DBID</th>
pro <th>REQST(%)</th>
pro <th>TOTAL_REQST</th>
pro <th>FLASH_REQST</th>
pro <th>DISK_REQST</th>
pro <th>MB(%)</th>
pro <th>TOTAL_MB</th>
pro <th>FLASH_MB</th>
pro <th>DISK_MB</th>
pro </tr>
SET HEAD OFF

SELECT  CHR(10)||'<tr>'||CHR(10)
     ||'<td class="r">'||SRC_DBNAME||'</td>'||CHR(10)
     ||'<td class="r">'||SRC_DBID||'</td>'||CHR(10)
     ||'<td class="r">'||PCT_REQST||'</td>'||CHR(10)
     ||'<td class="r">'||TOTAL_REQST||'</td>'||CHR(10)
     ||'<td class="r">'||FLASH_REQST||'</td>'||CHR(10)
     ||'<td class="r">'||DISK_REQST||'</td>'||CHR(10)
     ||'<td class="r">'||PCT_MB||'</td>'||CHR(10)
     ||'<td class="r">'||TOTAL_MB||'</td>'||CHR(10)
     ||'<td class="r">'||FLASH_MB||'</td>'||CHR(10)
     ||'<td class="r">'||DISK_MB||'</td>'||CHR(10)
     ||'</TR>'
from (
select  DECODE(SRC_DBNAME, :L_DBNAME, '<blue>'||SRC_DBNAME||'</blue>',SRC_DBNAME ) SRC_DBNAME, SRC_DBID,
ROUND((RATIO_TO_REPORT(sum(total_rq)) OVER())*100) PCT_REQST,
TOTAL_RQ TOTAL_REQST, FRQ FLASH_REQST, DRQ DISK_REQST,
ROUND((RATIO_TO_REPORT(sum(total_by_M)) OVER())*100) PCT_MB,
total_by_M TOTAL_MB, fby_M FLASH_MB, dby_M DISK_MB
from (
select  src_dbname, src_dbid,
sum(frq)+sum(drq) total_rq,
sum(frq) frq,
sum(drq) drq,
round((sum(fby)+sum(dby))/1024/1024,2) total_by_M,
round(sum(fby)/1024/1024,2) fby_M,
round(sum(dby)/1024/1024,2) dby_M
from (
select e.dbid, e.cell_hash,
             e.src_dbname, e.src_dbid,
             1             pct,
             e.flash_requests - nvl(b.flash_requests,0)  frq,
             e.disk_requests  - nvl(b.disk_requests,0)   drq,
             e.flash_bytes    - nvl(b.flash_bytes,0)     fby,
             e.disk_bytes     - nvl(b.disk_bytes,0)      dby,
             null          missing_db
        from dba_hist_cell_db b,
             dba_hist_cell_db e
       where e.dbid            = :L_DBID
         and b.snap_id (+)     = :L_B_SNAP_ID
         and e.snap_id         = :L_E_SNAP_ID
         and e.dbid            = b.dbid     (+)
         and e.cell_hash       = b.cell_hash(+)
         and e.incarnation_num = b.incarnation_num (+)
         and e.src_dbid        = b.src_dbid (+)
)
group by src_dbname, src_dbid )
group by src_dbname, src_dbid, total_rq, frq, drq,  total_by_M, fby_M, dby_M
order by 3 desc  )
/

pro </TR></tbody>
pro </table>

pro <table>
pro <tbody><tr>
pro <th>DBID</th>
pro <th>CELL_HASH</th>
pro <th>CELL_NAME</th>
pro <th>Flash_Cache_Mode</th>
pro <th>Compression</th>
pro <th>Remark</th>
pro </tr>
SET HEAD OFF

SELECT  CHR(10)||'<tr>'||CHR(10)
     ||'<td class="r">'||DBID||'</td>'||CHR(10)
     ||'<td class="r">'||CELL_HASH||'</td>'||CHR(10)
     ||'<td class="r">'||CELL_NAME||'</td>'||CHR(10)
     ||'<td class="r">'||FLASH_CACHE_MODE||'</td>'||CHR(10)
     ||'<td class="r">'||COMPRESSION||'</td>'||CHR(10)
     ||'<td class="r">'||REMARK||'</td>'||CHR(10)
     ||'</TR>'
from ( 
       SELECT DBID, CELL_HASH, CELL_NAME, DECODE(FLASH_CACHE_MODE,'WriteBack', FLASH_CACHE_MODE, '<RED>'||FLASH_CACHE_MODE||'</RED>') FLASH_CACHE_MODE,COMPRESSION
       , DECODE(FLASH_CACHE_MODE,'WriteThrough', '<red>Refer bug 27975747 to set WriteBack</red>') REMARK
       FROM (
        select dbid, cellhash cell_hash,
               extractvalue(xmltype(confval),'//cell/name') cell_name,
               extractvalue(xmltype(confval),'//cell/flashCacheMode') FLASH_CACHE_MODE,
               extractvalue(xmltype(confval),'//cell/flashCacheCompress') COMPRESSION
          from dba_hist_cell_config_detail
         where dbid     = :L_DBID
           and snap_id  = :L_E_SNAP_ID
           and conftype = 'CELL'
       )
     )
/

pro </TR></tbody>
pro </table>

SET HEAD ON
---------exec order start--------

delete plan_table ;
commit;

DECLARE
   pragma autonomous_transaction;
   l_exec_order number;

    PROCEDURE assign_execution_order (
      p_plan_hash_value IN NUMBER,
      p_id              IN NUMBER )
    IS
    BEGIN
      FOR j IN (SELECT id
                  FROM plan_table
                 WHERE 1 = 1
                   AND plan_id      = p_plan_hash_value
                   AND parent_id    = p_id
                   AND object_name  = :l_sql_id
                 -- ORDER BY position
                 ORDER BY (case when parent_id = 0 then position else null end) desc, position  -- PSRv10 to fix scalar subquery ordering
                 )
      LOOP
        assign_execution_order (
          p_plan_hash_value => p_plan_hash_value,
          p_id              => j.id );
      END LOOP;

      l_exec_order := l_exec_order + 1;


      UPDATE plan_table
         SET cardinality = l_exec_order
       WHERE 1 = 1
         AND object_name  = :l_sql_id
         AND plan_id      = p_plan_hash_value
         AND id = p_id;

      -- dbms_output.put_line('rows updated: ' || sql%rowcount || ' l_exec_order: ' || l_exec_order || ' plan/id: ' || p_plan_hash_value || '/'|| p_id);
    END assign_execution_order;

begin

  DELETE plan_table where object_name = :l_sql_id and plan_id = :l_report_id;
  commit;

  begin
    insert into plan_table
--20200728---
            (object_name, plan_id, id, parent_id, position, cardinality, time)
      select sql_id, REPORT_ID, id, parent_id, position, exec_order, skp
        from (       select :L_SQL_ID   sql_id, C.REPORT_ID,
                             extractValue(value(d), '/operation/@id') id ,
                             extractValue(value(d), '/operation/@parent_id') parent_id  ,
                             extractValue(value(d), '/operation/@position') position ,
                             -1 as exec_order ,
                             extractValue(value(d), '/operation/@skp') skp
--20200728---
                      from  DBA_HIST_REPORTS_DETAILS c,
                            TABLE(XMLSEQUENCE(EXTRACT(XMLTYPE(c.report), '/report/sql_monitor_report/plan_monitor/*'))) D
                      where c.DBID = :L_DBID AND C.INSTANCE_NUMBER = :L_INSTANCE_NUMBER
                      --2020922
                      AND C.SNAP_ID BETWEEN :L_SNAP_ID - 720 AND :L_SNAP_ID
                      and   c.report_id = :L_REPORT_ID and  :L_REPORT_ID <> 0
                      AND   :SQL_FROM_AWR_SPM = 1
             )
    ;

  exception when others then
    raise_application_error(-20000, 'Please create plan_table using script: $ORACLE_HOME/rdbms/admin/utlxplan.sql');
  end;

  for cn in (select distinct plan_id plan_hash_value from plan_table where object_name = :l_sql_id order by plan_id)
  loop
    FOR i IN (SELECT
                     plan_id      plan_hash_value,
                     id
                FROM plan_table
               WHERE plan_id = cn.plan_hash_value
                 AND object_name = :l_sql_id
                 AND parent_id IS NULL)
    LOOP
      l_exec_order := 0;

      assign_execution_order (
        p_plan_hash_value => i.plan_hash_value,
        p_id              => i.id );
    END LOOP;
  END LOOP;
  COMMIT;

end;
/

-- 20200728 making execution order without skp 

update plan_table p
set POSITION = (select ok.real_ord from
                (select id, rownum real_ord
                 from  (select id, cardinality
                        from plan_table where time = 0  order by  cardinality )
                 order by id ) ok
               where ok.id = p.id );

/*
SELECT object_name, plan_id, id, parent_id, position, cardinality , time
FROM plan_table
where object_name = :l_sql_id  and plan_id = :l_report_id;
*/

---------exec order end----------
--20200710--
INSERT INTO PLAN_TABLE (STATEMENT_ID,PLAN_ID,ID,REMARKS)
with plan_monitor as (
select extractValue(value(d), '/operation/@id') id ,
       extractValue(value(d), '/operation/@parent_id') parent_id  ,
       extractValue(value(d), '/operation/@depth') depth  ,
       extractValue(value(d), '/operation/@name') operation,
       extractValue(value(d), '/operation/@skp') skip_op,
       extractValue(value(d), '/operation/@options') options,
       extractValue(value(d), '/operation/object/owner') object_owner,
       extractValue(value(d), '/operation/object/name') object_name,
       extractValue(value(d), '/operation/stats/stat[@name="cardinality"]') act_rows,
       extractValue(value(d), '/operation/stats/stat[@name="duration"]') duration,
       extractValue(value(d), '/operation/optimizer/cardinality') cardinality,
       extractValue(value(d), '/operation/stats/stat[@name="starts"]') exec,
       --extractValue(value(d), '/operation/stats/stat[@name="max_starts"]') exec,
       extractValue(value(d), '/operation/optimizer/io_cost') cost,
TO_NUMBER(extractValue(value(d), '/operation/activity_sampled/activity[1][@class="Cpu"]')) CPU_count,
          extractValue(value(d), '/operation/activity_sampled/activity[1]/@event') event1,
TO_NUMBER(extractValue(value(d), '/operation/activity_sampled/activity[1][@event]')) event_count1 ,
          extractValue(value(d), '/operation/activity_sampled/activity[2]/@event') event2,
TO_NUMBER(extractValue(value(d), '/operation/activity_sampled/activity[2][@event]')) event_count2 ,
          extractValue(value(d), '/operation/activity_sampled/activity[3]/@event') event3,
TO_NUMBER(extractValue(value(d), '/operation/activity_sampled/activity[3][@event]')) event_count3 ,
          extractValue(value(d), '/operation/activity_sampled/activity[4]/@event') event4,
TO_NUMBER(extractValue(value(d), '/operation/activity_sampled/activity[4][@event]')) event_count4 ,
       C.REPORT_ID
from  DBA_HIST_REPORTS_DETAILS c,
      TABLE(XMLSEQUENCE(EXTRACT(XMLTYPE(c.report), '/report/sql_monitor_report/plan_monitor/*'))) D
where c.DBID = :L_DBID AND C.INSTANCE_NUMBER = :L_INSTANCE_NUMBER
--2020922
AND C.SNAP_ID BETWEEN :L_SNAP_ID - 720 AND :L_SNAP_ID
and   c.report_id = :L_REPORT_ID and  :L_REPORT_ID <> 0
AND   :SQL_FROM_AWR_SPM = 1
--and   extractValue(value(d), '/operation/@skp') = 0
--AND   :SQL_FROM_SPM = 0
) ,
plan_monitor0 as (
select  p.ID,
        p.COST,        p.CARDINALITY,   p.exec,     P.act_rows,    P.duration,        P.depth,
        P.operation,   p.skip_op, p.OPTIONS,  P.object_owner,     P.object_name,
        P.EVENT1, P.EVENT_COUNT1, P.EVENT2, P.EVENT_COUNT2, P.EVENT3, P.EVENT_COUNT3, P.EVENT4, P.EVENT_COUNT4, P.CPU_COUNT,
        P.REPORT_ID,
        d.qblock, d.object_alias
from plan_monitor p,
     (select report, DBID, report_id
       from DBA_HIST_REPORTS_DETAILS c
       where c.DBID = :L_DBID AND C.INSTANCE_NUMBER = :L_INSTANCE_NUMBER
       --2020922
       AND C.SNAP_ID BETWEEN :L_SNAP_ID - 720 AND :L_SNAP_ID
       and   c.report_id = :L_REPORT_ID and  :L_REPORT_ID <> 0
       AND   :SQL_FROM_AWR_SPM = 1
       --AND   :SQL_FROM_SPM = 0
      ) c,
       xmltable (
         '/report/sql_monitor_report/plan/operation'
         passing XMLTYPE(c.report)
         columns
           pid path '@id',
           qblock path 'qblock',
           object_alias path 'object_alias',
           object path 'object'
       ) d
where p.id = d.pid(+)
)
, exec_plan as (
select  p.ID,  SEO.OID,
        p.COST,        p.CARDINALITY,   p.exec,     P.act_rows,    P.duration,        P.depth,
        P.operation,   p.skip_op, p.OPTIONS,   P.object_owner,    P.object_name,
        P.EVENT1, P.EVENT_COUNT1, P.EVENT2, P.EVENT_COUNT2, P.EVENT3, P.EVENT_COUNT3, P.EVENT4, P.EVENT_COUNT4, P.CPU_COUNT,
        P.REPORT_ID,
        P.qblock, P.object_alias
-----20200728-------------------------
from plan_monitor0 p, ( select id, position oid from plan_table
                        where object_name = :l_sql_id  and plan_id = :l_report_id and time = 0 ) SEO
---from plan_monitor0 p, ( select id, cardinality oid from plan_table
--                       where object_name = :l_sql_id  and plan_id = :l_report_id ) SEO
------------------------------
WHERE P.ID = SEO.ID
--order by to_number(p.id)
) ,
exec_join as (
select  p.ID, P.OID   OID,
        p.COST,        p.CARDINALITY,   p.exec,     P.act_rows,    P.duration,        P.depth,
        P.operation,   p.skip_op,   p.OPTIONS,  P.object_owner,     P.object_name,
        P.EVENT1, P.EVENT_COUNT1, P.EVENT2, P.EVENT_COUNT2, P.EVENT3, P.EVENT_COUNT3, P.EVENT4, P.EVENT_COUNT4, P.CPU_COUNT,
        P.REPORT_ID,
        P.qblock, P.object_alias, PB.qblock BQBLOCK, PB.object_alias BOBJECT_ALIAS,
        PB.act_rows    BEFORE_ACT_ROWS, PB.OPERATION BOPERATION
from    EXEC_PLAN P, EXEC_PLAN PB
WHERE   P.OID-1 = PB.OID(+)
)
/* v4 sql plan order : 20190827 jseo*/
/* V19C 20200710 */
select  :L_SQL_ID SQL_ID, :L_REPORT_ID SMP_TYPE, P.ID,
        decode(p.skip_op,0,' ',1,'-')||
        LPAD('    ',6-LENGTH(p.ID))||p.ID||
---------------
        LPAD('    ',6-LENGTH(P.OID))||P.OID||
---------------
--        lpad('        ',10-length(NVL(COST,0)))||NVL(TO_CHAR(COST),' ')
        lpad('        ',7-length(
                                nvl(CASE
                                    WHEN COST >= 1e18 THEN ROUND(COST /1e18,1) || 'E'
                                    WHEN COST >= 1e15 THEN ROUND(COST /1e15,1) || 'P'
                                    WHEN COST >= 1e12 THEN ROUND(COST /1e12,1) || 'T'
                                    WHEN COST >= 1e9  THEN ROUND(COST / 1e9,1) || 'G'
                                    WHEN COST >= 1e6  THEN ROUND(COST / 1e6,1) || 'M'
                                    WHEN COST >= 1e3  THEN ROUND(COST / 1e3,1) || 'K'
                                    ELSE to_char(round(COST,2)) END, ' ')))
                         ||     nvl(CASE
                                    WHEN COST >= 1e18 THEN ROUND(COST /1e18,1) || 'E'
                                    WHEN COST >= 1e15 THEN ROUND(COST /1e15,1) || 'P'
                                    WHEN COST >= 1e12 THEN ROUND(COST /1e12,1) || 'T'
                                    WHEN COST >= 1e9  THEN ROUND(COST / 1e9,1) || 'G'
                                    WHEN COST >= 1e6  THEN ROUND(COST / 1e6,1) || 'M'
                                    WHEN COST >= 1e3  THEN ROUND(COST / 1e3,1) || 'K'
                                    ELSE to_char(round(COST,2)) END, ' ')||
--||lpad('        ',15-length(nvl(CARDINALITY,0)))||NVL(TO_CHAR(CARDINALITY),' ')||':'||
        case   when (  ( cardinality*exec > act_rows*1.5 and act_rows > 1 and operation NOT like 'NESTED%' )
                      or ( cardinality*exec < act_rows*0.5 and act_rows > 1 and operation NOT like 'NESTED%' )
                      or ( cardinality = 1 and exec = 1    and act_rows > 1 and operation NOT like 'NESTED%' ) )
--sma19c
                 then
                      lpad('        ',7-length(
                                    nvl(CASE
                                    WHEN CARDINALITY >= 1e18  THEN ROUND(CARDINALITY / 1e18,1) || 'E'
                                    WHEN CARDINALITY >= 1e15  THEN ROUND(CARDINALITY / 1e15,1) || 'P'
                                    WHEN CARDINALITY >= 1e12  THEN ROUND(CARDINALITY / 1e12,1) || 'T'
                                    WHEN CARDINALITY >= 1e9  THEN ROUND(CARDINALITY / 1e9,1) || 'G'
                                    WHEN CARDINALITY >= 1e6 THEN ROUND(CARDINALITY / 1e6,1) || 'M'
                                    WHEN CARDINALITY >= 1e3 THEN ROUND(CARDINALITY / 1e3,1) || 'K'
                                    ELSE to_char(round(CARDINALITY,2)) END, ' ')))||'<RED>'||
                                    nvl(CASE
                                    WHEN CARDINALITY >= 1e18  THEN ROUND(CARDINALITY / 1e18,1) || 'E'
                                    WHEN CARDINALITY >= 1e15  THEN ROUND(CARDINALITY / 1e15,1) || 'P'
                                    WHEN CARDINALITY >= 1e12  THEN ROUND(CARDINALITY / 1e12,1) || 'T'
                                    WHEN CARDINALITY >= 1e9  THEN ROUND(CARDINALITY / 1e9,1) || 'G'
                                    WHEN CARDINALITY >= 1e6 THEN ROUND(CARDINALITY / 1e6,1) || 'M'
                                    WHEN CARDINALITY >= 1e3 THEN ROUND(CARDINALITY / 1e3,1) || 'K'
                                    ELSE to_char(round(CARDINALITY,2)) END, ' ')||'</RED>'
                 else lpad('        ',7-length(
                                nvl(CASE
                                    WHEN CARDINALITY >= 1e18  THEN ROUND(CARDINALITY / 1e18,1) || 'E'
                                    WHEN CARDINALITY >= 1e15  THEN ROUND(CARDINALITY / 1e15,1) || 'P'
                                    WHEN CARDINALITY >= 1e12  THEN ROUND(CARDINALITY / 1e12,1) || 'T'
                                    WHEN CARDINALITY >= 1e9  THEN ROUND(CARDINALITY / 1e9,1) || 'G'
                                    WHEN CARDINALITY >= 1e6 THEN ROUND(CARDINALITY / 1e6,1) || 'M'
                                    WHEN CARDINALITY >= 1e3 THEN ROUND(CARDINALITY / 1e3,1) || 'K'
                                    ELSE to_char(round(CARDINALITY,2)) END, ' ')))
                           ||   nvl(CASE
                                    WHEN CARDINALITY >= 1e18 THEN ROUND(CARDINALITY / 1e18,1) || 'E'
                                    WHEN CARDINALITY >= 1e15 THEN ROUND(CARDINALITY / 1e15,1) || 'P'
                                    WHEN CARDINALITY >= 1e12 THEN ROUND(CARDINALITY / 1e12,1) || 'T'
                                    WHEN CARDINALITY >= 1e19 THEN ROUND(CARDINALITY / 1e19,1) || 'G'
                                    WHEN CARDINALITY >= 1e6 THEN ROUND(CARDINALITY / 1e6,1) || 'M'
                                    WHEN CARDINALITY >= 1e3 THEN ROUND(CARDINALITY / 1e3,1) || 'K'
                                    ELSE to_char(round(CARDINALITY,2)) END, ' ')
/*
                 then
                      lpad('        ',15-length(nvl(CARDINALITY,0)))||'<RED>'||NVL(TO_CHAR(CARDINALITY),' ')||'</RED>'
                 else lpad('        ',15-length(nvl(CARDINALITY,0)))||NVL(TO_CHAR(CARDINALITY),' ')   --||':'
cf)
     , nvl(CASE
         WHEN CARDINALITY >= 1e9 THEN ROUND(CARDINALITY / 1e9,1) || 'G'
         WHEN CARDINALITYm >= 1e6 THEN ROUND(CARDINALITY / 1e6,1) || 'M'
         WHEN CARDINALITY >= 1e3 THEN ROUND(CARDINALITY / 1e3,1) || 'K'
         ELSE to_char(round(CARDINALITY,2)) END, ' ') conv
*/
        end ||
--        lpad('        ',15-length(nvl(exec,0)))||NVL(TO_CHAR(exec),' ')||
        lpad('        ',7-length(
                                nvl(CASE
                                    WHEN exec >= 1e18 THEN ROUND(exec /1e18,1) || 'E'
                                    WHEN exec >= 1e15 THEN ROUND(exec /1e15,1) || 'P'
                                    WHEN exec >= 1e12 THEN ROUND(exec /1e12,1) || 'T'
                                    WHEN exec >= 1e9  THEN ROUND(exec / 1e9,1) || 'G'
                                    WHEN exec >= 1e6  THEN ROUND(exec / 1e6,1) || 'M'
                                    WHEN exec >= 1e3  THEN ROUND(exec / 1e3,1) || 'K'
                                    ELSE to_char(round(exec,2)) END, ' ')))
                         ||     nvl(CASE
                                    WHEN exec >= 1e18 THEN ROUND(exec /1e18,1) || 'E'
                                    WHEN exec >= 1e15 THEN ROUND(exec /1e15,1) || 'P'
                                    WHEN exec >= 1e12 THEN ROUND(exec /1e12,1) || 'T'
                                    WHEN exec >= 1e9  THEN ROUND(exec / 1e9,1) || 'G'
                                    WHEN exec >= 1e6  THEN ROUND(exec / 1e6,1) || 'M'
                                    WHEN exec >= 1e3  THEN ROUND(exec / 1e3,1) || 'K'
                                    ELSE to_char(round(exec,2)) END, ' ')||
--        lpad('        ',15-length(nvl(act_rows,0)))||NVL(TO_CHAR(act_rows),' ')||
        lpad('        ',7-length(
                                nvl(CASE
                                    WHEN act_rows >= 1e18 THEN ROUND(act_rows /1e18,1) || 'E'
                                    WHEN act_rows >= 1e15 THEN ROUND(act_rows /1e15,1) || 'P'
                                    WHEN act_rows >= 1e12 THEN ROUND(act_rows /1e12,1) || 'T'
                                    WHEN act_rows >= 1e9  THEN ROUND(act_rows / 1e9,1) || 'G'
                                    WHEN act_rows >= 1e6  THEN ROUND(act_rows / 1e6,1) || 'M'
                                    WHEN act_rows >= 1e3  THEN ROUND(act_rows / 1e3,1) || 'K'
                                    ELSE to_char(round(act_rows,2)) END, ' ')))
                         ||     nvl(CASE
                                    WHEN act_rows >= 1e18 THEN ROUND(act_rows /1e18,1) || 'E'
                                    WHEN act_rows >= 1e15 THEN ROUND(act_rows /1e15,1) || 'P'
                                    WHEN act_rows >= 1e12 THEN ROUND(act_rows /1e12,1) || 'T'
                                    WHEN act_rows >= 1e9  THEN ROUND(act_rows / 1e9,1) || 'G'
                                    WHEN act_rows >= 1e6  THEN ROUND(act_rows / 1e6,1) || 'M'
                                    WHEN act_rows >= 1e3  THEN ROUND(act_rows / 1e3,1) || 'K'
                                    ELSE to_char(round(act_rows,2)) END, ' ')||
---       lpad('        ',10-length(nvl(duration,0)))||NVL(TO_CHAR(duration),' ')||
        lpad('        ',7-length(
                                nvl(CASE
                                    WHEN duration >= 1e18 THEN ROUND(duration /1e18,1) || 'E'
                                    WHEN duration >= 1e15 THEN ROUND(duration /1e15,1) || 'P'
                                    WHEN duration >= 1e12 THEN ROUND(duration /1e12,1) || 'T'
                                    WHEN duration >= 1e9  THEN ROUND(duration / 1e9,1) || 'G'
                                    WHEN duration >= 1e6  THEN ROUND(duration / 1e6,1) || 'M'
                                    WHEN duration >= 1e3  THEN ROUND(duration / 1e3,1) || 'K'
                                    ELSE to_char(round(duration,2)) END, ' ')))
                         ||     nvl(CASE
                                    WHEN duration >= 1e18 THEN ROUND(duration /1e18,1) || 'E'
                                    WHEN duration >= 1e15 THEN ROUND(duration /1e15,1) || 'P'
                                    WHEN duration >= 1e12 THEN ROUND(duration /1e12,1) || 'T'
                                    WHEN duration >= 1e9  THEN ROUND(duration / 1e9,1) || 'G'
                                    WHEN duration >= 1e6  THEN ROUND(duration / 1e6,1) || 'M'
                                    WHEN duration >= 1e3  THEN ROUND(duration / 1e3,1) || 'K'
                                    ELSE to_char(round(duration,2)) END, ' ')||
        lpad('...............................', (depth+1))
        --DECODE(EVENT,NULL,lpad('...............................', (depth)),'<RED>'||lpad('...............................', (depth))||'</RED>')
        ||decode(p.skip_op,1,'<strike>')
-- sma19c 20200514
         ||case when OPERATION ='SORT' AND OPTIONS = 'ORDER BY STOPKEY' then '<RED>'||OPERATION||' '||OPTIONS||'</RED>'
                when OBJECT_OWNER =  'FUSION' then OPERATION ||' '|| OPTIONS ||' '||OBJECT_NAME
                when OBJECT_OWNER <> 'FUSION' then OPERATION ||' '|| OPTIONS ||' '||OBJECT_OWNER||'.'|| OBJECT_NAME
                when OBJECT_OWNER IS NULL     then OPERATION ||' '|| OPTIONS
           end
--        ||operation||' '||OPTIONS||' '||object_name
        ||decode(p.skip_op,1,'</strike>')
        --||DECODE(BEFORE_ACT_ROWS,NULL,NULL,' ( change: '||BEFORE_ACT_ROWS||' => '||act_rows||') ')||    --20190909
        ||case when BEFORE_ACT_ROWS >=  act_rows*30 and BEFORE_ACT_ROWS <> act_rows
                    and ( QBLOCK = BQBLOCK  OR ( BOPERATION = 'NESTED LOOPS' AND BQBLOCK IS NULL ) )
--20200712
                    and OPERATION not like '%INDEX%'
--20200712
               then ' (<RED>'||BEFORE_ACT_ROWS||' => '||ACT_ROWS||'</RED>) '
               when BEFORE_ACT_ROWS <   act_rows*30 and BEFORE_ACT_ROWS <> act_rows
                    and ( QBLOCK = BQBLOCK  OR ( BOPERATION = 'NESTED LOOPS' AND BQBLOCK IS NULL ) )
               then ' ('||BEFORE_ACT_ROWS||' => '||ACT_ROWS||') '
               --else ' ('||BEFORE_ACT_ROWS||' => '||act_rows||') '
          end ||
        DECODE(EVENT1,NULL,NULL,' "<BLUE>'||EVENT1||'</BLUE>":'||EVENT_COUNT1)||
        DECODE(EVENT2,NULL,NULL,' "<BLUE>'||EVENT2||'</BLUE>":'||EVENT_COUNT2)||
        DECODE(EVENT3,NULL,NULL,' "<BLUE>'||EVENT3||'</BLUE>":'||EVENT_COUNT3)||
        DECODE(EVENT4,NULL,NULL,' "<BLUE>'||EVENT4||'</BLUE>":'||EVENT_COUNT4)||
        DECODE(CPU_count,NULL,NULL,' "<BLUE>CPU</BLUE>":'||CPU_COUNT||' ')||
        DECODE(NVL(EVENT_COUNT1,0)+NVL(EVENT_COUNT2,0)+NVL(EVENT_COUNT3,0)+NVL(EVENT_COUNT4,0)+NVL(CPU_COUNT,0),0,NULL,
              '<RED>('||ROUND((RATIO_TO_REPORT
              (NVL(EVENT_COUNT1,0)+NVL(EVENT_COUNT2,0)+NVL(EVENT_COUNT3,0)+NVL(EVENT_COUNT4,0)+NVL(CPU_COUNT,0))
              over(partition by P.REPORT_ID))*100, 2)||'%)</RED>')
        AS "AWR SQL PLAN MONITOR"
from exec_join p
--where p.skip_op = 0
order by to_number(p.id)
/
/*
SELECT STATEMENT_ID, plan_id, id, parent_id, id, remarks
FROM plan_table
where STATEMENT_ID = :l_sql_id  and plan_id = :l_report_id;
*/
BEGIN
   FOR SM IN ( SELECT id, REPLACE(remarks,'%)','WAIT_CPU)') REMARKS
               FROM plan_table
               WHERE STATEMENT_ID = :l_sql_id  and plan_id = :l_report_id
               AND   REMARKS not LIKE '-%'
               AND   remarks LIKE '%<RED>%' ORDER BY ID )
   LOOP
       IF( SM.REMARKS LIKE '%WAIT_CPU%' )
           THEN :ISSUE_HEAVY_OPERATION := 1;
       END IF;
       IF( SM.REMARKS LIKE '%.TABLE%=>%' OR SM.REMARKS LIKE '%.VIEW%=>%' OR SM.REMARKS LIKE '%.HASH%=>%' OR SM.REMARKS LIKE '%.NESTED%=>%' )
           THEN :ISSUE_THROW_AWAY := 1;
       END IF;
   END LOOP;
   EXCEPTION  WHEN OTHERS THEN
       DBMS_OUTPUT.PUT_LINE('ERROR ON AWRSMP ISSUE: '||SQLERRM||' => where '||:L_WHERE_LOG);
END ;
/

PROMPT <DETAILS>
PROMPT <SUMMARY><BLUE> 1. AWR SQL MONITOR PLAN</BLUE></SUMMARY>
PROMPT ===============================================================================================================================================
--PROMPT S    ID   OID      COST       CARDINAL          EXECS    <BLUE>ACTUAL-ROWS</BLUE>  DURATION OPERATIONS "WAITS CPU" (WAIT_CPU%)
--PROMPT = ===== ===== ========= ============== ============== ============== ========= ===========================================================
PROMPT S    ID   OID   COST CARDNL  EXECS  <BLUE>A-ROW</BLUE>  DURAT OPERATIONS "WAITS CPU" (WAIT_CPU%)
PROMPT = ===== ===== ====== ====== ====== ====== ====== ==============================================================================================

SELECT remarks
FROM plan_table
where STATEMENT_ID = :l_sql_id  and plan_id = :l_report_id
and  remarks not like '-%'
order by id;

PROMPT </DETAILS>

col PID  FORMAT 99999
col ACCESS_PREDICATES format a70
col FILTER_PREDICATES format a70
COL QBLOCK FORMAT A16
COL ALIAS  FORMAT A33
COL OBJECT FORMAT A30

PROMPT <DETAILS>
PROMPT <SUMMARY><BLUE> 2. AWR SQL MONITOR PLAN PREDICATES</BLUE></SUMMARY>
prompt =================================================================================================================================================================================================
prompt S ID     OBJECT                         ACCESS_PREDICATES                                                      FILTER_PREDICATES                                                     (WAIT_CPU%)
prompt = ====== ============================== ====================================================================== ===================================================================== ============

with plan_monitor as (
select pid,  skip_op,
'('||ROUND((RATIO_TO_REPORT(NVL(EVENT_COUNT1,0)+NVL(EVENT_COUNT2,0)+NVL(EVENT_COUNT3,0)+NVL(EVENT_COUNT4,0)+NVL(CPU_COUNT,0)) over(partition by REPORT_ID))*100, 2)||'%)' evt_cpu
from ( select extractValue(value(d), '/operation/@id') pid ,
              extractValue(value(d), '/operation/@name') operation,
              extractValue(value(d), '/operation/@skp') skip_op,
         TO_NUMBER(extractValue(value(d), '/operation/activity_sampled/activity[1][@class="Cpu"]')) CPU_count,
         TO_NUMBER(extractValue(value(d), '/operation/activity_sampled/activity[1][@event]')) event_count1 ,
         TO_NUMBER(extractValue(value(d), '/operation/activity_sampled/activity[2][@event]')) event_count2 ,
         TO_NUMBER(extractValue(value(d), '/operation/activity_sampled/activity[3][@event]')) event_count3 ,
         TO_NUMBER(extractValue(value(d), '/operation/activity_sampled/activity[4][@event]')) event_count4 ,
         c.report_id
       from  DBA_HIST_REPORTS_DETAILS c,
             TABLE(XMLSEQUENCE(EXTRACT(XMLTYPE(c.report), '/report/sql_monitor_report/plan_monitor/*'))) D
       where c.DBID = :L_DBID  AND C.INSTANCE_NUMBER = :L_INSTANCE_NUMBER
       --2020922
       AND  C.SNAP_ID BETWEEN :L_SNAP_ID - 720 AND :L_SNAP_ID
       and   c.report_id = :L_REPORT_ID and  :L_REPORT_ID <> 0
       AND   :SQL_FROM_AWR_SPM = 1
       --and   extractValue(value(d), '/operation/@skp') = 0
       --AND   :SQL_FROM_SPM = 0
       )
where  to_number( NVL(EVENT_COUNT1,0)+NVL(EVENT_COUNT2,0)+NVL(EVENT_COUNT3,0)+NVL(EVENT_COUNT4,0)+NVL(CPU_COUNT,0) ) > 0
    or skip_op = 1
    )
SELECT --decode(p.pid,null,null, '<RED>')||D.PID|| decode(p.pid,null,null, '</RED>')
       --LPAD('    ',6-LENGTH(D.pID))||d.PID  PID,  --D.QBLOCK, D.OBJECT_ALIAS,
       decode(p.skip_op,0,' ',1,'-') S,
       to_number(D.PID) PID,
       nvl(D.OBJECT, D.operation) OBJECT,
       D.ACCESS_PREDICATES,
       D.FILTER_PREDICATES,
       decode(p.pid,null,null, '<RED>')||p.evt_cpu|| decode(p.pid,null,null, '</RED>')
FROM  plan_monitor p,
     (select report, DBID, report_id
       from DBA_HIST_REPORTS_DETAILS c
       where c.DBID = :L_DBID AND C.INSTANCE_NUMBER = :L_INSTANCE_NUMBER
       --2020922
       AND C.SNAP_ID BETWEEN :L_SNAP_ID - 720 AND :L_SNAP_ID
       and   c.report_id = :L_REPORT_ID and  :L_REPORT_ID <> 0
       AND   :SQL_FROM_AWR_SPM = 1
       --AND   :SQL_FROM_SPM = 0
       ) c,
       xmltable (
         '/report/sql_monitor_report/plan/operation'
         passing XMLTYPE(c.report)
         columns
           pid path '@id',
           operation path '@name',
           --qblock path 'qblock',
           --object_alias path 'object_alias',
           object path 'object',
           --skip_op path '@skp',
           ACCESS_PREDICATES clob path 'predicates[@type="access"]',
           FILTER_PREDICATES clob path 'predicates[@type="filter"]'
       ) d
where( d.ACCESS_PREDICATES is NOT NULL OR d.FILTER_PREDICATES IS NOT NULL )
and   d.pid = p.pid(+)
order by to_number(d.pid)
/

PROMPT </DETAILS>


COL PARAM_NAME FORMAT  A50
COL PARAM_VALUE FORMAT A30

PROMPT <DETAILS>
prompt <SUMMARY><BLUE> 3. AWR SQL MONITOR PLAN OPTIMIZER ENVIRONMENT</BLUE></SUMMARY>
PROMPT ================================================= ===============================
PROMPT PARAMETER_NAME                                    PARAMETER_VALUE
PROMPT ================================================= ===============================

select extractValue(value(d), '/param/@name') PARAM_NAME ,
       extractValue(value(d), '/param')       PARAM_VALUE
from  DBA_HIST_REPORTS_DETAILS c,
      TABLE(XMLSEQUENCE(EXTRACT(XMLTYPE(c.report), '/report/sql_monitor_report/target/optimizer_env/param'))) D
where  c.DBID = :L_DBID AND C.INSTANCE_NUMBER = :L_INSTANCE_NUMBER
--2020922
AND C.SNAP_ID BETWEEN :L_SNAP_ID - 720 AND :L_SNAP_ID
AND    c.report_id = :L_REPORT_ID and  :L_REPORT_ID <> 0
AND   :SQL_FROM_AWR_SPM = 1
--AND   :SQL_FROM_SPM = 0
/

PROMPT </DETAILS>

PROMPT <DETAILS>
prompt <SUMMARY><BLUE> 4. AWR SQL MONITOR PLAN BINDS</BLUE></SUMMARY>

col bname   format  a30
col dtystr  format  a20
col dlength format  a10
col bvalue  format  a60

PROMPT ============================== ==================== ========== ==========================================================
PROMPT BIND_VARIABLE_NAME             TYPE                 LENGTH     BIND_VALUE
PROMPT ============================== ==================== ========== ==========================================================
--2021/05/27
select bname, dtystr, dlength,
substr(bvalue, length(bvalue)/3+1)||rpad('***********************************', length(bvalue)*2/3)  bvalue
from (
select extractValue(value(d), '/bind/@name')   bname,
       --extractValue(value(d), '/bind/@dty')    dtype,
       extractValue(value(d), '/bind/@dtystr') dtystr,
       extractValue(value(d), '/bind/@maxlen') dlength,
       extractValue(value(d), '/bind')         bvalue
from  DBA_HIST_REPORTS_DETAILS c,
      TABLE(XMLSEQUENCE(EXTRACT(XMLTYPE(c.report), '/report/sql_monitor_report/binds/bind'))) D
where c.DBID = :L_DBID  AND C.INSTANCE_NUMBER = :L_INSTANCE_NUMBER
--2020922
AND C.SNAP_ID BETWEEN :L_SNAP_ID - 720 AND :L_SNAP_ID
AND    c.report_id = :L_REPORT_ID and  :L_REPORT_ID <> 0
AND   :SQL_FROM_AWR_SPM = 1
)
/
PROMPT </DETAILS>

-----------------20200728 START-----------------------------

COL PID    FORMAT 99999
COL QBLOCK FORMAT A30
COL OBJECT_ALIAS  FORMAT A50
COL OBJECT FORMAT A30
COL WAIT_CPU FORMAT A21

DELETE PLAN_TABLE ;
COMMIT;

PROMPT <DETAILS>
PROMPT <SUMMARY><BLUE> 5. AWR SQL MONITOR PLAN QBLOCK and ALIAS</BLUE></SUMMARY>
prompt ===================================================================================================================================
prompt ID     QBLOCK                         OBJECT_ALIAS                                       OBJECT                         (WAIT_CPU%)
prompt ====== ============================== ================================================== ============================== ===========

INSERT INTO PLAN_TABLE ( id, qblock_name, object_alias, object_name, remarks, cost )
with plan_monitor as (
select pid, skip_op,
'('||ROUND((RATIO_TO_REPORT(NVL(EVENT_COUNT1,0)+NVL(EVENT_COUNT2,0)+NVL(EVENT_COUNT3,0)+NVL(EVENT_COUNT4,0)+NVL(CPU_COUNT,0)) over(partition by REPORT_ID))*100, 2)||'%)' evt_cpu,
ROUND((RATIO_TO_REPORT(NVL(EVENT_COUNT1,0)+NVL(EVENT_COUNT2,0)+NVL(EVENT_COUNT3,0)+NVL(EVENT_COUNT4,0)+NVL(CPU_COUNT,0)) over(partition by REPORT_ID))*100, 2) evt_cpu_fg
from ( select extractValue(value(d), '/operation/@id') pid ,
              extractValue(value(d), '/operation/@skp') skip_op,
         TO_NUMBER(extractValue(value(d), '/operation/activity_sampled/activity[1][@class="Cpu"]')) CPU_count,
         TO_NUMBER(extractValue(value(d), '/operation/activity_sampled/activity[1][@event]')) event_count1 ,
         TO_NUMBER(extractValue(value(d), '/operation/activity_sampled/activity[2][@event]')) event_count2 ,
         TO_NUMBER(extractValue(value(d), '/operation/activity_sampled/activity[3][@event]')) event_count3 ,
         TO_NUMBER(extractValue(value(d), '/operation/activity_sampled/activity[4][@event]')) event_count4 ,
         c.report_id
       from  DBA_HIST_REPORTS_DETAILS c,
             TABLE(XMLSEQUENCE(EXTRACT(XMLTYPE(c.report), '/report/sql_monitor_report/plan_monitor/*'))) D
       where c.DBID = :L_DBID AND C.INSTANCE_NUMBER = :L_INSTANCE_NUMBER
       --2020922
       AND C.SNAP_ID BETWEEN :L_SNAP_ID - 720 AND :L_SNAP_ID
       and   c.report_id = :L_REPORT_ID and  :L_REPORT_ID <> 0
       AND   :SQL_FROM_AWR_SPM = 1
       and   extractValue(value(d), '/operation/@skp') = 0
       --AND   :SQL_FROM_SPM = 0
       )
where  to_number( NVL(EVENT_COUNT1,0)+NVL(EVENT_COUNT2,0)+NVL(EVENT_COUNT3,0)+NVL(EVENT_COUNT4,0)+NVL(CPU_COUNT,0) ) > 0
    )
--20210127
SELECT  to_number(D.PID) PID, '@"'||D.QBLOCK||'"' QBLOCK,
       (case when D.OBJECT_ALIAS like '"%'     then D.OBJECT_ALIAS
             when D.OBJECT_ALIAS not like '"%' then '"'||replace(replace(D.OBJECT_ALIAS,'"',''),'@','"@"')||'"'
        end ) OBJECT_ALIAS,
        '"'||D.OBJECT||'"' OBJECT,
--SELECT  to_number(D.PID) PID, '@'||D.QBLOCK QBLOCK, '"'||replace(D.OBJECT_ALIAS,'@','"@"')||'"' OBJECT_ALIAS, D.OBJECT,
--SELECT  to_number(D.PID) PID, '@'||D.QBLOCK QBLOCK, D.OBJECT_ALIAS, D.OBJECT,
       --D.ACCESS_PREDICATES,
       --D.FILTER_PREDICATES,
       decode(p.pid,null,null, '<RED>')||p.evt_cpu|| decode(p.pid,null,null, '</RED>'),
       to_number(p.evt_cpu_fg)
FROM  plan_monitor p,
     (select report, DBID, report_id
       from DBA_HIST_REPORTS_DETAILS c
       where c.DBID = :L_DBID AND C.INSTANCE_NUMBER = :L_INSTANCE_NUMBER
       --2020922
       AND C.SNAP_ID BETWEEN :L_SNAP_ID - 720 AND :L_SNAP_ID
       and   c.report_id = :L_REPORT_ID and  :L_REPORT_ID <> 0
       AND   :SQL_FROM_AWR_SPM = 1
       --AND   :SQL_FROM_SPM = 0
       ) c,
       xmltable (
         '/report/sql_monitor_report/plan/operation'
         passing XMLTYPE(c.report)
         columns
           pid path '@id',
           qblock path 'qblock',
           object_alias path 'object_alias',
           object path 'object'
           --ACCESS_PREDICATES clob path 'predicates[@type="access"]',
           --FILTER_PREDICATES clob path 'predicates[@type="filter"]'
       ) d
where( D.QBLOCK IS NOT NULL )
and   d.pid = p.pid(+)
order by to_number(d.pid)
/
select  id as pid, qblock_name as QBLOCK, object_alias as OBJECT_ALIAS, object_name as OBJECT, trim(remarks) AS WAIT_CPU
from    plan_table
/

var l_object_alias_1st  varchar2(100)
var l_object_alias_2nd  varchar2(100)
var l_object_alias_3rd  varchar2(100)


begin
  :l_object_alias_1st := NULL;
  :l_object_alias_2nd := NULL;
  for sm in ( select rownum rwm, OBJECT_ALIAS
              from
                   ( select  OBJECT_ALIAS, SUM(COST) COST
                     from    plan_table
                     where   cost is not null
                     GROUP BY OBJECT_ALIAS
                     order by cost desc )
              where rownum <= 3 )
  loop
       if ( sm.rwm = 1 ) then :l_object_alias_1st := sm.OBJECT_ALIAS; end if;
       if ( sm.rwm = 2 ) then :l_object_alias_2nd := sm.OBJECT_ALIAS; end if;
       if ( sm.rwm = 3 ) then :l_object_alias_3rd := sm.OBJECT_ALIAS; end if;
  end loop;
end;
/

PROMPT </DETAILS>

PROMPT <DETAILS>
prompt <SUMMARY><BLUE> 6. AWR SQL MONITOR PLAN HINTS</BLUE></SUMMARY>


COL OUTLINE_DATA FORMAT A500

PROMPT =======================================================================================================================
PROMPT OUTLINE_DATA
PROMPT =======================================================================================================================

SELECT replace(replace(replace(D.hint,:l_object_alias_1st,'<red>'||:l_object_alias_1st||'</red>'),
                       :l_object_alias_2nd,'<green>'||:l_object_alias_2ND||'</green>'),
               :l_object_alias_2nd,'<pink>'||:l_object_alias_2ND||'</pink>') OUTLINE_DATA
FROM
 (SELECT D.HINT
-- (SELECT replace(D.hint,'"','') HINT
  FROM (select report, DBID, report_id
       from DBA_HIST_REPORTS_DETAILS c
       where c.DBID = :L_DBID AND C.INSTANCE_NUMBER = :L_INSTANCE_NUMBER
       --2020922
       AND C.SNAP_ID BETWEEN :L_SNAP_ID - 720 AND :L_SNAP_ID
       AND    c.report_id = :L_REPORT_ID and  :L_REPORT_ID <> 0
       AND   :SQL_FROM_AWR_SPM = 1
       ) c,
       xmltable (
         '/report/sql_monitor_report/plan/operation/other_xml/outline_data/*'
         passing XMLTYPE(c.report)
         columns
           hint path '/hint'
       ) d
 ) D
/

PROMPT </DETAILS>



-----------------20200728 END-----------------------------

prompt </details>
--  8s155kx32c6xy
/*
asm2p.sql end   ===============================
*/


/* THERE IS NO DATA IN SQL_MONITOR AND AWR_SQL_MONITOR.*/

--prompt <details>
--prompt <summary><blue>MEMORY(GV$SQL) PLAN BY SMA</BLUE></SUMMARY>


--20200811 spool sma_xplan_log.txt

BEGIN

              :L_AS5 := 0 ;   --20200811
              :L_AS4 := 0 ;
              :L_AS3 := 0 ;
              :L_AS2 := 0 ;
              :L_AS1 := 0 ;

   :L_WHERE_LOG := 'XPLAN';
 IF ( :SQL_FROM_MEM = 1 ) THEN    -- 20200811 regardless of SPM
-- IF (:SQL_FROM_SPM = 0 AND :SQL_FROM_AWR_SPM in (0) ) THEN   -- v3 THERE IS NO DATA IN SQL_MONITOR --AND AWR_SQL_MONITOR.

   DBMS_OUTPUT.PUT_LINE('<details>');
   DBMS_OUTPUT.PUT_LINE('<summary><blue>MEMORY(GV$SQL) PLAN BY SMA</BLUE></SUMMARY>');

   FOR M1 IN (SELECT QRY.* FROM (SELECT INST_ID, SQL_ID, PLAN_HASH_VALUE,
                     SQL_PROFILE, SQL_PATCH, SQL_PLAN_BASELINE,
                     ROUND(AVG(ELAPSED_TIME/GREATEST(EXECUTIONS,1)/1000000),2) ELAPSED_TIME,
                     ROUND(AVG(CPU_TIME/GREATEST(EXECUTIONS,1)/1000000),2) CPU_TIME, MAX(CHILD_NUMBER) CHILD_NUMBER,
                     ROUND(SUM(BUFFER_GETS)/SUM(GREATEST(EXECUTIONS, 1)),0) AVG_BUFFER_GETS,
                     ROUND(SUM(DISK_READS)/SUM(GREATEST(EXECUTIONS, 1)),0) AVG_DISK_READS,
                     ROUND(SUM(ROWS_PROCESSED)/SUM(GREATEST(EXECUTIONS, 1)),0) AVG_ROWS_PROCESSED,
                     MAX(LAST_LOAD_TIME) LAST_LOAD_TIME, MAX(LAST_ACTIVE_TIME) LAST_ACTIVE_TIME,
                     SUM(GREATEST(EXECUTIONS, 1)) EXECUTIONS,
                     max(PX_SERVERS_EXECUTIONS) PX,
                     MIN(MODULE) MIN_MODULE, MAX(MODULE) MAX_MODULE, COUNT(DISTINCT MODULE) NDM
              FROM   GV$SQL
              WHERE  SQL_ID = :L_SQL_ID
              --AND    EXECUTIONS  > 0
--20210303
              AND PLAN_HASH_VALUE IN (:L_CURRENT_BEST,:L_CURRENT_BEST1,:L_CURRENT_WORST1)
              GROUP BY  INST_ID, SQL_ID, PLAN_HASH_VALUE, SQL_PROFILE, SQL_PATCH, SQL_PLAN_BASELINE
              ORDER BY 7) QRY
              WHERE ROWNUM <= 3 )
   LOOP
      DBMS_OUTPUT.PUT_LINE('.');
      DBMS_OUTPUT.PUT_LINE('<a name="PHV'||M1.PLAN_HASH_VALUE||'"></a>'||'[PLAN HASH VALUE: '||M1.PLAN_HASH_VALUE||']');
      DBMS_OUTPUT.PUT_LINE('*******************************************');
      :L_INST_ID := M1.INST_ID;
      :L_SQL_ID  := M1.SQL_ID;
      :L_PLAN_HASH_VALUE := M1.PLAN_HASH_VALUE;
      :L_CHILD_NUMBER := M1.CHILD_NUMBER;
--      DBMS_OUTPUT.PUT_LINE('PLAN_HASH_VALUE:'||M1.PLAN_HASH_VALUE||', ELAPSED_TIME:'||M1.ELAPSED_TIME||'secs, CPU_TIME:'||M1.CPU_TIME||'secs');
      DBMS_OUTPUT.PUT_LINE('.');
      DBMS_OUTPUT.PUT_LINE('ELAPSED_TIME: '||M1.ELAPSED_TIME||'secs, CPU_TIME: '||M1.CPU_TIME||'secs, PX_SERVERS_EXECUTIONS: '||M1.PX||', INST_ID: '||M1.INST_ID);
      DBMS_OUTPUT.PUT_LINE('AVG_BUFFER_GETS: '||M1.AVG_BUFFER_GETS||', AVG_DISK_READS: '||M1.AVG_DISK_READS||', AVG_ROWS_PROCESSED: '||M1.AVG_ROWS_PROCESSED);
      DBMS_OUTPUT.PUT_LINE('MODULE(NDM: '||M1.NDM||'): '||M1.MIN_MODULE||' - '||M1.MAX_MODULE);
      DBMS_OUTPUT.PUT_LINE('EXECUTIONS: '||M1.EXECUTIONS||', LAST_LOAD_TIME: '||M1.LAST_LOAD_TIME||', LAST_ACTIVE_TIME: '||M1.LAST_ACTIVE_TIME);
      IF (M1.SQL_PROFILE IS NOT NULL) THEN DBMS_OUTPUT.PUT_LINE('SQL_PROFILE: '||M1.SQL_PROFILE); END IF;
      IF (M1.SQL_PATCH IS NOT NULL) THEN DBMS_OUTPUT.PUT_LINE('SQL_PATCH: '||M1.SQL_PATCH); END IF;
      IF (M1.SQL_PLAN_BASELINE IS NOT NULL) THEN DBMS_OUTPUT.PUT_LINE('SQL_PLAN_BASELINE: '||M1.SQL_PLAN_BASELINE); END IF;
      DBMS_OUTPUT.PUT_LINE('.');
      FOR M2 IN (
                 WITH ACTIVE_SQL_PLAN AS
                (SELECT /*+ no_parallel opt_param('parallel_execution_enabled', 'false') */ XPLAN.*
                 FROM GV$SQL_PLAN_STATISTICS_ALL M2,
                     XMLTABLE ( '/other_xml/display_map/row' passing XMLTYPE(M2.OTHER_XML) COLUMNS
                     op  NUMBER PATH '@op',    -- operation
                     dis NUMBER PATH '@dis',   -- display
                     par NUMBER PATH '@par',   -- parent
                     dep NUMBER PATH '@dep',   -- depth
                     skp NUMBER PATH '@skp' )  -- skip
                     AS XPLAN
                 WHERE M2.INST_ID      = M1.INST_ID
                 AND   M2.SQL_ID       = M1.SQL_ID
                 AND   M2.CHILD_NUMBER = M1.CHILD_NUMBER
                 AND   M2.PLAN_HASH_VALUE = M1.PLAN_HASH_VALUE -- 20200811
                 AND   M2.OTHER_XML   IS NOT NULL
                ),
                ASH AS (
                    (SELECT /*+ no_parallel opt_param('parallel_execution_enabled', 'false') */
                     INST_ID, SQL_ID, SQL_PLAN_HASH_VALUE, SQL_PLAN_LINE_ID,
                     --EVENT, CURRENT_OBJ#,
                     ROUND(WAITS_CNT/TSNAP_COUNT*100,2) WAITS_CNT,
                     ROUND(CPU_CNT/TSNAP_COUNT*100,2)   CPU_CNT,
                     SNAP_COUNT, SESSION_COUNT, BLOCKING_SESSION_COUNT
                     FROM
                         (SELECT COUNT(*) TSNAP_COUNT
                          FROM GV$ACTIVE_SESSION_HISTORY ASH
                          WHERE ASH.INST_ID = M1.INST_ID
                          AND   ASH.SQL_ID  = M1.SQL_ID
                          and   ash.SQL_CHILD_NUMBER    = m1.child_number   -- 20200811
                          AND   ASH.SQL_PLAN_HASH_VALUE = M1.PLAN_HASH_VALUE),
                         (SELECT ASH.INST_ID, ASH.SQL_ID, ASH.SQL_PLAN_HASH_VALUE, ASH.SQL_PLAN_LINE_ID,
                          -- NVL(ASH.EVENT, ASH.SESSION_STATE) EVENT, ASH.CURRENT_OBJ# ,
                          COUNT(ASH.EVENT)         WAITS_CNT,
                          COUNT(ASH.SESSION_STATE) CPU_CNT,
                          COUNT(*) SNAP_COUNT, COUNT(DISTINCT ASH.SESSION_ID) SESSION_COUNT,
                          COUNT(DISTINCT ASH.BLOCKING_SESSION) BLOCKING_SESSION_COUNT
                          FROM GV$ACTIVE_SESSION_HISTORY ASH
                          WHERE ASH.INST_ID = M1.INST_ID
                          AND   ASH.SQL_ID  = M1.SQL_ID
                          AND   ASH.SQL_PLAN_HASH_VALUE = M1.PLAN_HASH_VALUE
                          and   ash.SQL_CHILD_NUMBER    = m1.child_number   -- 20200811
                          --AND   ASH.SESSION_ID      = M1.SID             -- NOT MANY ROWS --
                          --AND   ASH.SESSION_SERIAL# = M1.SESSION_SERIAL# -- NOT MANY ROWS --
                          --AND   ASH.EVENT IS NOT NULL                      -- PICK ONLY WAITS except CPU --
                          GROUP BY ASH.INST_ID, ASH.SQL_ID,
                          --ASH.SESSION_ID,
                          ASH.SQL_PLAN_HASH_VALUE, ASH.SQL_PLAN_LINE_ID
                          --,NVL(ASH.EVENT, ASH.SESSION_STATE), ASH.CURRENT_OBJ#
                          ORDER BY  COUNT(ASH.EVENT)+COUNT(ASH.SESSION_STATE) DESC )
                     WHERE ROWNUM < 6
                     AND ( ROUND(WAITS_CNT/TSNAP_COUNT*100,2) > 19.9
                        OR ROUND(CPU_CNT/TSNAP_COUNT*100,2)   > 19.9 )
                     AND   SNAP_COUNT > 1 )
                ),
/* v4 sql plan order : 20190827 */
                SP_EXEC_ORDER AS (
                SELECT ID,
                       PARENT_ID AS PID
                ,      ROW_NUMBER() OVER (ORDER BY ROWNUM DESC) AS OID
                --,    MAX(ID) OVER () AS MAXID
                FROM   (
                       SELECT  ID, PARENT_ID
                       FROM   (SELECT  ID, PARENT_ID
                               FROM    GV$SQL_PLAN_STATISTICS_ALL SPS
                               WHERE   SPS.INST_ID      = M1.INST_ID
                               AND     SPS.SQL_ID       = M1.SQL_ID
                               AND     SPS.CHILD_NUMBER = M1.CHILD_NUMBER
                               AND     SPS.plan_hash_value = M1.plan_hash_value)    --20200811
                       START   WITH ID = 0
                       CONNECT BY PRIOR ID = PARENT_ID
                       ORDER   SIBLINGS BY ID DESC )
                ),
                XPLAN AS (
                SELECT
                sp.id           AS id,
                sp.output_rows  AS NUM_output_rows,
                -----
                SEO.OID         AS OID,
                -----
                CASE
                WHEN sp.output_rows < 1000 THEN TO_CHAR(sp.output_rows)
                WHEN sp.output_rows >= 1000 AND sp.output_rows < 1000000 THEN ROUND(sp.output_rows/1000)||'K'
                WHEN sp.output_rows >= 1000000 AND sp.output_rows < 1000000000 THEN ROUND(sp.output_rows/1000000)||'M'
                WHEN sp.output_rows >= 1000000000          AND sp.output_rows < 1000000000000          THEN ROUND(sp.output_rows/1000000000)||'G'
                WHEN sp.output_rows >= 1000000000000       AND sp.output_rows < 1000000000000000       THEN ROUND(sp.output_rows/1000000000000)||'T'
                WHEN sp.output_rows >= 1000000000000000    AND sp.output_rows < 1000000000000000000    THEN ROUND(sp.output_rows/1000000000000000)||'P'
                WHEN sp.output_rows >= 1000000000000000000 AND sp.output_rows < 1000000000000000000000 THEN ROUND(sp.output_rows/1000000000000000000)||'E'
                END AS OUTPUT_ROWS   ,
-----------------------------
                sp.output_rows R_output_rows,
-----------------------------
                nvl(sp.cost,0)  AS NUM_cost,
                CASE
                WHEN nvl(sp.cost,0) < 1000 THEN TO_CHAR(nvl(sp.cost,0))
                WHEN nvl(sp.cost,0) >= 1000 AND nvl(sp.cost,0) < 1000000 THEN ROUND(sp.COST/1000)||'K'
                WHEN nvl(sp.cost,0) >= 1000000 AND nvl(sp.cost,0) < 1000000000 THEN ROUND(sp.COST/1000000)||'M'
                WHEN nvl(sp.cost,0) >= 1000000000          AND nvl(sp.cost,0) < 1000000000000          THEN ROUND(sp.COST/1000000000)||'G'
                WHEN nvl(sp.cost,0) >= 1000000000000       AND nvl(sp.cost,0) < 1000000000000000       THEN ROUND(sp.COST/1000000000000)||'T'
                WHEN nvl(sp.cost,0) >= 1000000000000000    AND nvl(sp.cost,0) < 1000000000000000000    THEN ROUND(sp.COST/1000000000000000)||'P'
                WHEN nvl(sp.cost,0) >= 1000000000000000000 AND nvl(sp.cost,0) < 1000000000000000000000 THEN ROUND(sp.COST/1000000000000000000)||'E'
                END AS COST,
                nvl(sp.CARDINALITY,-0)  AS NUM_CARDINALITY,
                CASE
                WHEN nvl(sp.CARDINALITY,0) < 1000 THEN TO_CHAR(nvl(sp.CARDINALITY,0))
                WHEN nvl(sp.CARDINALITY,0) >= 1000 AND nvl(sp.CARDINALITY,0) < 1000000 THEN ROUND(sp.CARDINALITY/1000)||'K'
                WHEN nvl(sp.CARDINALITY,0) >= 1000000 AND nvl(sp.CARDINALITY,0) < 1000000000 THEN ROUND(sp.CARDINALITY/1000000)||'M'
                WHEN nvl(sp.CARDINALITY,0) >= 1000000000          AND nvl(sp.CARDINALITY,0) < 1000000000000          THEN ROUND(sp.CARDINALITY/1000000000)||'G'
                WHEN nvl(sp.CARDINALITY,0) >= 1000000000000       AND nvl(sp.CARDINALITY,0) < 1000000000000000       THEN ROUND(sp.CARDINALITY/1000000000000)||'T'
                WHEN nvl(sp.CARDINALITY,0) >= 1000000000000000    AND nvl(sp.CARDINALITY,0) < 1000000000000000000    THEN ROUND(sp.CARDINALITY/1000000000000000)||'P'
                WHEN nvl(sp.CARDINALITY,0) >= 1000000000000000000 AND nvl(sp.CARDINALITY,0) < 1000000000000000000000 THEN ROUND(sp.CARDINALITY/1000000000000000000)||'E'
                END AS CARDINALITY,
-----------------------------
                sp.CARDINALITY R_CARDINALITY,
-------------------------------
                NVL(asp.dis, sp.id) AS new_id,
                NVL(asp.par, sp.PARENT_ID) AS new_parent,
                nvl(asp.dep, sp.DEPTH)     AS new_depth,
             -- lpad(' ',nvl(asp.dep,sp.depth)*1,' ')|| sp.operation ||' '|| sp.OPTIONS   ||' '|| sp.object_name
-- sma19c -- 20200514 --
                case when SP.OPERATION ='SORT' AND SP.OPTIONS = 'ORDER BY STOPKEY' then '<RED>'||SP.OPERATION ||' '|| SP.OPTIONS||'</RED>'
                     when SP.OBJECT_OWNER = 'FUSION'  then SP.OPERATION ||' '|| SP.OPTIONS ||' '|| sp.object_name
                     when SP.OBJECT_OWNER <> 'FUSION' then SP.OPERATION ||' '|| SP.OPTIONS ||' '||SP.OBJECT_OWNER||'.'|| sp.object_name
                     when SP.OBJECT_OWNER IS NULL     then SP.OPERATION ||' '|| SP.OPTIONS
                end  AS operation,
---                SP.OPERATION ||' '|| SP.OPTIONS   ||' '||SP.OBJECT_OWNER||'.'|| sp.object_name AS operation,
                ASH.SNAP_COUNT,
                ASH.WAITS_CNT,
                ASH.CPU_CNT,
                SP.ACCESS_PREDICATES,
                SP.FILTER_PREDICATES,
                SP.PROJECTION,
                SP.OTHER_XML
                FROM GV$SQL_PLAN_STATISTICS_ALL SP,
                     -----
                     SP_EXEC_ORDER SEO,
                     -----
                     ACTIVE_SQL_PLAN ASP,
                     ASH
                WHERE SP.INST_ID       = M1.INST_ID
                AND   sp.sql_Id        = M1.SQL_ID
                AND   sp.child_number  = M1.CHILD_NUMBER
                AND   sp.plan_hash_value  = M1.plan_hash_value  -- 20200811
                     -----
                AND   SEO.ID           = SP.ID
                     -----
                AND   SP.INST_ID       = ASH.INST_ID(+)
                AND   sp.sql_Id        = ASH.SQL_ID(+)
                AND   sp.PLAN_HASH_VALUE = ASH.SQL_PLAN_HASH_VALUE(+)
                AND   SP.ID              = ASH.SQL_PLAN_LINE_ID(+)
                AND   NVL(asp.skp,0)   <> 1
                AND sp.id = asp.op(+)
                ORDER BY NVL(asp.dis, sp.id) )
         SELECT 'PLAN' TY, c.id xid, C.*, B.R_output_rows B_R_output_rows, B.R_CARDINALITY B_R_CARDINALITY
--                FROM XPLAN
         FROM XPLAN C, XPLAN B
         WHERE C.OID-1 = B.OID(+)
         UNION all
         SELECT 'PRDC' TY, id xid,  XPLAN.*, 0 B_R_output_row, 0 B_R_CARDINALITY
         FROM XPLAN
         WHERE (ACCESS_PREDICATES IS not null or FILTER_PREDICATES is not null or OTHER_XML is not null or ID = 0)
         order by 1,2  /*20200714*/
                )
      LOOP
      IF( M2.TY = 'PLAN' ) THEN
        IF (M2.OUTPUT_ROWS IS NOT NULL) THEN
          IF ( M2.ID = 0 ) THEN
               DBMS_OUTPUT.PUT_LINE('[NOTE  Dot line(....)=>Expensive operation, P=>CPU, W=>WAITS');
               DBMS_OUTPUT.PUT_LINE('------ ------ ---------- --------- --------- --------------------------------------------------------------');
               DBMS_OUTPUT.PUT_LINE(':   ID    OID       COST ESTM-ROWS ACTL-ROWS ROW SOURCE FROM <blue>MEMORY</blue> (NO OF EXECUTION:'||M1.EXECUTIONS||')');
               DBMS_OUTPUT.PUT_LINE('------ ------ ---------- --------- --------- --------------------------------------------------------------');
          END IF;
          IF ( M2.WAITS_CNT > 0 AND M2.CPU_CNT > 0 ) THEN
              DBMS_OUTPUT.PUT_LINE('<RED>PW'||LPAD('....',4-LENGTH(M2.ID))||M2.ID||'.'
-----
              ||LPAD('....',6-LENGTH(M2.OID))||M2.OID||'.'
-----
              ||LPAD('..........',10-LENGTH(M2.COST))||M2.COST
              ||LPAD('..........',10-LENGTH(M2.CARDINALITY))||M2.CARDINALITY
              ||LPAD('..........',10-LENGTH(M2.OUTPUT_ROWS))||M2.OUTPUT_ROWS||LPAD('.',1)
              ||LPAD('.',M2.new_depth,'.')||M2.OPERATION||'...( WAITS:'||M2.WAITS_CNT||'%, CPU:'||M2.CPU_CNT||'% )</RED>'
              ||'('||M2.B_R_output_rows||' => '||M2.R_output_rows||')' );
              :ISSUE_HEAVY_OPERATION := 1;
          ELSIF ( M2.WAITS_CNT > 0 AND M2.CPU_CNT = 0 ) THEN
              DBMS_OUTPUT.PUT_LINE('<RED>W.'||LPAD('....',4-LENGTH(M2.ID))||M2.ID||'.'
-----
              ||LPAD('....',6-LENGTH(M2.OID))||M2.OID||'.'
-----
              ||LPAD('..........',10-LENGTH(M2.COST))||M2.COST
              ||LPAD('..........',10-LENGTH(M2.CARDINALITY))||M2.CARDINALITY
              ||LPAD('..........',10-LENGTH(M2.OUTPUT_ROWS))||M2.OUTPUT_ROWS||LPAD('.',1)
              ||LPAD('.',M2.new_depth,'.')||M2.OPERATION||'...( WAITS:'||M2.WAITS_CNT||'% )</RED>'
              ||'('||M2.B_R_output_rows||' => '||M2.R_output_rows||')' );
              :ISSUE_HEAVY_OPERATION := 1;
          ELSIF ( M2.WAITS_CNT =0  AND M2.CPU_CNT > 0 ) THEN
              DBMS_OUTPUT.PUT_LINE('<RED>P.'||LPAD('....',4-LENGTH(M2.ID))||M2.ID||'.'
-----
              ||LPAD('....',6-LENGTH(M2.OID))||M2.OID||'.'
-----
              ||LPAD('..........',10-LENGTH(M2.COST))||M2.COST
              ||LPAD('..........',10-LENGTH(M2.CARDINALITY))||M2.CARDINALITY
              ||LPAD('..........',10-LENGTH(M2.OUTPUT_ROWS))||M2.OUTPUT_ROWS||LPAD('.',1)
              ||LPAD('.',M2.new_depth,'.')||M2.OPERATION||'...( CPU:'||M2.CPU_CNT||'% )</RED>'
              ||'('||M2.B_R_output_rows||' => '||M2.R_output_rows||')' );
              :ISSUE_HEAVY_OPERATION := 1;
          ELSE
              DBMS_OUTPUT.PUT_LINE(': '||LPAD('    ',4-LENGTH(M2.ID))||M2.ID||' '
-----
              ||LPAD('    ',6-LENGTH(M2.OID))||M2.OID||' '
-----
              ||LPAD('          ',10-LENGTH(M2.COST))||M2.COST
              ||LPAD('          ',10-LENGTH(M2.CARDINALITY))||M2.CARDINALITY
              ||LPAD('          ',10-LENGTH(M2.OUTPUT_ROWS))||M2.OUTPUT_ROWS||LPAD(' ',1)
              ||LPAD(' ',M2.new_depth,' ')||M2.OPERATION );
          END IF;
        ELSE
          IF ( M2.ID = 0 ) THEN
               DBMS_OUTPUT.PUT_LINE('[NOTE  Dot line(....)=>Expensive operation, P=>CPU, W=>WAITS');
               DBMS_OUTPUT.PUT_LINE('------ ------ ---------- --------- --------------------------------------------------------------');
               DBMS_OUTPUT.PUT_LINE(':   ID    OID       COST ESTM-ROWS ROW SOURCE FROM <blue>MEMORY</blue> (NO OF EXECUTION:'||M1.EXECUTIONS||')');
               DBMS_OUTPUT.PUT_LINE('------ ------ ---------- --------- --------------------------------------------------------------');
          END IF;
          IF ( M2.WAITS_CNT > 0 AND M2.CPU_CNT > 0 ) THEN
              DBMS_OUTPUT.PUT_LINE('<RED>PW'||LPAD('....',4-LENGTH(M2.ID))||M2.ID||'.'
-----
              ||LPAD('....',6-LENGTH(M2.OID))||M2.OID||'.'
-----
              ||LPAD('..........',10-LENGTH(M2.COST))||M2.COST
              ||LPAD('..........',10-LENGTH(M2.CARDINALITY))||M2.CARDINALITY||LPAD('.',1)
              ||LPAD('.',M2.new_depth,'.')||M2.OPERATION||'...( WAITS:'||M2.WAITS_CNT||'%, CPU:'||M2.CPU_CNT||'% )</RED>'
              ||'('||M2.B_R_CARDINALITY||' => '||M2.R_CARDINALITY||')' );
              :ISSUE_HEAVY_OPERATION := 1;
          ELSIF ( M2.WAITS_CNT > 0 AND M2.CPU_CNT = 0 ) THEN
              DBMS_OUTPUT.PUT_LINE('<c1>W '||LPAD('....',4-LENGTH(M2.ID))||M2.ID||'.'
-----
              ||LPAD('....',6-LENGTH(M2.OID))||M2.OID||'.'
-----
              ||LPAD('..........',10-LENGTH(M2.COST))||M2.COST
              ||LPAD('..........',10-LENGTH(M2.CARDINALITY))||M2.CARDINALITY||LPAD('.',1)
              ||LPAD('.',M2.new_depth,'.')||M2.OPERATION||'...( WAITS:'||M2.WAITS_CNT||'% )</RED>'
              ||'('||M2.B_R_CARDINALITY||' => '||M2.R_CARDINALITY||')' );
              :ISSUE_HEAVY_OPERATION := 1;
          ELSIF ( M2.WAITS_CNT =0  AND M2.CPU_CNT > 0 ) THEN
              DBMS_OUTPUT.PUT_LINE('<RED>P '||LPAD('....',4-LENGTH(M2.ID))||M2.ID||'.'
-----
              ||LPAD('....',6-LENGTH(M2.OID))||M2.OID||'.'
-----
              ||LPAD('..........',10-LENGTH(M2.COST))||M2.COST
              ||LPAD('..........',10-LENGTH(M2.CARDINALITY))||M2.CARDINALITY||LPAD('.',1)
              ||LPAD('.',M2.new_depth,'.')||M2.OPERATION||'...( CPU:'||M2.CPU_CNT||'% )</RED>'
              ||'('||M2.B_R_CARDINALITY||' => '||M2.R_CARDINALITY||')' );
              :ISSUE_HEAVY_OPERATION := 1;
          ELSE
              DBMS_OUTPUT.PUT_LINE(': '||LPAD('    ',4-LENGTH(M2.ID))||M2.ID||' '
-----
              ||LPAD('    ',6-LENGTH(M2.OID))||M2.OID||' '
-----
              ||LPAD('          ',10-LENGTH(M2.COST))||M2.COST
              ||LPAD('          ',10-LENGTH(M2.CARDINALITY))||M2.CARDINALITY||LPAD(' ',1)
              ||LPAD(' ',M2.new_depth,' ')||M2.OPERATION);
          END IF;
        END IF;
        IF ( M2.WAITS_CNT > 0 OR M2.CPU_CNT > 0 ) THEN
           :l_as5 := :l_as4;
           :l_as4 := :l_as3;
           :l_as3 := :l_as3;
           :l_as2 := :l_as2;
           :l_as1 :=  M2.ID;
        END IF;
      END IF;
      IF (M2.TY = 'PRDC') THEN
/**/
--- bind information -----------------------
/*
          IF(M2.BINDS_XML IS NOT NULL AND :L_BIND_LOG = 'ON' ) THEN
            :L_WHERE_LOG := 'BIND SECTION';
            FOR I IN (
                     SELECT ROWNUM ROW_NUM, NAME, POS, DTYD, DTYSTR, VALUE
                     FROM (
                      SELECT --+ opt_param('parallel_execution_enabled', 'false')
                           EXTRACTVALUE(VALUE(OXML), '/bind/@name') name,
                           EXTRACTVALUE(VALUE(OXML), '/bind/@pos') pos,
                           EXTRACTVALUE(VALUE(OXML), '/bind/@dty') dtyD,
                           EXTRACTVALUE(VALUE(OXML), '/bind/@dtystr') dtystr,
                           EXTRACTVALUE(VALUE(OXML), '/bind') value
                      FROM TABLE(XMLSEQUENCE(EXTRACT(XMLTYPE(SM.BINDS_XML), '/binds/bind'))) OXML
                      ORDER BY TO_NUMBER(EXTRACTVALUE(VALUE(OXML), '/bind/@pos'))
                      )
                     )
            LOOP
              :L_VALUE_RECOMMEND := null;
              :L_WHERE_LOG := 'BIND SECTION WITHIN LOOP'||I.VALUE;
              IF (I.NAME IS NOT NULL) THEN
                IF (I.ROW_NUM = 1) THEN
                    DBMS_OUTPUT.PUT_LINE('<details>');
                    DBMS_OUTPUT.PUT_LINE('<summary><blue>Bind Information</blue></summary>');
                END IF;
                DBMS_OUTPUT.PUT_LINE(' POSITION=>'||I.POS||' ,NAME=>'||I.NAME||' ,DATA_TYPE('||I.DTYD||')=>'||I.DTYSTR||' ,VALUE=>'||I.VALUE);
              END IF;
              IF( INSTR(I.VALUE,'%') <= 5 and INSTR(I.VALUE,'%') >= 1) THEN :L_VALUE_RECOMMEND := ' => Please use selective bind input'; END IF;
              IF ( :L_VALUE_RECOMMEND IS NOT NULL ) THEN
                DBMS_OUTPUT.PUT_LINE('* Analysis');
              --  DBMS_OUTPUT.PUT_LINE('* The bind variable, '||I.NAME||' was used with "'||I.VALUE||'".');
                DBMS_OUTPUT.PUT_LINE('=>Issue Category: <RED>Blind input or unselective input</RED>');  :issue_blind_input := 1;
                DBMS_OUTPUT.PUT_LINE('=>Suggestion: Use more selective bind input');
              --  DBMS_OUTPUT.PUT_LINE('.');
                :L_VALUE_RECOMMEND := null;
              END IF;
            END LOOP;
            :L_BIND_LOG := 'OFF';
            DBMS_OUTPUT.PUT_LINE('</details>');
          END IF;
*/
--------------------------

             IF (M2.ID = 0) THEN
                DBMS_OUTPUT.PUT_LINE('+');
                DBMS_OUTPUT.PUT_LINE('<details>');
                DBMS_OUTPUT.PUT_LINE('<summary><blue>All Predicates Information</blue></summary>');
                DBMS_OUTPUT.PUT_LINE('Predicates Information (identified by operation id):');
                DBMS_OUTPUT.PUT_LINE('----------------------------------------------------');
             END IF;
             IF ( M2.ID IN ( --:l_co1,  :l_co2,  :l_co3,  :l_co4,  :l_co5,
                             --:l_mo1,  :l_mo2,  :l_mo3,  :l_mo4,  :l_mo5,
                             :l_as1,  :l_as2,  :l_as3,  :l_as4,  :l_as5 ) )
               THEN
                IF (M2.ACCESS_PREDICATES IS NOT NULL) THEN
                   --DBMS_OUTPUT.PUT_LINE('ID: '||M2.ID||'A- '||M2.ACCESS_PREDICATES);
                  IF( instr(substr(M2.access_predicates,100),' ') = 0 ) THEN
                     DBMS_OUTPUT.PUT_LINE(
                     --'<a name="PHVP'||M2.SQL_PLAN_HASH_VALUE||M2.KEY||M2.MO||'"></a>'||
                     '<RED>ID: '||M2.ID||' Access - </RED>'||substr(M2.access_predicates,1,
                     nvl(instr(substr(M2.access_predicates,100),' ')+150-1,150)));
                  ELSE
                     DBMS_OUTPUT.PUT_LINE(
                     --'<a name="PHVP'||M2.SQL_PLAN_HASH_VALUE||M2.KEY||M2.MO||'"></a>'||
                     '<RED>ID: '||M2.ID||' Access - </RED>'||substr(M2.access_predicates,1,
                     nvl(instr(substr(M2.access_predicates,100),' ')+100-1,100)));
                     DBMS_OUTPUT.PUT_LINE(substr(M2.access_predicates,instr(substr(M2.access_predicates,100),' ')+100,
                     nvl(instr(substr(M2.access_predicates,220),' ')+120-0,120)));
                     DBMS_OUTPUT.PUT_LINE(substr(M2.access_predicates,instr(substr(M2.access_predicates,220),' ')+220,
                     nvl(instr(substr(M2.access_predicates,340),' ')+120-1,120)));
                     DBMS_OUTPUT.PUT_LINE(substr(M2.access_predicates,instr(substr(M2.access_predicates,340),' ')+340,
                     nvl(instr(substr(M2.access_predicates,460),' ')+120-0,120)));
                  END IF;
                END IF;
                IF (M2.FILTER_PREDICATES IS NOT NULL) THEN
                   --DBMS_OUTPUT.PUT_LINE('ID: '||M2.ID||'F- '||M2.FILTER_PREDICATES);
                  IF( instr(substr(M2.filter_predicates,100),' ') = 0 ) THEN
                     DBMS_OUTPUT.PUT_LINE(
                     --'<a name="PHVP'||M2.SQL_PLAN_HASH_VALUE||M2.KEY||M2.MO||'"></a>'||
                     '<RED>ID: '||M2.ID||' Access - </RED>'||substr(M2.filter_predicates,1,
                     nvl(instr(substr(M2.filter_predicates,100),' ')+150-1,150)));
                  ELSE
                     DBMS_OUTPUT.PUT_LINE(
                     --'<a name="PHVP'||M2.SQL_PLAN_HASH_VALUE||M2.KEY||M2.MO||'"></a>'||
                     '<RED>ID: '||M2.ID||' Filter - </RED>'||substr(M2.filter_predicates,1,
                     nvl(instr(substr(M2.filter_predicates,100),' ')+100-1,100)));
                     DBMS_OUTPUT.PUT_LINE(substr(M2.filter_predicates,instr(substr(M2.filter_predicates,100),' ')+100,
                     nvl(instr(substr(M2.filter_predicates,220),' ')+120-0,120)));
                     DBMS_OUTPUT.PUT_LINE(substr(M2.filter_predicates,instr(substr(M2.filter_predicates,220),' ')+220,
                     nvl(instr(substr(M2.filter_predicates,340),' ')+120-1,120)));
                     DBMS_OUTPUT.PUT_LINE(substr(M2.filter_predicates,instr(substr(M2.filter_predicates,340),' ')+340,
                     nvl(instr(substr(M2.filter_predicates,460),' ')+120-0,120)));
                  END IF;
                END IF;
             ELSE
                IF (M2.ACCESS_PREDICATES IS NOT NULL) THEN
                   --DBMS_OUTPUT.PUT_LINE('ID: '||M2.ID||'A- '||M2.ACCESS_PREDICATES);
                  IF( instr(substr(M2.access_predicates,100),' ') = 0 ) THEN
                     DBMS_OUTPUT.PUT_LINE(
                     'ID: '||M2.ID||' Access - '||substr(M2.access_predicates,1,
                     nvl(instr(substr(M2.access_predicates,100),' ')+150-1,150)));
                  ELSE
                     DBMS_OUTPUT.PUT_LINE(
                     'ID: '||M2.ID||' Access - '||substr(M2.access_predicates,1,
                     nvl(instr(substr(M2.access_predicates,100),' ')+100-1,100)));
                     DBMS_OUTPUT.PUT_LINE(substr(M2.access_predicates,instr(substr(M2.access_predicates,100),' ')+100,
                     nvl(instr(substr(M2.access_predicates,220),' ')+120-0,120)));
                     DBMS_OUTPUT.PUT_LINE(substr(M2.access_predicates,instr(substr(M2.access_predicates,220),' ')+220,
                     nvl(instr(substr(M2.access_predicates,340),' ')+120-1,120)));
                     DBMS_OUTPUT.PUT_LINE(substr(M2.access_predicates,instr(substr(M2.access_predicates,340),' ')+340,
                     nvl(instr(substr(M2.access_predicates,460),' ')+120-0,120)));
                  END IF;
                END IF;
                IF (M2.FILTER_PREDICATES IS NOT NULL) THEN
                   --DBMS_OUTPUT.PUT_LINE('ID: '||M2.ID||'F- '||M2.FILTER_PREDICATES);
                  IF( instr(substr(M2.filter_predicates,100),' ') = 0 ) THEN
                     DBMS_OUTPUT.PUT_LINE(
                     'ID: '||M2.ID||' Access - '||substr(M2.filter_predicates,1,
                     nvl(instr(substr(M2.filter_predicates,100),' ')+150-1,150)));
                  ELSE
                     DBMS_OUTPUT.PUT_LINE(
                     'ID: '||M2.ID||' Filter - '||substr(M2.filter_predicates,1,
                     nvl(instr(substr(M2.filter_predicates,100),' ')+100-1,100)));
                     DBMS_OUTPUT.PUT_LINE(substr(M2.filter_predicates,instr(substr(M2.filter_predicates,100),' ')+100,
                     nvl(instr(substr(M2.filter_predicates,220),' ')+120-0,120)));
                     DBMS_OUTPUT.PUT_LINE(substr(M2.filter_predicates,instr(substr(M2.filter_predicates,220),' ')+220,
                     nvl(instr(substr(M2.filter_predicates,340),' ')+120-1,120)));
                     DBMS_OUTPUT.PUT_LINE(substr(M2.filter_predicates,instr(substr(M2.filter_predicates,340),' ')+340,
                     nvl(instr(substr(M2.filter_predicates,460),' ')+120-0,120)));
                  END IF;
                END IF;
             END IF;
/**/
      END IF;
      END LOOP;
      DBMS_OUTPUT.PUT_LINE('</details>');
              :L_AS5 := 0 ;   --20200811
              :L_AS4 := 0 ;
              :L_AS3 := 0 ;
              :L_AS2 := 0 ;
              :L_AS1 := 0 ;
  --    DBMS_OUTPUT.PUT_LINE('</pre><a href="#PHV_ANALYSIS">Back to PHV level Analysis</a><pre>');
  --    DBMS_OUTPUT.PUT_LINE('</pre><a href="#top">Back to top</a><pre>');
  --    DBMS_OUTPUT.PUT_LINE('</DETAILS>');  -- 20200811
   END LOOP;
   DBMS_OUTPUT.PUT_LINE('</DETAILS>');
 END IF;
 EXCEPTION  WHEN OTHERS THEN
 DBMS_OUTPUT.PUT_LINE('ERROR ON XPLAN: '||SQLERRM||' => where '||:L_WHERE_LOG);
 :L_OTHER_XML := NULL;
 DBMS_OUTPUT.PUT_LINE('</DETAILS>');
END ;
/
--20200811
--spool off sma_log.txt


--prompt </details>

--prompt <details>
--prompt <summary><blue>AWR SQL PLAN BY SMA</BLUE></SUMMARY>


--IF ( :SQL_FROM_SPM = 0 and :SQL_FROM_MEM = 0 and  :SQL_FROM_AWR = 1 )
BEGIN

 IF ( :SQL_FROM_AWR = 1 ) THEN   --  20200811  DATA is only available in AWR.
-- IF (:SQL_FROM_SPM = 0 and :SQL_FROM_MEM = 0 and :SQL_FROM_AWR_SPM = 0 and  :SQL_FROM_AWR = 1 ) THEN   --  DATA is only available in AWR.


              :L_AS5 := 0 ;   --20200811
              :L_AS4 := 0 ;
              :L_AS3 := 0 ;
              :L_AS2 := 0 ;
              :L_AS1 := 0 ;

 :L_WHERE_LOG := 'AWRPLAN';
 :L_PLAN_HASH_VALUE1 := 0;
 :L_PLAN_HASH_VALUE2 := 0;
 :L_PLAN_HASH_VALUE  := 0;
 :L_PX := 0;

      DBMS_OUTPUT.PUT_LINE('<details>');
      DBMS_OUTPUT.PUT_LINE('<summary><blue>AWR SQL PLAN BY SMA</BLUE></SUMMARY>');


   FOR M1 IN (SELECT QRK.*, ROWNUM RN  FROM
              (SELECT DBID, INSTANCE_NUMBER, SQL_ID, PLAN_HASH_VALUE, SQL_PROFILE,
                     ROUND(SUM(ELAPSED_TIME_DELTA)/SUM(GREATEST(EXECUTIONS_DELTA, 1))/1000000,3) ELAPSED_TIME,
                     ROUND(SUM(CPU_TIME_DELTA)/SUM(GREATEST(EXECUTIONS_DELTA, 1))/1000000,3) CPU_TIME,
                     ROUND(SUM(BUFFER_GETS_DELTA)/SUM(GREATEST(EXECUTIONS_DELTA, 1)),0) AVG_BUFFER_GETS,
                     ROUND(SUM(DISK_READS_DELTA)/SUM(GREATEST(EXECUTIONS_DELTA, 1)),0) AVG_DISK_READS,
                     ROUND(SUM(ROWS_PROCESSED_DELTA)/SUM(GREATEST(EXECUTIONS_DELTA, 1)),0) AVG_ROWS_PROCESSED,
                     MIN(SNAP_ID) MIN_SNAP_ID,  MAX(SNAP_ID) MAX_SNAP_ID,
                     SUM(GREATEST(EXECUTIONS_DELTA, 1)) EXECUTIONS,
                     max(PX_SERVERS_EXECS_DELTA) PX,
                     MIN(MODULE) MIN_MODULE, MAX(MODULE) MAX_MODULE, COUNT(DISTINCT MODULE) NDM
               FROM   DBA_HIST_SQLSTAT
               WHERE  SQL_ID = :L_SQL_ID
               AND    DBID = :L_DBID
--20210303
               AND PLAN_HASH_VALUE IN (:L_CURRENT_BEST,:L_CURRENT_BEST1,:L_CURRENT_WORST1)
               AND   SNAP_ID BETWEEN :L_SNAP_ID - 720 AND :L_SNAP_ID
               --AND    EXECUTIONS_DELTA  > 0
               GROUP BY  DBID, INSTANCE_NUMBER, SQL_ID, PLAN_HASH_VALUE, SQL_PROFILE
               ORDER BY 6 ) QRK
              WHERE ROWNUM <= 3 )
   LOOP
      DBMS_OUTPUT.PUT_LINE('.');
      DBMS_OUTPUT.PUT_LINE('<a name="PHV'||M1.PLAN_HASH_VALUE||'"></a>'||'[PLAN HASH VALUE: '||M1.PLAN_HASH_VALUE||']');
      DBMS_OUTPUT.PUT_LINE('*******************************************');
      :L_INST_ID := M1.INSTANCE_NUMBER ;
      :L_SQL_ID  := M1.SQL_ID;
      :L_PLAN_HASH_VALUE  := M1.PLAN_HASH_VALUE;
      :L_PX := M1.PX;
/*v3*/IF (M1.RN <= 2 ) THEN
         :L_PLAN_HASH_VALUE2 := :L_PLAN_HASH_VALUE1;
         :L_PLAN_HASH_VALUE1  := M1.PLAN_HASH_VALUE;
      END IF;
      :L_SNAP_ID := M1.max_SNAP_ID;
--      DBMS_OUTPUT.PUT_LINE('PLAN_HASH_VALUE:'||M1.PLAN_HASH_VALUE||', ELAPSED_TIME:'||M1.ELAPSED_TIME||'secs, CPU_TIME:'||M1.CPU_TIME||'secs');
      DBMS_OUTPUT.PUT_LINE('.');
      DBMS_OUTPUT.PUT_LINE('ELAPSED_TIME: '||M1.ELAPSED_TIME||'secs, CPU_TIME: '||M1.CPU_TIME||'secs, PX_SERVERS_EXECS: '||M1.PX||', INSTANCE_NUMBER: '||M1.INSTANCE_NUMBER);
      DBMS_OUTPUT.PUT_LINE('AVG_BUFFER_GETS: '||M1.AVG_BUFFER_GETS||', AVG_DISK_READS: '||M1.AVG_DISK_READS||', AVG_ROWS_PROCESSED: '||M1.AVG_ROWS_PROCESSED);
      DBMS_OUTPUT.PUT_LINE('MODULE(NDM: '||M1.NDM||'): '||M1.MIN_MODULE||' - '||M1.MAX_MODULE);
      DBMS_OUTPUT.PUT_LINE('EXECUTIONS: '||M1.EXECUTIONS||' from SNAP_ID '||M1.MIN_SNAP_ID||' to SNAP_ID '||M1.MAX_SNAP_ID);
      IF (M1.SQL_PROFILE IS NOT NULL) THEN DBMS_OUTPUT.PUT_LINE('SQL_PROFILE: '||M1.SQL_PROFILE); END IF;
      DBMS_OUTPUT.PUT_LINE('.');
      FOR M2 IN (
                 WITH ACTIVE_SQL_PLAN AS
                (SELECT /*+ no_parallel opt_param('parallel_execution_enabled', 'false') */ XPLAN.*
                 FROM DBA_HIST_SQL_PLAN M2,
                     XMLTABLE ( '/other_xml/display_map/row' passing XMLTYPE(M2.OTHER_XML) COLUMNS
                     op  NUMBER PATH '@op',    -- operation
                     dis NUMBER PATH '@dis',   -- display
                     par NUMBER PATH '@par',   -- parent
                     dep NUMBER PATH '@dep',   -- depth
                     skp NUMBER PATH '@skp' )  -- skip
                     AS XPLAN
                 WHERE M2.DBID            = M1.DBID
                 --AND   M2.INSTANCE_NUMBER = M1.INSTANCE_NUMBER
                 --AND   M2.SNAP_ID         = M1.SNAP_ID
                 AND   M2.SQL_ID          = M1.SQL_ID
                 AND   M2.PLAN_HASH_VALUE = M1.PLAN_HASH_VALUE
                 AND   M2.OTHER_XML IS NOT NULL
                ),
                ASH AS (
                    (SELECT DBID, INSTANCE_NUMBER, SQL_ID, SQL_PLAN_HASH_VALUE, SQL_PLAN_LINE_ID,
                     --EVENT, CURRENT_OBJ#,
                     ROUND(WAITS_CNT/TSNAP_COUNT*100,2) WAITS_CNT,
                     ROUND(CPU_CNT/TSNAP_COUNT*100,2)   CPU_CNT,
                     SNAP_COUNT, SESSION_COUNT, BLOCKING_SESSION_COUNT
                     FROM
                         (SELECT COUNT(*) TSNAP_COUNT
                          FROM DBA_HIST_ACTIVE_SESS_HISTORY ASH
                          WHERE ASH.DBID   = M1.DBID
                          AND   ASH.INSTANCE_NUMBER = M1.INSTANCE_NUMBER
                          AND   ASH.SQL_ID  = M1.SQL_ID
                          AND   ASH.SQL_PLAN_HASH_VALUE = M1.PLAN_HASH_VALUE
                          --2020922
                          AND   ASH.SNAP_ID BETWEEN :L_SNAP_ID - 720 AND :L_SNAP_ID
                          ),
                         (SELECT ASH.DBID, ASH.INSTANCE_NUMBER, ASH.SQL_ID, ASH.SQL_PLAN_HASH_VALUE, ASH.SQL_PLAN_LINE_ID,
                          -- NVL(ASH.EVENT, ASH.SESSION_STATE) EVENT, ASH.CURRENT_OBJ# ,
                          COUNT(ASH.EVENT)         WAITS_CNT,
                          COUNT(ASH.SESSION_STATE) CPU_CNT,
                          COUNT(*) SNAP_COUNT, COUNT(DISTINCT ASH.SESSION_ID) SESSION_COUNT,
                          COUNT(DISTINCT ASH.BLOCKING_SESSION) BLOCKING_SESSION_COUNT
                          FROM DBA_HIST_ACTIVE_SESS_HISTORY ASH
                          WHERE ASH.DBID   = M1.DBID
                          AND   ASH.INSTANCE_NUMBER = M1.INSTANCE_NUMBER
                          AND   ASH.SQL_ID  = M1.SQL_ID
                          AND   ASH.SQL_PLAN_HASH_VALUE = M1.PLAN_HASH_VALUE
                          --2020922
                          AND   ASH.SNAP_ID BETWEEN :L_SNAP_ID - 720 AND :L_SNAP_ID
                        -- AND  ASH.SNAP_ID  = M1.SNAP_ID   -- AS RARELY DETECHED, REMOVE SNAP_ID CONDITION.
                         -- AND   ASH.SESSION_ID      = SM.SID             -- NOT MANY ROWS --
                         -- AND   ASH.SESSION_SERIAL# = SM.SESSION_SERIAL# -- NOT MANY ROWS --
                          --AND   ASH.EVENT IS NOT NULL                      -- PICK ONLY WAITS except CPU --
                          GROUP BY ASH.DBID, ASH.INSTANCE_NUMBER, ASH.SQL_ID,
                          --ASH.SESSION_ID,
                          ASH.SQL_PLAN_HASH_VALUE, ASH.SQL_PLAN_LINE_ID
                          --,NVL(ASH.EVENT, ASH.SESSION_STATE), ASH.CURRENT_OBJ#
                          ORDER BY  COUNT(ASH.EVENT)+COUNT(ASH.SESSION_STATE) DESC )
                     WHERE ROWNUM < 6
--20180520
                     AND ( ROUND(WAITS_CNT/TSNAP_COUNT*100,2) > 19.9
                        OR ROUND(CPU_CNT/TSNAP_COUNT*100,2)   > 19.9 )
                     AND   SNAP_COUNT > 1 )
                ),
--20200714
                SP_EXEC_ORDER AS (
                SELECT ID,
                       PARENT_ID AS PID
                ,      ROW_NUMBER() OVER (ORDER BY ROWNUM DESC) AS OID
                --,    MAX(ID) OVER () AS MAXID
                FROM   (
                       SELECT  ID, PARENT_ID
                       FROM   (SELECT  ID, PARENT_ID
                               FROM    DBA_HIST_SQL_PLAN SPS
                               WHERE   SPS.DBID            = :L_DBID
                               --AND     SPS.INSTANCE_NUMBER = M1.INSTANCE_NUMBER
                               AND     SPS.SQL_ID          = M1.SQL_ID
                               AND     SPS.PLAN_HASH_VALUE = M1.PLAN_HASH_VALUE)
                       START   WITH ID = 0
                       CONNECT BY PRIOR ID = PARENT_ID
                       ORDER   SIBLINGS BY ID DESC )
                ),
                AWRPLAN AS (
                SELECT PLAN.*, rownum-1 AS EXPLAIN_ID FROM (
                SELECT
                sp.id           AS id,
/*20200714*/    -----
                SEO.OID         AS OID,
                SP.CARDINALITY  AS R_CARDINALITY,
                -----
/*v3*/          nvl(sp.cost,0)  AS NUM_cost,
                CASE
                WHEN nvl(sp.cost,0) < 1000 THEN TO_CHAR(nvl(sp.cost,0))
                WHEN nvl(sp.cost,0) >= 1000                AND nvl(sp.cost,0) < 1000000                THEN ROUND(sp.COST/1000)||'K'
                WHEN nvl(sp.cost,0) >= 1000000             AND nvl(sp.cost,0) < 1000000000             THEN ROUND(sp.COST/1000000)||'M'
                WHEN nvl(sp.cost,0) >= 1000000000          AND nvl(sp.cost,0) < 1000000000000          THEN ROUND(sp.COST/1000000000)||'G'
                WHEN nvl(sp.cost,0) >= 1000000000000       AND nvl(sp.cost,0) < 1000000000000000       THEN ROUND(sp.COST/1000000000000)||'T'
                WHEN nvl(sp.cost,0) >= 1000000000000000    AND nvl(sp.cost,0) < 1000000000000000000    THEN ROUND(sp.COST/1000000000000000)||'P'
                WHEN nvl(sp.cost,0) >= 1000000000000000000 AND nvl(sp.cost,0) < 1000000000000000000000 THEN ROUND(sp.COST/1000000000000000000)||'E'
                END AS COST,
                nvl(sp.CARDINALITY,-0)  AS NUM_CARDINALITY,
                CASE
                WHEN nvl(sp.CARDINALITY,0) < 1000 THEN TO_CHAR(nvl(sp.CARDINALITY,0))
                WHEN nvl(sp.CARDINALITY,0) >= 1000 AND nvl(sp.CARDINALITY,0) < 1000000 THEN ROUND(sp.CARDINALITY/1000)||'K'
                WHEN nvl(sp.CARDINALITY,0) >= 1000000 AND nvl(sp.CARDINALITY,0) < 1000000000 THEN ROUND(sp.CARDINALITY/1000000)||'M'
                WHEN nvl(sp.CARDINALITY,0) >= 1000000000          AND nvl(sp.CARDINALITY,0) < 1000000000000          THEN ROUND(sp.CARDINALITY/1000000000)||'G'
                WHEN nvl(sp.CARDINALITY,0) >= 1000000000000       AND nvl(sp.CARDINALITY,0) < 1000000000000000       THEN ROUND(sp.CARDINALITY/1000000000000)||'T'
                WHEN nvl(sp.CARDINALITY,0) >= 1000000000000000    AND nvl(sp.CARDINALITY,0) < 1000000000000000000    THEN ROUND(sp.CARDINALITY/1000000000000000)||'P'
                WHEN nvl(sp.CARDINALITY,0) >= 1000000000000000000 AND nvl(sp.CARDINALITY,0) < 1000000000000000000000 THEN ROUND(sp.CARDINALITY/1000000000000000000)||'E'
                END AS CARDINALITY,
--
                NVL(asp.dis, sp.id) AS new_id,
                NVL(asp.par, sp.PARENT_ID) AS new_parent,
                nvl(asp.dep, sp.DEPTH)     AS new_depth,
             -- lpad(' ',nvl(asp.dep,sp.depth)*1,' ')|| sp.operation ||' '|| sp.OPTIONS   ||' '|| sp.object_name
-- sma19c -- 20200514 --
                case when SP.OPERATION ='SORT' AND SP.OPTIONS = 'ORDER BY STOPKEY' then '<RED>'||SP.OPERATION ||' '|| SP.OPTIONS||'</RED>'
                     when SP.OBJECT_OWNER = 'FUSION'  then SP.OPERATION ||' '|| SP.OPTIONS ||' '|| sp.object_name
                     when SP.OBJECT_OWNER <> 'FUSION' then SP.OPERATION ||' '|| SP.OPTIONS ||' '||SP.OBJECT_OWNER||'.'|| sp.object_name
                     when SP.OBJECT_OWNER IS NULL     then SP.OPERATION ||' '|| SP.OPTIONS
                end  AS operation,
--                sp.operation ||' '|| sp.OPTIONS   ||' '||sp.object_owner||'.'||sp.object_name AS operation,
                ASH.SNAP_COUNT,
                ASH.WAITS_CNT,
                ASH.CPU_CNT
                FROM DBA_HIST_SQL_PLAN SP,
                     ACTIVE_SQL_PLAN ASP,
                     ASH,
                     SP_EXEC_ORDER   SEO
                WHERE SEO.ID = SP.ID
                AND   SP.DBID            = M1.DBID
                --AND   SP.INSTANCE_NUMBER = M1.INSTANCE_NUMBER
                AND   SP.SQL_ID          = M1.SQL_ID
                AND   sp.plan_hash_value = M1.plan_hash_value
                AND   SP.DBID            = ASH.DBID(+)
                --AND   SP.INSTANCE_NUMBER = ASH.INSTANCE_NUMBER(+)
                AND   sp.sql_Id          = ASH.SQL_ID(+)
                AND   sp.PLAN_HASH_VALUE = ASH.SQL_PLAN_HASH_VALUE(+)
                AND   SP.ID              = ASH.SQL_PLAN_LINE_ID(+)
                AND   NVL(asp.skp,0)   <> 1
                AND   sp.id = asp.op(+)
                ORDER BY NVL(asp.dis, sp.id) ) PLAN )
/*20200714*/    SELECT 'AWRPLAN' TY, C.*, B.R_CARDINALITY B_R_CARDINALITY
                FROM AWRPLAN C, AWRPLAN B
                WHERE C.OID-1 = B.OID(+)
                ORDER BY C.ID
            )
      LOOP
          IF ( M2.ID = 0 ) THEN
               DBMS_OUTPUT.PUT_LINE('[NOTE EXPI=>EXPLAIN_ID, Dot line(....)=>Expensive operation, P=>CPU, W=>WAITS');
               DBMS_OUTPUT.PUT_LINE('------ ----- ----- ---------- --------- --------------------------------------------------------------');
               DBMS_OUTPUT.PUT_LINE(':   ID  EXPI   OID       COST ESTM-ROWS ROW SOURCE FROM <blue>AWR</blue> (NO OF EXECUTIONS:'||M1.EXECUTIONS||')');
               DBMS_OUTPUT.PUT_LINE('------ ----- ----- ---------- --------- --------------------------------------------------------------');
          END IF;
          IF ( M2.WAITS_CNT > 0 AND M2.CPU_CNT > 0 ) THEN
              DBMS_OUTPUT.PUT_LINE('<RED>PW'
              ||LPAD('....',4-LENGTH(M2.ID))||M2.ID||'.'
              ||LPAD('....',5-LENGTH(M2.EXPLAIN_ID))||M2.EXPLAIN_ID||'.'
              ||LPAD('....',5-LENGTH(M2.OID))||M2.OID||'.'
              ||LPAD('..........',10-LENGTH(M2.COST))||M2.COST
              ||LPAD('..........',10-LENGTH(M2.CARDINALITY))||M2.CARDINALITY||LPAD('.',1)
              ||LPAD('.',M2.new_depth,'.')||M2.OPERATION||'...( WAITS:'||M2.WAITS_CNT||'%, CPU:'||M2.CPU_CNT||'% )</RED>'
/*20200714*/  ||'('||M2.B_R_CARDINALITY||' => '||M2.R_CARDINALITY||')' );
              :ISSUE_HEAVY_OPERATION := 1;
          ELSIF ( M2.WAITS_CNT > 0 AND M2.CPU_CNT = 0 ) THEN
              DBMS_OUTPUT.PUT_LINE('<RED>W '||LPAD('....',4-LENGTH(M2.ID))||M2.ID||'.'
              ||LPAD('....',5-LENGTH(M2.EXPLAIN_ID))||M2.EXPLAIN_ID||'.'
              ||LPAD('....',5-LENGTH(M2.OID))||M2.OID||'.'
              ||LPAD('..........',10-LENGTH(M2.COST))||M2.COST
              ||LPAD('..........',10-LENGTH(M2.CARDINALITY))||M2.CARDINALITY||LPAD('.',1)
              ||LPAD('.',M2.new_depth,'.')||M2.OPERATION||'...( WAITS:'||M2.WAITS_CNT||'% )</RED>'
/*20200714*/  ||'('||M2.B_R_CARDINALITY||' => '||M2.R_CARDINALITY||')' );
              :ISSUE_HEAVY_OPERATION := 1;
          ELSIF ( M2.WAITS_CNT =0  AND M2.CPU_CNT > 0 ) THEN
              DBMS_OUTPUT.PUT_LINE('<RED>P '||LPAD('....',4-LENGTH(M2.ID))||M2.ID||'.'
              ||LPAD('....',5-LENGTH(M2.EXPLAIN_ID))||M2.EXPLAIN_ID||'.'
              ||LPAD('....',5-LENGTH(M2.OID))||M2.OID||'.'
              ||LPAD('..........',10-LENGTH(M2.COST))||M2.COST
              ||LPAD('..........',10-LENGTH(M2.CARDINALITY))||M2.CARDINALITY||LPAD('.',1)
              ||LPAD('.',M2.new_depth,'.')||M2.OPERATION||'...( CPU:'||M2.CPU_CNT||'% )</RED>'
/*20200714*/  ||'('||M2.B_R_CARDINALITY||' => '||M2.R_CARDINALITY||')' );
              :ISSUE_HEAVY_OPERATION := 1;
          ELSE
              DBMS_OUTPUT.PUT_LINE(': '||LPAD('    ',4-LENGTH(M2.ID))||M2.ID||' '
              ||LPAD('    ',5-LENGTH(M2.EXPLAIN_ID))||M2.EXPLAIN_ID||' '
              ||LPAD('    ',5-LENGTH(M2.OID))||M2.OID||' '
              ||LPAD('          ',10-LENGTH(M2.COST))||M2.COST
              ||LPAD('          ',10-LENGTH(M2.CARDINALITY))||M2.CARDINALITY||LPAD(' ',1)
              ||LPAD(' ',M2.new_depth,' ')||M2.OPERATION );
          END IF;
          IF ( M2.WAITS_CNT > 0 OR M2.CPU_CNT > 0 ) THEN
              :L_AS5 := :L_AS4 ;
              :L_AS4 := :L_AS3 ;
              :L_AS3 := :L_AS2 ;
              :L_AS2 := :L_AS1 ;
              :L_AS1 := M2.EXPLAIN_ID ;
          END IF;

      END LOOP;
              :L_AS5 := 0 ;   --20200811
              :L_AS4 := 0 ;
              :L_AS3 := 0 ;
              :L_AS2 := 0 ;
              :L_AS1 := 0 ;
--v3
--      DBMS_OUTPUT.PUT_LINE('</DETAILS>');
--      DBMS_OUTPUT.PUT_LINE('</pre><a href="#PHV_ANALYSIS">Back to PHV level Analysis</a><pre>');
--      DBMS_OUTPUT.PUT_LINE('</pre><a href="#top">Back to top</a><pre>');
   END LOOP;
   DBMS_OUTPUT.PUT_LINE('</details>');
 END IF;
 EXCEPTION  WHEN OTHERS THEN
 DBMS_OUTPUT.PUT_LINE('ERROR ON AWRPLAN: '||SQLERRM||' => where '||:L_WHERE_LOG); :L_OTHER_XML := NULL;
 DBMS_OUTPUT.PUT_LINE('</details>');
END ;
/
--prompt </DETAILS>

set long 1000000 lines 500
PRO
pro </pre><a name="APPENDIX"></a><h2>Appendix/Supporting details</h2><pre>
BEGIN
IF (:SQL_FROM_MEM = 1 AND :L_PLAN_PRINT = 'S') THEN
    DBMS_OUTPUT.PUT_LINE('<H3>* SQLTUNE ADVISOR</H3>');
END IF;
END;
/

var L_SQLTUNE_Advisor_Start varchar2(50)

begin
  IF ( :SQL_FROM_MEM = 1 AND :L_PLAN_PRINT = 'S' ) THEN
    SELECT  to_char(systimestamp, 'YYYY-MM-DD HH24:MI:SS:FF') into :L_SQLTUNE_Advisor_Start FROM DUAL
    where :SQL_FROM_MEM = 1 AND :L_PLAN_PRINT = 'S';
  end if;
end ;
/
DECLARE
 ret_val VARCHAR2(4000);
BEGIN
--  IF ( :SQL_FROM_SPM = 1 OR :SQL_FROM_AWR = 1 OR :SQL_FROM_MEM = 1 ) THEN
  IF ( :SQL_FROM_MEM = 1 AND :L_PLAN_PRINT = 'S' ) THEN
    ret_val := dbms_sqltune.create_tuning_task(task_name=> :L_SQL_ID||substr(:L_SMASTART,14,10), sql_id=>:L_SQL_ID);
--    ret_val := dbms_sqltune.create_tuning_task(task_name=> &&files_prefix, sql_id=>:L_SQL_ID);
    dbms_sqltune.execute_tuning_task(:L_SQL_ID||substr(:L_SMASTART,14,10));
--    dbms_sqltune.execute_tuning_task(&&files_prefix);
  END IF ;
END;
/
col RTT format a499
select REPLACE(REPLACE(REPLACE(RTT,'Recommendation','<blue>Recommendation</blue>'),
                                   'create index','<RED>create index</RED>'),
                                   'Hint Report','<blue>Hint Report</blue>')  RTT    /*v3 for 19c */
FROM (
 SELECT dbms_sqltune.report_tuning_task(:L_SQL_ID||substr(:L_SMASTART,14,10)) RTT
-- SELECT dbms_sqltune.report_tuning_task(&&files_prefix) RTT
 FROM dual
 WHERE :SQL_FROM_MEM = 1 AND :L_PLAN_PRINT = 'S' )
/
select '<blue>Note. In case the SQLTUNE advisor suggests the index creation, the index should be reviewed with PSR DB team.</blue>'
FROM dual
WHERE :SQL_FROM_MEM = 1 AND :L_PLAN_PRINT = 'S'
UNION ALL
SELECT ''
FROM dual
WHERE :SQL_FROM_MEM = 1 AND :L_PLAN_PRINT = 'S'
/

BEGIN
  IF ( :SQL_FROM_MEM = 1 AND :L_PLAN_PRINT = 'S' ) THEN
      dbms_sqltune.drop_tuning_task(:L_SQL_ID||substr(:L_SMASTART,14,10));
--      dbms_sqltune.drop_tuning_task(&&files_prefix);
  END IF ;
END;
/
SELECT 'SQLTUNE ADVISOR Start: '||to_timestamp(:L_SQLTUNE_Advisor_Start, 'YYYY-MM-DD HH24:MI:SS:FF')
from dual WHERE :SQL_FROM_MEM = 1 AND :L_PLAN_PRINT = 'S';

SELECT 'SQLTUNE Advisor End  : ' || to_timestamp(to_char(systimestamp, 'YYYY-MM-DD HH24:MI:SS:FF'), 'YYYY-MM-DD HH24:MI:SS:FF') from dual
WHERE :SQL_FROM_MEM = 1 AND :L_PLAN_PRINT = 'S';

SELECT 'SQLTUNE Advisor Time : ' || (to_timestamp(to_char(systimestamp, 'YYYY-MM-DD HH24:MI:SS:FF'), 'YYYY-MM-DD HH24:MI:SS:FF')
- to_timestamp(:L_SQLTUNE_Advisor_Start, 'YYYY-MM-DD HH24:MI:SS:FF')) as sqlhc_runtime from dual
WHERE :SQL_FROM_MEM = 1 AND :L_PLAN_PRINT = 'S';

BEGIN
  IF ( :SQL_FROM_MEM = 1 AND :L_PLAN_PRINT = 'S' ) THEN
      DBMS_OUTPUT.PUT_LINE('</pre><a href="#APPENDIX">Back to Appendix/Supporting details</a><pre>');
      DBMS_OUTPUT.PUT_LINE('</pre><a href="#top">Back to top</a><pre>');
  END IF ;
END;
/

spool off

--rem sma AND sqlhc
--20200705 start
--SPOOL sma_&&files_prefix..sql2;

-- rem sma_summary_&&files_prefix..html moved the end of sma.. 20200708.
--
-- v3 1st explain start

--SET ECHO OFF;
--SET FEED OFF LIN 2000 TRIMS ON TIM OFF SERVEROUT ON FOR WOR;

alter session set current_schema = FUSION ;

begin
   if ( :L_PLAN_HASH_VALUE2 is null  or  :L_PLAN_HASH_VALUE2 = 0) then
     :L_PLAN_HASH_VALUE2 := :L_PLAN_HASH_VALUE;
   end if;
end;
/

VAR L_FIRST_SQL_TEXT VARCHAR2(100);
begin
SELECT '/**/ '||regexp_substr(:sql_text,'(select |insert |update |delete |merge)',1,1,'i')
INTO :L_FIRST_SQL_TEXT
FROM DUAL;
end;
/

SPOOL sma_exp_&&files_prefix..sql
--SPOOL sma_explain_&&files_prefix..sql

prompt DELETE PLAN_TABLE WHERE  statement_id = 'SMA'
prompt /
prompt commit
prompt /

WITH DRV AS (
SELECT ROWNUM RN, PLAN_TABLE_OUTPUT FROM TABLE(DBMS_XPLAN.DISPLAY_AWR( :L_SQL_ID,:L_PLAN_HASH_VALUE2,:L_DBID,FORMAT=> 'advanced'))
WHERE :SQL_FROM_MEM = 0 AND (:SQL_FROM_AWR = 1 OR :SQL_FROM_SPM = 1) AND :L_PLAN_HASH_VALUE2 <> 0
),
SQL_START AS (
SELECT RN, PLAN_TABLE_OUTPUT
FROM DRV
WHERE PLAN_TABLE_OUTPUT LIKE 'SQL_ID%' ),
SQL_END AS (
SELECT RN, PLAN_TABLE_OUTPUT
FROM DRV
WHERE PLAN_TABLE_OUTPUT LIKE 'Plan hash value%' ),
OUTLINE_START AS (
SELECT RN, PLAN_TABLE_OUTPUT
FROM DRV
WHERE PLAN_TABLE_OUTPUT LIKE '%BEGIN_OUTLINE_DATA%' ),
OUTLINE_END AS (
SELECT RN, PLAN_TABLE_OUTPUT
FROM DRV
WHERE PLAN_TABLE_OUTPUT LIKE '%END_OUTLINE_DATA%' )
SELECT 'explain plan set statement_id = ''SMA'' into plan_TABLE for' FROM DUAL
UNION ALL
SELECT :L_FIRST_SQL_TEXT FROM DUAL
UNION ALL
SELECT DRV.PLAN_TABLE_OUTPUT
FROM DRV, OUTLINE_START, OUTLINE_END
WHERE DRV.RN  BETWEEN OUTLINE_START.RN-1 AND OUTLINE_END.RN+1
AND   DRV.PLAN_TABLE_OUTPUT IS NOT NULL
/
spool off

--VAR sql_text1 CLOB;
--EXEC :sql_text1 := NULL;

SPOOL sma_exp_&&files_prefix..sql append
--SPOOL sma_explain_&&files_prefix..sql append
DECLARE
  l_sql_text CLOB;
  l_pos NUMBER;
  l_first number := 0;
BEGIN
  l_first := 0;
  IF(:SQL_FROM_MEM = 0 AND (:SQL_FROM_AWR = 1 OR :SQL_FROM_SPM = 1)  AND ( :L_PX = 0 or  :L_PX is null ) ) THEN

    :sql_text := TRIM(CHR(10) FROM TRIM(:sql_text))||CHR(10);
    :sql_text := REPLACE(:sql_text, CHR(10)||CHR(10)||CHR(10), CHR(10));
    :sql_text := REPLACE(:sql_text, CHR(10)||CHR(10), CHR(10));
    :sql_text := REPLACE(:sql_text, '&','');
    l_sql_text := :sql_text;


    WHILE NVL(LENGTH(l_sql_text), 0) > 0
    LOOP
      l_pos := INSTR(l_sql_text, CHR(10));
--       DBMS_OUTPUT.PUT_LINE(L_POS);
      IF ( l_pos > 0 and l_first = 0 ) THEN
        DBMS_OUTPUT.PUT_LINE(
           SUBSTR(
            regexp_replace(l_sql_text,'(select |insert |update |delete |merge )','       ',1,1,'i'),
            1, l_pos - 1)
            );     /*v3*/
        l_sql_text := SUBSTR(l_sql_text, l_pos + 1);
        l_first := 1;
      ELSIF ( l_pos > 0 and l_first = 1
      ) THEN
        DBMS_OUTPUT.PUT_LINE(SUBSTR(l_sql_text, 1, l_pos - 1));  /*v3*/
        l_sql_text := SUBSTR(l_sql_text, l_pos + 1);
        l_first := 1;
      ELSE
        DBMS_OUTPUT.PUT_LINE(l_sql_text);      /*v3*/
        l_sql_text := NULL;
      END IF;
    END LOOP;
    DBMS_OUTPUT.PUT_LINE('/');
  END IF;
  IF(:SQL_FROM_MEM = 0 AND (:SQL_FROM_AWR = 1 OR :SQL_FROM_SPM = 1)  AND :L_PX = 1 ) THEN

    :sql_text := TRIM(CHR(10) FROM TRIM(:sql_text))||CHR(10);
    :sql_text := REPLACE(:sql_text, CHR(10)||CHR(10)||CHR(10), CHR(10));
    :sql_text := REPLACE(:sql_text, CHR(10)||CHR(10), CHR(10));
    :sql_text := REPLACE(:sql_text, '&','');
    l_sql_text := :sql_text;


    WHILE NVL(LENGTH(l_sql_text), 0) > 0
    LOOP
      l_pos := INSTR(l_sql_text, CHR(10));
--       DBMS_OUTPUT.PUT_LINE(L_POS);
      IF ( l_pos > 0 and l_first = 0 ) THEN
        DBMS_OUTPUT.PUT_LINE(
           SUBSTR(
            regexp_replace(l_sql_text,'(select |insert |update |delete |merge )','       ',1,1,'i'),
            1, l_pos - 1) );
        l_sql_text := SUBSTR(l_sql_text, l_pos + 1);
        l_first := 1;
      ELSIF ( l_pos > 0 and l_first = 1
      ) THEN
        DBMS_OUTPUT.PUT_LINE(SUBSTR(l_sql_text, 1, l_pos - 1));
        l_sql_text := SUBSTR(l_sql_text, l_pos + 1);
        l_first := 1;
      ELSE
        DBMS_OUTPUT.PUT_LINE(l_sql_text);
        l_sql_text := NULL;
      END IF;
    END LOOP;
    DBMS_OUTPUT.PUT_LINE('/');
  END IF;
END;
/
--SET ECHO OFF;
--SET FEED OFF LIN 2000 TRIMS ON TIM OFF SERVEROUT ON FOR WOR;

PROMPT SPOOL sma_ep_&&files_prefix..output
--PROMPT SPOOL sma_exp_pred_&&files_prefix..output
PROMPT SET LINES 500
PROMPT select '<details>' FROM DUAL WHERE (:SQL_FROM_SPM = 1 or :SQL_FROM_AWR = 1 or :SQL_FROM_AWR_SPM = 1) AND :L_PLAN_HASH_VALUE2 <> 0
PROMPT /
--prompt prompt <summary><blue>Explain Plan Predicates</blue></summary>
--prompt prompt
PROMPT select '<summary><blue>Explain PLAN_HASH_VALUE:'||:L_PLAN_HASH_VALUE2||'</blue></summary>' FROM DUAL
prompt WHERE (:SQL_FROM_SPM = 1 or :SQL_FROM_AWR = 1 or :SQL_FROM_AWR_SPM = 1) and :L_PLAN_HASH_VALUE2 <> 0
PROMPT /
PROMPT SELECT ' ' plan_type FROM DUAL WHERE (:SQL_FROM_SPM = 1 or :SQL_FROM_AWR = 1 or :SQL_FROM_AWR_SPM = 1)  AND :L_PLAN_HASH_VALUE2 <> 0
PROMPT UNION ALL SELECT 'EXPLAIN PLAN' FROM DUAL WHERE (:SQL_FROM_SPM = 1 or :SQL_FROM_AWR = 1 or :SQL_FROM_AWR_SPM = 1)  AND :L_PLAN_HASH_VALUE2 <> 0
PROMPT UNION ALL SELECT ' ' FROM DUAL WHERE (:SQL_FROM_SPM = 1 or :SQL_FROM_AWR = 1 or :SQL_FROM_AWR_SPM = 1) AND :L_PLAN_HASH_VALUE2 <> 0
PROMPT /
PROMPT SELECT 'EXPID: '||lpad('   ',4-length(ID))||id||' '||lpad('  ', 1*(DEPTH-1)) || operation||' '||options ||' '||OBJECT_OWNER||'.'||object_name
PROMPT FROM PLAN_TABLE WHERE  statement_id = 'SMA'  AND (:SQL_FROM_SPM = 1 or :SQL_FROM_AWR = 1 or :SQL_FROM_AWR_SPM = 1) AND :L_PLAN_HASH_VALUE2 <> 0
PROMPT ORDER BY ID
PROMPT /
--PROMPT prompt PREDICATES
PROMPT select '<blue>PREDICATES</blue>' FROM DUAL WHERE (:SQL_FROM_SPM = 1 or :SQL_FROM_AWR = 1 or :SQL_FROM_AWR_SPM = 1) AND :L_PLAN_HASH_VALUE2 <> 0
PROMPT /
--PROMPT SELECT CASE WHEN ID IN (:l_as1,  :l_as2,  :l_as3,  :l_as4,  :l_as5) THEN '<RED>EXPID: '||ID||' '||PREDICATES||'</RED>' ELSE 'EXPID: '||ID||' '||PREDICATES END
PROMPT SELECT 'EXPID: '||ID||' '||PREDICATES
PROMPT FROM (
PROMPT SELECT ID, '@QRYBLK ALIAS: @'||QBLOCK_NAME||' '||OBJECT_ALIAS PREDICATES FROM PLAN_TABLE WHERE  statement_id = 'SMA'
PROMPT AND FILTER_PREDICATES IS NOT NULL AND :L_PLAN_HASH_VALUE2 <> 0
PROMPT UNION ALL
PROMPT SELECT ID, 'ACCESS: '||ACCESS_PREDICATES PREDICATES FROM PLAN_TABLE WHERE  statement_id = 'SMA'
PROMPT AND ACCESS_PREDICATES IS NOT NULL AND :L_PLAN_HASH_VALUE2 <> 0
PROMPT UNION ALL
PROMPT SELECT ID, 'FILTER: '||substr(FILTER_PREDICATES,1,3000) PREDICATES FROM PLAN_TABLE WHERE  statement_id = 'SMA'
PROMPT AND FILTER_PREDICATES IS NOT NULL AND :L_PLAN_HASH_VALUE2 <> 0
PROMPT ) ORDER BY ID, PREDICATES
PROMPT /
PROMPT select '</details>' FROM DUAL WHERE (:SQL_FROM_SPM = 1 or :SQL_FROM_AWR = 1 or :SQL_FROM_AWR_SPM = 1 or :SQL_FROM_AWR_SPM = 1) AND :L_PLAN_HASH_VALUE2 <> 0
PROMPT /
--prompt prompt </pre>
PROMPT SPOOL OFF
SPOOL OFF
@sma_exp_&&files_prefix..sql
--@sma_explain_&&files_prefix..sql

-- v3 1st explain end


-- v3 2nd explain start

SPOOL sma_exp1_&&files_prefix..sql
--SPOOL sma_explain1_&&files_prefix..sql

prompt DELETE PLAN_TABLE WHERE  statement_id = 'SMA1'
prompt /
prompt commit
prompt /

WITH DRV AS (
SELECT ROWNUM RN, PLAN_TABLE_OUTPUT FROM TABLE(DBMS_XPLAN.DISPLAY_AWR( :L_SQL_ID,:L_PLAN_HASH_VALUE1,:L_DBID,FORMAT=> 'advanced'))
WHERE :SQL_FROM_MEM = 0 AND (:SQL_FROM_AWR = 1 OR :SQL_FROM_SPM = 1 or :SQL_FROM_AWR_SPM = 1) AND :L_PLAN_HASH_VALUE1 <> 0 AND ( :L_PX = 0 OR :L_PX IS NULL )
),
SQL_START AS (
SELECT RN, PLAN_TABLE_OUTPUT
FROM DRV
WHERE PLAN_TABLE_OUTPUT LIKE 'SQL_ID%' ),
SQL_END AS (
SELECT RN, PLAN_TABLE_OUTPUT
FROM DRV
WHERE PLAN_TABLE_OUTPUT LIKE 'Plan hash value%' ),
OUTLINE_START AS (
SELECT RN, PLAN_TABLE_OUTPUT
FROM DRV
WHERE PLAN_TABLE_OUTPUT LIKE '%BEGIN_OUTLINE_DATA%' ),
OUTLINE_END AS (
SELECT RN, PLAN_TABLE_OUTPUT
FROM DRV
WHERE PLAN_TABLE_OUTPUT LIKE '%END_OUTLINE_DATA%' )
SELECT 'explain plan set statement_id = ''SMA1'' into plan_TABLE for' FROM DUAL
UNION ALL
SELECT :L_FIRST_SQL_TEXT FROM DUAL
UNION ALL
SELECT DRV.PLAN_TABLE_OUTPUT
FROM DRV, OUTLINE_START, OUTLINE_END
WHERE DRV.RN  BETWEEN OUTLINE_START.RN-1 AND OUTLINE_END.RN+1
AND DRV.PLAN_TABLE_OUTPUT IS NOT NULL
/
spool off

--VAR sql_text1 CLOB;
--EXEC :sql_text1 := NULL;

SPOOL sma_exp1_&&files_prefix..sql append
--SPOOL sma_explain1_&&files_prefix..sql append
DECLARE
  l_sql_text CLOB;
  l_pos NUMBER;
  l_first number := 0;
BEGIN
  IF(:SQL_FROM_MEM = 0 AND (:SQL_FROM_AWR = 1 OR :SQL_FROM_SPM = 1)) THEN

    :sql_text := TRIM(CHR(10) FROM TRIM(:sql_text))||CHR(10);
    :sql_text := REPLACE(:sql_text, CHR(10)||CHR(10)||CHR(10), CHR(10));
    :sql_text := REPLACE(:sql_text, CHR(10)||CHR(10), CHR(10));
    :sql_text := REPLACE(:sql_text, '&','');
     l_sql_text := :sql_text;

    WHILE NVL(LENGTH(l_sql_text), 0) > 0
    LOOP
      l_pos := INSTR(l_sql_text, CHR(10));
--       DBMS_OUTPUT.PUT_LINE(L_POS);
      IF ( l_pos > 0 and l_first = 0 ) THEN
        DBMS_OUTPUT.PUT_LINE(
           SUBSTR(
            regexp_replace(l_sql_text,'(select |insert |update |delete |merge )','       ',1,1,'i'),
            1, l_pos - 1));   /*v3*/
        l_sql_text := SUBSTR(l_sql_text, l_pos + 1);
        l_first := 1;
      ELSIF ( l_pos > 0 and l_first = 1
      ) THEN
        DBMS_OUTPUT.PUT_LINE(SUBSTR(l_sql_text, 1, l_pos - 1));     /*v3*/
        l_sql_text := SUBSTR(l_sql_text, l_pos + 1);
        l_first := 1;
      ELSE
        DBMS_OUTPUT.PUT_LINE(l_sql_text);  /*v3*/
        l_sql_text := NULL;
      END IF;
    END LOOP;
    DBMS_OUTPUT.PUT_LINE('/');
  END IF;
END;
/
--SET ECHO OFF;
--SET FEED OFF LIN 2000 TRIMS ON TIM OFF SERVEROUT ON FOR WOR;

PROMPT SPOOL sma_ep1_&&files_prefix..output
--PROMPT SPOOL sma_exp_pred1_&&files_prefix..output
PROMPT SET LINES 500
--prompt prompt <details>
PROMPT select '<details>' FROM DUAL WHERE (:SQL_FROM_SPM = 1 or :SQL_FROM_AWR = 1 or :SQL_FROM_AWR_SPM = 1) AND :L_PLAN_HASH_VALUE1 <> 0
PROMPT /
PROMPT select '<summary><blue>Explain PLAN_HASH_VALUE:'||:L_PLAN_HASH_VALUE1||'</blue></summary>' FROM DUAL
prompt WHERE (:SQL_FROM_SPM = 1 or :SQL_FROM_AWR = 1 or :SQL_FROM_AWR_SPM = 1) AND :L_PLAN_HASH_VALUE1 <> 0
PROMPT /
PROMPT SELECT ' ' plan_type FROM DUAL WHERE (:SQL_FROM_SPM = 1 or :SQL_FROM_AWR = 1 or :SQL_FROM_AWR_SPM = 1)
prompt union all SELECT 'EXPLAIN PLAN' FROM DUAL WHERE (:SQL_FROM_SPM = 1 or :SQL_FROM_AWR = 1 or :SQL_FROM_AWR_SPM = 1) AND :L_PLAN_HASH_VALUE1 <> 0
prompt UNION ALL SELECT ' ' FROM DUAL WHERE (:SQL_FROM_SPM = 1 or :SQL_FROM_AWR = 1 or :SQL_FROM_AWR_SPM = 1) AND :L_PLAN_HASH_VALUE1 <> 0
PROMPT /
PROMPT SELECT 'EXPID: '||lpad('   ',4-length(ID))||id||' '||lpad('  ', 1*(DEPTH-1)) || operation||' '||options ||' '||OBJECT_OWNER||'.'||object_name
PROMPT FROM PLAN_TABLE WHERE  statement_id = 'SMA1'  AND (:SQL_FROM_SPM = 1 or :SQL_FROM_AWR = 1 or :SQL_FROM_AWR_SPM = 1) AND :L_PLAN_HASH_VALUE1 <> 0
PROMPT ORDER BY ID
PROMPT /
--PROMPT prompt PREDICATES
PROMPT select '<blue>PREDICATES</blue>' FROM DUAL WHERE (:SQL_FROM_SPM = 1 or :SQL_FROM_AWR = 1 or :SQL_FROM_AWR_SPM = 1) AND :L_PLAN_HASH_VALUE1 <> 0
PROMPT /
--PROMPT SELECT CASE WHEN ID IN (:l_as1,  :l_as2,  :l_as3,  :l_as4,  :l_as5) THEN '<RED>EXPID: '||ID||' '||PREDICATES||'</RED>' ELSE 'EXPID: '||ID||' '||PREDICATES END
PROMPT SELECT 'EXPID: '||ID||' '||PREDICATES
PROMPT FROM (
PROMPT SELECT ID, '@QRYBLK ALIAS: @'||QBLOCK_NAME||' '||OBJECT_ALIAS PREDICATES FROM PLAN_TABLE WHERE  statement_id = 'SMA1'
PROMPT AND FILTER_PREDICATES IS NOT NULL AND :L_PLAN_HASH_VALUE1 <> 0
PROMPT UNION ALL
PROMPT SELECT ID, 'ACCESS: '||ACCESS_PREDICATES PREDICATES FROM PLAN_TABLE WHERE  statement_id = 'SMA1'
PROMPT AND ACCESS_PREDICATES IS NOT NULL AND :L_PLAN_HASH_VALUE1 <> 0
PROMPT UNION ALL
PROMPT SELECT ID, 'FILTER: '||substr(FILTER_PREDICATES,1,3000) PREDICATES FROM PLAN_TABLE WHERE  statement_id = 'SMA1'
PROMPT AND FILTER_PREDICATES IS NOT NULL AND :L_PLAN_HASH_VALUE1 <> 0
PROMPT ) ORDER BY ID, PREDICATES
PROMPT /
PROMPT select '</details>' FROM DUAL WHERE (:SQL_FROM_SPM = 1 or :SQL_FROM_AWR = 1 or :SQL_FROM_AWR_SPM = 1) AND :L_PLAN_HASH_VALUE1 <> 0
PROMPT /
PROMPT SPOOL OFF
SPOOL OFF
@sma_exp1_&&files_prefix..sql
--@sma_explain1_&&files_prefix..sql


-- v3 2nd explain end

SPOOL sma_&&files_prefix..sql4;

BEGIN
  IF ( :SQL_FROM_MEM = 1 AND :L_PLAN_PRINT = 'S' ) THEN
      DBMS_OUTPUT.PUT_LINE('</pre><a href="#APPENDIX">Back to Appendix/Supporting details</a><pre>');
      DBMS_OUTPUT.PUT_LINE('</pre><a href="#top">Back to top</a><pre>');
  END IF ;
END;
/
--20210419 FEEDBACK START
pro   <a name="STATSFEEDBACK"></a>
pro <details>
pro   <summary><blue>STATISTICS FEEDBACK (MEM)</blue></summary>

pro <table>
pro <tbody><tr>
pro <th>INST<br>ID</th>
pro <th>PLAN_HASH<br>VALUE</th>
pro <th>CHILD<br>NUMBER</th>
pro <th>ID</th>
pro <th>OBJECT_ALIAS</th>
pro <th>OBJECT_NAME</th>
pro <th>OBJECT_TYPE</th>
pro <th>CARDINALITY</th>
pro <th>FEEDBACK_STATS</th>
pro </tr>
SET HEAD OFF

SELECT  CHR(10)||'<tr>'||CHR(10)
     ||'<td class="r">'||INST_ID||'</td>'||CHR(10)
     ||'<td class="r">'||PLAN_HASH_VALUE||'</td>'||CHR(10)
     ||'<td class="r">'||CHILD_NUMBER||'</td>'||CHR(10)
     ||'<td class="r">'||ID||'</td>'||CHR(10)
     ||'<td class="r">'||OBJECT_ALIAS||'</td>'||CHR(10)
     ||'<td class="r">'||OBJECT_NAME||'</td>'||CHR(10)
     ||'<td class="r">'||OBJECT_TYPE||'</td>'||CHR(10)
     ||'<td class="r">'||CARDINALITY||'</td>'||CHR(10)
     ||'<td class="r">'||FEEDBACK_STATS||'</td>'||CHR(10)
     ||'</TR>'
FROM (
SELECT p.inst_id, p.plan_hash_value, p.child_number, p.id, p.object_alias, P.OBJECT_NAME, P.OBJECT_TYPE,
--SUBSTR(HINT_TEXT, INSTR( HINT_TEXT,' ',1,2 )+1,5) OBJECT_TYPE,
--SUBSTR(HINT_TEXT, INSTR( HINT_TEXT,' ',1,3 ),INSTR( HINT_TEXT,' ',1,4 )+1-INSTR( HINT_TEXT,' ',1,3 ) ) OBJECT_ALIAS1,
--DECODE(SUBSTR(HINT_TEXT, INSTR( HINT_TEXT,' ',1,2 )+1,5),'INDEX', SUBSTR(HINT_TEXT, INSTR( HINT_TEXT,' ',1,4 ),INSTR( HINT_TEXT,' ',1,5 )+1-INSTR( HINT_TEXT,' ',1,4 ) ),
--SUBSTR(HINT_TEXT, INSTR( HINT_TEXT,' ',1,3 ),INSTR( HINT_TEXT,' ',1,4 )+1-INSTR( HINT_TEXT,' ',1,3 ) )) HOBJECT_NAME,
P.CARDINALITY,
DECODE(SUBSTR(HINT_TEXT, INSTR( HINT_TEXT,' ',1,2 )+1,5),'INDEX',SUBSTR(HINT_TEXT, INSTR( HINT_TEXT,' ',1,5 ),INSTR( HINT_TEXT,' ',1,6 )+1-INSTR( HINT_TEXT,' ',1,5 ))
      ,SUBSTR(HINT_TEXT, INSTR( HINT_TEXT,' ',1,4 ),INSTR( HINT_TEXT,' ',1,5 )+1-INSTR( HINT_TEXT,' ',1,4 ))) FEEDBACK_STATS
--,HINT_TEXT
from gv$sql_reoptimization_hints  h, gv$sql_plan p
WHERE p.SQL_ID = :L_SQL_ID
AND (h.HINT_TEXT LIKE '%TABLE%' OR h.HINT_TEXT LIKE '%INDEX_FILTER%')
and  p.object_type in ('TABLE','INDEX')
and h.inst_id = p.inst_id
and h.sql_id = p.sql_id
and h.child_number = p.child_number
and SUBSTR(h.HINT_TEXT, INSTR( HINT_TEXT,' ',1,2 )+1,5) = p.object_type
and TRIM(SUBSTR(HINT_TEXT, INSTR( HINT_TEXT,' ',1,3 ),INSTR( HINT_TEXT,' ',1,4 )+1-INSTR( HINT_TEXT,' ',1,3 ) )) = p.object_alias
order by p.inst_id, p.plan_hash_value, p.child_number, p.id ) ;

pro </tbody>
pro </table>

pro <table>
pro <tbody><tr>
pro <th>INST<br>ID</th>
pro <th>PLAN_HASH<br>VALUE</th>
pro <th>CHILD<br>NUMBER</th>
pro <th>IS_REOPTIMIZABLE</th>
pro <th>LAST_LOAD_TIME</th>
pro <th>FEEDBACK_STATS</th>
pro </tr>
SET HEAD OFF

SELECT  CHR(10)||'<tr>'||CHR(10)
     ||'<td class="r">'||INST_ID||'</td>'||CHR(10)
     ||'<td class="r">'||PLAN_HASH_VALUE||'</td>'||CHR(10)
     ||'<td class="r">'||CHILD_NUMBER||'</td>'||CHR(10)
     ||'<td class="r">'||IS_REOPTIMIZABLE||'</td>'||CHR(10)
     ||'<td class="r">'||LAST_LOAD_TIME||'</td>'||CHR(10)
     ||'<td class="r">'||FEEDBACK_STATS||'</td>'||CHR(10)
     ||'</TR>'
FROM (
SELECT INST_ID, PLAN_HASH_VALUE, CHILD_NUMBER, IS_REOPTIMIZABLE, LAST_LOAD_TIME, 'STATS FEEDBACK' FEEDBACK_STATS
FROM (
SELECT s.inst_id, S.SQL_ID, S.plan_hash_value, s.CHILD_NUMBER ,S.IS_REOPTIMIZABLE, S.LAST_LOAD_TIME
  FROM GV$SQL S
 WHERE S.sql_id = :L_SQL_ID
 AND EXISTS (SELECT 'Y' FROM GV$SQL_PLAN P
                     WHERE P.INST_ID = S.INST_ID AND P.SQL_ID = S.SQL_ID AND P.PLAN_HASH_VALUE = S.PLAN_HASH_VALUE AND P.CHILD_NUMBER = S.CHILD_NUMBER
                     AND P.OTHER_XML IS NOT NULL AND P.OTHER_XML LIKE '%cardinality_feedback" note="y">yes%' AND ROWNUM = 1 )
)  S ) ;

pro </tbody>
pro </table>
pro </details>
SET HEAD ON
--20210419 FEEDBACK END

pro   <a name="HARDPARSE"></a>
pro <details>
pro   <summary><blue>HARD PARSING TIME AND VPD BY PLAN HASH VALUE (MEM)</blue></summary>
-- SMA19C 2020/02/04

pro <table>
pro <tbody><tr>
pro <th>INST<br>ID</th>
pro <th>PLAN_HASH<br>VALUE</th>
pro <th>CHILD<br>NUMBER</th>
pro <th>AVG<br>HARD<BR>PARSING<br>TIME</th>
pro <th>OBJECT_NAME</th>
pro <th>POLICY</th>
pro <th>PREDICATE</th>
pro </tr>
SET HEAD OFF

SELECT  CHR(10)||'<tr>'||CHR(10)
     ||'<td class="r">'||INST_ID||'</td>'||CHR(10)
     ||'<td class="r">'||PLAN_HASH_VALUE||'</td>'||CHR(10)
     ||'<td class="r">'||CHILD_NUMBER||'</td>'||CHR(10)
     ||'<td class="r">'||AVG_HARD_PARSING_TIME||'</td>'||CHR(10)
     ||'<td class="r">'||OBJECT_NAME||'</td>'||CHR(10)
     ||'<td class="r">'||POLICY||'</td>'||CHR(10)
     ||'<td class="r">'||PREDICATE||'</td>'||CHR(10)
     ||'</TR>'
FROM (
with drv as (
select drv.sql_id, drv.inst_id, drv.plan_hash_value, max(drv.child_number) child_number,
round(ss.AVG_HARD_PARSE_TIME/ss.VERSION_COUNT/1000000, 3) avg_hard_parsing_time
from  gv$sql drv, gv$sqlstats ss
where ss.inst_id = drv.inst_id
and   ss.sql_id  = drv.sql_id
and   ss.plan_hash_value = drv.plan_hash_value
and   drv.sql_id =  :l_sql_id
group by  drv.sql_id, drv.inst_id, drv.plan_hash_value, round(ss.AVG_HARD_PARSE_TIME/ss.VERSION_COUNT/1000000, 3)
order by   round(ss.AVG_HARD_PARSE_TIME/ss.VERSION_COUNT/1000000, 3) desc )
select  s.inst_id, s.plan_hash_value, s.child_number,
 s.avg_hard_parsing_time,  p.object_name, REPLACE(p.policy,'_PII_','_<RED>PII</RED>_') POLICY, p.predicate
from gv$vpd_policy p, drv s
where  s.inst_id = p.inst_id
   and s.sql_id  = p.sql_id
   and s.child_number = p.child_number
   and p.sql_id = :l_sql_id
ORDER BY  s.avg_hard_parsing_time,  s.child_number,  s.inst_id, p.object_name, P.POLICY ) ;

pro </tbody>
pro </table>
pro </details>
SET HEAD ON


/* 20200722 repeated predicates start */

VAR  ISSUE_REPEATED_PREDICATES NUMBER
EXEC :ISSUE_REPEATED_PREDICATES := 0;

pro   <a name="REP_APREDICATES"></a>
pro <details>
pro   <summary><blue>REPEATED ACCESS PREDICATES (MEM)</blue></summary>
-- SMA19C 2020/02/04

pro <table>
pro <tbody><tr>
pro <th>PLAN_HASH_VALUE</th>
pro <th>ROW_COUNT</th>
pro <th>LINE_ID</th>
pro <th>OBJECT_NAME</th>
pro <th>ACCESS_PREDICATES</th>
pro </tr>
SET HEAD OFF

DELETE PLAN_TABLE ;
COMMIT;
-- 20201010 need to fix
INSERT INTO PLAN_TABLE (id, OTHER)
SELECT rownum, CHR(10)||'<tr>'||CHR(10)
     ||'<td class="r">'||PLAN_HASH_VALUE||'</td>'||CHR(10)
     ||'<td class="r">'||RCOUNT||'</td>'||CHR(10)
     ||'<td class="r">'||ID||'</td>'||CHR(10)
     ||'<td class="r">'||OBJECT_NAME||'</td>'||CHR(10)
     ||'<td class="r">'||ACCESS_PREDICATES||'</td>'||CHR(10)
     ||'</TR>'
FROM (
with PICK_ONE AS ( SELECT INST_ID, sql_id, plan_hash_value, CHILD_NUMBER FROM GV$SQL WHERE SQL_ID = :L_SQL_ID AND ROWNUM = 1 ),
drv as (
  select INST_ID, sql_id, cnt, plan_hash_value, CHILD_NUMBER, access_predicates from (
  select SP.INST_ID, SP.sql_id, SP.plan_hash_value, SP.CHILD_NUMBER, SP.access_predicates, count(*) cnt
  from Gv$sql_plan SP, PICK_ONE P
  where access_predicates is not null
  and SP.INST_ID = P.INST_ID AND SP.sql_id = P.SQL_ID AND SP.PLAN_HASH_VALUE = P.PLAN_HASH_VALUE AND SP.CHILD_NUMBER = P.CHILD_NUMBER
  group by SP.INST_ID, SP.sql_id, SP.plan_hash_value, SP.CHILD_NUMBER, SP.access_predicates )
  where cnt > 2
  order by sql_id, plan_hash_value, cnt desc )
SELECT
--sql_id,
plan_hash_value,
--cnt,
ROW_NUMBER() over (PARTITION BY ACCESS_PREDICATES ORDER BY OBJECT_NAME) RCOUNT,
id, OBJECT_NAME, access_predicates
FROM ( select a.sql_id, a.plan_hash_value, P.cnt,
a.id, A.OBJECT_NAME, a.access_predicates
from  Gv$sql_plan a, drv P
where  A.INST_ID = P.INST_ID AND A.sql_id = P.SQL_ID AND A.PLAN_HASH_VALUE = P.PLAN_HASH_VALUE AND A.CHILD_NUMBER = P.CHILD_NUMBER
and a.access_predicates = P.access_predicates
AND   :L_SQLHC_MIN_FLAG < 15  /* limits */
order by a.sql_id, a.plan_hash_value, P.cnt desc , a.access_predicates, a.id )
)
/
SELECT OTHER
FROM PLAN_TABLE
order by id
/

begin
  SELECT COUNT(*) INTO :ISSUE_REPEATED_PREDICATES FROM PLAN_TABLE;
end;
/

DELETE PLAN_TABLE ;
COMMIT;

pro </tbody>
pro </table>
pro </details>

pro   <a name="REP_FAPREDICATES"></a>
pro <details>
pro   <summary><blue>REPEATED FILTER PREDICATES (MEM)</blue></summary>
-- SMA19C 2020/02/04

pro <table>
pro <tbody><tr>
pro <th>PLAN_HASH_VALUE</th>
pro <th>ROW_COUNT</th>
pro <th>LINE_ID</th>
pro <th>OBJECT_NAME</th>
pro <th>FILTER_PREDICATES</th>
pro </tr>
SET HEAD OFF
-- 20201010 need to fix
INSERT INTO PLAN_TABLE (id, OTHER)
SELECT rownum,  CHR(10)||'<tr>'||CHR(10)
     ||'<td class="r">'||PLAN_HASH_VALUE||'</td>'||CHR(10)
     ||'<td class="r">'||RCOUNT||'</td>'||CHR(10)
     ||'<td class="r">'||ID||'</td>'||CHR(10)
     ||'<td class="r">'||OBJECT_NAME||'</td>'||CHR(10)
     ||'<td class="r">'||FILTER_PREDICATES||'</td>'||CHR(10)
     ||'</TR>'
FROM (
with PICK_ONE AS ( SELECT INST_ID, sql_id, plan_hash_value, CHILD_NUMBER FROM GV$SQL WHERE SQL_ID = :L_SQL_ID AND ROWNUM = 1 ),
drv as (
  select INST_ID, sql_id, cnt, plan_hash_value, CHILD_NUMBER, FILTER_predicates from (
  select SP.INST_ID, SP.sql_id, SP.plan_hash_value, SP.CHILD_NUMBER, SP.FILTER_predicates, count(*) cnt
  from Gv$sql_plan SP, PICK_ONE P
  where FILTER_predicates is not null
  and SP.INST_ID = P.INST_ID AND SP.sql_id = P.SQL_ID AND SP.PLAN_HASH_VALUE = P.PLAN_HASH_VALUE AND SP.CHILD_NUMBER = P.CHILD_NUMBER
  group by SP.INST_ID, SP.sql_id, SP.plan_hash_value, SP.CHILD_NUMBER, SP.FILTER_predicates )
  where cnt > 2
  order by sql_id, plan_hash_value, cnt desc )
SELECT
--sql_id,
plan_hash_value,
--cnt,
ROW_NUMBER() over (PARTITION BY FILTER_PREDICATES ORDER BY OBJECT_NAME) RCOUNT,
id, OBJECT_NAME, FILTER_predicates
FROM ( select a.sql_id, a.plan_hash_value, P.cnt,
a.id, A.OBJECT_NAME, a.FILTER_predicates
from  Gv$sql_plan a, drv P
where  A.INST_ID = P.INST_ID AND A.sql_id = P.SQL_ID AND A.PLAN_HASH_VALUE = P.PLAN_HASH_VALUE AND A.CHILD_NUMBER = P.CHILD_NUMBER
and a.FILTER_predicates = P.FILTER_predicates
AND   :L_SQLHC_MIN_FLAG < 15  /* limits */
order by a.sql_id, a.plan_hash_value, P.cnt desc , a.FILTER_predicates, a.id )
)
/
SELECT OTHER
FROM PLAN_TABLE
order by id
/
pro </tbody>
pro </table>
pro </details>

begin
  if(  :ISSUE_REPEATED_PREDICATES = 0  ) then
   SELECT COUNT(*) INTO :ISSUE_REPEATED_PREDICATES FROM PLAN_TABLE;
  end if;
end;
/

SET HEAD ON

-------------------------------------------
/* 20200722 repeated predicates end */
-------------------------------------------

--smabv.sql start
--set head on heading on LINESIZE 300 pagesize 100
--bind usage check ref : https://docs.oracle.com/database/121/TGSQL/tgsql_cursor.htm#TGSQL94745

--prompt dynamic_bind check start
VAR L_DYN_BIND  VARCHAR2(3)

BEGIN
  :L_DYN_BIND := 'N';
  FOR SM IN ( SELECT INST_ID, CHILD_NUMBER, NAME BIND_NAME,
  COUNT(DISTINCT POSITION) NUM_DIST_POSITION,
  COUNT(DISTINCT DATATYPE) NUM_DIST_TYPE,
  MIN(DATATYPE) SAMPLE_TYPE1, MAX(DATATYPE) SAMPLE_TYPE2,
  MIN(SUBSTR(VALUE_STRING,1,30)) SAMPLE_VAL1, MAX(SUBSTR(VALUE_STRING,1,30)) SAMPLE_VAL2,
  COUNT(DISTINCT VALUE_STRING) NUM_DIST_VALUE
  FROM GV$SQL_BIND_CAPTURE
  WHERE SQL_ID = :L_SQL_ID
  GROUP BY  INST_ID, CHILD_NUMBER, NAME  HAVING COUNT(DISTINCT DATATYPE) > 1 OR COUNT(DISTINCT VALUE_STRING) > 1
  ORDER BY INST_ID, CHILD_NUMBER, NAME )
  LOOP
      :L_DYN_BIND := 'Y';
  END LOOP;
END;
/
--prompt dynamic_bind check end

set lines 600
col COLUMN_NAME format a30
col m_COLUMN_NAME format a30
col LOW_VALUE format a30
col HIGH_VALUE format a30
col BIND_NAME format a30
col BIND_VALUE format a30
col BIND_DTYPE format a10
col HISTOGRAM format a10
col COL_DTYPE format a10
col OPERATION format a20
col WITHIN format a6
col OPTIONS format a20
col ACCESS_PREDICATES format a30
col FILTER_PREDICATES format a30
col INDEX_NAME format a30
COL TABLE_OWNER FORMAT A20
col TABLE_NAME format a30
col CP format 9999
col BP format 9999
col LAST_LOAD_TIME format a20
col LAST_ANALYZED format a20
col INST_ID format 999
COL SAMPLE_VAL1 FORMAT A30
COL SAMPLE_VAL2 FORMAT A30

pro
pro   <a name="BINDUSAGE"></a>
pro <details>
pro   <summary><blue>BIND USAGE PATTERN Information (MEM)</blue></summary>

--set head on heading on pages 500   only for text version, not for html
/**/

--20200617
--prompt mis_bind_type/size start

pro <blue>MIS-BIND TYPE/SIZE FROM GV$SQL_BIND_CAPTURE/DBA_HIST_SQLBIND</blue>

pro <table>
pro <tbody><tr>
pro <th>SRC</th>
pro <th>NAME</th>
pro <th>POSISION</th>
pro <th>DATATYPE_STRING1</th>
pro <th>DATATYPE_STRING2</th>
pro <th>NDV_DATATYPE_STRING</th>
pro </tr>

select  CHR(10)||'<tr>'||CHR(10)
     ||'<td class="r">'||SRC||'</td>'||CHR(10)
     ||'<td class="r"><RED>'||NAME||'</RED></td>'||CHR(10)
     ||'<td class="r">'||POSITION||'</td>'||CHR(10)
     ||'<td class="r"><RED>'||DATATYPE_STRING1||'</RED></td>'||CHR(10)
     ||'<td class="r"><RED>'||DATATYPE_STRING2||'</RED></td>'||CHR(10)
     ||'<td class="r"><RED>'||NDV_DATATYPE_STRING||'</RED></td>'||CHR(10)
     ||'</TR>'
FROM (
SELECT 'MEM' AS SRC, NAME, POSITION, min(DATATYPE_STRING) DATATYPE_STRING1, max(DATATYPE_STRING) DATATYPE_STRING2, count(distinct DATATYPE_STRING) NDV_DATATYPE_STRING
from GV$SQL_BIND_CAPTURE
WHERE SQL_ID = :L_SQL_ID
group by NAME, POSITION HAVING count(distinct DATATYPE_STRING) > 1
ORDER BY POSITION )
/

select  CHR(10)||'<tr>'||CHR(10)
     ||'<td class="r">'||SRC||'</td>'||CHR(10)
     ||'<td class="r"><RED>'||NAME||'</RED></td>'||CHR(10)
     ||'<td class="r">'||POSITION||'</td>'||CHR(10)
     ||'<td class="r"><RED>'||DATATYPE_STRING1||'</RED></td>'||CHR(10)
     ||'<td class="r"><RED>'||DATATYPE_STRING2||'</RED></td>'||CHR(10)
     ||'<td class="r"><RED>'||NDV_DATATYPE_STRING||'</RED></td>'||CHR(10)
     ||'</TR>'
FROM (
SELECT 'AWR' AS SRC, NAME, POSITION, min(DATATYPE_STRING) DATATYPE_STRING1, max(DATATYPE_STRING) DATATYPE_STRING2, count(distinct DATATYPE_STRING) NDV_DATATYPE_STRING
FROM DBA_HIST_SQLBIND
WHERE SQL_ID = :L_SQL_ID
AND   DBID   = :L_DBID
AND   SNAP_ID BETWEEN :L_SNAP_ID - 720 AND :L_SNAP_ID
group by NAME, POSITION HAVING count(distinct DATATYPE_STRING) > 1
ORDER BY POSITION )
/

pro </tbody>
pro </table>
--20200617
--prompt mis_bind_type/size end




/***************************************************************************************/
pro <blue>GV$SQL_BIND_CAPTURE/CAPTURED_BIND</blue>

pro <table>
pro <tbody><tr>
pro <th>INST_ID</th>
pro <th>CHILD<br>NUMBER</th>
pro <th>PLAN_HASH_VALUE</th>
pro <th>LAST_LOAD_TIME</th>
pro <th>POSITION</th>
pro <th>BIND<BR>DATATYPE</th>
pro <th>BIND_NAME</th>
pro <th>CAPTURED<BR>BIND_VALUE</th>
pro <th>BIND<BR>SENSITIVE</th>
pro <th>BIND<BR>AWARE</th>
pro <th>SHAREABLE</th>
pro </tr>

select  CHR(10)||'<tr>'||CHR(10)
     ||'<td class="r">'||INST_ID||'</td>'||CHR(10)
     ||'<td class="r">'||CHILD_NUMBER||'</td>'||CHR(10)
     ||'<td class="r">'||PLAN_HASH_VALUE||'</td>'||CHR(10)
     ||'<td class="r">'||LAST_LOAD_TIME||'</td>'||CHR(10)
     ||'<td class="r">'||POSITION||'</td>'||CHR(10)
     ||'<td class="c">'||BIND_DATATYPE||'</td>'||CHR(10)
     ||'<td class="r">'||BIND_NAME||'</td>'||CHR(10)
     ||'<td class="r">'||CAPTURED_BIND_VALUE||'</td>'||CHR(10)
     ||'<td class="c">'||BIND_SENSITIVE||'</td>'||CHR(10)
     ||'<td class="c">'||BIND_AWARE||'</td>'||CHR(10)
     ||'<td class="c">'||SHAREABLE||'</td>'||CHR(10)
     ||'</TR>'
from  (
--2021/05/27
select  inst_id, child_number, plan_hash_value,  last_load_time, position, BIND_DATATYPE,  BIND_NAME,
        substr(CAPTURED_BIND_VALUE,1,length(CAPTURED_BIND_VALUE)/3+1)||rpad('***********************************', length(CAPTURED_BIND_VALUE)*2/3)  CAPTURED_BIND_VALUE ,
        BIND_SENSITIVE, BIND_AWARE, SHAREABLE
 from (
 select d.inst_id, d.child_number, c.plan_hash_value,  c.last_load_time, d.position, d.DATATYPE_STRING BIND_DATATYPE,
       decode(:L_DYN_BIND,'Y','<BLUE>'||d.NAME||'</BLUE>',d.NAME) BIND_NAME,
       decode(:L_DYN_BIND,'Y','<BLUE>'||substr(d.VALUE_STRING,1,100)||'</BLUE>',substr(d.VALUE_STRING,1,100))  CAPTURED_BIND_VALUE ,
       is_bind_sensitive BIND_SENSITIVE, is_bind_aware BIND_AWARE, IS_SHAREABLE SHAREABLE
 FROM gv$sql_bind_capture  D,
         (   select  inst_id, sql_id, plan_hash_value, LAST_LOAD_TIME, child_number, address, child_address,
                     is_bind_sensitive, is_bind_aware, IS_SHAREABLE
            from gv$sql
            where (inst_id, sql_id, plan_hash_value, LAST_LOAD_TIME) in
                 (select inst_id, sql_id, plan_hash_value, max(LAST_LOAD_TIME) LAST_LOAD_TIME
                  from gv$sql
                  where SQL_ID = :L_SQL_ID  --AND :L_DYN_BIND = 'Y'
                  group by inst_id, sql_id, plan_hash_value )
            and  SQL_ID = :L_SQL_ID    ) c
 where d.sql_id = :L_SQL_ID  --AND :L_DYN_BIND = 'Y'
 and   d.inst_id = c.inst_id
 and   d.sql_id = c.sql_id
 and   d.child_number = c.child_number
 and   d.address = c.address
 and   d.child_address = c.child_address
 order by  1, 2, 3, 4, 5  )
)
/


pro </tbody>
pro </table>

/***************************************************************************************/
pro <blue>GV$SQL_PLAN/OTHER_XML/PEEKED_BINDS</blue>

pro <table>
pro <tbody><tr>
pro <th>INST_ID</th>
pro <th>CHILD<br>NUMBER</th>
pro <th>PLAN_HASH_VALUE</th>
pro <th>LAST_LOAD_TIME</th>
pro <th>POSITION</th>
pro <th>BIND<BR>DATATYPE</th>
pro <th>MAX<BR>LENGTH</th>
pro <th>BIND_NAME</th>
pro <th>BIND_VALUE</th>
pro <th>DUP<BR>POD</th>
pro </tr>

--EXEC :L_SQL_ID := '00dbu6tugbgs3';

select  CHR(10)||'<tr>'||CHR(10)
     ||'<td class="r">'||INST_ID||'</td>'||CHR(10)
     ||'<td class="r">'||CHILD_NUMBER||'</td>'||CHR(10)
     ||'<td class="r">'||PLAN_HASH_VALUE||'</td>'||CHR(10)
     ||'<td class="r">'||LAST_LOAD_TIME||'</td>'||CHR(10)
     ||'<td class="r">'||POSITION||'</td>'||CHR(10)
     ||'<td class="c">'||BIND_DATATYPE||'</td>'||CHR(10)
     ||'<td class="c">'||MAX_LENGTH||'</td>'||CHR(10)
     ||'<td class="r">'||BIND_NAME||'</td>'||CHR(10)
     ||'<td class="r">'||BIND_VALUE||'</td>'||CHR(10)
     ||'<td class="c">'||DUP_POS||'</td>'||CHR(10)
     ||'</TR>'
from ( select
  INST_ID, CHILD_NUMBER, plan_hash_value, LAST_LOAD_TIME, POSITION, BIND_DATATYPE, MAX_LENGTH, BIND_NAME,
--2021/05/27
  substr(BIND_VALUE,1,length(BIND_VALUE)/3+1)||rpad('***********************************', length(BIND_VALUE)*2/3) BIND_VALUE,
  DUP_POS
 from
 (
 select  INST_ID, CHILD_NUMBER, plan_hash_value, LAST_LOAD_TIME, POSITION, BIND_DATATYPE, MAX_LENGTH, BIND_NAME,
        substr(
        decode( SUBSTR(BIND_DATATYPE,1,9)
          ,'NUMBER'       ,to_char(utl_raw.cast_to_number(BIND_VALUE)) ||''
          ,'VARCHAR2'     ,to_char(utl_raw.cast_to_varchar2(substr(BIND_VALUE,1,50))) ||''
          ,'NVARCHAR2'    ,to_char(utl_raw.cast_to_nvarchar2(substr(BIND_VALUE,1,50))) ||''
          ,'BINARY_DO'    ,to_char(utl_raw.cast_to_binary_double(BIND_VALUE)) ||''
          ,'DATE'         ,decode(BIND_VALUE, NULL, NULL, rtrim(
                                to_char(100*(to_number(substr(BIND_VALUE,1,2),'XX')-100)
                                       + (to_number(substr(BIND_VALUE,3,2),'XX')-100),'fm0000')||'-'||
                                to_char(to_number(substr(BIND_VALUE,5,2),'XX'),'fm00')||'-'||
                                to_char(to_number(substr(BIND_VALUE,7,2),'XX'),'fm00')||' '||
                                to_char(to_number(substr(BIND_VALUE,9,2),'XX')-1,'fm00')||':'||
                                to_char(to_number(substr(BIND_VALUE,11,2),'XX')-1,'fm00')||':'||
                                to_char(to_number(substr(BIND_VALUE,13,2),'XX')-1,'fm00'))) ||''
          ,'TIMESTAMP'    ,decode(BIND_VALUE, NULL, NULL, rtrim(
                           to_char(100*(to_number(substr(BIND_VALUE,1,2),'XX')-100)
                                  + (to_number(substr(BIND_VALUE,3,2),'XX')-100),'fm0000')||'-'||
                           to_char(to_number(substr(BIND_VALUE,5,2),'XX'),'fm00')||'-'||
                           to_char(to_number(substr(BIND_VALUE,7,2),'XX'),'fm00')||' '||
                           to_char(to_number(substr(BIND_VALUE,9,2),'XX')-1,'fm00')||':'||
                           to_char(to_number(substr(BIND_VALUE,11,2),'XX')-1,'fm00')||':'||
                           to_char(to_number(substr(BIND_VALUE,13,2),'XX')-1,'fm00')
                          ||'.'||to_char(to_number(substr(BIND_VALUE,15,8),'XXXXXXXX')))) ||''
          , BIND_VALUE
       ),1,100)  BIND_VALUE,
       DUP_POS
 from
 (
 SELECT   c.INST_ID, c.CHILD_NUMBER, c.plan_hash_value,
         TO_DATE(LAST_LOAD_TIME,'yyyy-mm-dd hh24:mi:ss') LAST_LOAD_TIME,
         to_number(extractValue(value(d), '/bind/@pos')) POSITION,
         DECODE(extractValue(value(d), '/bind/@dty'),1,'VARCHAR2',2,'NUMBER',12,'DATE',180,'TIMESTAMP',181,'TIMESTAMP', NULL ) BIND_DATATYPE,
         to_number(extractValue(value(d), '/bind/@mxl')) MAX_LENGTH,
         extractValue(value(d), '/bind/@nam') BIND_NAME,
         extractValue(value(d), '/bind') BIND_VALUE  ,
         to_number(extractValue(value(d), '/bind/@ppo')) DUP_POS
    FROM   (select  inst_id, sql_id, plan_hash_value, LAST_LOAD_TIME, child_number
            from gv$sql
            where (inst_id, sql_id, plan_hash_value, LAST_LOAD_TIME) in
                 (select inst_id, sql_id, plan_hash_value, max(LAST_LOAD_TIME) LAST_LOAD_TIME
                  from gv$sql
                  where SQL_ID = :L_SQL_ID
                  group by inst_id, sql_id, plan_hash_value )
            and  SQL_ID = :L_SQL_ID ) s
         ,  gv$sql_plan c
         , TABLE(XMLSEQUENCE(EXTRACT(XMLTYPE(c.other_xml ), '/*/peeked_binds/bind'))) D
   where c.other_xml is not null and extractValue(value(d), '/bind') is not null
   AND s.SQL_ID = :L_SQL_ID    and c.sql_id = :L_SQL_ID
   and s.sql_id = c.sql_id and s.inst_id = c.inst_id and s.plan_hash_value = c.plan_hash_value and s.child_number = c.child_number )
 order by  1, 2, 3, 4, 5  )
)
/

pro </tbody>
pro </table>


/***************************************************************************************/
/* #0  need to check sql statement has :b1 or :1 bind
       :l_dyn_bind := 'Y' OR 'N'
   #1. if YES, need to replace the bind (:b1 or :1) with :PSR<bind_pos>__b1 or :PSR<bind_pos>__1
               and run explain plan
               --and check the predicates having :PSR from PLAN_TABLE
               and check the predicates having :B1/:b1/:1 from PLAN_TABLE
               if there is :B1/:b1/:1, :L_DYN_BIND := 'Y'
               if no, :L_DYN_BIND := 'N'
               --and join PLAN_TABLE with the predicates
   #2. if NO,  no need explain plan.

   #3.         join gv$sql_plan.other_xml (peeked_value) from memory
                    dba_hist_sql_plan.other_xml (peeked_value) from awr

               + cf gv$sql_bind_capture  from memory
                    dba_hist_sqlstat.bind_data (capture_value) from awr.

               note. other_xml can include no binds or can include only restricted peeked binds.

               <strike>:l_dyn_bind</strike>
               <s>:l_dyn_bind</s>

   #4. query 
       from PT, SM, gv$sql_plan P, DBA_TABLES T,  DBA_TAB_COLUMNS M, DBA_IND_COLUMNS IC(+)

             (   ( p.object_type = 'TABLE'  and t.table_name = p.object_name )
              or ( p.object_type = 'INDEX'  and t.table_name = (SELECT table_name from dba_indexes i where i.index_name = p.index_name) )
             )
             
   #5  dba_objects => SYS.OBJ$
   
*/

VAR L_DYN_BIND VARCHAR2(3)
BEGIN
:L_DYN_BIND := 'N';
SELECT NVL((SELECT 'Y'
            FROM ( select To_Char(upper(regexp_substr(:sql_text,':\S+',1,level))) BIND_NAME
                   from DUAL connect by level <= regexp_count(:sql_text ,':\S+')  )
            WHERE BIND_NAME IN ( ':B1',':b1',':1' )  and rownum = 1 ), 'N') INTO :L_DYN_BIND
FROM DUAL ;
END;
/

--prompt before explain
--print :L_DYN_BIND

/* collect only sql statement bind start */

delete plan_table ;
--SET SERVEROUT ON SIZE UNL;

DECLARE
  L_SQL_STMT  VARCHAR2(32700);
BEGIN
     L_SQL_STMT := '';

  IF (  :L_DYN_BIND in ( 'Y' ) ) THEN
     FOR S IN ( SELECT  replace(sql_fulltext,':',':PSR_') sql_fulltext
                FROM GV$SQL
                WHERE sql_id = :L_SQL_ID
                and rownum = 1
               )
     LOOP
         L_SQL_STMT := S.sql_fulltext;
     END LOOP;
     L_SQL_STMT := ' EXPLAIN PLAN SET STATEMENT_ID = ''SMA_PSR'' INTO PLAN_TABLE FOR '||L_SQL_STMT;
   EXECUTE IMMEDIATE L_SQL_STMT ;
  END IF ;
  EXCEPTION  WHEN OTHERS THEN
     null;
END;
/



BEGIN
SELECT NVL((SELECT 'Y'
            FROM ( select STATEMENT_ID --ACCESS_PREDICATES||' '||FILTER_PREDICATES
                   from PLAN_TABLE
                   WHERE STATEMENT_ID = 'SMA_PSR'
                   AND ( upper(ACCESS_PREDICATES||' '||FILTER_PREDICATES) LIKE '%:B1%' OR ACCESS_PREDICATES||' '||FILTER_PREDICATES LIKE '%:1%' ) )
            WHERE rownum = 1 ), 'N') INTO :L_DYN_BIND
FROM DUAL ;
END;
/

/* collect only sql statement bind end */

--set heading off  head off
set echo off  FEED OFF verify off heading off LINESIZE 300 pagesize 500 TI OFF TIMI OFF SERVEROUT ON SIZE UNL;

prompt <blue>BASED ON CURRENT STATS</blue>

pro <table>
pro <tbody><tr>
pro <th>INST_ID</th>
pro <th>PLAN_HASH_VALUE</th>
pro <th>CHILD<br>NUMBER</th>
pro <th>ID</th>
pro <th>ACCESS_PREDICATES</th>
pro <th>FILTER_PREDICATES</th>
pro <th>PEEKED<br>BIND_VALUE</th>
pro <th>LOW_VALUE</th>
pro <th>HIGH_VALUE</th>
pro <th>TABLE_OWNER</th>
pro <th>TABLE_NAME</th>
pro <th>INDEX_NAME</th>
pro <th>CP</th>
pro <th>COLUMN_NAME</th>
pro <th>BIND_NAME</th>
pro <th>BIND<br>DTYPE</th>
pro <th>COL<br>DTYPE</th>
pro <th>HISTOGRAM</th>
pro <th>OPERATION</th>
pro <th>OPTIONS</th>
pro <th>COST</th>
pro <th>CARDINALITY</th>
pro <th>SEARCH<br>COLUMNS</th>
pro <th>NUM<br>DISTINCT</th>
pro <th>NUM<br>NULLS</th>
pro <th>NUM<br>ROWS</th>
pro <th>LAST_LOAD_TIME</th>
pro <th>LAST_ANALYZED</th>
pro </tr>

select  CHR(10)||'<tr>'||CHR(10)
     ||'<td class="r">'||INST_ID||'</td>'||CHR(10)
     ||'<td class="r">'||PLAN_HASH_VALUE||'</td>'||CHR(10)
     ||'<td class="r">'||CHILD_NUMBER||'</td>'||CHR(10)
     ||'<td class="r">'||ID||'</td>'||CHR(10)
     ||'<td class="r">'||access_predicates||'</td>'||CHR(10)
     ||'<td class="r">'||filter_predicates||'</td>'||CHR(10)
     ||'<td class="r">'||PEEKED_BIND_VALUE||'</td>'||CHR(10)
     ||'<td class="r">'||LOW_VALUE||'</td>'||CHR(10)
     ||'<td class="r">'||HIGH_VALUE||'</td>'||CHR(10)
     ||'<td class="r">'||TABLE_OWNER||'</td>'||CHR(10)
     ||'<td class="r">'||TABLE_NAME||'</td>'||CHR(10)
     ||'<td class="r">'||INDEX_NAME||'</td>'||CHR(10)
     ||'<td class="r">'||CP||'</td>'||CHR(10)
     ||'<td class="r">'||COLUMN_NAME||'</td>'||CHR(10)
     ||'<td class="r">'||BIND_NAME||'</td>'||CHR(10)
     ||'<td class="r">'||decode(BIND_DTYPE,COL_DTYPE,BIND_DTYPE,'<RED>'||BIND_DTYPE||'</RED>')||'</td>'||CHR(10)
     ||'<td class="r">'||COL_DTYPE||'</td>'||CHR(10)
     ||'<td class="r">'||HISTOGRAM||'</td>'||CHR(10)
     ||'<td class="r">'||OPERATION||'</td>'||CHR(10)
     ||'<td class="r">'||OPTIONS||'</td>'||CHR(10)
     ||'<td class="r">'||COST||'</td>'||CHR(10)
     ||'<td class="r">'||CARDINALITY||'</td>'||CHR(10)
     ||'<td class="r">'||SEARCH_COLUMNS||'</td>'||CHR(10)
     ||'<td class="r">'||NUM_DISTINCT||'</td>'||CHR(10)
     ||'<td class="r">'||NUM_NULLS||'</td>'||CHR(10)
     ||'<td class="r">'||NUM_ROWS||'</td>'||CHR(10)
     ||'<td class="r">'||LAST_LOAD_TIME||'</td>'||CHR(10)
     ||'<td class="r">'||LAST_ANALYZED||'</td>'||CHR(10)
     ||'</TR>'
from (
WITH /* INDEX */ PT AS (
SELECT P.ID,
REPLACE(REPLACE( REGEXP_REPLACE(P.ACCESS_PREDICATES,':PSR\S+',
':'||SUBSTR(regexp_substr(P.ACCESS_PREDICATES,':PSR\S+',1),INSTR(regexp_substr(P.ACCESS_PREDICATES,':PSR\S+',1),'__')+2,LENGTH(regexp_substr(P.ACCESS_PREDICATES,':PSR\S+',1)))
  ),'TO_NUMBER(:', ':'),'TO_CHAR(:', ':') aACCESS_PREDICATES,
ACCESS_PREDICATES,
 SUBSTR(P.ACCESS_PREDICATES, INSTR(P.ACCESS_PREDICATES,':PSR')+4, INSTR(P.ACCESS_PREDICATES,'__')-INSTR(P.ACCESS_PREDICATES,':PSR')-4 )-1 APOSITION,
REPLACE(REPLACE( REGEXP_REPLACE(P.FILTER_PREDICATES,':PSR\S+',
':'||SUBSTR(regexp_substr(P.FILTER_PREDICATES,':PSR\S+',1),INSTR(regexp_substr(P.FILTER_PREDICATES,':PSR\S+',1),'__')+2,LENGTH(regexp_substr(P.FILTER_PREDICATES,':PSR\S+',1)))
  ),'TO_NUMBER(:', ':'),'TO_CHAR(:', ':') aFILTER_PREDICATES,
FILTER_PREDICATES,
 SUBSTR(P.FILTER_PREDICATES, INSTR(P.FILTER_PREDICATES,':PSR')+4, INSTR(P.FILTER_PREDICATES,'__')-INSTR(P.FILTER_PREDICATES,':PSR')-4 )-1 FPOSITION
FROM PLAN_TABLE  P
WHERE P.STATEMENT_ID = 'SMA_PSR'  AND  :L_DYN_BIND = 'Y'
AND ( P.ACCESS_PREDICATES LIKE '%:PSR%' OR P.FILTER_PREDICATES LIKE '%:PSR%' ) ),
SM AS  (
SELECT /*+ materialize */ c.INST_ID, c.sql_id, c.plan_hash_value, TO_DATE(LAST_LOAD_TIME,'yyyy-mm-dd hh24:mi:ss') LAST_LOAD_TIME, c.CHILD_NUMBER,
         to_number(extractValue(value(d), '/bind/@pos')) position,
         to_number(extractValue(value(d), '/bind/@pos'))+1 aposition,
         extractValue(value(d), '/bind/@nam') NAME,
         extractValue(value(d), '/bind') value  ,
         --to_number(extractValue(value(d), '/bind/@ppo')) dup_pos,
         DECODE(extractValue(value(d), '/bind/@dty'),1,'VARCHAR2',2,'NUMBER',12,'DATE',180,'TIMESTAMP',181,'TIMESTAMP', NULL ) dtype
         --to_number(extractValue(value(d), '/bind/@mxl')) max_length
    FROM   (select  inst_id, sql_id, plan_hash_value, LAST_LOAD_TIME, child_number
            from gv$sql
            where (inst_id, sql_id, plan_hash_value, LAST_LOAD_TIME) in
                 (select inst_id, sql_id, plan_hash_value, max(LAST_LOAD_TIME) LAST_LOAD_TIME
                  from gv$sql
                  where SQL_ID = :L_SQL_ID --AND :L_DYN_BIND = 'N'
                  group by inst_id, sql_id, plan_hash_value )
            and  SQL_ID = :L_SQL_ID ) s
         ,  gv$sql_plan c
         , TABLE(XMLSEQUENCE(EXTRACT(XMLTYPE(c.other_xml ), '/*/peeked_binds/bind'))) D
   where c.other_xml is not null and extractValue(value(d), '/bind') is not null
   AND s.SQL_ID = :L_SQL_ID    and c.sql_id = :L_SQL_ID
   and s.sql_id = c.sql_id and s.inst_id = c.inst_id and s.plan_hash_value = c.plan_hash_value and s.child_number = c.child_number
   )
SELECT INST_ID, PLAN_HASH_VALUE,CHILD_NUMBER, id,
--FULL_ACCESS_PREDICATES,
ACCESS_PREDICATES,
FILTER_PREDICATES,
--2021/05/27
substr(BIND_VALUE,1,length(BIND_VALUE)/3+1)||rpad('***********************************', length(BIND_VALUE)*2/3) PEEKED_BIND_VALUE,
(case when BIND_DTYPE = 'NUMBER' and COL_DTYPE = 'NUMBER'
           and to_number(BIND_VALUE) < LOW_VALUE  then '<RED>'||substr(LOW_VALUE,1,length(LOW_VALUE)/3+1)||rpad('***********************************', length(LOW_VALUE)*2/3)||'</RED>'
      when BIND_DTYPE = 'VARCHAR2' AND COL_DTYPE = 'VARCHAR2'
           and BIND_VALUE < LOW_VALUE  then '<RED>'||substr(LOW_VALUE,1,length(LOW_VALUE)/3+1)||rpad('***********************************', length(LOW_VALUE)*2/3)||'</RED>'
     ELSE  substr(LOW_VALUE,1,length(LOW_VALUE)/3+1)||rpad('***********************************', length(LOW_VALUE)*2/3)  end ) LOW_VALUE ,
(case when BIND_DTYPE = 'NUMBER' and COL_DTYPE = 'NUMBER'
           and to_number(BIND_VALUE) > HIGH_VALUE  then '<RED>'||substr(HIGH_VALUE,1,length(HIGH_VALUE)/3+1)||rpad('***********************************', length(HIGH_VALUE)*2/3)||'</RED>'
      when BIND_DTYPE = 'VARCHAR2' AND COL_DTYPE = 'VARCHAR2'
           and BIND_VALUE > HIGH_VALUE  then '<RED>'||substr(HIGH_VALUE,1,length(HIGH_VALUE)/3+1)||rpad('***********************************', length(HIGH_VALUE)*2/3)||'</RED>'
     ELSE  substr(HIGH_VALUE,1,length(HIGH_VALUE)/3+1)||rpad('***********************************', length(HIGH_VALUE)*2/3) end ) HIGH_VALUE ,
INDEX_NAME,  CP,
COLUMN_NAME,
TABLE_OWNER, TABLE_NAME,
BIND_NAME,
/*
 ( case
   when BIND_DTYPE = 'NUMBER' and to_number(BIND_VALUE) between to_number(low_value) and to_number(high_value)  then 'IN'
   when BIND_DTYPE = 'VARCHAR2' and to_char(BIND_VALUE) between to_char(low_value) and to_char(high_value)  then 'IN'
   when BIND_DTYPE = 'DATE' and to_date(BIND_VALUE) between to_date(low_value) and to_date(high_value)  then 'IN'
   when BIND_DTYPE = 'TIMESTAMP' and to_TIMESTAMP(BIND_VALUE) between to_TIMESTAMP(low_value) and to_TIMESTAMP(high_value)  then 'IN'
   ELSE 'OUT' END) WITHIN,
*/
BIND_DTYPE BIND_DTYPE,
/*
decode(:L_DYN_BIND,'Y',NULL,BIND_DTYPE) BIND_DTYPE,
*/
COL_DTYPE, HISTOGRAM, substr(OPERATION,1,20) OPERATION, substr(OPTIONS,1,20) OPTIONS, COST, CARDINALITY, SEARCH_COLUMNS
, NUM_DISTINCT,  NUM_NULLS, NUM_ROWS
, LAST_LOAD_TIME, LAST_ANALYZED
FROM (
select /*+ LEADING(PT SM P IC T M) */ --P.INST_ID, , P.sql_id, P.plan_hash_value, P.object_type,
DISTINCT p.INST_ID, P.plan_hash_value, P.CHILD_NUMBER, P.id,
P.access_predicates FULL_ACCESS_PREDICATES,
DECODE(SIGN(INSTR( P.access_predicates, '"'||IC.COLUMN_NAME||'"='||SM.NAME,1)),1,
 SUBSTR(P.access_predicates,INSTR( P.access_predicates, '"'||IC.COLUMN_NAME||'"='||SM.NAME,1),LENGTH( '"'||IC.COLUMN_NAME||'"='||SM.NAME))
 ,DECODE(SIGN(INSTR( P.access_predicates, '"'||IC.COLUMN_NAME||'">='||SM.NAME,1)),1,
   SUBSTR(P.access_predicates,INSTR( P.access_predicates, '"'||IC.COLUMN_NAME||'">='||SM.NAME,1),LENGTH( '"'||IC.COLUMN_NAME||'">='||SM.NAME))
   ,DECODE(SIGN(INSTR( P.access_predicates, '"'||IC.COLUMN_NAME||'"<='||SM.NAME,1)),1,
     SUBSTR(P.access_predicates,INSTR( P.access_predicates, '"'||IC.COLUMN_NAME||'"<='||SM.NAME,1),LENGTH( '"'||IC.COLUMN_NAME||'"<='||SM.NAME))
     ,DECODE(SIGN(INSTR( P.access_predicates, '"'||IC.COLUMN_NAME||'"=TO_NUMBER('||SM.NAME,1)),1,
       SUBSTR(P.access_predicates,INSTR( P.access_predicates, '"'||IC.COLUMN_NAME||'"=TO_NUMBER('||SM.NAME,1),LENGTH( '"'||IC.COLUMN_NAME||'"=TO_NUMBER('||SM.NAME)+1)
       ,DECODE(SIGN(INSTR( P.access_predicates, '"'||IC.COLUMN_NAME||'"<=TO_NUMBER('||SM.NAME,1)),1,
        SUBSTR(P.access_predicates,INSTR( P.access_predicates, '"'||IC.COLUMN_NAME||'"<=TO_NUMBER('||SM.NAME,1),LENGTH( '"'||IC.COLUMN_NAME||'"<=TO_NUMBER('||SM.NAME)+1)
        ,DECODE(SIGN(INSTR( P.access_predicates, '"'||IC.COLUMN_NAME||'">=TO_NUMBER('||SM.NAME,1)),1,
         SUBSTR(P.access_predicates,INSTR( P.access_predicates, '"'||IC.COLUMN_NAME||'">=TO_NUMBER('||SM.NAME,1),LENGTH( '"'||IC.COLUMN_NAME||'">=TO_NUMBER('||SM.NAME)+1)
         ,DECODE(SIGN(INSTR( P.access_predicates, '"'||IC.COLUMN_NAME||'" LIKE '||SM.NAME,1)),1,
          SUBSTR(P.access_predicates,INSTR( P.access_predicates, '"'||IC.COLUMN_NAME||'" LIKE '||SM.NAME,1),LENGTH( '"'||IC.COLUMN_NAME||'" LIKE '||SM.NAME)+1)
))))))) access_predicates,
--P.filter_predicates FULL_FILTER_PREDICATES,
DECODE(SIGN(INSTR( P.filter_predicates, '"'||IC.COLUMN_NAME||'"='||SM.NAME,1)),1,
 SUBSTR(P.filter_predicates,INSTR( P.filter_predicates, '"'||IC.COLUMN_NAME||'"='||SM.NAME,1),LENGTH( '"'||IC.COLUMN_NAME||'"='||SM.NAME))
 ,DECODE(SIGN(INSTR( P.filter_predicates, '"'||IC.COLUMN_NAME||'">='||SM.NAME,1)),1,
   SUBSTR(P.filter_predicates,INSTR( P.filter_predicates, '"'||IC.COLUMN_NAME||'">='||SM.NAME,1),LENGTH( '"'||IC.COLUMN_NAME||'">='||SM.NAME))
   ,DECODE(SIGN(INSTR( P.filter_predicates, '"'||IC.COLUMN_NAME||'"<='||SM.NAME,1)),1,
     SUBSTR(P.filter_predicates,INSTR( P.filter_predicates, '"'||IC.COLUMN_NAME||'"<='||SM.NAME,1),LENGTH( '"'||IC.COLUMN_NAME||'"<='||SM.NAME))
     ,DECODE(SIGN(INSTR( P.filter_predicates, '"'||IC.COLUMN_NAME||'"=TO_NUMBER('||SM.NAME,1)),1,
       SUBSTR(P.filter_predicates,INSTR( P.filter_predicates, '"'||IC.COLUMN_NAME||'"=TO_NUMBER('||SM.NAME,1),LENGTH( '"'||IC.COLUMN_NAME||'"=TO_NUMBER('||SM.NAME)+1)
       ,DECODE(SIGN(INSTR( P.filter_predicates, '"'||IC.COLUMN_NAME||'"<=TO_NUMBER('||SM.NAME,1)),1,
        SUBSTR(P.filter_predicates,INSTR( P.filter_predicates, '"'||IC.COLUMN_NAME||'"<=TO_NUMBER('||SM.NAME,1),LENGTH( '"'||IC.COLUMN_NAME||'"<=TO_NUMBER('||SM.NAME)+1)
        ,DECODE(SIGN(INSTR( P.filter_predicates, '"'||IC.COLUMN_NAME||'">=TO_NUMBER('||SM.NAME,1)),1,
         SUBSTR(P.filter_predicates,INSTR( P.access_predicates, '"'||IC.COLUMN_NAME||'">=TO_NUMBER('||SM.NAME,1),LENGTH( '"'||IC.COLUMN_NAME||'">=TO_NUMBER('||SM.NAME)+1)
)))))) filter_predicates,
IC.INDEX_NAME,  IC.COLUMN_POSITION CP, IC.COLUMN_NAME,
m.owner table_owner, m.table_name,
       substr(
        decode(substr(M.DATA_TYPE,1,9) -- as there are several timestamp types
          ,'NUMBER'       ,to_char(utl_raw.cast_to_number(M.low_value)) ||''
          ,'VARCHAR2'     ,to_char(utl_raw.cast_to_varchar2(M.low_value)) ||''
          ,'NVARCHAR2'    ,to_char(utl_raw.cast_to_nvarchar2(M.low_value)) ||''
          ,'BINARY_DO'    ,to_char(utl_raw.cast_to_binary_double(M.low_value)) ||''
          ,'BINARY_FL'    ,to_char(utl_raw.cast_to_binary_float(M.low_value)) ||''
          ,'DATE'         ,decode(M.low_value, NULL, NULL, rtrim(
                                to_char(100*(to_number(substr(M.low_value,1,2),'XX')-100)
                                       + (to_number(substr(M.low_value,3,2),'XX')-100),'fm0000')||'-'||
                                to_char(to_number(substr(M.low_value,5,2),'XX'),'fm00')||'-'||
                                to_char(to_number(substr(M.low_value,7,2),'XX'),'fm00')||' '||
                                to_char(to_number(substr(M.low_value,9,2),'XX')-1,'fm00')||':'||
                                to_char(to_number(substr(M.low_value,11,2),'XX')-1,'fm00')||':'||
                                to_char(to_number(substr(M.low_value,13,2),'XX')-1,'fm00'))) ||''
          ,'TIMESTAMP'    ,decode(M.low_value, NULL, NULL, rtrim(
                           to_char(100*(to_number(substr(M.low_value,1,2),'XX')-100)
                                  + (to_number(substr(M.low_value,3,2),'XX')-100),'fm0000')||'-'||
                           to_char(to_number(substr(M.low_value,5,2),'XX'),'fm00')||'-'||
                           to_char(to_number(substr(M.low_value,7,2),'XX'),'fm00')||' '||
                           to_char(to_number(substr(M.low_value,9,2),'XX')-1,'fm00')||':'||
                           to_char(to_number(substr(M.low_value,11,2),'XX')-1,'fm00')||':'||
                           to_char(to_number(substr(M.low_value,13,2),'XX')-1,'fm00')
                          ||'.'||to_number(substr(M.low_value,15,8),'XXXXXXXX')  )) ||''
          , M.low_value
        ),1,30) low_value,
       substr(
        decode(substr(M.DATA_TYPE,1,9) -- as there are several timestamp types
          ,'NUMBER'       ,to_char(utl_raw.cast_to_number(M.high_value)) ||''
          ,'VARCHAR2'     ,to_char(utl_raw.cast_to_varchar2(M.high_value)) ||''
          ,'NVARCHAR2'    ,to_char(utl_raw.cast_to_nvarchar2(M.high_value)) ||''
          ,'BINARY_DO'    ,to_char(utl_raw.cast_to_binary_double(M.high_value)) ||''
          ,'DATE'         ,decode(M.high_value, NULL, NULL, rtrim(
                                to_char(100*(to_number(substr(M.high_value,1,2),'XX')-100)
                                       + (to_number(substr(M.high_value,3,2),'XX')-100),'fm0000')||'-'||
                                to_char(to_number(substr(M.high_value,5,2),'XX'),'fm00')||'-'||
                                to_char(to_number(substr(M.high_value,7,2),'XX'),'fm00')||' '||
                                to_char(to_number(substr(M.high_value,9,2),'XX')-1,'fm00')||':'||
                                to_char(to_number(substr(M.high_value,11,2),'XX')-1,'fm00')||':'||
                                to_char(to_number(substr(M.high_value,13,2),'XX')-1,'fm00'))) ||''
          ,'TIMESTAMP'    ,decode(M.high_value, NULL, NULL, rtrim(
                           to_char(100*(to_number(substr(M.high_value,1,2),'XX')-100)
                                  + (to_number(substr(M.high_value,3,2),'XX')-100),'fm0000')||'-'||
                           to_char(to_number(substr(M.high_value,5,2),'XX'),'fm00')||'-'||
                           to_char(to_number(substr(M.high_value,7,2),'XX'),'fm00')||' '||
                           to_char(to_number(substr(M.high_value,9,2),'XX')-1,'fm00')||':'||
                           to_char(to_number(substr(M.high_value,11,2),'XX')-1,'fm00')||':'||
                           to_char(to_number(substr(M.high_value,13,2),'XX')-1,'fm00')
                          ||'.'||to_char(to_number(substr(M.high_value,15,8),'XXXXXXXX')))) ||''
          , M.high_value
       ),1,30) high_value,
        SM.NAME BIND_NAME,
        substr(
        decode( SUBSTR(SM.dtype,1,9)
          ,'NUMBER'       ,to_char(utl_raw.cast_to_number(SM.VALUE)) ||''
          ,'VARCHAR2'     ,to_char(utl_raw.cast_to_varchar2(SM.VALUE)) ||''
          ,'NVARCHAR2'    ,to_char(utl_raw.cast_to_nvarchar2(SM.VALUE)) ||''
          ,'BINARY_DO'    ,to_char(utl_raw.cast_to_binary_double(SM.VALUE)) ||''
          ,'DATE'         ,decode(SM.VALUE, NULL, NULL, rtrim(
                                to_char(100*(to_number(substr(SM.VALUE,1,2),'XX')-100)
                                       + (to_number(substr(SM.VALUE,3,2),'XX')-100),'fm0000')||'-'||
                                to_char(to_number(substr(SM.VALUE,5,2),'XX'),'fm00')||'-'||
                                to_char(to_number(substr(SM.VALUE,7,2),'XX'),'fm00')||' '||
                                to_char(to_number(substr(SM.VALUE,9,2),'XX')-1,'fm00')||':'||
                                to_char(to_number(substr(SM.VALUE,11,2),'XX')-1,'fm00')||':'||
                                to_char(to_number(substr(SM.VALUE,13,2),'XX')-1,'fm00'))) ||''
          ,'TIMESTAMP'    ,decode(SM.VALUE, NULL, NULL, rtrim(
                           to_char(100*(to_number(substr(SM.VALUE,1,2),'XX')-100)
                                  + (to_number(substr(SM.VALUE,3,2),'XX')-100),'fm0000')||'-'||
                           to_char(to_number(substr(SM.VALUE,5,2),'XX'),'fm00')||'-'||
                           to_char(to_number(substr(SM.VALUE,7,2),'XX'),'fm00')||' '||
                           to_char(to_number(substr(SM.VALUE,9,2),'XX')-1,'fm00')||':'||
                           to_char(to_number(substr(SM.VALUE,11,2),'XX')-1,'fm00')||':'||
                           to_char(to_number(substr(SM.VALUE,13,2),'XX')-1,'fm00')
                          ||'.'||to_char(to_number(substr(SM.VALUE,15,8),'XXXXXXXX')))) ||''
          , SM.VALUE
       ),1,30) BIND_VALUE,
       --( case when SM.VALUE between M.low_value and M.high_value then 'IN' ELSE 'OUT' END) WITHIN,
       SM.DTYPE BIND_DTYPE,
       M.DATA_TYPE COL_DTYPE, m.HISTOGRAM,
       p.OPERATION, p.OPTIONS, p.SEARCH_COLUMNS, P.COST, P.CARDINALITY
       , M.NUM_DISTINCT,  M.NUM_NULLS, T.NUM_ROWS - M.NUM_NULLS NUM_ROWS
       , sm.LAST_LOAD_TIME, t.last_analyzed
from PT, SM, gv$sql_plan P, DBA_IND_COLUMNS IC, DBA_TABLES T,  DBA_TAB_COLUMNS M
where :L_DYN_BIND = 'Y'
--20201118
AND   :L_SQLHC_MIN_FLAG < 15
AND   ( ( PT.APOSITION = SM.POSITION AND ( PT.ACCESS_PREDICATES LIKE '%'||IC.COLUMN_NAME||'%'||':PSR'||SM.aPOSITION||replace(SM.NAME,':','__')||'%' ) )
     OR ( PT.FPOSITION = SM.POSITION AND ( PT.FILTER_PREDICATES LIKE '%'||IC.COLUMN_NAME||'%'||':PSR'||SM.aPOSITION||replace(SM.NAME,':','__')||'%' ) ))
AND ( SUBSTR( PT.aACCESS_PREDICATES,INSTR(PT.aACCESS_PREDICATES,':')-4,7)
      = SUBSTR(P.ACCESS_PREDICATES,INSTR(P.ACCESS_PREDICATES,':')-4,7)
  OR  SUBSTR( PT.aFILTER_PREDICATES,INSTR(PT.aFILTER_PREDICATES,':')-4,7)
      LIKE SUBSTR(P.FILTER_PREDICATES,INSTR(P.FILTER_PREDICATES,':')-4,6)||')'
  OR  SUBSTR( PT.aACCESS_PREDICATES,INSTR(PT.aACCESS_PREDICATES,':')-4,7)
      = SUBSTR(P.ACCESS_PREDICATES,INSTR(P.ACCESS_PREDICATES,':')-4,7)
  OR  SUBSTR( PT.aFILTER_PREDICATES,INSTR(PT.aFILTER_PREDICATES,':')-4,7)
      LIKE SUBSTR(P.FILTER_PREDICATES,INSTR(P.FILTER_PREDICATES,':')-4,6)||')'  )
AND
(  P.access_predicates like '%=:%'  or P.filter_predicates like '%=:%'
OR P.access_predicates like '%<=:%'  or P.filter_predicates like '%<=:%'
OR P.access_predicates like '%>=:%'  or P.filter_predicates like '%>=:%'
OR P.access_predicates like '%=TO_NUMBER(:%'  or P.filter_predicates like '%=TO_NUMBER(:%'
OR P.access_predicates like '%<=TO_NUMBER(:%'  or P.filter_predicates like '%<=TO_NUMBER(:%'
OR P.access_predicates like '%>=TO_NUMBER(:%'  or P.filter_predicates like '%>=TO_NUMBER(:%'
OR P.access_predicates like '% LIKE :%'  or P.filter_predicates like '% LIKE :%'
)
and ( P.access_predicates not like '%"SESSION_ROLE_SET_KEY"="FND_GLOBAL"."SESSION_ROLE_SET_KEY"%'
and    P.access_predicates not like '%"SANDBOX_ID"=SYS_CONTEXT(''FND_VPD_CTX''%'
and    P.access_predicates not like '%"USER_GUID"="FND_GLOBAL"."USER_GUID"()%'
and    P.access_predicates not like '%"ENTERPRISE_ID"=%"FUNCTION_ID"=%' )
and  ( P.object_type LIKE 'INDEX%'
--or P.object_type LIKE 'TABLE%' /* IC should be outer joined */
)
and T.TABLE_NAME   = IC.TABLE_NAME
AND T.OWNER        = IC.TABLE_OWNER
and IC.INDEX_NAME  = P.OBJECT_NAME
AND IC.INDEX_OWNER = P.OBJECT_OWNER
and P.SQL_ID = :L_SQL_ID
AND ( P.access_predicates LIKE '%"'||IC.COLUMN_NAME||'"=:%'   or P.filter_predicates LIKE '%"'||IC.COLUMN_NAME||'"=:%'
   OR P.access_predicates LIKE '%"'||IC.COLUMN_NAME||'"<=:%'  or P.filter_predicates LIKE '%"'||IC.COLUMN_NAME||'"<=:%'
   OR P.access_predicates LIKE '%"'||IC.COLUMN_NAME||'">=:%'  or P.filter_predicates LIKE '%"'||IC.COLUMN_NAME||'">=:%'
   OR P.access_predicates LIKE '%"'||IC.COLUMN_NAME||'"=TO_NUMBER(:%'   or P.filter_predicates LIKE '%"'||IC.COLUMN_NAME||'"=TO_NUMBER(:%'
   OR P.access_predicates LIKE '%"'||IC.COLUMN_NAME||'"<=TO_NUMBER(:%'  or P.filter_predicates LIKE '%"'||IC.COLUMN_NAME||'"<=TO_NUMBER(:%'
   OR P.access_predicates LIKE '%"'||IC.COLUMN_NAME||'">=TO_NUMBER(:%'  or P.filter_predicates LIKE '%"'||IC.COLUMN_NAME||'">=TO_NUMBER(:%' 
   OR P.access_predicates LIKE '%"'||IC.COLUMN_NAME||'" LIKE :%'  or P.filter_predicates LIKE '%"'||IC.COLUMN_NAME||'" LIKE :%' )
AND P.OPTIONS NOT IN ('FAST FULL SCAN','SAMPLE FAST FULL SCAN')
AND M.OWNER       = IC.TABLE_OWNER
AND M.TABLE_NAME  = IC.TABLE_NAME
AND M.COLUMN_NAME = IC.COLUMN_NAME
--------------
AND P.INST_ID          = SM.INST_ID
AND P.SQL_ID           = SM.SQL_ID
AND P.CHILD_NUMBER     = SM.CHILD_NUMBER
AND P.PLAN_HASH_VALUE  = SM.PLAN_HASH_VALUE
--------------
AND ( P.access_predicates LIKE '%"'||IC.COLUMN_NAME||'"='||SM.NAME||'%'  or P.filter_predicates LIKE '%"'||IC.COLUMN_NAME||'"='||SM.NAME||'%'
   OR P.access_predicates LIKE '%"'||IC.COLUMN_NAME||'"<='||SM.NAME||'%' or P.filter_predicates LIKE '%"'||IC.COLUMN_NAME||'"<='||SM.NAME||'%'
   OR P.access_predicates LIKE '%"'||IC.COLUMN_NAME||'">='||SM.NAME||'%' or P.filter_predicates LIKE '%"'||IC.COLUMN_NAME||'">='||SM.NAME||'%'
   OR P.access_predicates LIKE '%"'||IC.COLUMN_NAME||'"=TO_NUMBER('||SM.NAME||'%' or P.filter_predicates LIKE '%"'||IC.COLUMN_NAME||'"=TO_NUMBER('||SM.NAME||'%'
   OR P.access_predicates LIKE '%"'||IC.COLUMN_NAME||'"<=TO_NUMBER('||SM.NAME||'%' or P.filter_predicates LIKE '%"'||IC.COLUMN_NAME||'"<=TO_NUMBER('||SM.NAME||'%'
   OR P.access_predicates LIKE '%"'||IC.COLUMN_NAME||'">=TO_NUMBER('||SM.NAME||'%' or P.filter_predicates LIKE '%"'||IC.COLUMN_NAME||'">=TO_NUMBER('||SM.NAME||'%' 
   OR P.access_predicates LIKE '%"'||IC.COLUMN_NAME||'" LIKE '||SM.NAME||'%' or P.filter_predicates LIKE '%"'||IC.COLUMN_NAME||'" LIKE '||SM.NAME||'%'
   )
--ORDER BY P.ID, IC.INDEX_NAME, IC.COLUMN_POSITION
)
union all
SELECT INST_ID, PLAN_HASH_VALUE,CHILD_NUMBER, id,
--FULL_ACCESS_PREDICATES,
ACCESS_PREDICATES,
FILTER_PREDICATES,
--2021/05/27
substr(BIND_VALUE,1,length(BIND_VALUE)/3+1)||rpad('***********************************', length(BIND_VALUE)*2/3) PEEKED_BIND_VALUE,
(case when BIND_DTYPE = 'NUMBER' and COL_DTYPE = 'NUMBER'
           and to_number(BIND_VALUE) < LOW_VALUE  then '<RED>'||substr(LOW_VALUE,1,length(LOW_VALUE)/3+1)||rpad('***********************************', length(LOW_VALUE)*2/3)||'</RED>'
      when BIND_DTYPE = 'VARCHAR2' AND COL_DTYPE = 'VARCHAR2'
           and BIND_VALUE < LOW_VALUE  then '<RED>'||substr(LOW_VALUE,1,length(LOW_VALUE)/3+1)||rpad('***********************************', length(LOW_VALUE)*2/3)||'</RED>'
     ELSE  substr(LOW_VALUE,1,length(LOW_VALUE)/3+1)||rpad('***********************************', length(LOW_VALUE)*2/3)  end ) LOW_VALUE ,
(case when BIND_DTYPE = 'NUMBER' and COL_DTYPE = 'NUMBER'
           and to_number(BIND_VALUE) > HIGH_VALUE  then '<RED>'||substr(HIGH_VALUE,1,length(HIGH_VALUE)/3+1)||rpad('***********************************', length(HIGH_VALUE)*2/3)||'</RED>'
      when BIND_DTYPE = 'VARCHAR2' AND COL_DTYPE = 'VARCHAR2'
           and BIND_VALUE > HIGH_VALUE  then '<RED>'||substr(HIGH_VALUE,1,length(HIGH_VALUE)/3+1)||rpad('***********************************', length(HIGH_VALUE)*2/3)||'</RED>'
     ELSE  substr(HIGH_VALUE,1,length(HIGH_VALUE)/3+1)||rpad('***********************************', length(HIGH_VALUE)*2/3) end ) HIGH_VALUE ,
INDEX_NAME,  CP,
COLUMN_NAME,
TABLE_OWNER, TABLE_NAME,
BIND_NAME,
/*
 ( case
   when BIND_DTYPE = 'NUMBER' and to_number(BIND_VALUE) between to_number(low_value) and to_number(high_value)  then 'IN'
   when BIND_DTYPE = 'VARCHAR2' and to_char(BIND_VALUE) between to_char(low_value) and to_char(high_value)  then 'IN'
   when BIND_DTYPE = 'DATE' and to_date(BIND_VALUE) between to_date(low_value) and to_date(high_value)  then 'IN'
   when BIND_DTYPE = 'TIMESTAMP' and to_TIMESTAMP(BIND_VALUE) between to_TIMESTAMP(low_value) and to_TIMESTAMP(high_value)  then 'IN'
   ELSE 'OUT' END) WITHIN,
*/
BIND_DTYPE BIND_DTYPE,
/*
decode(:L_DYN_BIND,'Y',NULL,BIND_DTYPE) BIND_DTYPE,
*/
COL_DTYPE, HISTOGRAM, substr(OPERATION,1,20) OPERATION, substr(OPTIONS,1,20) OPTIONS, COST, CARDINALITY, SEARCH_COLUMNS
, NUM_DISTINCT,  NUM_NULLS, NUM_ROWS
, LAST_LOAD_TIME, LAST_ANALYZED
FROM (
select /*+ LEADING(PT SM P IC T M) */ --P.INST_ID, , P.sql_id, P.plan_hash_value, P.object_type,
DISTINCT p.INST_ID, P.plan_hash_value, P.CHILD_NUMBER, P.id,
P.access_predicates FULL_ACCESS_PREDICATES,
DECODE(SIGN(INSTR( P.access_predicates, '"'||IC.COLUMN_NAME||'"='||SM.NAME,1)),1,
 SUBSTR(P.access_predicates,INSTR( P.access_predicates, '"'||IC.COLUMN_NAME||'"='||SM.NAME,1),LENGTH( '"'||IC.COLUMN_NAME||'"='||SM.NAME))
 ,DECODE(SIGN(INSTR( P.access_predicates, '"'||IC.COLUMN_NAME||'">='||SM.NAME,1)),1,
   SUBSTR(P.access_predicates,INSTR( P.access_predicates, '"'||IC.COLUMN_NAME||'">='||SM.NAME,1),LENGTH( '"'||IC.COLUMN_NAME||'">='||SM.NAME))
   ,DECODE(SIGN(INSTR( P.access_predicates, '"'||IC.COLUMN_NAME||'"<='||SM.NAME,1)),1,
     SUBSTR(P.access_predicates,INSTR( P.access_predicates, '"'||IC.COLUMN_NAME||'"<='||SM.NAME,1),LENGTH( '"'||IC.COLUMN_NAME||'"<='||SM.NAME))
     ,DECODE(SIGN(INSTR( P.access_predicates, '"'||IC.COLUMN_NAME||'"=TO_NUMBER('||SM.NAME,1)),1,
       SUBSTR(P.access_predicates,INSTR( P.access_predicates, '"'||IC.COLUMN_NAME||'"=TO_NUMBER('||SM.NAME,1),LENGTH( '"'||IC.COLUMN_NAME||'"=TO_NUMBER('||SM.NAME)+1)
       ,DECODE(SIGN(INSTR( P.access_predicates, '"'||IC.COLUMN_NAME||'"<=TO_NUMBER('||SM.NAME,1)),1,
        SUBSTR(P.access_predicates,INSTR( P.access_predicates, '"'||IC.COLUMN_NAME||'"<=TO_NUMBER('||SM.NAME,1),LENGTH( '"'||IC.COLUMN_NAME||'"<=TO_NUMBER('||SM.NAME)+1)
        ,DECODE(SIGN(INSTR( P.access_predicates, '"'||IC.COLUMN_NAME||'">=TO_NUMBER('||SM.NAME,1)),1,
         SUBSTR(P.access_predicates,INSTR( P.access_predicates, '"'||IC.COLUMN_NAME||'">=TO_NUMBER('||SM.NAME,1),LENGTH( '"'||IC.COLUMN_NAME||'">=TO_NUMBER('||SM.NAME)+1)
         ,DECODE(SIGN(INSTR( P.access_predicates, '"'||IC.COLUMN_NAME||'" LIKE '||SM.NAME,1)),1,
          SUBSTR(P.access_predicates,INSTR( P.access_predicates, '"'||IC.COLUMN_NAME||'" LIKE '||SM.NAME,1),LENGTH( '"'||IC.COLUMN_NAME||'" LIKE '||SM.NAME)+1)
))))))) access_predicates,
--P.filter_predicates FULL_FILTER_PREDICATES,
DECODE(SIGN(INSTR( P.filter_predicates, '"'||IC.COLUMN_NAME||'"='||SM.NAME,1)),1,
 SUBSTR(P.filter_predicates,INSTR( P.filter_predicates, '"'||IC.COLUMN_NAME||'"='||SM.NAME,1),LENGTH( '"'||IC.COLUMN_NAME||'"='||SM.NAME))
 ,DECODE(SIGN(INSTR( P.filter_predicates, '"'||IC.COLUMN_NAME||'">='||SM.NAME,1)),1,
   SUBSTR(P.filter_predicates,INSTR( P.filter_predicates, '"'||IC.COLUMN_NAME||'">='||SM.NAME,1),LENGTH( '"'||IC.COLUMN_NAME||'">='||SM.NAME))
   ,DECODE(SIGN(INSTR( P.filter_predicates, '"'||IC.COLUMN_NAME||'"<='||SM.NAME,1)),1,
     SUBSTR(P.filter_predicates,INSTR( P.filter_predicates, '"'||IC.COLUMN_NAME||'"<='||SM.NAME,1),LENGTH( '"'||IC.COLUMN_NAME||'"<='||SM.NAME))
     ,DECODE(SIGN(INSTR( P.filter_predicates, '"'||IC.COLUMN_NAME||'"=TO_NUMBER('||SM.NAME,1)),1,
       SUBSTR(P.filter_predicates,INSTR( P.filter_predicates, '"'||IC.COLUMN_NAME||'"=TO_NUMBER('||SM.NAME,1),LENGTH( '"'||IC.COLUMN_NAME||'"=TO_NUMBER('||SM.NAME)+1)
       ,DECODE(SIGN(INSTR( P.filter_predicates, '"'||IC.COLUMN_NAME||'"<=TO_NUMBER('||SM.NAME,1)),1,
        SUBSTR(P.filter_predicates,INSTR( P.filter_predicates, '"'||IC.COLUMN_NAME||'"<=TO_NUMBER('||SM.NAME,1),LENGTH( '"'||IC.COLUMN_NAME||'"<=TO_NUMBER('||SM.NAME)+1)
        ,DECODE(SIGN(INSTR( P.filter_predicates, '"'||IC.COLUMN_NAME||'">=TO_NUMBER('||SM.NAME,1)),1,
         SUBSTR(P.filter_predicates,INSTR( P.access_predicates, '"'||IC.COLUMN_NAME||'">=TO_NUMBER('||SM.NAME,1),LENGTH( '"'||IC.COLUMN_NAME||'">=TO_NUMBER('||SM.NAME)+1)
)))))) filter_predicates,
IC.INDEX_NAME,  IC.COLUMN_POSITION CP, IC.COLUMN_NAME,
m.owner table_owner, m.table_name,
       substr(
        decode(substr(M.DATA_TYPE,1,9) -- as there are several timestamp types
          ,'NUMBER'       ,to_char(utl_raw.cast_to_number(M.low_value)) ||''
          ,'VARCHAR2'     ,to_char(utl_raw.cast_to_varchar2(M.low_value)) ||''
          ,'NVARCHAR2'    ,to_char(utl_raw.cast_to_nvarchar2(M.low_value)) ||''
          ,'BINARY_DO'    ,to_char(utl_raw.cast_to_binary_double(M.low_value)) ||''
          ,'BINARY_FL'    ,to_char(utl_raw.cast_to_binary_float(M.low_value)) ||''
          ,'DATE'         ,decode(M.low_value, NULL, NULL, rtrim(
                                to_char(100*(to_number(substr(M.low_value,1,2),'XX')-100)
                                       + (to_number(substr(M.low_value,3,2),'XX')-100),'fm0000')||'-'||
                                to_char(to_number(substr(M.low_value,5,2),'XX'),'fm00')||'-'||
                                to_char(to_number(substr(M.low_value,7,2),'XX'),'fm00')||' '||
                                to_char(to_number(substr(M.low_value,9,2),'XX')-1,'fm00')||':'||
                                to_char(to_number(substr(M.low_value,11,2),'XX')-1,'fm00')||':'||
                                to_char(to_number(substr(M.low_value,13,2),'XX')-1,'fm00'))) ||''
          ,'TIMESTAMP'    ,decode(M.low_value, NULL, NULL, rtrim(
                           to_char(100*(to_number(substr(M.low_value,1,2),'XX')-100)
                                  + (to_number(substr(M.low_value,3,2),'XX')-100),'fm0000')||'-'||
                           to_char(to_number(substr(M.low_value,5,2),'XX'),'fm00')||'-'||
                           to_char(to_number(substr(M.low_value,7,2),'XX'),'fm00')||' '||
                           to_char(to_number(substr(M.low_value,9,2),'XX')-1,'fm00')||':'||
                           to_char(to_number(substr(M.low_value,11,2),'XX')-1,'fm00')||':'||
                           to_char(to_number(substr(M.low_value,13,2),'XX')-1,'fm00')
                          ||'.'||to_number(substr(M.low_value,15,8),'XXXXXXXX')  )) ||''
          , M.low_value
        ),1,30) low_value,
       substr(
        decode(substr(M.DATA_TYPE,1,9) -- as there are several timestamp types
          ,'NUMBER'       ,to_char(utl_raw.cast_to_number(M.high_value)) ||''
          ,'VARCHAR2'     ,to_char(utl_raw.cast_to_varchar2(M.high_value)) ||''
          ,'NVARCHAR2'    ,to_char(utl_raw.cast_to_nvarchar2(M.high_value)) ||''
          ,'BINARY_DO'    ,to_char(utl_raw.cast_to_binary_double(M.high_value)) ||''
          ,'DATE'         ,decode(M.high_value, NULL, NULL, rtrim(
                                to_char(100*(to_number(substr(M.high_value,1,2),'XX')-100)
                                       + (to_number(substr(M.high_value,3,2),'XX')-100),'fm0000')||'-'||
                                to_char(to_number(substr(M.high_value,5,2),'XX'),'fm00')||'-'||
                                to_char(to_number(substr(M.high_value,7,2),'XX'),'fm00')||' '||
                                to_char(to_number(substr(M.high_value,9,2),'XX')-1,'fm00')||':'||
                                to_char(to_number(substr(M.high_value,11,2),'XX')-1,'fm00')||':'||
                                to_char(to_number(substr(M.high_value,13,2),'XX')-1,'fm00'))) ||''
          ,'TIMESTAMP'    ,decode(M.high_value, NULL, NULL, rtrim(
                           to_char(100*(to_number(substr(M.high_value,1,2),'XX')-100)
                                  + (to_number(substr(M.high_value,3,2),'XX')-100),'fm0000')||'-'||
                           to_char(to_number(substr(M.high_value,5,2),'XX'),'fm00')||'-'||
                           to_char(to_number(substr(M.high_value,7,2),'XX'),'fm00')||' '||
                           to_char(to_number(substr(M.high_value,9,2),'XX')-1,'fm00')||':'||
                           to_char(to_number(substr(M.high_value,11,2),'XX')-1,'fm00')||':'||
                           to_char(to_number(substr(M.high_value,13,2),'XX')-1,'fm00')
                          ||'.'||to_char(to_number(substr(M.high_value,15,8),'XXXXXXXX')))) ||''
          , M.high_value
       ),1,30) high_value,
        SM.NAME BIND_NAME,
        substr(
        decode( SUBSTR(SM.dtype,1,9)
          ,'NUMBER'       ,to_char(utl_raw.cast_to_number(SM.VALUE)) ||''
          ,'VARCHAR2'     ,to_char(utl_raw.cast_to_varchar2(SM.VALUE)) ||''
          ,'NVARCHAR2'    ,to_char(utl_raw.cast_to_nvarchar2(SM.VALUE)) ||''
          ,'BINARY_DO'    ,to_char(utl_raw.cast_to_binary_double(SM.VALUE)) ||''
          ,'DATE'         ,decode(SM.VALUE, NULL, NULL, rtrim(
                                to_char(100*(to_number(substr(SM.VALUE,1,2),'XX')-100)
                                       + (to_number(substr(SM.VALUE,3,2),'XX')-100),'fm0000')||'-'||
                                to_char(to_number(substr(SM.VALUE,5,2),'XX'),'fm00')||'-'||
                                to_char(to_number(substr(SM.VALUE,7,2),'XX'),'fm00')||' '||
                                to_char(to_number(substr(SM.VALUE,9,2),'XX')-1,'fm00')||':'||
                                to_char(to_number(substr(SM.VALUE,11,2),'XX')-1,'fm00')||':'||
                                to_char(to_number(substr(SM.VALUE,13,2),'XX')-1,'fm00'))) ||''
          ,'TIMESTAMP'    ,decode(SM.VALUE, NULL, NULL, rtrim(
                           to_char(100*(to_number(substr(SM.VALUE,1,2),'XX')-100)
                                  + (to_number(substr(SM.VALUE,3,2),'XX')-100),'fm0000')||'-'||
                           to_char(to_number(substr(SM.VALUE,5,2),'XX'),'fm00')||'-'||
                           to_char(to_number(substr(SM.VALUE,7,2),'XX'),'fm00')||' '||
                           to_char(to_number(substr(SM.VALUE,9,2),'XX')-1,'fm00')||':'||
                           to_char(to_number(substr(SM.VALUE,11,2),'XX')-1,'fm00')||':'||
                           to_char(to_number(substr(SM.VALUE,13,2),'XX')-1,'fm00')
                          ||'.'||to_char(to_number(substr(SM.VALUE,15,8),'XXXXXXXX')))) ||''
          , SM.VALUE
       ),1,30) BIND_VALUE,
       --( case when SM.VALUE between M.low_value and M.high_value then 'IN' ELSE 'OUT' END) WITHIN,
       SM.DTYPE BIND_DTYPE,
       M.DATA_TYPE COL_DTYPE, m.HISTOGRAM,
       p.OPERATION, p.OPTIONS, p.SEARCH_COLUMNS, P.COST, P.CARDINALITY
       , M.NUM_DISTINCT,  M.NUM_NULLS, T.NUM_ROWS - M.NUM_NULLS NUM_ROWS
       , sm.LAST_LOAD_TIME, t.last_analyzed
from  SM, gv$sql_plan P, DBA_IND_COLUMNS IC, DBA_TABLES T,  DBA_TAB_COLUMNS M
where :L_DYN_BIND = 'N'  
--20201118
AND   :L_SQLHC_MIN_FLAG < 15
/*
AND ( SUBSTR( PT.ACCESS_PREDICATES,INSTR(PT.ACCESS_PREDICATES,':')-4,7)
      = SUBSTR(P.ACCESS_PREDICATES,INSTR(P.ACCESS_PREDICATES,':')-4,7)
  OR  SUBSTR( PT.FILTER_PREDICATES,INSTR(PT.FILTER_PREDICATES,':')-4,7)
      LIKE SUBSTR(P.FILTER_PREDICATES,INSTR(P.FILTER_PREDICATES,':')-4,6)||')'
  OR  SUBSTR( PT.ACCESS_PREDICATES,INSTR(PT.ACCESS_PREDICATES,':')-4,7)
      = SUBSTR(P.ACCESS_PREDICATES,INSTR(P.ACCESS_PREDICATES,':')-4,7)
  OR  SUBSTR( PT.FILTER_PREDICATES,INSTR(PT.FILTER_PREDICATES,':')-4,7)
      LIKE SUBSTR(P.FILTER_PREDICATES,INSTR(P.FILTER_PREDICATES,':')-4,6)||')'  )
*/      
AND
( P.access_predicates like '%=:%'  or P.filter_predicates like '%=:%'
OR P.access_predicates like '%<=:%'  or P.filter_predicates like '%<=:%'
OR P.access_predicates like '%>=:%'  or P.filter_predicates like '%>=:%'
OR P.access_predicates like '%=TO_NUMBER(:%'  or P.filter_predicates like '%=TO_NUMBER(:%'
OR P.access_predicates like '%<=TO_NUMBER(:%'  or P.filter_predicates like '%<=TO_NUMBER(:%'
OR P.access_predicates like '%>=TO_NUMBER(:%'  or P.filter_predicates like '%>=TO_NUMBER(:%'
OR P.access_predicates like '% LIKE :%'  or P.filter_predicates like '% LIKE :%'
)
and ( P.access_predicates not like '%"SESSION_ROLE_SET_KEY"="FND_GLOBAL"."SESSION_ROLE_SET_KEY"%'
and    P.access_predicates not like '%"SANDBOX_ID"=SYS_CONTEXT(''FND_VPD_CTX''%'
and    P.access_predicates not like '%"USER_GUID"="FND_GLOBAL"."USER_GUID"()%'
and    P.access_predicates not like '%"ENTERPRISE_ID"=%"FUNCTION_ID"=%' )
and  ( P.object_type LIKE 'INDEX%'
--or P.object_type LIKE 'TABLE%' /* IC should be outer joined */
)
and T.TABLE_NAME   = IC.TABLE_NAME
AND T.OWNER        = IC.TABLE_OWNER
and IC.INDEX_NAME  = P.OBJECT_NAME
AND IC.INDEX_OWNER = P.OBJECT_OWNER
and P.SQL_ID = :L_SQL_ID
AND ( P.access_predicates LIKE '%"'||IC.COLUMN_NAME||'"=:%'   or P.filter_predicates LIKE '%"'||IC.COLUMN_NAME||'"=:%'
   OR P.access_predicates LIKE '%"'||IC.COLUMN_NAME||'"<=:%'  or P.filter_predicates LIKE '%"'||IC.COLUMN_NAME||'"<=:%'
   OR P.access_predicates LIKE '%"'||IC.COLUMN_NAME||'">=:%'  or P.filter_predicates LIKE '%"'||IC.COLUMN_NAME||'">=:%'
   OR P.access_predicates LIKE '%"'||IC.COLUMN_NAME||'"=TO_NUMBER(:%'   or P.filter_predicates LIKE '%"'||IC.COLUMN_NAME||'"=TO_NUMBER(:%'
   OR P.access_predicates LIKE '%"'||IC.COLUMN_NAME||'"<=TO_NUMBER(:%'  or P.filter_predicates LIKE '%"'||IC.COLUMN_NAME||'"<=TO_NUMBER(:%'
   OR P.access_predicates LIKE '%"'||IC.COLUMN_NAME||'">=TO_NUMBER(:%'  or P.filter_predicates LIKE '%"'||IC.COLUMN_NAME||'">=TO_NUMBER(:%'
   OR P.access_predicates LIKE '%"'||IC.COLUMN_NAME||'" LIKE :%'  or P.filter_predicates LIKE '%"'||IC.COLUMN_NAME||'" LIKE :%' )
AND P.OPTIONS NOT IN ('FAST FULL SCAN','SAMPLE FAST FULL SCAN')
AND M.OWNER       = IC.TABLE_OWNER
AND M.TABLE_NAME  = IC.TABLE_NAME
AND M.COLUMN_NAME = IC.COLUMN_NAME
--------------
AND P.INST_ID          = SM.INST_ID
AND P.SQL_ID           = SM.SQL_ID
AND P.CHILD_NUMBER     = SM.CHILD_NUMBER
AND P.PLAN_HASH_VALUE  = SM.PLAN_HASH_VALUE
--------------
AND ( P.access_predicates LIKE '%"'||IC.COLUMN_NAME||'"='||SM.NAME||'%'  or P.filter_predicates LIKE '%"'||IC.COLUMN_NAME||'"='||SM.NAME||'%'
   OR P.access_predicates LIKE '%"'||IC.COLUMN_NAME||'"<='||SM.NAME||'%' or P.filter_predicates LIKE '%"'||IC.COLUMN_NAME||'"<='||SM.NAME||'%'
   OR P.access_predicates LIKE '%"'||IC.COLUMN_NAME||'">='||SM.NAME||'%' or P.filter_predicates LIKE '%"'||IC.COLUMN_NAME||'">='||SM.NAME||'%'
   OR P.access_predicates LIKE '%"'||IC.COLUMN_NAME||'"=TO_NUMBER('||SM.NAME||'%' or P.filter_predicates LIKE '%"'||IC.COLUMN_NAME||'"=TO_NUMBER('||SM.NAME||'%'
   OR P.access_predicates LIKE '%"'||IC.COLUMN_NAME||'"<=TO_NUMBER('||SM.NAME||'%' or P.filter_predicates LIKE '%"'||IC.COLUMN_NAME||'"<=TO_NUMBER('||SM.NAME||'%'
   OR P.access_predicates LIKE '%"'||IC.COLUMN_NAME||'">=TO_NUMBER('||SM.NAME||'%' or P.filter_predicates LIKE '%"'||IC.COLUMN_NAME||'">=TO_NUMBER('||SM.NAME||'%' 
   OR P.access_predicates LIKE '%"'||IC.COLUMN_NAME||'" LIKE '||SM.NAME||'%' or P.filter_predicates LIKE '%"'||IC.COLUMN_NAME||'" LIKE '||SM.NAME||'%'
   )
--ORDER BY P.ID, IC.INDEX_NAME, IC.COLUMN_POSITION
)
ORDER BY INST_ID, CHILD_NUMBER, PLAN_HASH_VALUE,  ID, INDEX_NAME, CP
)
/


pro </tbody>
pro  </table>

pro <table>
pro <tbody><tr>
pro <th>INST_ID</th>
pro <th>PLAN_HASH_VALUE</th>
pro <th>CHILD<br>NUMBER</th>
pro <th>ID</th>
pro <th>ACCESS_PREDICATES</th>
pro <th>FILTER_PREDICATES</th>
pro <th>PEEKED<BR>BIND_VALUE</th>
pro <th>LOW_VALUE</th>
pro <th>HIGH_VALUE</th>
pro <th>TABLE_OWNER</th>
pro <th>TABLE_NAME</th>
pro <th>BP</th>
pro <th>COLUMN_NAME</th>
pro <th>BIND_NAME</th>
pro <th>BIND<br>DTYPE</th>
pro <th>COL<br>DTYPE</th>
pro <th>HISTOGRAM</th>
pro <th>OPERATION</th>
pro <th>OPTIONS</th>
pro <th>COST</th>
pro <th>CARDINALITY</th>
pro <th>SEARCH<br>COLUMNS</th>
pro <th>NUM<br>DISTINCT</th>
pro <th>NUM<br>NULLS</th>
pro <th>NUM<br>ROWS</th>
pro <th>LAST_LOAD_TIME</th>
pro <th>LAST_ANALYZED</th>
pro </tr>

set head off

select  CHR(10)||'<tr>'||CHR(10)
     ||'<td class="r">'||INST_ID||'</td>'||CHR(10)
     ||'<td class="r">'||PLAN_HASH_VALUE||'</td>'||CHR(10)
     ||'<td class="r">'||CHILD_NUMBER||'</td>'||CHR(10)
     ||'<td class="r">'||ID||'</td>'||CHR(10)
     ||'<td class="r">'||ACCESS_PREDICATES||'</td>'||CHR(10)
     ||'<td class="r">'||FILTER_PREDICATES||'</td>'||CHR(10)
     ||'<td class="r">'||PEEKED_BIND_VALUE||'</td>'||CHR(10)
     ||'<td class="r">'||LOW_VALUE||'</td>'||CHR(10)
     ||'<td class="r">'||HIGH_VALUE||'</td>'||CHR(10)
     ||'<td class="r">'||TABLE_OWNER||'</td>'||CHR(10)
     ||'<td class="r">'||TABLE_NAME||'</td>'||CHR(10)
     ||'<td class="r">'||BP||'</td>'||CHR(10)
     ||'<td class="r">'||COLUMN_NAME||'</td>'||CHR(10)
     ||'<td class="r">'||BIND_NAME||'</td>'||CHR(10)
     ||'<td class="r">'||decode(BIND_DTYPE,COL_DTYPE,BIND_DTYPE,'<RED>'||BIND_DTYPE||'</RED>')||'</td>'||CHR(10)
     ||'<td class="r">'||COL_DTYPE||'</td>'||CHR(10)
     ||'<td class="r">'||HISTOGRAM||'</td>'||CHR(10)
     ||'<td class="r">'||OPERATION||'</td>'||CHR(10)
     ||'<td class="r">'||OPTIONS||'</td>'||CHR(10)
     ||'<td class="r">'||COST||'</td>'||CHR(10)
     ||'<td class="r">'||CARDINALITY||'</td>'||CHR(10)
     ||'<td class="r">'||SEARCH_COLUMNS||'</td>'||CHR(10)
     ||'<td class="r">'||NUM_DISTINCT||'</td>'||CHR(10)
     ||'<td class="r">'||NUM_NULLS||'</td>'||CHR(10)
     ||'<td class="r">'||NUM_ROWS||'</td>'||CHR(10)
     ||'<td class="r">'||LAST_LOAD_TIME||'</td>'||CHR(10)
     ||'<td class="r">'||LAST_ANALYZED||'</td>'||CHR(10)
     ||'</TR>'
FROM (
WITH /* TABLE */ PT AS (
SELECT P.ID,
REPLACE(REPLACE( REGEXP_REPLACE(P.ACCESS_PREDICATES,':PSR\S+',
':'||SUBSTR(regexp_substr(P.ACCESS_PREDICATES,':PSR\S+',1),INSTR(regexp_substr(P.ACCESS_PREDICATES,':PSR\S+',1),'__')+2,LENGTH(regexp_substr(P.ACCESS_PREDICATES,':PSR\S+',1)))
  ),'TO_NUMBER(:', ':'),'TO_CHAR(:', ':') ACCESS_PREDICATES,
 SUBSTR(P.ACCESS_PREDICATES, INSTR(P.ACCESS_PREDICATES,':PSR')+4, INSTR(P.ACCESS_PREDICATES,'__')-INSTR(P.ACCESS_PREDICATES,':PSR')-4 )-1 APOSITION,
REPLACE(REPLACE( REGEXP_REPLACE(P.FILTER_PREDICATES,':PSR\S+',
':'||SUBSTR(regexp_substr(P.FILTER_PREDICATES,':PSR\S+',1),INSTR(regexp_substr(P.FILTER_PREDICATES,':PSR\S+',1),'__')+2,LENGTH(regexp_substr(P.FILTER_PREDICATES,':PSR\S+',1)))
  ),'TO_NUMBER(:', ':'),'TO_CHAR(:', ':') FILTER_PREDICATES,
 SUBSTR(P.FILTER_PREDICATES, INSTR(P.FILTER_PREDICATES,':PSR')+4, INSTR(P.FILTER_PREDICATES,'__')-INSTR(P.FILTER_PREDICATES,':PSR')-4 )-1 FPOSITION
FROM PLAN_TABLE  P
WHERE P.STATEMENT_ID = 'SMA_PSR'   AND  :L_DYN_BIND = 'Y'
AND ( P.ACCESS_PREDICATES LIKE '%:PSR%' OR P.FILTER_PREDICATES LIKE '%:PSR%' ) ),
SM AS  (
SELECT /*+ materialize */ c.INST_ID, c.sql_id, c.plan_hash_value, TO_DATE(LAST_LOAD_TIME,'yyyy-mm-dd hh24:mi:ss') LAST_LOAD_TIME, c.CHILD_NUMBER,
         to_number(extractValue(value(d), '/bind/@pos')) position,
         extractValue(value(d), '/bind/@nam') NAME,
         extractValue(value(d), '/bind') value  ,
         --to_number(extractValue(value(d), '/bind/@ppo')) dup_pos,
         DECODE(extractValue(value(d), '/bind/@ dty'),1,'VARCHAR2',2,'NUMBER',12,'DATE',180,'TIMESTAMP',181,'TIMESTAMP', NULL ) dtype
         --to_number(extractValue(value(d), '/bind/@mxl')) max_length
    FROM   (
            select  inst_id, sql_id, plan_hash_value, LAST_LOAD_TIME, child_number
            from gv$sql
            where (inst_id, sql_id, plan_hash_value, LAST_LOAD_TIME) in
                 (select inst_id, sql_id, plan_hash_value, max(LAST_LOAD_TIME) LAST_LOAD_TIME
                  from gv$sql
                  where SQL_ID = :L_SQL_ID --AND :L_DYN_BIND = 'N'
                  group by inst_id, sql_id, plan_hash_value )
            and  SQL_ID = :L_SQL_ID ) s
         ,  gv$sql_plan c
         , TABLE(XMLSEQUENCE(EXTRACT(XMLTYPE(c.other_xml ), '/*/peeked_binds/bind'))) D
   where c.other_xml is not null and extractValue(value(d), '/bind') is not null
   AND C.SQL_ID = :L_SQL_ID
   and s.sql_id = c.sql_id and s.inst_id = c.inst_id and s.plan_hash_value = c.plan_hash_value and s.child_number = c.child_number
   )
SELECT INST_ID, PLAN_HASH_VALUE,CHILD_NUMBER, ID,
--FULL_ACCESS_PREDICATES,
ACCESS_PREDICATES,
--FULL_filter_predicates,
FILTER_PREDICATES,
--2021/05/27
substr(BIND_VALUE,1,length(BIND_VALUE)/3+1)||rpad('***********************************', length(BIND_VALUE)*2/3) PEEKED_BIND_VALUE,
(case when BIND_DTYPE = 'NUMBER' and COL_DTYPE = 'NUMBER'
           and to_number(BIND_VALUE) < LOW_VALUE  then '<RED>'||substr(LOW_VALUE,1,length(LOW_VALUE)/3+1)||rpad('***********************************', length(LOW_VALUE)*2/3)||'</RED>'
      when BIND_DTYPE = 'VARCHAR2' AND COL_DTYPE = 'VARCHAR2'
           and BIND_VALUE < LOW_VALUE  then '<RED>'||substr(LOW_VALUE,1,length(LOW_VALUE)/3+1)||rpad('***********************************', length(LOW_VALUE)*2/3)||'</RED>'
     ELSE  substr(LOW_VALUE,1,length(LOW_VALUE)/3+1)||rpad('***********************************', length(LOW_VALUE)*2/3)  end ) LOW_VALUE ,
(case when BIND_DTYPE = 'NUMBER' and COL_DTYPE = 'NUMBER'
           and to_number(BIND_VALUE) > HIGH_VALUE  then '<RED>'||substr(HIGH_VALUE,1,length(HIGH_VALUE)/3+1)||rpad('***********************************', length(HIGH_VALUE)*2/3)||'</RED>'
      when BIND_DTYPE = 'VARCHAR2' AND COL_DTYPE = 'VARCHAR2'
           and BIND_VALUE > HIGH_VALUE  then '<RED>'||substr(HIGH_VALUE,1,length(HIGH_VALUE)/3+1)||rpad('***********************************', length(HIGH_VALUE)*2/3)||'</RED>'
     ELSE  substr(HIGH_VALUE,1,length(HIGH_VALUE)/3+1)||rpad('***********************************', length(HIGH_VALUE)*2/3) end ) HIGH_VALUE ,
--INDEX_NAME,  CP,
TABLE_OWNER, TABLE_NAME,
BP,
COLUMN_NAME,
BIND_NAME,
/*
( case
   when BIND_DTYPE = 'NUMBER' and to_number(BIND_VALUE) between to_number(low_value) and to_number(high_value)  then 'IN'
   when BIND_DTYPE = 'VARCHAR2' and to_char(BIND_VALUE) between to_char(low_value) and to_char(high_value)  then 'IN'
   when BIND_DTYPE = 'DATE' and to_date(BIND_VALUE) between to_date(low_value) and to_date(high_value)  then 'IN'
   when BIND_DTYPE = 'TIMESTAMP' and to_TIMESTAMP(BIND_VALUE) between to_TIMESTAMP(low_value) and to_TIMESTAMP(high_value)  then 'IN'
   ELSE 'OUT' END ) WITHIN,
*/
BIND_DTYPE BIND_DTYPE,
/* decode(:L_DYN_BIND,'Y',NULL,BIND_DTYPE) BIND_DTYPE, */
COL_DTYPE, HISTOGRAM, substr(OPERATION,1,20) OPERATION, substr(OPTIONS,1,20) OPTIONS, COST, CARDINALITY, SEARCH_COLUMNS
, NUM_DISTINCT,  NUM_NULLS, NUM_ROWS
, LAST_LOAD_TIME, LAST_ANALYZED
FROM (
select /*+ LEADING(PT SM P T M) */ --P.INST_ID, , P.sql_id, P.plan_hash_value, P.object_type,
DISTINCT p.INST_ID, P.plan_hash_value, P.CHILD_NUMBER, P.id,
P.access_predicates FULL_ACCESS_PREDICATES,
DECODE(SIGN(INSTR( P.access_predicates, '"'||M.COLUMN_NAME||'"='||SM.NAME,1)),1,
 SUBSTR(P.access_predicates,INSTR( P.access_predicates, '"'||M.COLUMN_NAME||'"='||SM.NAME,1),LENGTH( '"'||M.COLUMN_NAME||'"='||SM.NAME))
 ,DECODE(SIGN(INSTR( P.access_predicates, '"'||M.COLUMN_NAME||'">='||SM.NAME,1)),1,
   SUBSTR(P.access_predicates,INSTR( P.access_predicates, '"'||M.COLUMN_NAME||'">='||SM.NAME,1),LENGTH( '"'||M.COLUMN_NAME||'">='||SM.NAME))
   ,DECODE(SIGN(INSTR( P.access_predicates, '"'||M.COLUMN_NAME||'"<='||SM.NAME,1)),1,
     SUBSTR(P.access_predicates,INSTR( P.access_predicates, '"'||M.COLUMN_NAME||'"<='||SM.NAME,1),LENGTH( '"'||M.COLUMN_NAME||'"<='||SM.NAME))
     ,DECODE(SIGN(INSTR( P.access_predicates, '"'||M.COLUMN_NAME||'"=TO_NUMBER('||SM.NAME,1)),1,
       SUBSTR(P.access_predicates,INSTR( P.access_predicates, '"'||M.COLUMN_NAME||'"=TO_NUMBER('||SM.NAME,1),LENGTH( '"'||M.COLUMN_NAME||'"=TO_NUMBER('||SM.NAME)+1)
       ,DECODE(SIGN(INSTR( P.access_predicates, '"'||M.COLUMN_NAME||'"<=TO_NUMBER('||SM.NAME,1)),1,
        SUBSTR(P.access_predicates,INSTR( P.access_predicates, '"'||M.COLUMN_NAME||'"<=TO_NUMBER('||SM.NAME,1),LENGTH( '"'||M.COLUMN_NAME||'"<=TO_NUMBER('||SM.NAME)+1)
        ,DECODE(SIGN(INSTR( P.access_predicates, '"'||M.COLUMN_NAME||'">=TO_NUMBER('||SM.NAME,1)),1,
         SUBSTR(P.access_predicates,INSTR( P.access_predicates, '"'||M.COLUMN_NAME||'" LIKE '||SM.NAME,1),LENGTH( '"'||M.COLUMN_NAME||'" LIKE '||SM.NAME)+1)
         ,DECODE(SIGN(INSTR( P.access_predicates, '"'||M.COLUMN_NAME||'">=TO_NUMBER('||SM.NAME,1)),1,
          SUBSTR(P.access_predicates,INSTR( P.access_predicates, '"'||M.COLUMN_NAME||'" LIKE '||SM.NAME,1),LENGTH( '"'||M.COLUMN_NAME||'" LIKE '||SM.NAME)+1)
))))))) access_predicates,
P.filter_predicates FULL_FILTER_PREDICATES,
DECODE(SIGN(INSTR( P.filter_predicates, '"'||M.COLUMN_NAME||'"='||SM.NAME,1)),1,
 SUBSTR(P.filter_predicates,INSTR( P.filter_predicates, '"'||M.COLUMN_NAME||'"='||SM.NAME,1),LENGTH( '"'||M.COLUMN_NAME||'"='||SM.NAME))
 ,DECODE(SIGN(INSTR( P.filter_predicates, '"'||M.COLUMN_NAME||'">='||SM.NAME,1)),1,
   SUBSTR(P.filter_predicates,INSTR( P.filter_predicates, '"'||M.COLUMN_NAME||'">='||SM.NAME,1),LENGTH( '"'||M.COLUMN_NAME||'">='||SM.NAME))
   ,DECODE(SIGN(INSTR( P.filter_predicates, '"'||M.COLUMN_NAME||'"<='||SM.NAME,1)),1,
     SUBSTR(P.filter_predicates,INSTR( P.filter_predicates, '"'||M.COLUMN_NAME||'"<='||SM.NAME,1),LENGTH( '"'||M.COLUMN_NAME||'"<='||SM.NAME))
     ,DECODE(SIGN(INSTR( P.filter_predicates, '"'||M.COLUMN_NAME||'"=TO_NUMBER('||SM.NAME,1)),1,
       SUBSTR(P.filter_predicates,INSTR( P.filter_predicates, '"'||M.COLUMN_NAME||'"=TO_NUMBER('||SM.NAME,1),LENGTH( '"'||M.COLUMN_NAME||'"=TO_NUMBER('||SM.NAME)+1)
       ,DECODE(SIGN(INSTR( P.filter_predicates, '"'||M.COLUMN_NAME||'"<=TO_NUMBER('||SM.NAME,1)),1,
        SUBSTR(P.filter_predicates,INSTR( P.filter_predicates, '"'||M.COLUMN_NAME||'"<=TO_NUMBER('||SM.NAME,1),LENGTH( '"'||M.COLUMN_NAME||'"<=TO_NUMBER('||SM.NAME)+1)
        ,DECODE(SIGN(INSTR( P.filter_predicates, '"'||M.COLUMN_NAME||'">=TO_NUMBER('||SM.NAME,1)),1,
         SUBSTR(P.filter_predicates,INSTR( P.access_predicates, '"'||M.COLUMN_NAME||'">=TO_NUMBER('||SM.NAME,1),LENGTH( '"'||M.COLUMN_NAME||'">=TO_NUMBER('||SM.NAME)+1)
         ,DECODE(SIGN(INSTR( P.filter_predicates, '"'||M.COLUMN_NAME||'" LIKE '||SM.NAME,1)),1,
          SUBSTR(P.filter_predicates,INSTR( P.access_predicates, '"'||M.COLUMN_NAME||'" LIKE '||SM.NAME,1),LENGTH( '"'||M.COLUMN_NAME||'" LIKE '||SM.NAME)+1)
))))))) filter_predicates,
--IC.INDEX_NAME,  IC.COLUMN_POSITION CP,
SM.position BP,
M.OWNER TABLE_OWNER, M.TABLE_NAME, M.COLUMN_NAME,
       substr(
        decode(substr(M.DATA_TYPE,1,9) -- as there are several timestamp types
          ,'NUMBER'       ,to_char(utl_raw.cast_to_number(M.low_value)) ||''
          ,'VARCHAR2'     ,to_char(utl_raw.cast_to_varchar2(M.low_value)) ||''
          ,'NVARCHAR2'    ,to_char(utl_raw.cast_to_nvarchar2(M.low_value)) ||''
          ,'BINARY_DO'    ,to_char(utl_raw.cast_to_binary_double(M.low_value)) ||''
          ,'BINARY_FL'    ,to_char(utl_raw.cast_to_binary_float(M.low_value)) ||''
          ,'DATE'         ,decode(M.low_value, NULL, NULL, rtrim(
                                to_char(100*(to_number(substr(M.low_value,1,2),'XX')-100)
                                       + (to_number(substr(M.low_value,3,2),'XX')-100),'fm0000')||'-'||
                                to_char(to_number(substr(M.low_value,5,2),'XX'),'fm00')||'-'||
                                to_char(to_number(substr(M.low_value,7,2),'XX'),'fm00')||' '||
                                to_char(to_number(substr(M.low_value,9,2),'XX')-1,'fm00')||':'||
                                to_char(to_number(substr(M.low_value,11,2),'XX')-1,'fm00')||':'||
                                to_char(to_number(substr(M.low_value,13,2),'XX')-1,'fm00'))) ||''
          ,'TIMESTAMP'    ,decode(M.low_value, NULL, NULL, rtrim(
                           to_char(100*(to_number(substr(M.low_value,1,2),'XX')-100)
                                  + (to_number(substr(M.low_value,3,2),'XX')-100),'fm0000')||'-'||
                           to_char(to_number(substr(M.low_value,5,2),'XX'),'fm00')||'-'||
                           to_char(to_number(substr(M.low_value,7,2),'XX'),'fm00')||' '||
                           to_char(to_number(substr(M.low_value,9,2),'XX')-1,'fm00')||':'||
                           to_char(to_number(substr(M.low_value,11,2),'XX')-1,'fm00')||':'||
                           to_char(to_number(substr(M.low_value,13,2),'XX')-1,'fm00')
                          ||'.'||to_number(substr(M.low_value,15,8),'XXXXXXXX')  )) ||''
          , M.low_value
        ),1,30) low_value  ,
       substr(
        decode(substr(M.DATA_TYPE,1,9) -- as there are several timestamp types
          ,'NUMBER'       ,to_char(utl_raw.cast_to_number(M.high_value)) ||''
          ,'VARCHAR2'     ,to_char(utl_raw.cast_to_varchar2(M.high_value)) ||''
          ,'NVARCHAR2'    ,to_char(utl_raw.cast_to_nvarchar2(M.high_value)) ||''
          ,'BINARY_DO'    ,to_char(utl_raw.cast_to_binary_double(M.high_value)) ||''
          ,'DATE'         ,decode(M.high_value, NULL, NULL, rtrim(
                                to_char(100*(to_number(substr(M.high_value,1,2),'XX')-100)
                                       + (to_number(substr(M.high_value,3,2),'XX')-100),'fm0000')||'-'||
                                to_char(to_number(substr(M.high_value,5,2),'XX'),'fm00')||'-'||
                                to_char(to_number(substr(M.high_value,7,2),'XX'),'fm00')||' '||
                                to_char(to_number(substr(M.high_value,9,2),'XX')-1,'fm00')||':'||
                                to_char(to_number(substr(M.high_value,11,2),'XX')-1,'fm00')||':'||
                                to_char(to_number(substr(M.high_value,13,2),'XX')-1,'fm00'))) ||''
          ,'TIMESTAMP'    ,decode(M.high_value, NULL, NULL, rtrim(
                           to_char(100*(to_number(substr(M.high_value,1,2),'XX')-100)
                                  + (to_number(substr(M.high_value,3,2),'XX')-100),'fm0000')||'-'||
                           to_char(to_number(substr(M.high_value,5,2),'XX'),'fm00')||'-'||
                           to_char(to_number(substr(M.high_value,7,2),'XX'),'fm00')||' '||
                           to_char(to_number(substr(M.high_value,9,2),'XX')-1,'fm00')||':'||
                           to_char(to_number(substr(M.high_value,11,2),'XX')-1,'fm00')||':'||
                           to_char(to_number(substr(M.high_value,13,2),'XX')-1,'fm00')
                          ||'.'||to_char(to_number(substr(M.high_value,15,8),'XXXXXXXX')))) ||''
          , M.high_value
       ),1,30) high_value
        ,SM.NAME BIND_NAME,
        substr(
        decode( SUBSTR(SM.dtype,1,9)
          ,'NUMBER'       ,to_char(utl_raw.cast_to_number(SM.VALUE)) ||''
          ,'VARCHAR2'     ,to_char(utl_raw.cast_to_varchar2(SM.VALUE)) ||''
          ,'NVARCHAR2'    ,to_char(utl_raw.cast_to_nvarchar2(SM.VALUE)) ||''
          ,'BINARY_DO'    ,to_char(utl_raw.cast_to_binary_double(SM.VALUE)) ||''
          ,'DATE'         ,decode(SM.VALUE, NULL, NULL, rtrim(
                                to_char(100*(to_number(substr(SM.VALUE,1,2),'XX')-100)
                                       + (to_number(substr(SM.VALUE,3,2),'XX')-100),'fm0000')||'-'||
                                to_char(to_number(substr(SM.VALUE,5,2),'XX'),'fm00')||'-'||
                                to_char(to_number(substr(SM.VALUE,7,2),'XX'),'fm00')||' '||
                                to_char(to_number(substr(SM.VALUE,9,2),'XX')-1,'fm00')||':'||
                                to_char(to_number(substr(SM.VALUE,11,2),'XX')-1,'fm00')||':'||
                                to_char(to_number(substr(SM.VALUE,13,2),'XX')-1,'fm00'))) ||''
          ,'TIMESTAMP'    ,decode(SM.VALUE, NULL, NULL, rtrim(
                           to_char(100*(to_number(substr(SM.VALUE,1,2),'XX')-100)
                                  + (to_number(substr(SM.VALUE,3,2),'XX')-100),'fm0000')||'-'||
                           to_char(to_number(substr(SM.VALUE,5,2),'XX'),'fm00')||'-'||
                           to_char(to_number(substr(SM.VALUE,7,2),'XX'),'fm00')||' '||
                           to_char(to_number(substr(SM.VALUE,9,2),'XX')-1,'fm00')||':'||
                           to_char(to_number(substr(SM.VALUE,11,2),'XX')-1,'fm00')||':'||
                           to_char(to_number(substr(SM.VALUE,13,2),'XX')-1,'fm00')
                          ||'.'||to_char(to_number(substr(SM.VALUE,15,8),'XXXXXXXX')))) ||''
          , SM.VALUE
       ),1,30) BIND_VALUE,
       --( case when SM.VALUE between M.low_value and M.high_value then 'IN' ELSE 'OUT' END) WITHIN,
       SM.DTYPE BIND_DTYPE, M.DATA_TYPE COL_DTYPE, m.HISTOGRAM, p.OPERATION, p.OPTIONS, p.SEARCH_COLUMNS, P.COST, P.CARDINALITY
       , M.NUM_DISTINCT,  M.NUM_NULLS , T.NUM_ROWS - M.NUM_NULLS NUM_ROWS
       , SM.LAST_LOAD_TIME, T.LAST_ANALYZED
from PT, SM, gv$sql_plan P, --DBA_IND_COLUMNS IC,
DBA_TABLES T, DBA_TAB_COLUMNS M
where :L_DYN_BIND = 'Y'   
--20201118
AND   :L_SQLHC_MIN_FLAG < 15
AND
( ( PT.APOSITION = SM.POSITION AND  PT.ACCESS_PREDICATES LIKE  '%"'||M.COLUMN_NAME||'"%'||SM.NAME||'%' )
     OR ( PT.FPOSITION = SM.POSITION AND  PT.FILTER_PREDICATES LIKE  '%"'||M.COLUMN_NAME||'"%'||SM.NAME||'%' ) )
/*
AND ( SUBSTR( PT.ACCESS_PREDICATES,INSTR(PT.ACCESS_PREDICATES,':')-4,7)
      = SUBSTR(P.ACCESS_PREDICATES,INSTR(P.ACCESS_PREDICATES,':')-4,7)
  OR  SUBSTR( PT.FILTER_PREDICATES,INSTR(PT.FILTER_PREDICATES,':')-4,7)
      LIKE SUBSTR(P.FILTER_PREDICATES,INSTR(P.FILTER_PREDICATES,':')-4,6)||')'
  OR  SUBSTR( PT.ACCESS_PREDICATES,INSTR(PT.ACCESS_PREDICATES,':')-4,7)
      = SUBSTR(P.ACCESS_PREDICATES,INSTR(P.ACCESS_PREDICATES,':')-4,7)
  OR  SUBSTR( PT.FILTER_PREDICATES,INSTR(PT.FILTER_PREDICATES,':')-4,7)
      LIKE SUBSTR(P.FILTER_PREDICATES,INSTR(P.FILTER_PREDICATES,':')-4,6)||')'  )
*/
AND ( P.access_predicates like '%=:%'  or P.filter_predicates like '%=:%'
OR P.access_predicates like '%<=:%'  or P.filter_predicates like '%<=:%'
OR P.access_predicates like '%>=:%'  or P.filter_predicates like '%>=:%'
OR P.access_predicates like '%=TO_NUMBER(:%'  or P.filter_predicates like '%=TO_NUMBER(:%'
OR P.access_predicates like '%<=TO_NUMBER(:%'  or P.filter_predicates like '%<=TO_NUMBER(:%'
OR P.access_predicates like '%>=TO_NUMBER(:%'  or P.filter_predicates like '%>=TO_NUMBER(:%'
OR P.access_predicates like '% LIKE :%'  or P.filter_predicates like '% LIKE :%'
)
--and ( P.access_predicates not like '%"SESSION_ROLE_SET_KEY"="FND_GLOBAL"."SESSION_ROLE_SET_KEY"%'
--and    P.access_predicates not like '%"SANDBOX_ID"=SYS_CONTEXT(''FND_VPD_CTX''%'
--and    P.access_predicates not like '%"USER_GUID"="FND_GLOBAL"."USER_GUID"()%'
--and    P.access_predicates not like '%"ENTERPRISE_ID"=%"FUNCTION_ID"=%' )
and  (P.object_type LIKE '%TABLE%' /* IC should be outer joined */
)
--and P.OBJECT_NAME = IC.INDEX_NAME(+)
--AND P.OBJECT_OWNER = IC.INDEX_OWNER(+)
and P.OBJECT_NAME = T.TABLE_NAME
AND P.OBJECT_OWNER = T.OWNER
and P.OBJECT_NAME = M.TABLE_NAME
AND P.OBJECT_OWNER = M.OWNER
and p.SQL_ID = :L_SQL_ID
AND ( P.access_predicates LIKE '%"'||M.COLUMN_NAME||'"=:%'   or P.filter_predicates LIKE '%"'||M.COLUMN_NAME||'"=:%'
   OR P.access_predicates LIKE '%"'||M.COLUMN_NAME||'"<=:%'  or P.filter_predicates LIKE '%"'||M.COLUMN_NAME||'"<=:%'
   OR P.access_predicates LIKE '%"'||M.COLUMN_NAME||'">=:%'  or P.filter_predicates LIKE '%"'||M.COLUMN_NAME||'">=:%'
   OR P.access_predicates LIKE '%"'||M.COLUMN_NAME||'"=TO_NUMBER(:%'   or P.filter_predicates LIKE '%"'||M.COLUMN_NAME||'"=TO_NUMBER(:%'
   OR P.access_predicates LIKE '%"'||M.COLUMN_NAME||'"<=TO_NUMBER(:%'  or P.filter_predicates LIKE '%"'||M.COLUMN_NAME||'"<=TO_NUMBER(:%'
   OR P.access_predicates LIKE '%"'||M.COLUMN_NAME||'">=TO_NUMBER(:%'  or P.filter_predicates LIKE '%"'||M.COLUMN_NAME||'">=TO_NUMBER(:%'
   OR P.access_predicates LIKE '%"'||M.COLUMN_NAME||'" LIKE :%'  or P.filter_predicates LIKE '%"'||M.COLUMN_NAME||'" LIKE :%'
   )
AND P.OPTIONS NOT IN ('FAST FULL SCAN','SAMPLE FAST FULL SCAN')
--AND M.OWNER       = IC.TABLE_OWNER(+)
--AND M.TABLE_NAME  = IC.TABLE_NAME(+)
--AND M.COLUMN_NAME = IC.COLUMN_NAME(+)
AND SM.INST_ID = P.INST_ID
AND SM.SQL_ID = P.SQL_ID
AND SM.CHILD_NUMBER = P.CHILD_NUMBER
AND SM.PLAN_HASH_VALUE = P.PLAN_HASH_VALUE
AND ( P.access_predicates LIKE '%"'||M.COLUMN_NAME||'"='||SM.NAME||'%'  or P.filter_predicates LIKE '%"'||M.COLUMN_NAME||'"=' ||SM.NAME||'%'
   OR P.access_predicates LIKE '%"'||M.COLUMN_NAME||'"<='||SM.NAME||'%' or P.filter_predicates LIKE '%"'||M.COLUMN_NAME||'"<='||SM.NAME||'%'
   OR P.access_predicates LIKE '%"'||M.COLUMN_NAME||'">='||SM.NAME||'%' or P.filter_predicates LIKE '%"'||M.COLUMN_NAME||'">='||SM.NAME||'%'
   OR P.access_predicates LIKE '%"'||M.COLUMN_NAME||'"=TO_NUMBER('||SM.NAME||'%'  or P.filter_predicates LIKE '%"'||M.COLUMN_NAME||'"=TO_NUMBER(' ||SM.NAME||'%'
   OR P.access_predicates LIKE '%"'||M.COLUMN_NAME||'"<=TO_NUMBER('||SM.NAME||'%' or P.filter_predicates LIKE '%"'||M.COLUMN_NAME||'"<=TO_NUMBER('||SM.NAME||'%'
   OR P.access_predicates LIKE '%"'||M.COLUMN_NAME||'">=TO_NUMBER('||SM.NAME||'%' or P.filter_predicates LIKE '%"'||M.COLUMN_NAME||'">=TO_NUMBER('||SM.NAME||'%'
   OR P.access_predicates LIKE '%"'||M.COLUMN_NAME||'" LIKE '||SM.NAME||'%' or P.filter_predicates LIKE '%"'||M.COLUMN_NAME||'" LIKE '||SM.NAME||'%'
   )
--ORDER BY P.ID, IC.INDEX_NAME, IC.COLUMN_POSITION
)
UNION ALL
SELECT INST_ID, PLAN_HASH_VALUE,CHILD_NUMBER, ID,
--FULL_ACCESS_PREDICATES,
ACCESS_PREDICATES,
--FULL_filter_predicates,
FILTER_PREDICATES,
--2021/05/27
substr(BIND_VALUE,1,length(BIND_VALUE)/3+1)||rpad('***********************************', length(BIND_VALUE)*2/3) PEEKED_BIND_VALUE,
(case when BIND_DTYPE = 'NUMBER' and COL_DTYPE = 'NUMBER'
           and to_number(BIND_VALUE) < LOW_VALUE  then '<RED>'||substr(LOW_VALUE,1,length(LOW_VALUE)/3+1)||rpad('***********************************', length(LOW_VALUE)*2/3)||'</RED>'
      when BIND_DTYPE = 'VARCHAR2' AND COL_DTYPE = 'VARCHAR2'
           and BIND_VALUE < LOW_VALUE  then '<RED>'||substr(LOW_VALUE,1,length(LOW_VALUE)/3+1)||rpad('***********************************', length(LOW_VALUE)*2/3)||'</RED>'
     ELSE  substr(LOW_VALUE,1,length(LOW_VALUE)/3+1)||rpad('***********************************', length(LOW_VALUE)*2/3)  end ) LOW_VALUE ,
(case when BIND_DTYPE = 'NUMBER' and COL_DTYPE = 'NUMBER'
           and to_number(BIND_VALUE) > HIGH_VALUE  then '<RED>'||substr(HIGH_VALUE,1,length(HIGH_VALUE)/3+1)||rpad('***********************************', length(HIGH_VALUE)*2/3)||'</RED>'
      when BIND_DTYPE = 'VARCHAR2' AND COL_DTYPE = 'VARCHAR2'
           and BIND_VALUE > HIGH_VALUE  then '<RED>'||substr(HIGH_VALUE,1,length(HIGH_VALUE)/3+1)||rpad('***********************************', length(HIGH_VALUE)*2/3)||'</RED>'
     ELSE  substr(HIGH_VALUE,1,length(HIGH_VALUE)/3+1)||rpad('***********************************', length(HIGH_VALUE)*2/3) end ) HIGH_VALUE ,
--INDEX_NAME,  CP,
TABLE_OWNER, TABLE_NAME,
BP,
COLUMN_NAME,
BIND_NAME,
/*
( case
   when BIND_DTYPE = 'NUMBER' and to_number(BIND_VALUE) between to_number(low_value) and to_number(high_value)  then 'IN'
   when BIND_DTYPE = 'VARCHAR2' and to_char(BIND_VALUE) between to_char(low_value) and to_char(high_value)  then 'IN'
   when BIND_DTYPE = 'DATE' and to_date(BIND_VALUE) between to_date(low_value) and to_date(high_value)  then 'IN'
   when BIND_DTYPE = 'TIMESTAMP' and to_TIMESTAMP(BIND_VALUE) between to_TIMESTAMP(low_value) and to_TIMESTAMP(high_value)  then 'IN'
   ELSE 'OUT' END ) WITHIN,
*/
BIND_DTYPE BIND_DTYPE,
/* decode(:L_DYN_BIND,'Y',NULL,BIND_DTYPE) BIND_DTYPE, */
COL_DTYPE, HISTOGRAM, substr(OPERATION,1,20) OPERATION, substr(OPTIONS,1,20) OPTIONS, COST, CARDINALITY, SEARCH_COLUMNS
, NUM_DISTINCT,  NUM_NULLS, NUM_ROWS
, LAST_LOAD_TIME, LAST_ANALYZED
FROM (
select /*+ LEADING(SM P T M) */ --P.INST_ID, , P.sql_id, P.plan_hash_value, P.object_type,
DISTINCT p.INST_ID, P.plan_hash_value, P.CHILD_NUMBER, P.id,
P.access_predicates FULL_ACCESS_PREDICATES,
DECODE(SIGN(INSTR( P.access_predicates, '"'||M.COLUMN_NAME||'"='||SM.NAME,1)),1,
 SUBSTR(P.access_predicates,INSTR( P.access_predicates, '"'||M.COLUMN_NAME||'"='||SM.NAME,1),LENGTH( '"'||M.COLUMN_NAME||'"='||SM.NAME))
 ,DECODE(SIGN(INSTR( P.access_predicates, '"'||M.COLUMN_NAME||'">='||SM.NAME,1)),1,
   SUBSTR(P.access_predicates,INSTR( P.access_predicates, '"'||M.COLUMN_NAME||'">='||SM.NAME,1),LENGTH( '"'||M.COLUMN_NAME||'">='||SM.NAME))
   ,DECODE(SIGN(INSTR( P.access_predicates, '"'||M.COLUMN_NAME||'"<='||SM.NAME,1)),1,
     SUBSTR(P.access_predicates,INSTR( P.access_predicates, '"'||M.COLUMN_NAME||'"<='||SM.NAME,1),LENGTH( '"'||M.COLUMN_NAME||'"<='||SM.NAME))
     ,DECODE(SIGN(INSTR( P.access_predicates, '"'||M.COLUMN_NAME||'"=TO_NUMBER('||SM.NAME,1)),1,
       SUBSTR(P.access_predicates,INSTR( P.access_predicates, '"'||M.COLUMN_NAME||'"=TO_NUMBER('||SM.NAME,1),LENGTH( '"'||M.COLUMN_NAME||'"=TO_NUMBER('||SM.NAME)+1)
       ,DECODE(SIGN(INSTR( P.access_predicates, '"'||M.COLUMN_NAME||'"<=TO_NUMBER('||SM.NAME,1)),1,
        SUBSTR(P.access_predicates,INSTR( P.access_predicates, '"'||M.COLUMN_NAME||'"<=TO_NUMBER('||SM.NAME,1),LENGTH( '"'||M.COLUMN_NAME||'"<=TO_NUMBER('||SM.NAME)+1)
        ,DECODE(SIGN(INSTR( P.access_predicates, '"'||M.COLUMN_NAME||'">=TO_NUMBER('||SM.NAME,1)),1,
         SUBSTR(P.access_predicates,INSTR( P.access_predicates, '"'||M.COLUMN_NAME||'" LIKE '||SM.NAME,1),LENGTH( '"'||M.COLUMN_NAME||'" LIKE '||SM.NAME)+1)
         ,DECODE(SIGN(INSTR( P.access_predicates, '"'||M.COLUMN_NAME||'">=TO_NUMBER('||SM.NAME,1)),1,
          SUBSTR(P.access_predicates,INSTR( P.access_predicates, '"'||M.COLUMN_NAME||'" LIKE '||SM.NAME,1),LENGTH( '"'||M.COLUMN_NAME||'" LIKE '||SM.NAME)+1)
))))))) access_predicates,
P.filter_predicates FULL_FILTER_PREDICATES,
DECODE(SIGN(INSTR( P.filter_predicates, '"'||M.COLUMN_NAME||'"='||SM.NAME,1)),1,
 SUBSTR(P.filter_predicates,INSTR( P.filter_predicates, '"'||M.COLUMN_NAME||'"='||SM.NAME,1),LENGTH( '"'||M.COLUMN_NAME||'"='||SM.NAME))
 ,DECODE(SIGN(INSTR( P.filter_predicates, '"'||M.COLUMN_NAME||'">='||SM.NAME,1)),1,
   SUBSTR(P.filter_predicates,INSTR( P.filter_predicates, '"'||M.COLUMN_NAME||'">='||SM.NAME,1),LENGTH( '"'||M.COLUMN_NAME||'">='||SM.NAME))
   ,DECODE(SIGN(INSTR( P.filter_predicates, '"'||M.COLUMN_NAME||'"<='||SM.NAME,1)),1,
     SUBSTR(P.filter_predicates,INSTR( P.filter_predicates, '"'||M.COLUMN_NAME||'"<='||SM.NAME,1),LENGTH( '"'||M.COLUMN_NAME||'"<='||SM.NAME))
     ,DECODE(SIGN(INSTR( P.filter_predicates, '"'||M.COLUMN_NAME||'"=TO_NUMBER('||SM.NAME,1)),1,
       SUBSTR(P.filter_predicates,INSTR( P.filter_predicates, '"'||M.COLUMN_NAME||'"=TO_NUMBER('||SM.NAME,1),LENGTH( '"'||M.COLUMN_NAME||'"=TO_NUMBER('||SM.NAME)+1)
       ,DECODE(SIGN(INSTR( P.filter_predicates, '"'||M.COLUMN_NAME||'"<=TO_NUMBER('||SM.NAME,1)),1,
        SUBSTR(P.filter_predicates,INSTR( P.filter_predicates, '"'||M.COLUMN_NAME||'"<=TO_NUMBER('||SM.NAME,1),LENGTH( '"'||M.COLUMN_NAME||'"<=TO_NUMBER('||SM.NAME)+1)
        ,DECODE(SIGN(INSTR( P.filter_predicates, '"'||M.COLUMN_NAME||'">=TO_NUMBER('||SM.NAME,1)),1,
         SUBSTR(P.filter_predicates,INSTR( P.access_predicates, '"'||M.COLUMN_NAME||'">=TO_NUMBER('||SM.NAME,1),LENGTH( '"'||M.COLUMN_NAME||'">=TO_NUMBER('||SM.NAME)+1)
         ,DECODE(SIGN(INSTR( P.filter_predicates, '"'||M.COLUMN_NAME||'" LIKE '||SM.NAME,1)),1,
          SUBSTR(P.filter_predicates,INSTR( P.access_predicates, '"'||M.COLUMN_NAME||'" LIKE '||SM.NAME,1),LENGTH( '"'||M.COLUMN_NAME||'" LIKE '||SM.NAME)+1)
))))))) filter_predicates,
--IC.INDEX_NAME,  IC.COLUMN_POSITION CP,
SM.position BP,
M.OWNER TABLE_OWNER, M.TABLE_NAME, M.COLUMN_NAME,
       substr(
        decode(substr(M.DATA_TYPE,1,9) -- as there are several timestamp types
          ,'NUMBER'       ,to_char(utl_raw.cast_to_number(M.low_value)) ||''
          ,'VARCHAR2'     ,to_char(utl_raw.cast_to_varchar2(M.low_value)) ||''
          ,'NVARCHAR2'    ,to_char(utl_raw.cast_to_nvarchar2(M.low_value)) ||''
          ,'BINARY_DO'    ,to_char(utl_raw.cast_to_binary_double(M.low_value)) ||''
          ,'BINARY_FL'    ,to_char(utl_raw.cast_to_binary_float(M.low_value)) ||''
          ,'DATE'         ,decode(M.low_value, NULL, NULL, rtrim(
                                to_char(100*(to_number(substr(M.low_value,1,2),'XX')-100)
                                       + (to_number(substr(M.low_value,3,2),'XX')-100),'fm0000')||'-'||
                                to_char(to_number(substr(M.low_value,5,2),'XX'),'fm00')||'-'||
                                to_char(to_number(substr(M.low_value,7,2),'XX'),'fm00')||' '||
                                to_char(to_number(substr(M.low_value,9,2),'XX')-1,'fm00')||':'||
                                to_char(to_number(substr(M.low_value,11,2),'XX')-1,'fm00')||':'||
                                to_char(to_number(substr(M.low_value,13,2),'XX')-1,'fm00'))) ||''
          ,'TIMESTAMP'    ,decode(M.low_value, NULL, NULL, rtrim(
                           to_char(100*(to_number(substr(M.low_value,1,2),'XX')-100)
                                  + (to_number(substr(M.low_value,3,2),'XX')-100),'fm0000')||'-'||
                           to_char(to_number(substr(M.low_value,5,2),'XX'),'fm00')||'-'||
                           to_char(to_number(substr(M.low_value,7,2),'XX'),'fm00')||' '||
                           to_char(to_number(substr(M.low_value,9,2),'XX')-1,'fm00')||':'||
                           to_char(to_number(substr(M.low_value,11,2),'XX')-1,'fm00')||':'||
                           to_char(to_number(substr(M.low_value,13,2),'XX')-1,'fm00')
                          ||'.'||to_number(substr(M.low_value,15,8),'XXXXXXXX')  )) ||''
          , M.low_value
        ),1,30) low_value  ,
       substr(
        decode(substr(M.DATA_TYPE,1,9) -- as there are several timestamp types
          ,'NUMBER'       ,to_char(utl_raw.cast_to_number(M.high_value)) ||''
          ,'VARCHAR2'     ,to_char(utl_raw.cast_to_varchar2(M.high_value)) ||''
          ,'NVARCHAR2'    ,to_char(utl_raw.cast_to_nvarchar2(M.high_value)) ||''
          ,'BINARY_DO'    ,to_char(utl_raw.cast_to_binary_double(M.high_value)) ||''
          ,'DATE'         ,decode(M.high_value, NULL, NULL, rtrim(
                                to_char(100*(to_number(substr(M.high_value,1,2),'XX')-100)
                                       + (to_number(substr(M.high_value,3,2),'XX')-100),'fm0000')||'-'||
                                to_char(to_number(substr(M.high_value,5,2),'XX'),'fm00')||'-'||
                                to_char(to_number(substr(M.high_value,7,2),'XX'),'fm00')||' '||
                                to_char(to_number(substr(M.high_value,9,2),'XX')-1,'fm00')||':'||
                                to_char(to_number(substr(M.high_value,11,2),'XX')-1,'fm00')||':'||
                                to_char(to_number(substr(M.high_value,13,2),'XX')-1,'fm00'))) ||''
          ,'TIMESTAMP'    ,decode(M.high_value, NULL, NULL, rtrim(
                           to_char(100*(to_number(substr(M.high_value,1,2),'XX')-100)
                                  + (to_number(substr(M.high_value,3,2),'XX')-100),'fm0000')||'-'||
                           to_char(to_number(substr(M.high_value,5,2),'XX'),'fm00')||'-'||
                           to_char(to_number(substr(M.high_value,7,2),'XX'),'fm00')||' '||
                           to_char(to_number(substr(M.high_value,9,2),'XX')-1,'fm00')||':'||
                           to_char(to_number(substr(M.high_value,11,2),'XX')-1,'fm00')||':'||
                           to_char(to_number(substr(M.high_value,13,2),'XX')-1,'fm00')
                          ||'.'||to_char(to_number(substr(M.high_value,15,8),'XXXXXXXX')))) ||''
          , M.high_value
       ),1,30) high_value
        ,SM.NAME BIND_NAME,
        substr(
        decode( SUBSTR(SM.dtype,1,9)
          ,'NUMBER'       ,to_char(utl_raw.cast_to_number(SM.VALUE)) ||''
          ,'VARCHAR2'     ,to_char(utl_raw.cast_to_varchar2(SM.VALUE)) ||''
          ,'NVARCHAR2'    ,to_char(utl_raw.cast_to_nvarchar2(SM.VALUE)) ||''
          ,'BINARY_DO'    ,to_char(utl_raw.cast_to_binary_double(SM.VALUE)) ||''
          ,'DATE'         ,decode(SM.VALUE, NULL, NULL, rtrim(
                                to_char(100*(to_number(substr(SM.VALUE,1,2),'XX')-100)
                                       + (to_number(substr(SM.VALUE,3,2),'XX')-100),'fm0000')||'-'||
                                to_char(to_number(substr(SM.VALUE,5,2),'XX'),'fm00')||'-'||
                                to_char(to_number(substr(SM.VALUE,7,2),'XX'),'fm00')||' '||
                                to_char(to_number(substr(SM.VALUE,9,2),'XX')-1,'fm00')||':'||
                                to_char(to_number(substr(SM.VALUE,11,2),'XX')-1,'fm00')||':'||
                                to_char(to_number(substr(SM.VALUE,13,2),'XX')-1,'fm00'))) ||''
          ,'TIMESTAMP'    ,decode(SM.VALUE, NULL, NULL, rtrim(
                           to_char(100*(to_number(substr(SM.VALUE,1,2),'XX')-100)
                                  + (to_number(substr(SM.VALUE,3,2),'XX')-100),'fm0000')||'-'||
                           to_char(to_number(substr(SM.VALUE,5,2),'XX'),'fm00')||'-'||
                           to_char(to_number(substr(SM.VALUE,7,2),'XX'),'fm00')||' '||
                           to_char(to_number(substr(SM.VALUE,9,2),'XX')-1,'fm00')||':'||
                           to_char(to_number(substr(SM.VALUE,11,2),'XX')-1,'fm00')||':'||
                           to_char(to_number(substr(SM.VALUE,13,2),'XX')-1,'fm00')
                          ||'.'||to_char(to_number(substr(SM.VALUE,15,8),'XXXXXXXX')))) ||''
          , SM.VALUE
       ),1,30) BIND_VALUE,
       --( case when SM.VALUE between M.low_value and M.high_value then 'IN' ELSE 'OUT' END) WITHIN,
       SM.DTYPE BIND_DTYPE, M.DATA_TYPE COL_DTYPE, m.HISTOGRAM, p.OPERATION, p.OPTIONS, p.SEARCH_COLUMNS, P.COST, P.CARDINALITY
       , M.NUM_DISTINCT,  M.NUM_NULLS , T.NUM_ROWS - M.NUM_NULLS NUM_ROWS
       , SM.LAST_LOAD_TIME, T.LAST_ANALYZED
from SM, gv$sql_plan P, --DBA_IND_COLUMNS IC,
DBA_TABLES T, DBA_TAB_COLUMNS M
where :L_DYN_BIND = 'N'
--20201118
AND   :L_SQLHC_MIN_FLAG < 15
/*
AND ( SUBSTR( PT.ACCESS_PREDICATES,INSTR(PT.ACCESS_PREDICATES,':')-4,7)
      = SUBSTR(P.ACCESS_PREDICATES,INSTR(P.ACCESS_PREDICATES,':')-4,7)
  OR  SUBSTR( PT.FILTER_PREDICATES,INSTR(PT.FILTER_PREDICATES,':')-4,7)
      LIKE SUBSTR(P.FILTER_PREDICATES,INSTR(P.FILTER_PREDICATES,':')-4,6)||')'
  OR  SUBSTR( PT.ACCESS_PREDICATES,INSTR(PT.ACCESS_PREDICATES,':')-4,7)
      = SUBSTR(P.ACCESS_PREDICATES,INSTR(P.ACCESS_PREDICATES,':')-4,7)
  OR  SUBSTR( PT.FILTER_PREDICATES,INSTR(PT.FILTER_PREDICATES,':')-4,7)
      LIKE SUBSTR(P.FILTER_PREDICATES,INSTR(P.FILTER_PREDICATES,':')-4,6)||')'  )
*/
AND ( P.access_predicates like '%=:%'  or P.filter_predicates like '%=:%'
OR P.access_predicates like '%<=:%'  or P.filter_predicates like '%<=:%'
OR P.access_predicates like '%>=:%'  or P.filter_predicates like '%>=:%'
OR P.access_predicates like '%=TO_NUMBER(:%'  or P.filter_predicates like '%=TO_NUMBER(:%'
OR P.access_predicates like '%<=TO_NUMBER(:%'  or P.filter_predicates like '%<=TO_NUMBER(:%'
OR P.access_predicates like '%>=TO_NUMBER(:%'  or P.filter_predicates like '%>=TO_NUMBER(:%'
OR P.access_predicates like '% LIKE :%'  or P.filter_predicates like '% LIKE :%'
)
--and ( P.access_predicates not like '%"SESSION_ROLE_SET_KEY"="FND_GLOBAL"."SESSION_ROLE_SET_KEY"%'
--and    P.access_predicates not like '%"SANDBOX_ID"=SYS_CONTEXT(''FND_VPD_CTX''%'
--and    P.access_predicates not like '%"USER_GUID"="FND_GLOBAL"."USER_GUID"()%'
--and    P.access_predicates not like '%"ENTERPRISE_ID"=%"FUNCTION_ID"=%' )
and  (P.object_type LIKE '%TABLE%' /* IC should be outer joined */
)
--and P.OBJECT_NAME = IC.INDEX_NAME(+)
--AND P.OBJECT_OWNER = IC.INDEX_OWNER(+)
and P.OBJECT_NAME = T.TABLE_NAME
AND P.OBJECT_OWNER = T.OWNER
and P.OBJECT_NAME = M.TABLE_NAME
AND P.OBJECT_OWNER = M.OWNER
and p.SQL_ID = :L_SQL_ID
AND ( P.access_predicates LIKE '%"'||M.COLUMN_NAME||'"=:%'   or P.filter_predicates LIKE '%"'||M.COLUMN_NAME||'"=:%'
   OR P.access_predicates LIKE '%"'||M.COLUMN_NAME||'"<=:%'  or P.filter_predicates LIKE '%"'||M.COLUMN_NAME||'"<=:%'
   OR P.access_predicates LIKE '%"'||M.COLUMN_NAME||'">=:%'  or P.filter_predicates LIKE '%"'||M.COLUMN_NAME||'">=:%'
   OR P.access_predicates LIKE '%"'||M.COLUMN_NAME||'"=TO_NUMBER(:%'   or P.filter_predicates LIKE '%"'||M.COLUMN_NAME||'"=TO_NUMBER(:%'
   OR P.access_predicates LIKE '%"'||M.COLUMN_NAME||'"<=TO_NUMBER(:%'  or P.filter_predicates LIKE '%"'||M.COLUMN_NAME||'"<=TO_NUMBER(:%'
   OR P.access_predicates LIKE '%"'||M.COLUMN_NAME||'">=TO_NUMBER(:%'  or P.filter_predicates LIKE '%"'||M.COLUMN_NAME||'">=TO_NUMBER(:%'
   OR P.access_predicates LIKE '%"'||M.COLUMN_NAME||'" LIKE :%'  or P.filter_predicates LIKE '%"'||M.COLUMN_NAME||'" LIKE :%'
   )
AND P.OPTIONS NOT IN ('FAST FULL SCAN','SAMPLE FAST FULL SCAN')
--AND M.OWNER       = IC.TABLE_OWNER(+)
--AND M.TABLE_NAME  = IC.TABLE_NAME(+)
--AND M.COLUMN_NAME = IC.COLUMN_NAME(+)
AND SM.INST_ID = P.INST_ID
AND SM.SQL_ID = P.SQL_ID
AND SM.CHILD_NUMBER = P.CHILD_NUMBER
AND SM.PLAN_HASH_VALUE = P.PLAN_HASH_VALUE
AND ( P.access_predicates LIKE '%"'||M.COLUMN_NAME||'"='||SM.NAME||'%'  or P.filter_predicates LIKE '%"'||M.COLUMN_NAME||'"=' ||SM.NAME||'%'
   OR P.access_predicates LIKE '%"'||M.COLUMN_NAME||'"<='||SM.NAME||'%' or P.filter_predicates LIKE '%"'||M.COLUMN_NAME||'"<='||SM.NAME||'%'
   OR P.access_predicates LIKE '%"'||M.COLUMN_NAME||'">='||SM.NAME||'%' or P.filter_predicates LIKE '%"'||M.COLUMN_NAME||'">='||SM.NAME||'%'
   OR P.access_predicates LIKE '%"'||M.COLUMN_NAME||'"=TO_NUMBER('||SM.NAME||'%'  or P.filter_predicates LIKE '%"'||M.COLUMN_NAME||'"=TO_NUMBER(' ||SM.NAME||'%'
   OR P.access_predicates LIKE '%"'||M.COLUMN_NAME||'"<=TO_NUMBER('||SM.NAME||'%' or P.filter_predicates LIKE '%"'||M.COLUMN_NAME||'"<=TO_NUMBER('||SM.NAME||'%'
   OR P.access_predicates LIKE '%"'||M.COLUMN_NAME||'">=TO_NUMBER('||SM.NAME||'%' or P.filter_predicates LIKE '%"'||M.COLUMN_NAME||'">=TO_NUMBER('||SM.NAME||'%'
   OR P.access_predicates LIKE '%"'||M.COLUMN_NAME||'" LIKE '||SM.NAME||'%' or P.filter_predicates LIKE '%"'||M.COLUMN_NAME||'" LIKE '||SM.NAME||'%'
   )
)   
ORDER BY INST_ID, CHILD_NUMBER, PLAN_HASH_VALUE,  ID, TABLE_NAME, BP )
/

pro </tbody>
pro  </table>

--SET HEAD ON

-------------------------------------------------------------------------------
-------------------------------------------------------------------------------
-------------------------------------------------------------------------------
PROMPT <blue>BASED ON THE LAST HARD PARSING POINT </blue>
-------------------------------------------------------------------------------
-------------------------------------------------------------------------------
-------------------------------------------------------------------------------
pro <table>
pro <tbody><tr>
pro <th>INST_ID</th>
pro <th>PLAN_HASH_VALUE</th>
pro <th>CHILD<br>NUMBER</th>
pro <th>ID</th>
pro <th>ACCESS_PREDICATES</th>
pro <th>FILTER_PREDICATES</th>
pro <th>PEEKED<BR>BIND_VALUE</th>
pro <th>LOW_VALUE</th>
pro <th>HIGH_VALUE</th>
pro <th>TABLE_OWNER</th>
pro <th>TABLE_NAME</th>
pro <th>INDEX_NAME</th>
pro <th>CP</th>
pro <th>COLUMN_NAME</th>
pro <th>BIND_NAME</th>
pro <th>BIND<br>DTYPE</th>
pro <th>COL<br>DTYPE</th>
pro <th>OPERATION</th>
pro <th>OPTIONS</th>
pro <th>COST</th>
pro <th>CARDINALITY</th>
pro <th>SEARCH<br>COLUMNS</th>
pro <th>NUM<br>DISTINCT</th>
pro <th>NUM<br>NULLS</th>
pro <th>NUM<br>ROWS</th>
pro <th>LAST_LOAD_TIME</th>
pro <th>SAVTIME</th>
pro </tr>

select  CHR(10)||'<tr>'||CHR(10)
     ||'<td class="r">'||INST_ID||'</td>'||CHR(10)
     ||'<td class="r">'||PLAN_HASH_VALUE||'</td>'||CHR(10)
     ||'<td class="r">'||CHILD_NUMBER||'</td>'||CHR(10)
     ||'<td class="r">'||ID||'</td>'||CHR(10)
     ||'<td class="r">'||access_predicates||'</td>'||CHR(10)
     ||'<td class="r">'||filter_predicates||'</td>'||CHR(10)
     ||'<td class="r">'||PEEKED_BIND_VALUE||'</td>'||CHR(10)
     ||'<td class="r">'||LOW_VALUE||'</td>'||CHR(10)
     ||'<td class="r">'||HIGH_VALUE||'</td>'||CHR(10)
     ||'<td class="r">'||TABLE_OWNER||'</td>'||CHR(10)
     ||'<td class="r">'||TABLE_NAME||'</td>'||CHR(10)
     ||'<td class="r">'||INDEX_NAME||'</td>'||CHR(10)
     ||'<td class="r">'||CP||'</td>'||CHR(10)
     ||'<td class="r">'||COLUMN_NAME||'</td>'||CHR(10)
     ||'<td class="r">'||BIND_NAME||'</td>'||CHR(10)
     ||'<td class="r">'||decode(BIND_DTYPE,COL_DTYPE,BIND_DTYPE,'<RED>'||BIND_DTYPE||'</RED>')||'</td>'||CHR(10)
     ||'<td class="r">'||COL_DTYPE||'</td>'||CHR(10)
     ||'<td class="r">'||OPERATION||'</td>'||CHR(10)
     ||'<td class="r">'||OPTIONS||'</td>'||CHR(10)
     ||'<td class="r">'||COST||'</td>'||CHR(10)
     ||'<td class="r">'||CARDINALITY||'</td>'||CHR(10)
     ||'<td class="r">'||SEARCH_COLUMNS||'</td>'||CHR(10)
     ||'<td class="r">'||NUM_DISTINCT||'</td>'||CHR(10)
     ||'<td class="r">'||NUM_NULLS||'</td>'||CHR(10)
     ||'<td class="r">'||NUM_ROWS||'</td>'||CHR(10)
     ||'<td class="r">'||LAST_LOAD_TIME||'</td>'||CHR(10)
     ||'<td class="r">'||SAVTIME||'</td>'||CHR(10)
     ||'</TR>'
from (
WITH /* INDEXH */ PT AS (
SELECT P.ID,
REPLACE(REPLACE( REGEXP_REPLACE(P.ACCESS_PREDICATES,':PSR\S+',
':'||SUBSTR(regexp_substr(P.ACCESS_PREDICATES,':PSR\S+',1),INSTR(regexp_substr(P.ACCESS_PREDICATES,':PSR\S+',1),'__')+2,LENGTH(regexp_substr(P.ACCESS_PREDICATES,':PSR\S+',1)))
  ),'TO_NUMBER(:', ':'),'TO_CHAR(:', ':') ACCESS_PREDICATES,
 SUBSTR(P.ACCESS_PREDICATES, INSTR(P.ACCESS_PREDICATES,':PSR')+4, INSTR(P.ACCESS_PREDICATES,'__')-INSTR(P.ACCESS_PREDICATES,':PSR')-4 )-1 APOSITION,
REPLACE(REPLACE( REGEXP_REPLACE(P.FILTER_PREDICATES,':PSR\S+',
':'||SUBSTR(regexp_substr(P.FILTER_PREDICATES,':PSR\S+',1),INSTR(regexp_substr(P.FILTER_PREDICATES,':PSR\S+',1),'__')+2,LENGTH(regexp_substr(P.FILTER_PREDICATES,':PSR\S+',1)))
  ),'TO_NUMBER(:', ':'),'TO_CHAR(:', ':') FILTER_PREDICATES,
 SUBSTR(P.FILTER_PREDICATES, INSTR(P.FILTER_PREDICATES,':PSR')+4, INSTR(P.FILTER_PREDICATES,'__')-INSTR(P.FILTER_PREDICATES,':PSR')-4 )-1 FPOSITION
FROM PLAN_TABLE  P
WHERE P.STATEMENT_ID = 'SMA_PSR'  AND :L_DYN_BIND = 'Y'
AND ( P.ACCESS_PREDICATES LIKE '%:PSR%' OR P.FILTER_PREDICATES LIKE '%:PSR%' ) ),
 SM AS  (
SELECT /*+ materialize */ c.INST_ID, c.sql_id, c.plan_hash_value, TO_DATE(LAST_LOAD_TIME,'yyyy-mm-dd hh24:mi:ss') LAST_LOAD_TIME, c.CHILD_NUMBER,
         to_number(extractValue(value(d), '/bind/@pos')) position,
         extractValue(value(d), '/bind/@nam') NAME,
         extractValue(value(d), '/bind') value  ,
         --to_number(extractValue(value(d), '/bind/@ppo')) dup_pos,
         DECODE(extractValue(value(d), '/bind/@dty'),1,'VARCHAR2',2,'NUMBER',12,'DATE',180,'TIMESTAMP',181,'TIMESTAMP', NULL ) dtype
         --to_number(extractValue(value(d), '/bind/@mxl')) max_length
    FROM  ( select  inst_id, sql_id, plan_hash_value, LAST_LOAD_TIME, child_number
            from gv$sql
            where (inst_id, sql_id, plan_hash_value, LAST_LOAD_TIME) in
                 (select inst_id, sql_id, plan_hash_value, max(LAST_LOAD_TIME) LAST_LOAD_TIME
                  from gv$sql
                  where SQL_ID = :L_SQL_ID --AND :L_DYN_BIND = 'N'
                  group by inst_id, sql_id, plan_hash_value )
            and  SQL_ID = :L_SQL_ID ) s
         ,  gv$sql_plan c
         , TABLE(XMLSEQUENCE(EXTRACT(XMLTYPE(c.other_xml ), '/*/peeked_binds/bind'))) D
   where c.other_xml is not null and extractValue(value(d), '/bind') is not null
   AND s.SQL_ID = :L_SQL_ID    and c.sql_id = :L_SQL_ID
   and s.sql_id = c.sql_id and s.inst_id = c.inst_id and s.plan_hash_value = c.plan_hash_value and s.child_number = c.child_number
   )
SELECT INST_ID, PLAN_HASH_VALUE,CHILD_NUMBER, id,
--FULL_ACCESS_PREDICATES,
ACCESS_PREDICATES,
FILTER_PREDICATES,
--2021/05/27
substr(BIND_VALUE,1,length(BIND_VALUE)/3+1)||rpad('***********************************', length(BIND_VALUE)*2/3) PEEKED_BIND_VALUE,
(case when BIND_DTYPE = 'NUMBER' and COL_DTYPE = 'NUMBER'
           and to_number(BIND_VALUE) < LOW_VALUE  then '<RED>'||substr(LOW_VALUE,1,length(LOW_VALUE)/3+1)||rpad('***********************************', length(LOW_VALUE)*2/3)||'</RED>'
      when BIND_DTYPE = 'VARCHAR2' AND COL_DTYPE = 'VARCHAR2'
           and BIND_VALUE < LOW_VALUE  then '<RED>'||substr(LOW_VALUE,1,length(LOW_VALUE)/3+1)||rpad('***********************************', length(LOW_VALUE)*2/3)||'</RED>'
     ELSE  substr(LOW_VALUE,1,length(LOW_VALUE)/3+1)||rpad('***********************************', length(LOW_VALUE)*2/3)  end ) LOW_VALUE ,
(case when BIND_DTYPE = 'NUMBER' and COL_DTYPE = 'NUMBER'
           and to_number(BIND_VALUE) > HIGH_VALUE  then '<RED>'||substr(HIGH_VALUE,1,length(HIGH_VALUE)/3+1)||rpad('***********************************', length(HIGH_VALUE)*2/3)||'</RED>'
      when BIND_DTYPE = 'VARCHAR2' AND COL_DTYPE = 'VARCHAR2'
           and BIND_VALUE > HIGH_VALUE  then '<RED>'||substr(HIGH_VALUE,1,length(HIGH_VALUE)/3+1)||rpad('***********************************', length(HIGH_VALUE)*2/3)||'</RED>'
     ELSE  substr(HIGH_VALUE,1,length(HIGH_VALUE)/3+1)||rpad('***********************************', length(HIGH_VALUE)*2/3) end ) HIGH_VALUE ,
INDEX_NAME,  CP,
COLUMN_NAME,
TABLE_OWNER, TABLE_NAME,
BIND_NAME,
/*
 ( case
   when BIND_DTYPE = 'NUMBER' and to_number(BIND_VALUE) between to_number(low_value) and to_number(high_value)  then 'IN'
   when BIND_DTYPE = 'VARCHAR2' and to_char(BIND_VALUE) between to_char(low_value) and to_char(high_value)  then 'IN'
   when BIND_DTYPE = 'DATE' and to_date(BIND_VALUE) between to_date(low_value) and to_date(high_value)  then 'IN'
   when BIND_DTYPE = 'TIMESTAMP' and to_TIMESTAMP(BIND_VALUE) between to_TIMESTAMP(low_value) and to_TIMESTAMP(high_value)  then 'IN'
   ELSE 'OUT' END) WITHIN,
*/
BIND_DTYPE BIND_DTYPE,
/*
decode(:L_DYN_BIND,'Y',NULL,BIND_DTYPE) BIND_DTYPE,
*/
COL_DTYPE,
--HISTOGRAM,
substr(OPERATION,1,20) OPERATION, substr(OPTIONS,1,20) OPTIONS, COST, CARDINALITY, SEARCH_COLUMNS
, NUM_DISTINCT,  NUM_NULLS,  NUM_ROWS
, LAST_LOAD_TIME, SAVTIME
FROM (
select /*+ LEADING(PT SM P IC T T1 C) */ --P.INST_ID, , P.sql_id, P.plan_hash_value, P.object_type,
DISTINCT p.INST_ID, P.plan_hash_value, P.CHILD_NUMBER, P.id,
P.access_predicates FULL_ACCESS_PREDICATES,
DECODE(SIGN(INSTR( P.access_predicates, '"'||IC.COLUMN_NAME||'"='||SM.NAME,1)),1,
 SUBSTR(P.access_predicates,INSTR( P.access_predicates, '"'||IC.COLUMN_NAME||'"='||SM.NAME,1),LENGTH( '"'||IC.COLUMN_NAME||'"='||SM.NAME))
 ,DECODE(SIGN(INSTR( P.access_predicates, '"'||IC.COLUMN_NAME||'">='||SM.NAME,1)),1,
   SUBSTR(P.access_predicates,INSTR( P.access_predicates, '"'||IC.COLUMN_NAME||'">='||SM.NAME,1),LENGTH( '"'||IC.COLUMN_NAME||'">='||SM.NAME))
   ,DECODE(SIGN(INSTR( P.access_predicates, '"'||IC.COLUMN_NAME||'"<='||SM.NAME,1)),1,
     SUBSTR(P.access_predicates,INSTR( P.access_predicates, '"'||IC.COLUMN_NAME||'"<='||SM.NAME,1),LENGTH( '"'||IC.COLUMN_NAME||'"<='||SM.NAME))
     ,DECODE(SIGN(INSTR( P.access_predicates, '"'||IC.COLUMN_NAME||'"=TO_NUMBER('||SM.NAME,1)),1,
       SUBSTR(P.access_predicates,INSTR( P.access_predicates, '"'||IC.COLUMN_NAME||'"=TO_NUMBER('||SM.NAME,1),LENGTH( '"'||IC.COLUMN_NAME||'"=TO_NUMBER('||SM.NAME)+1)
       ,DECODE(SIGN(INSTR( P.access_predicates, '"'||IC.COLUMN_NAME||'"<=TO_NUMBER('||SM.NAME,1)),1,
        SUBSTR(P.access_predicates,INSTR( P.access_predicates, '"'||IC.COLUMN_NAME||'"<=TO_NUMBER('||SM.NAME,1),LENGTH( '"'||IC.COLUMN_NAME||'"<=TO_NUMBER('||SM.NAME)+1)
        ,DECODE(SIGN(INSTR( P.access_predicates, '"'||IC.COLUMN_NAME||'">=TO_NUMBER('||SM.NAME,1)),1,
         SUBSTR(P.access_predicates,INSTR( P.access_predicates, '"'||IC.COLUMN_NAME||'">=TO_NUMBER('||SM.NAME,1),LENGTH( '"'||IC.COLUMN_NAME||'">=TO_NUMBER('||SM.NAME)+1)
         ,DECODE(SIGN(INSTR( P.access_predicates, '"'||IC.COLUMN_NAME||'" LIKE '||SM.NAME,1)),1,
          SUBSTR(P.access_predicates,INSTR( P.access_predicates, '"'||IC.COLUMN_NAME||'" LIKE '||SM.NAME,1),LENGTH( '"'||IC.COLUMN_NAME||'" LIKE '||SM.NAME)+1)
))))))) access_predicates,
--P.filter_predicates FULL_FILTER_PREDICATES,
DECODE(SIGN(INSTR( P.filter_predicates, '"'||IC.COLUMN_NAME||'"='||SM.NAME,1)),1,
 SUBSTR(P.filter_predicates,INSTR( P.filter_predicates, '"'||IC.COLUMN_NAME||'"='||SM.NAME,1),LENGTH( '"'||IC.COLUMN_NAME||'"='||SM.NAME))
 ,DECODE(SIGN(INSTR( P.filter_predicates, '"'||IC.COLUMN_NAME||'">='||SM.NAME,1)),1,
   SUBSTR(P.filter_predicates,INSTR( P.filter_predicates, '"'||IC.COLUMN_NAME||'">='||SM.NAME,1),LENGTH( '"'||IC.COLUMN_NAME||'">='||SM.NAME))
   ,DECODE(SIGN(INSTR( P.filter_predicates, '"'||IC.COLUMN_NAME||'"<='||SM.NAME,1)),1,
     SUBSTR(P.filter_predicates,INSTR( P.filter_predicates, '"'||IC.COLUMN_NAME||'"<='||SM.NAME,1),LENGTH( '"'||IC.COLUMN_NAME||'"<='||SM.NAME))
     ,DECODE(SIGN(INSTR( P.filter_predicates, '"'||IC.COLUMN_NAME||'"=TO_NUMBER('||SM.NAME,1)),1,
       SUBSTR(P.filter_predicates,INSTR( P.filter_predicates, '"'||IC.COLUMN_NAME||'"=TO_NUMBER('||SM.NAME,1),LENGTH( '"'||IC.COLUMN_NAME||'"=TO_NUMBER('||SM.NAME)+1)
       ,DECODE(SIGN(INSTR( P.filter_predicates, '"'||IC.COLUMN_NAME||'"<=TO_NUMBER('||SM.NAME,1)),1,
        SUBSTR(P.filter_predicates,INSTR( P.filter_predicates, '"'||IC.COLUMN_NAME||'"<=TO_NUMBER('||SM.NAME,1),LENGTH( '"'||IC.COLUMN_NAME||'"<=TO_NUMBER('||SM.NAME)+1)
        ,DECODE(SIGN(INSTR( P.filter_predicates, '"'||IC.COLUMN_NAME||'">=TO_NUMBER('||SM.NAME,1)),1,
         SUBSTR(P.filter_predicates,INSTR( P.access_predicates, '"'||IC.COLUMN_NAME||'">=TO_NUMBER('||SM.NAME,1),LENGTH( '"'||IC.COLUMN_NAME||'">=TO_NUMBER('||SM.NAME)+1)
         ,DECODE(SIGN(INSTR( P.filter_predicates, '"'||IC.COLUMN_NAME||'" LIKE '||SM.NAME,1)),1,
          SUBSTR(P.filter_predicates,INSTR( P.access_predicates, '"'||IC.COLUMN_NAME||'" LIKE '||SM.NAME,1),LENGTH( '"'||IC.COLUMN_NAME||'" LIKE '||SM.NAME)+1)
))))))) filter_predicates,
IC.INDEX_NAME,  IC.COLUMN_POSITION CP, IC.COLUMN_NAME,
t.owner table_owner, t.table_name,
       ( SELECT  substr(
         decode(c.type#
          ,2       ,to_char(utl_raw.cast_to_number(CSH.LOWVAL)) ||''
          ,1     ,to_char(utl_raw.cast_to_varchar2(CSH.LOWVAL)) ||''
          ,287    ,to_char(utl_raw.cast_to_nvarchar2(CSH.LOWVAL)) ||''
          ,101    ,to_char(utl_raw.cast_to_binary_double(CSH.LOWVAL)) ||''
          ,100    ,to_char(utl_raw.cast_to_binary_float(CSH.LOWVAL)) ||''
          ,12         ,decode(CSH.LOWVAL, NULL, NULL, rtrim(
                                to_char(100*(to_number(substr(CSH.LOWVAL,1,2),'XX')-100)
                                       + (to_number(substr(CSH.LOWVAL,3,2),'XX')-100),'fm0000')||'-'||
                                to_char(to_number(substr(CSH.LOWVAL,5,2),'XX'),'fm00')||'-'||
                                to_char(to_number(substr(CSH.LOWVAL,7,2),'XX'),'fm00')||' '||
                                to_char(to_number(substr(CSH.LOWVAL,9,2),'XX')-1,'fm00')||':'||
                                to_char(to_number(substr(CSH.LOWVAL,11,2),'XX')-1,'fm00')||':'||
                                to_char(to_number(substr(CSH.LOWVAL,13,2),'XX')-1,'fm00'))) ||''
          ,187    ,decode(CSH.LOWVAL, NULL, NULL, rtrim(
                           to_char(100*(to_number(substr(CSH.LOWVAL,1,2),'XX')-100)
                                  + (to_number(substr(CSH.LOWVAL,3,2),'XX')-100),'fm0000')||'-'||
                           to_char(to_number(substr(CSH.LOWVAL,5,2),'XX'),'fm00')||'-'||
                           to_char(to_number(substr(CSH.LOWVAL,7,2),'XX'),'fm00')||' '||
                           to_char(to_number(substr(CSH.LOWVAL,9,2),'XX')-1,'fm00')||':'||
                           to_char(to_number(substr(CSH.LOWVAL,11,2),'XX')-1,'fm00')||':'||
                           to_char(to_number(substr(CSH.LOWVAL,13,2),'XX')-1,'fm00')
                          ||'.'||to_number(substr(CSH.LOWVAL,15,8),'XXXXXXXX')  )) ||''
          , CSH.LOWVAL
        ),1,30) low_value
        FROM SYS.WRI$_OPTSTAT_HISTHEAD_HISTORY CSH
        WHERE CSH.OBJ#       = T1.OBJECT_ID
        AND   CSH.INTCOL#    = C.INTCOL#
        AND   to_DATE(to_CHAR(CSH.SAVTIME,'yyyy-mm-dd hh24:mi:ss'),'yyyy-mm-dd hh24:mi:ss') < SM.last_load_time
--        AND   to_DATE(to_CHAR(CSH.SAVTIME,'yyyy-mm-dd hh24:mi:ss'),'yyyy-mm-dd hh24:mi:ss') < SM.last_load_time
        order by to_DATE(to_CHAR(CSH.SAVTIME,'yyyy-mm-dd hh24:mi:ss'),'yyyy-mm-dd hh24:mi:ss') desc FETCH FIRST 1 ROW ONLY ) LOW_VALUE,
       ( SELECT  substr(
         decode(c.type# -- as there are several timestamp types
          ,2       ,to_char(utl_raw.cast_to_number(CSH.HIVAL)) ||''
          ,1     ,to_char(utl_raw.cast_to_varchar2(CSH.HIVAL)) ||''
          ,287    ,to_char(utl_raw.cast_to_nvarchar2(CSH.HIVAL)) ||''
          ,101    ,to_char(utl_raw.cast_to_binary_double(CSH.HIVAL)) ||''
          ,100    ,to_char(utl_raw.cast_to_binary_float(CSH.HIVAL)) ||''
          ,12         ,decode(CSH.HIVAL, NULL, NULL, rtrim(
                                to_char(100*(to_number(substr(CSH.HIVAL,1,2),'XX')-100)
                                       + (to_number(substr(CSH.HIVAL,3,2),'XX')-100),'fm0000')||'-'||
                                to_char(to_number(substr(CSH.HIVAL,5,2),'XX'),'fm00')||'-'||
                                to_char(to_number(substr(CSH.HIVAL,7,2),'XX'),'fm00')||' '||
                                to_char(to_number(substr(CSH.HIVAL,9,2),'XX')-1,'fm00')||':'||
                                to_char(to_number(substr(CSH.HIVAL,11,2),'XX')-1,'fm00')||':'||
                                to_char(to_number(substr(CSH.HIVAL,13,2),'XX')-1,'fm00'))) ||''
          ,187    ,decode(CSH.HIVAL, NULL, NULL, rtrim(
                           to_char(100*(to_number(substr(CSH.HIVAL,1,2),'XX')-100)
                                  + (to_number(substr(CSH.HIVAL,3,2),'XX')-100),'fm0000')||'-'||
                           to_char(to_number(substr(CSH.HIVAL,5,2),'XX'),'fm00')||'-'||
                           to_char(to_number(substr(CSH.HIVAL,7,2),'XX'),'fm00')||' '||
                           to_char(to_number(substr(CSH.HIVAL,9,2),'XX')-1,'fm00')||':'||
                           to_char(to_number(substr(CSH.HIVAL,11,2),'XX')-1,'fm00')||':'||
                           to_char(to_number(substr(CSH.HIVAL,13,2),'XX')-1,'fm00')
                          ||'.'||to_number(substr(CSH.HIVAL,15,8),'XXXXXXXX')  )) ||''
          , CSH.HIVAL
        ),1,30) HIGH_VALUE
        FROM SYS.WRI$_OPTSTAT_HISTHEAD_HISTORY CSH
        WHERE CSH.OBJ#       = T1.OBJECT_ID
        AND   CSH.INTCOL#    = C.INTCOL#
        AND   to_DATE(to_CHAR(CSH.SAVTIME,'yyyy-mm-dd hh24:mi:ss'),'yyyy-mm-dd hh24:mi:ss') < SM.last_load_time
--        AND   to_DATE(to_CHAR(CSH.SAVTIME,'yyyy-mm-dd hh24:mi:ss'),'yyyy-mm-dd hh24:mi:ss') < SM.last_load_time
        order by to_DATE(to_CHAR(CSH.SAVTIME,'yyyy-mm-dd hh24:mi:ss'),'yyyy-mm-dd hh24:mi:ss') desc FETCH FIRST 1 ROW ONLY ) HIGH_VALUE,
        SM.NAME BIND_NAME,
        substr(
        decode( SUBSTR(SM.dtype,1,9)
          ,'NUMBER'       ,to_char(utl_raw.cast_to_number(SM.VALUE)) ||''
          ,'VARCHAR2'     ,to_char(utl_raw.cast_to_varchar2(SM.VALUE)) ||''
          ,'NVARCHAR2'    ,to_char(utl_raw.cast_to_nvarchar2(SM.VALUE)) ||''
          ,'BINARY_DO'    ,to_char(utl_raw.cast_to_binary_double(SM.VALUE)) ||''
          ,'DATE'         ,decode(SM.VALUE, NULL, NULL, rtrim(
                                to_char(100*(to_number(substr(SM.VALUE,1,2),'XX')-100)
                                       + (to_number(substr(SM.VALUE,3,2),'XX')-100),'fm0000')||'-'||
                                to_char(to_number(substr(SM.VALUE,5,2),'XX'),'fm00')||'-'||
                                to_char(to_number(substr(SM.VALUE,7,2),'XX'),'fm00')||' '||
                                to_char(to_number(substr(SM.VALUE,9,2),'XX')-1,'fm00')||':'||
                                to_char(to_number(substr(SM.VALUE,11,2),'XX')-1,'fm00')||':'||
                                to_char(to_number(substr(SM.VALUE,13,2),'XX')-1,'fm00'))) ||''
          ,'TIMESTAMP'    ,decode(SM.VALUE, NULL, NULL, rtrim(
                           to_char(100*(to_number(substr(SM.VALUE,1,2),'XX')-100)
                                  + (to_number(substr(SM.VALUE,3,2),'XX')-100),'fm0000')||'-'||
                           to_char(to_number(substr(SM.VALUE,5,2),'XX'),'fm00')||'-'||
                           to_char(to_number(substr(SM.VALUE,7,2),'XX'),'fm00')||' '||
                           to_char(to_number(substr(SM.VALUE,9,2),'XX')-1,'fm00')||':'||
                           to_char(to_number(substr(SM.VALUE,11,2),'XX')-1,'fm00')||':'||
                           to_char(to_number(substr(SM.VALUE,13,2),'XX')-1,'fm00')
                          ||'.'||to_char(to_number(substr(SM.VALUE,15,8),'XXXXXXXX')))) ||''
          , SM.VALUE
       ),1,30) BIND_VALUE,
       --( case when SM.VALUE between CSH.LOWVAL and M.high_value then 'IN' ELSE 'OUT' END) WITHIN,
       SM.DTYPE BIND_DTYPE,
--       M.DATA_TYPE COL_DTYPE, m.HISTOGRAM,
DECODE(c.type#, 1,'VARCHAR2',2,'NUMBER',12,'DATE',180,'TIMESTAMP',181,'TIMESTAMP', C.TYPE#)  COL_DTYPE,
       p.OPERATION, p.OPTIONS, p.SEARCH_COLUMNS, P.COST, P.CARDINALITY,
--       , M.NUM_DISTINCT,  M.NUM_NULLS, T.NUM_ROWS - M.NUM_NULLS NUM_ROWS
       ( SELECT  CSH.DISTCNT  NUM_DISTINCT
        FROM SYS.WRI$_OPTSTAT_HISTHEAD_HISTORY CSH
        WHERE CSH.OBJ#       = T1.OBJECT_ID
        AND   CSH.INTCOL#    = C.INTCOL#
        AND   to_DATE(to_CHAR(CSH.SAVTIME,'yyyy-mm-dd hh24:mi:ss'),'yyyy-mm-dd hh24:mi:ss') < SM.last_load_time
--        AND   to_DATE(to_CHAR(CSH.SAVTIME,'yyyy-mm-dd hh24:mi:ss'),'yyyy-mm-dd hh24:mi:ss') < SM.last_load_time
        order by to_DATE(to_CHAR(CSH.SAVTIME,'yyyy-mm-dd hh24:mi:ss'),'yyyy-mm-dd hh24:mi:ss') desc FETCH FIRST 1 ROW ONLY ) NUM_DISTINCT,
       ( SELECT  CSH.NULL_CNT  NUM_NULLS
        FROM SYS.WRI$_OPTSTAT_HISTHEAD_HISTORY CSH
        WHERE CSH.OBJ#       = T1.OBJECT_ID
        AND   CSH.INTCOL#    = C.INTCOL#
        AND   to_DATE(to_CHAR(CSH.SAVTIME,'yyyy-mm-dd hh24:mi:ss'),'yyyy-mm-dd hh24:mi:ss') < SM.last_load_time
--        AND   to_DATE(to_CHAR(CSH.SAVTIME,'yyyy-mm-dd hh24:mi:ss'),'yyyy-mm-dd hh24:mi:ss') < SM.last_load_time
        order by to_DATE(to_CHAR(CSH.SAVTIME,'yyyy-mm-dd hh24:mi:ss'),'yyyy-mm-dd hh24:mi:ss') desc FETCH FIRST 1 ROW ONLY ) NUM_NULLS,
       ( SELECT  CSH.SAMPLE_SIZE SAMPLE_SIZE
        FROM SYS.WRI$_OPTSTAT_HISTHEAD_HISTORY CSH
        WHERE CSH.OBJ#       = T1.OBJECT_ID
        AND   CSH.INTCOL#    = C.INTCOL#
        AND   to_DATE(to_CHAR(CSH.SAVTIME,'yyyy-mm-dd hh24:mi:ss'),'yyyy-mm-dd hh24:mi:ss') < SM.last_load_time
--        AND   to_DATE(to_CHAR(CSH.SAVTIME,'yyyy-mm-dd hh24:mi:ss'),'yyyy-mm-dd hh24:mi:ss') < SM.last_load_time
        order by to_DATE(to_CHAR(CSH.SAVTIME,'yyyy-mm-dd hh24:mi:ss'),'yyyy-mm-dd hh24:mi:ss') desc FETCH FIRST 1 ROW ONLY ) NUM_ROWS,
      sm.LAST_LOAD_TIME,
      ( SELECT  to_char(TIMESTAMP#,'yyyy-mm-dd hh24:mi:ss')||' - '||to_CHAR(CSH.SAVTIME,'yyyy-mm-dd hh24:mi:ss') SAVTIME
        FROM SYS.WRI$_OPTSTAT_HISTHEAD_HISTORY CSH
        WHERE CSH.OBJ#       = T1.OBJECT_ID
        AND   CSH.INTCOL#    = C.INTCOL#
        AND   to_DATE(to_CHAR(CSH.SAVTIME,'yyyy-mm-dd hh24:mi:ss'),'yyyy-mm-dd hh24:mi:ss') < SM.last_load_time
--        AND   to_DATE(to_CHAR(CSH.SAVTIME,'yyyy-mm-dd hh24:mi:ss'),'yyyy-mm-dd hh24:mi:ss') < SM.last_load_time
        order by to_DATE(to_CHAR(CSH.SAVTIME,'yyyy-mm-dd hh24:mi:ss'),'yyyy-mm-dd hh24:mi:ss') desc FETCH FIRST 1 ROW ONLY ) SAVTIME
from PT, SM, gv$sql_plan P, DBA_IND_COLUMNS IC, DBA_TABLES T,
--DBA_TAB_COLUMNS M ,
SYS.COL$ C,
--DBA_OBJECTS T1
( SELECT  O.OBJ# OBJECT_ID, O.NAME OBJECT_NAME, U.NAME OWNER,  'TABLE' OBJECT_TYPE
  FROM SYS.OBJ$ O, SYS.USER$ U WHERE O.OWNER# = U.USER#  AND O.TYPE# = 2) T1
where :L_DYN_BIND = 'Y'
AND
( ( PT.APOSITION = SM.POSITION AND  PT.ACCESS_PREDICATES LIKE '%'||IC.COLUMN_NAME||'%'||SM.NAME||'%' )
     OR ( PT.FPOSITION = SM.POSITION AND  PT.FILTER_PREDICATES LIKE '%'||IC.COLUMN_NAME||'%'||SM.NAME||'%' ) )
AND ( SUBSTR( PT.ACCESS_PREDICATES,INSTR(PT.ACCESS_PREDICATES,':')-4,7)
      = SUBSTR(P.ACCESS_PREDICATES,INSTR(P.ACCESS_PREDICATES,':')-4,7)
  OR  SUBSTR( PT.FILTER_PREDICATES,INSTR(PT.FILTER_PREDICATES,':')-4,7)
      LIKE SUBSTR(P.FILTER_PREDICATES,INSTR(P.FILTER_PREDICATES,':')-4,6)||')'
  OR  SUBSTR( PT.ACCESS_PREDICATES,INSTR(PT.ACCESS_PREDICATES,':')-4,7)
      = SUBSTR(P.ACCESS_PREDICATES,INSTR(P.ACCESS_PREDICATES,':')-4,7)
  OR  SUBSTR( PT.FILTER_PREDICATES,INSTR(PT.FILTER_PREDICATES,':')-4,7)
      LIKE SUBSTR(P.FILTER_PREDICATES,INSTR(P.FILTER_PREDICATES,':')-4,6)||')'  )
AND  T1.OBJECT_NAME = T.TABLE_NAME   AND T1.OWNER = T.OWNER  AND T1.OBJECT_TYPE = 'TABLE'
AND C.OBJ# = T1.OBJECT_ID   AND C.NAME = IC.COLUMN_NAME
AND ( P.access_predicates like '%=:%'  or P.filter_predicates like '%=:%'
OR P.access_predicates like '%<=:%'  or P.filter_predicates like '%<=:%'
OR P.access_predicates like '%>=:%'  or P.filter_predicates like '%>=:%'
OR P.access_predicates like '%=TO_NUMBER(:%'  or P.filter_predicates like '%=TO_NUMBER(:%'
OR P.access_predicates like '%<=TO_NUMBER(:%'  or P.filter_predicates like '%<=TO_NUMBER(:%'
OR P.access_predicates like '%>=TO_NUMBER(:%'  or P.filter_predicates like '%>=TO_NUMBER(:%'
OR P.access_predicates like '% LIKE :%'  or P.filter_predicates like '% LIKE :%'
)
and ( P.access_predicates not like '%"SESSION_ROLE_SET_KEY"="FND_GLOBAL"."SESSION_ROLE_SET_KEY"%'
and    P.access_predicates not like '%"SANDBOX_ID"=SYS_CONTEXT(''FND_VPD_CTX''%'
and    P.access_predicates not like '%"USER_GUID"="FND_GLOBAL"."USER_GUID"()%'
and    P.access_predicates not like '%"ENTERPRISE_ID"=%"FUNCTION_ID"=%' )
and  ( P.object_type LIKE 'INDEX%'
--or P.object_type LIKE 'TABLE%' /* IC should be outer joined */
)
and T.TABLE_NAME   = IC.TABLE_NAME
AND T.OWNER        = IC.TABLE_OWNER
and IC.INDEX_NAME  = P.OBJECT_NAME
AND IC.INDEX_OWNER = P.OBJECT_OWNER
and P.SQL_ID = :L_SQL_ID
AND ( P.access_predicates LIKE '%"'||IC.COLUMN_NAME||'"=:%'   or P.filter_predicates LIKE '%"'||IC.COLUMN_NAME||'"=:%'
   OR P.access_predicates LIKE '%"'||IC.COLUMN_NAME||'"<=:%'  or P.filter_predicates LIKE '%"'||IC.COLUMN_NAME||'"<=:%'
   OR P.access_predicates LIKE '%"'||IC.COLUMN_NAME||'">=:%'  or P.filter_predicates LIKE '%"'||IC.COLUMN_NAME||'">=:%'
   OR P.access_predicates LIKE '%"'||IC.COLUMN_NAME||'"=TO_NUMBER(:%'   or P.filter_predicates LIKE '%"'||IC.COLUMN_NAME||'"=TO_NUMBER(:%'
   OR P.access_predicates LIKE '%"'||IC.COLUMN_NAME||'"<=TO_NUMBER(:%'  or P.filter_predicates LIKE '%"'||IC.COLUMN_NAME||'"<=TO_NUMBER(:%'
   OR P.access_predicates LIKE '%"'||IC.COLUMN_NAME||'">=TO_NUMBER(:%'  or P.filter_predicates LIKE '%"'||IC.COLUMN_NAME||'">=TO_NUMBER(:%'
   OR P.access_predicates LIKE '%"'||IC.COLUMN_NAME||'" LIKE :%'  or P.filter_predicates LIKE '%"'||IC.COLUMN_NAME||'" LIKE :%'
   )
AND P.OPTIONS NOT IN ('FAST FULL SCAN','SAMPLE FAST FULL SCAN')
--AND M.OWNER       = IC.TABLE_OWNER
--AND M.TABLE_NAME  = IC.TABLE_NAME
--AND M.COLUMN_NAME = IC.COLUMN_NAME
--------------
AND P.INST_ID          = SM.INST_ID
AND P.SQL_ID           = SM.SQL_ID
AND P.CHILD_NUMBER     = SM.CHILD_NUMBER
AND P.PLAN_HASH_VALUE  = SM.PLAN_HASH_VALUE
--------------
AND ( P.access_predicates LIKE '%"'||IC.COLUMN_NAME||'"='||SM.NAME||'%'  or P.filter_predicates LIKE '%"'||IC.COLUMN_NAME||'"='||SM.NAME||'%'
   OR P.access_predicates LIKE '%"'||IC.COLUMN_NAME||'"<='||SM.NAME||'%' or P.filter_predicates LIKE '%"'||IC.COLUMN_NAME||'"<='||SM.NAME||'%'
   OR P.access_predicates LIKE '%"'||IC.COLUMN_NAME||'">='||SM.NAME||'%' or P.filter_predicates LIKE '%"'||IC.COLUMN_NAME||'">='||SM.NAME||'%'
   OR P.access_predicates LIKE '%"'||IC.COLUMN_NAME||'"=TO_NUMBER('||SM.NAME||'%' or P.filter_predicates LIKE '%"'||IC.COLUMN_NAME||'"=TO_NUMBER('||SM.NAME||'%'
   OR P.access_predicates LIKE '%"'||IC.COLUMN_NAME||'"<=TO_NUMBER('||SM.NAME||'%' or P.filter_predicates LIKE '%"'||IC.COLUMN_NAME||'"<=TO_NUMBER('||SM.NAME||'%'
   OR P.access_predicates LIKE '%"'||IC.COLUMN_NAME||'">=TO_NUMBER('||SM.NAME||'%' or P.filter_predicates LIKE '%"'||IC.COLUMN_NAME||'">=TO_NUMBER('||SM.NAME||'%'
   OR P.access_predicates LIKE '%"'||IC.COLUMN_NAME||'" LIKE '||SM.NAME||'%' or P.filter_predicates LIKE '%"'||IC.COLUMN_NAME||'" LIKE '||SM.NAME||'%'
   )
--ORDER BY P.ID, IC.INDEX_NAME, IC.COLUMN_POSITION
)
UNION ALL
SELECT INST_ID, PLAN_HASH_VALUE,CHILD_NUMBER, id,
--FULL_ACCESS_PREDICATES,
ACCESS_PREDICATES,
FILTER_PREDICATES,
--2021/05/27
substr(BIND_VALUE,1,length(BIND_VALUE)/3+1)||rpad('***********************************', length(BIND_VALUE)*2/3) PEEKED_BIND_VALUE,
(case when BIND_DTYPE = 'NUMBER' and COL_DTYPE = 'NUMBER'
           and to_number(BIND_VALUE) < LOW_VALUE  then '<RED>'||substr(LOW_VALUE,1,length(LOW_VALUE)/3+1)||rpad('***********************************', length(LOW_VALUE)*2/3)||'</RED>'
      when BIND_DTYPE = 'VARCHAR2' AND COL_DTYPE = 'VARCHAR2'
           and BIND_VALUE < LOW_VALUE  then '<RED>'||substr(LOW_VALUE,1,length(LOW_VALUE)/3+1)||rpad('***********************************', length(LOW_VALUE)*2/3)||'</RED>'
     ELSE  substr(LOW_VALUE,1,length(LOW_VALUE)/3+1)||rpad('***********************************', length(LOW_VALUE)*2/3)  end ) LOW_VALUE ,
(case when BIND_DTYPE = 'NUMBER' and COL_DTYPE = 'NUMBER'
           and to_number(BIND_VALUE) > HIGH_VALUE  then '<RED>'||substr(HIGH_VALUE,1,length(HIGH_VALUE)/3+1)||rpad('***********************************', length(HIGH_VALUE)*2/3)||'</RED>'
      when BIND_DTYPE = 'VARCHAR2' AND COL_DTYPE = 'VARCHAR2'
           and BIND_VALUE > HIGH_VALUE  then '<RED>'||substr(HIGH_VALUE,1,length(HIGH_VALUE)/3+1)||rpad('***********************************', length(HIGH_VALUE)*2/3)||'</RED>'
     ELSE  substr(HIGH_VALUE,1,length(HIGH_VALUE)/3+1)||rpad('***********************************', length(HIGH_VALUE)*2/3) end ) HIGH_VALUE ,
INDEX_NAME,  CP,
COLUMN_NAME,
TABLE_OWNER, TABLE_NAME,
BIND_NAME,
/*
 ( case
   when BIND_DTYPE = 'NUMBER' and to_number(BIND_VALUE) between to_number(low_value) and to_number(high_value)  then 'IN'
   when BIND_DTYPE = 'VARCHAR2' and to_char(BIND_VALUE) between to_char(low_value) and to_char(high_value)  then 'IN'
   when BIND_DTYPE = 'DATE' and to_date(BIND_VALUE) between to_date(low_value) and to_date(high_value)  then 'IN'
   when BIND_DTYPE = 'TIMESTAMP' and to_TIMESTAMP(BIND_VALUE) between to_TIMESTAMP(low_value) and to_TIMESTAMP(high_value)  then 'IN'
   ELSE 'OUT' END) WITHIN,
*/
BIND_DTYPE BIND_DTYPE,
/*
decode(:L_DYN_BIND,'Y',NULL,BIND_DTYPE) BIND_DTYPE,
*/
COL_DTYPE,
--HISTOGRAM,
substr(OPERATION,1,20) OPERATION, substr(OPTIONS,1,20) OPTIONS, COST, CARDINALITY, SEARCH_COLUMNS
, NUM_DISTINCT,  NUM_NULLS,  NUM_ROWS
, LAST_LOAD_TIME, SAVTIME
FROM (
select /*+ LEADING(SM P IC T T1 C) */ --P.INST_ID, , P.sql_id, P.plan_hash_value, P.object_type,
DISTINCT p.INST_ID, P.plan_hash_value, P.CHILD_NUMBER, P.id,
P.access_predicates FULL_ACCESS_PREDICATES,
DECODE(SIGN(INSTR( P.access_predicates, '"'||IC.COLUMN_NAME||'"='||SM.NAME,1)),1,
 SUBSTR(P.access_predicates,INSTR( P.access_predicates, '"'||IC.COLUMN_NAME||'"='||SM.NAME,1),LENGTH( '"'||IC.COLUMN_NAME||'"='||SM.NAME))
 ,DECODE(SIGN(INSTR( P.access_predicates, '"'||IC.COLUMN_NAME||'">='||SM.NAME,1)),1,
   SUBSTR(P.access_predicates,INSTR( P.access_predicates, '"'||IC.COLUMN_NAME||'">='||SM.NAME,1),LENGTH( '"'||IC.COLUMN_NAME||'">='||SM.NAME))
   ,DECODE(SIGN(INSTR( P.access_predicates, '"'||IC.COLUMN_NAME||'"<='||SM.NAME,1)),1,
     SUBSTR(P.access_predicates,INSTR( P.access_predicates, '"'||IC.COLUMN_NAME||'"<='||SM.NAME,1),LENGTH( '"'||IC.COLUMN_NAME||'"<='||SM.NAME))
     ,DECODE(SIGN(INSTR( P.access_predicates, '"'||IC.COLUMN_NAME||'"=TO_NUMBER('||SM.NAME,1)),1,
       SUBSTR(P.access_predicates,INSTR( P.access_predicates, '"'||IC.COLUMN_NAME||'"=TO_NUMBER('||SM.NAME,1),LENGTH( '"'||IC.COLUMN_NAME||'"=TO_NUMBER('||SM.NAME)+1)
       ,DECODE(SIGN(INSTR( P.access_predicates, '"'||IC.COLUMN_NAME||'"<=TO_NUMBER('||SM.NAME,1)),1,
        SUBSTR(P.access_predicates,INSTR( P.access_predicates, '"'||IC.COLUMN_NAME||'"<=TO_NUMBER('||SM.NAME,1),LENGTH( '"'||IC.COLUMN_NAME||'"<=TO_NUMBER('||SM.NAME)+1)
        ,DECODE(SIGN(INSTR( P.access_predicates, '"'||IC.COLUMN_NAME||'">=TO_NUMBER('||SM.NAME,1)),1,
         SUBSTR(P.access_predicates,INSTR( P.access_predicates, '"'||IC.COLUMN_NAME||'">=TO_NUMBER('||SM.NAME,1),LENGTH( '"'||IC.COLUMN_NAME||'">=TO_NUMBER('||SM.NAME)+1)
         ,DECODE(SIGN(INSTR( P.access_predicates, '"'||IC.COLUMN_NAME||'" LIKE '||SM.NAME,1)),1,
          SUBSTR(P.access_predicates,INSTR( P.access_predicates, '"'||IC.COLUMN_NAME||'" LIKE '||SM.NAME,1),LENGTH( '"'||IC.COLUMN_NAME||'" LIKE '||SM.NAME)+1)
))))))) access_predicates,
--P.filter_predicates FULL_FILTER_PREDICATES,
DECODE(SIGN(INSTR( P.filter_predicates, '"'||IC.COLUMN_NAME||'"='||SM.NAME,1)),1,
 SUBSTR(P.filter_predicates,INSTR( P.filter_predicates, '"'||IC.COLUMN_NAME||'"='||SM.NAME,1),LENGTH( '"'||IC.COLUMN_NAME||'"='||SM.NAME))
 ,DECODE(SIGN(INSTR( P.filter_predicates, '"'||IC.COLUMN_NAME||'">='||SM.NAME,1)),1,
   SUBSTR(P.filter_predicates,INSTR( P.filter_predicates, '"'||IC.COLUMN_NAME||'">='||SM.NAME,1),LENGTH( '"'||IC.COLUMN_NAME||'">='||SM.NAME))
   ,DECODE(SIGN(INSTR( P.filter_predicates, '"'||IC.COLUMN_NAME||'"<='||SM.NAME,1)),1,
     SUBSTR(P.filter_predicates,INSTR( P.filter_predicates, '"'||IC.COLUMN_NAME||'"<='||SM.NAME,1),LENGTH( '"'||IC.COLUMN_NAME||'"<='||SM.NAME))
     ,DECODE(SIGN(INSTR( P.filter_predicates, '"'||IC.COLUMN_NAME||'"=TO_NUMBER('||SM.NAME,1)),1,
       SUBSTR(P.filter_predicates,INSTR( P.filter_predicates, '"'||IC.COLUMN_NAME||'"=TO_NUMBER('||SM.NAME,1),LENGTH( '"'||IC.COLUMN_NAME||'"=TO_NUMBER('||SM.NAME)+1)
       ,DECODE(SIGN(INSTR( P.filter_predicates, '"'||IC.COLUMN_NAME||'"<=TO_NUMBER('||SM.NAME,1)),1,
        SUBSTR(P.filter_predicates,INSTR( P.filter_predicates, '"'||IC.COLUMN_NAME||'"<=TO_NUMBER('||SM.NAME,1),LENGTH( '"'||IC.COLUMN_NAME||'"<=TO_NUMBER('||SM.NAME)+1)
        ,DECODE(SIGN(INSTR( P.filter_predicates, '"'||IC.COLUMN_NAME||'">=TO_NUMBER('||SM.NAME,1)),1,
         SUBSTR(P.filter_predicates,INSTR( P.access_predicates, '"'||IC.COLUMN_NAME||'">=TO_NUMBER('||SM.NAME,1),LENGTH( '"'||IC.COLUMN_NAME||'">=TO_NUMBER('||SM.NAME)+1)
         ,DECODE(SIGN(INSTR( P.filter_predicates, '"'||IC.COLUMN_NAME||'" LIKE '||SM.NAME,1)),1,
          SUBSTR(P.filter_predicates,INSTR( P.access_predicates, '"'||IC.COLUMN_NAME||'" LIKE '||SM.NAME,1),LENGTH( '"'||IC.COLUMN_NAME||'" LIKE '||SM.NAME)+1)
))))))) filter_predicates,
IC.INDEX_NAME,  IC.COLUMN_POSITION CP, IC.COLUMN_NAME,
t.owner table_owner, t.table_name,
       ( SELECT  substr(
         decode(c.type#
          ,2       ,to_char(utl_raw.cast_to_number(CSH.LOWVAL)) ||''
          ,1     ,to_char(utl_raw.cast_to_varchar2(CSH.LOWVAL)) ||''
          ,287    ,to_char(utl_raw.cast_to_nvarchar2(CSH.LOWVAL)) ||''
          ,101    ,to_char(utl_raw.cast_to_binary_double(CSH.LOWVAL)) ||''
          ,100    ,to_char(utl_raw.cast_to_binary_float(CSH.LOWVAL)) ||''
          ,12         ,decode(CSH.LOWVAL, NULL, NULL, rtrim(
                                to_char(100*(to_number(substr(CSH.LOWVAL,1,2),'XX')-100)
                                       + (to_number(substr(CSH.LOWVAL,3,2),'XX')-100),'fm0000')||'-'||
                                to_char(to_number(substr(CSH.LOWVAL,5,2),'XX'),'fm00')||'-'||
                                to_char(to_number(substr(CSH.LOWVAL,7,2),'XX'),'fm00')||' '||
                                to_char(to_number(substr(CSH.LOWVAL,9,2),'XX')-1,'fm00')||':'||
                                to_char(to_number(substr(CSH.LOWVAL,11,2),'XX')-1,'fm00')||':'||
                                to_char(to_number(substr(CSH.LOWVAL,13,2),'XX')-1,'fm00'))) ||''
          ,187    ,decode(CSH.LOWVAL, NULL, NULL, rtrim(
                           to_char(100*(to_number(substr(CSH.LOWVAL,1,2),'XX')-100)
                                  + (to_number(substr(CSH.LOWVAL,3,2),'XX')-100),'fm0000')||'-'||
                           to_char(to_number(substr(CSH.LOWVAL,5,2),'XX'),'fm00')||'-'||
                           to_char(to_number(substr(CSH.LOWVAL,7,2),'XX'),'fm00')||' '||
                           to_char(to_number(substr(CSH.LOWVAL,9,2),'XX')-1,'fm00')||':'||
                           to_char(to_number(substr(CSH.LOWVAL,11,2),'XX')-1,'fm00')||':'||
                           to_char(to_number(substr(CSH.LOWVAL,13,2),'XX')-1,'fm00')
                          ||'.'||to_number(substr(CSH.LOWVAL,15,8),'XXXXXXXX')  )) ||''
          , CSH.LOWVAL
        ),1,30) low_value
        FROM SYS.WRI$_OPTSTAT_HISTHEAD_HISTORY CSH
        WHERE CSH.OBJ#       = T1.OBJECT_ID
        AND   CSH.INTCOL#    = C.INTCOL#
        AND   to_DATE(to_CHAR(CSH.SAVTIME,'yyyy-mm-dd hh24:mi:ss'),'yyyy-mm-dd hh24:mi:ss') < SM.last_load_time
--        AND   to_DATE(to_CHAR(CSH.SAVTIME,'yyyy-mm-dd hh24:mi:ss'),'yyyy-mm-dd hh24:mi:ss') < SM.last_load_time
        order by to_DATE(to_CHAR(CSH.SAVTIME,'yyyy-mm-dd hh24:mi:ss'),'yyyy-mm-dd hh24:mi:ss') desc FETCH FIRST 1 ROW ONLY ) LOW_VALUE,
       ( SELECT  substr(
         decode(c.type# -- as there are several timestamp types
          ,2       ,to_char(utl_raw.cast_to_number(CSH.HIVAL)) ||''
          ,1     ,to_char(utl_raw.cast_to_varchar2(CSH.HIVAL)) ||''
          ,287    ,to_char(utl_raw.cast_to_nvarchar2(CSH.HIVAL)) ||''
          ,101    ,to_char(utl_raw.cast_to_binary_double(CSH.HIVAL)) ||''
          ,100    ,to_char(utl_raw.cast_to_binary_float(CSH.HIVAL)) ||''
          ,12         ,decode(CSH.HIVAL, NULL, NULL, rtrim(
                                to_char(100*(to_number(substr(CSH.HIVAL,1,2),'XX')-100)
                                       + (to_number(substr(CSH.HIVAL,3,2),'XX')-100),'fm0000')||'-'||
                                to_char(to_number(substr(CSH.HIVAL,5,2),'XX'),'fm00')||'-'||
                                to_char(to_number(substr(CSH.HIVAL,7,2),'XX'),'fm00')||' '||
                                to_char(to_number(substr(CSH.HIVAL,9,2),'XX')-1,'fm00')||':'||
                                to_char(to_number(substr(CSH.HIVAL,11,2),'XX')-1,'fm00')||':'||
                                to_char(to_number(substr(CSH.HIVAL,13,2),'XX')-1,'fm00'))) ||''
          ,187    ,decode(CSH.HIVAL, NULL, NULL, rtrim(
                           to_char(100*(to_number(substr(CSH.HIVAL,1,2),'XX')-100)
                                  + (to_number(substr(CSH.HIVAL,3,2),'XX')-100),'fm0000')||'-'||
                           to_char(to_number(substr(CSH.HIVAL,5,2),'XX'),'fm00')||'-'||
                           to_char(to_number(substr(CSH.HIVAL,7,2),'XX'),'fm00')||' '||
                           to_char(to_number(substr(CSH.HIVAL,9,2),'XX')-1,'fm00')||':'||
                           to_char(to_number(substr(CSH.HIVAL,11,2),'XX')-1,'fm00')||':'||
                           to_char(to_number(substr(CSH.HIVAL,13,2),'XX')-1,'fm00')
                          ||'.'||to_number(substr(CSH.HIVAL,15,8),'XXXXXXXX')  )) ||''
          , CSH.HIVAL
        ),1,30) HIGH_VALUE
        FROM SYS.WRI$_OPTSTAT_HISTHEAD_HISTORY CSH
        WHERE CSH.OBJ#       = T1.OBJECT_ID
        AND   CSH.INTCOL#    = C.INTCOL#
        AND   to_DATE(to_CHAR(CSH.SAVTIME,'yyyy-mm-dd hh24:mi:ss'),'yyyy-mm-dd hh24:mi:ss') < SM.last_load_time
--        AND   to_DATE(to_CHAR(CSH.SAVTIME,'yyyy-mm-dd hh24:mi:ss'),'yyyy-mm-dd hh24:mi:ss') < SM.last_load_time
        order by to_DATE(to_CHAR(CSH.SAVTIME,'yyyy-mm-dd hh24:mi:ss'),'yyyy-mm-dd hh24:mi:ss') desc FETCH FIRST 1 ROW ONLY ) HIGH_VALUE,
        SM.NAME BIND_NAME,
        substr(
        decode( SUBSTR(SM.dtype,1,9)
          ,'NUMBER'       ,to_char(utl_raw.cast_to_number(SM.VALUE)) ||''
          ,'VARCHAR2'     ,to_char(utl_raw.cast_to_varchar2(SM.VALUE)) ||''
          ,'NVARCHAR2'    ,to_char(utl_raw.cast_to_nvarchar2(SM.VALUE)) ||''
          ,'BINARY_DO'    ,to_char(utl_raw.cast_to_binary_double(SM.VALUE)) ||''
          ,'DATE'         ,decode(SM.VALUE, NULL, NULL, rtrim(
                                to_char(100*(to_number(substr(SM.VALUE,1,2),'XX')-100)
                                       + (to_number(substr(SM.VALUE,3,2),'XX')-100),'fm0000')||'-'||
                                to_char(to_number(substr(SM.VALUE,5,2),'XX'),'fm00')||'-'||
                                to_char(to_number(substr(SM.VALUE,7,2),'XX'),'fm00')||' '||
                                to_char(to_number(substr(SM.VALUE,9,2),'XX')-1,'fm00')||':'||
                                to_char(to_number(substr(SM.VALUE,11,2),'XX')-1,'fm00')||':'||
                                to_char(to_number(substr(SM.VALUE,13,2),'XX')-1,'fm00'))) ||''
          ,'TIMESTAMP'    ,decode(SM.VALUE, NULL, NULL, rtrim(
                           to_char(100*(to_number(substr(SM.VALUE,1,2),'XX')-100)
                                  + (to_number(substr(SM.VALUE,3,2),'XX')-100),'fm0000')||'-'||
                           to_char(to_number(substr(SM.VALUE,5,2),'XX'),'fm00')||'-'||
                           to_char(to_number(substr(SM.VALUE,7,2),'XX'),'fm00')||' '||
                           to_char(to_number(substr(SM.VALUE,9,2),'XX')-1,'fm00')||':'||
                           to_char(to_number(substr(SM.VALUE,11,2),'XX')-1,'fm00')||':'||
                           to_char(to_number(substr(SM.VALUE,13,2),'XX')-1,'fm00')
                          ||'.'||to_char(to_number(substr(SM.VALUE,15,8),'XXXXXXXX')))) ||''
          , SM.VALUE
       ),1,30) BIND_VALUE,
       --( case when SM.VALUE between CSH.LOWVAL and M.high_value then 'IN' ELSE 'OUT' END) WITHIN,
       SM.DTYPE BIND_DTYPE,
--       M.DATA_TYPE COL_DTYPE, m.HISTOGRAM,
DECODE(c.type#, 1,'VARCHAR2',2,'NUMBER',12,'DATE',180,'TIMESTAMP',181,'TIMESTAMP', C.TYPE#)  COL_DTYPE,
       p.OPERATION, p.OPTIONS, p.SEARCH_COLUMNS, P.COST, P.CARDINALITY,
--       , M.NUM_DISTINCT,  M.NUM_NULLS, T.NUM_ROWS - M.NUM_NULLS NUM_ROWS
       ( SELECT  CSH.DISTCNT  NUM_DISTINCT
        FROM SYS.WRI$_OPTSTAT_HISTHEAD_HISTORY CSH
        WHERE CSH.OBJ#       = T1.OBJECT_ID
        AND   CSH.INTCOL#    = C.INTCOL#
        AND   to_DATE(to_CHAR(CSH.SAVTIME,'yyyy-mm-dd hh24:mi:ss'),'yyyy-mm-dd hh24:mi:ss') < SM.last_load_time
--        AND   to_DATE(to_CHAR(CSH.SAVTIME,'yyyy-mm-dd hh24:mi:ss'),'yyyy-mm-dd hh24:mi:ss') < SM.last_load_time
        order by to_DATE(to_CHAR(CSH.SAVTIME,'yyyy-mm-dd hh24:mi:ss'),'yyyy-mm-dd hh24:mi:ss') desc FETCH FIRST 1 ROW ONLY ) NUM_DISTINCT,
       ( SELECT  CSH.NULL_CNT  NUM_NULLS
        FROM SYS.WRI$_OPTSTAT_HISTHEAD_HISTORY CSH
        WHERE CSH.OBJ#       = T1.OBJECT_ID
        AND   CSH.INTCOL#    = C.INTCOL#
        AND   to_DATE(to_CHAR(CSH.SAVTIME,'yyyy-mm-dd hh24:mi:ss'),'yyyy-mm-dd hh24:mi:ss') < SM.last_load_time
--        AND   to_DATE(to_CHAR(CSH.SAVTIME,'yyyy-mm-dd hh24:mi:ss'),'yyyy-mm-dd hh24:mi:ss') < SM.last_load_time
        order by to_DATE(to_CHAR(CSH.SAVTIME,'yyyy-mm-dd hh24:mi:ss'),'yyyy-mm-dd hh24:mi:ss') desc FETCH FIRST 1 ROW ONLY ) NUM_NULLS,
       ( SELECT  CSH.SAMPLE_SIZE SAMPLE_SIZE
        FROM SYS.WRI$_OPTSTAT_HISTHEAD_HISTORY CSH
        WHERE CSH.OBJ#       = T1.OBJECT_ID
        AND   CSH.INTCOL#    = C.INTCOL#
        AND   to_DATE(to_CHAR(CSH.SAVTIME,'yyyy-mm-dd hh24:mi:ss'),'yyyy-mm-dd hh24:mi:ss') < SM.last_load_time
--        AND   to_DATE(to_CHAR(CSH.SAVTIME,'yyyy-mm-dd hh24:mi:ss'),'yyyy-mm-dd hh24:mi:ss') < SM.last_load_time
        order by to_DATE(to_CHAR(CSH.SAVTIME,'yyyy-mm-dd hh24:mi:ss'),'yyyy-mm-dd hh24:mi:ss') desc FETCH FIRST 1 ROW ONLY ) NUM_ROWS,
      sm.LAST_LOAD_TIME,
      ( SELECT  to_char(TIMESTAMP#,'yyyy-mm-dd hh24:mi:ss')||' - '||to_CHAR(CSH.SAVTIME,'yyyy-mm-dd hh24:mi:ss') SAVTIME
        FROM SYS.WRI$_OPTSTAT_HISTHEAD_HISTORY CSH
        WHERE CSH.OBJ#       = T1.OBJECT_ID
        AND   CSH.INTCOL#    = C.INTCOL#
        AND   to_DATE(to_CHAR(CSH.SAVTIME,'yyyy-mm-dd hh24:mi:ss'),'yyyy-mm-dd hh24:mi:ss') < SM.last_load_time
--        AND   to_DATE(to_CHAR(CSH.SAVTIME,'yyyy-mm-dd hh24:mi:ss'),'yyyy-mm-dd hh24:mi:ss') < SM.last_load_time
        order by to_DATE(to_CHAR(CSH.SAVTIME,'yyyy-mm-dd hh24:mi:ss'),'yyyy-mm-dd hh24:mi:ss') desc FETCH FIRST 1 ROW ONLY ) SAVTIME
from SM, gv$sql_plan P, DBA_IND_COLUMNS IC, DBA_TABLES T,
--DBA_TAB_COLUMNS M ,
SYS.COL$ C,
--DBA_OBJECTS T1
( SELECT  O.OBJ# OBJECT_ID, O.NAME OBJECT_NAME, U.NAME OWNER,  'TABLE' OBJECT_TYPE
  FROM SYS.OBJ$ O, SYS.USER$ U WHERE O.OWNER# = U.USER#  AND O.TYPE# = 2) T1
where :L_DYN_BIND = 'N'
/*
AND ( SUBSTR( PT.ACCESS_PREDICATES,INSTR(PT.ACCESS_PREDICATES,':')-4,7)
      = SUBSTR(P.ACCESS_PREDICATES,INSTR(P.ACCESS_PREDICATES,':')-4,7)
  OR  SUBSTR( PT.FILTER_PREDICATES,INSTR(PT.FILTER_PREDICATES,':')-4,7)
      LIKE SUBSTR(P.FILTER_PREDICATES,INSTR(P.FILTER_PREDICATES,':')-4,6)||')'
  OR  SUBSTR( PT.ACCESS_PREDICATES,INSTR(PT.ACCESS_PREDICATES,':')-4,7)
      = SUBSTR(P.ACCESS_PREDICATES,INSTR(P.ACCESS_PREDICATES,':')-4,7)
  OR  SUBSTR( PT.FILTER_PREDICATES,INSTR(PT.FILTER_PREDICATES,':')-4,7)
      LIKE SUBSTR(P.FILTER_PREDICATES,INSTR(P.FILTER_PREDICATES,':')-4,6)||')'  )
*/
AND  T1.OBJECT_NAME = T.TABLE_NAME   AND T1.OWNER = T.OWNER  AND T1.OBJECT_TYPE = 'TABLE'
AND C.OBJ# = T1.OBJECT_ID   AND C.NAME = IC.COLUMN_NAME
AND ( P.access_predicates like '%=:%'  or P.filter_predicates like '%=:%'
OR P.access_predicates like '%<=:%'  or P.filter_predicates like '%<=:%'
OR P.access_predicates like '%>=:%'  or P.filter_predicates like '%>=:%'
OR P.access_predicates like '%=TO_NUMBER(:%'  or P.filter_predicates like '%=TO_NUMBER(:%'
OR P.access_predicates like '%<=TO_NUMBER(:%'  or P.filter_predicates like '%<=TO_NUMBER(:%'
OR P.access_predicates like '%>=TO_NUMBER(:%'  or P.filter_predicates like '%>=TO_NUMBER(:%'
OR P.access_predicates like '% LIKE :%'  or P.filter_predicates like '% LIKE :%'
)
and ( P.access_predicates not like '%"SESSION_ROLE_SET_KEY"="FND_GLOBAL"."SESSION_ROLE_SET_KEY"%'
and    P.access_predicates not like '%"SANDBOX_ID"=SYS_CONTEXT(''FND_VPD_CTX''%'
and    P.access_predicates not like '%"USER_GUID"="FND_GLOBAL"."USER_GUID"()%'
and    P.access_predicates not like '%"ENTERPRISE_ID"=%"FUNCTION_ID"=%' )
and  ( P.object_type LIKE 'INDEX%'
--or P.object_type LIKE 'TABLE%' /* IC should be outer joined */
)
and T.TABLE_NAME   = IC.TABLE_NAME
AND T.OWNER        = IC.TABLE_OWNER
and IC.INDEX_NAME  = P.OBJECT_NAME
AND IC.INDEX_OWNER = P.OBJECT_OWNER
and P.SQL_ID = :L_SQL_ID
AND ( P.access_predicates LIKE '%"'||IC.COLUMN_NAME||'"=:%'   or P.filter_predicates LIKE '%"'||IC.COLUMN_NAME||'"=:%'
   OR P.access_predicates LIKE '%"'||IC.COLUMN_NAME||'"<=:%'  or P.filter_predicates LIKE '%"'||IC.COLUMN_NAME||'"<=:%'
   OR P.access_predicates LIKE '%"'||IC.COLUMN_NAME||'">=:%'  or P.filter_predicates LIKE '%"'||IC.COLUMN_NAME||'">=:%'
   OR P.access_predicates LIKE '%"'||IC.COLUMN_NAME||'"=TO_NUMBER(:%'   or P.filter_predicates LIKE '%"'||IC.COLUMN_NAME||'"=TO_NUMBER(:%'
   OR P.access_predicates LIKE '%"'||IC.COLUMN_NAME||'"<=TO_NUMBER(:%'  or P.filter_predicates LIKE '%"'||IC.COLUMN_NAME||'"<=TO_NUMBER(:%'
   OR P.access_predicates LIKE '%"'||IC.COLUMN_NAME||'">=TO_NUMBER(:%'  or P.filter_predicates LIKE '%"'||IC.COLUMN_NAME||'">=TO_NUMBER(:%'
   OR P.access_predicates LIKE '%"'||IC.COLUMN_NAME||'" LIKE :%'  or P.filter_predicates LIKE '%"'||IC.COLUMN_NAME||'" LIKE :%'
   )
AND P.OPTIONS NOT IN ('FAST FULL SCAN','SAMPLE FAST FULL SCAN')
--AND M.OWNER       = IC.TABLE_OWNER
--AND M.TABLE_NAME  = IC.TABLE_NAME
--AND M.COLUMN_NAME = IC.COLUMN_NAME
--------------
AND P.INST_ID          = SM.INST_ID
AND P.SQL_ID           = SM.SQL_ID
AND P.CHILD_NUMBER     = SM.CHILD_NUMBER
AND P.PLAN_HASH_VALUE  = SM.PLAN_HASH_VALUE
--------------
AND ( P.access_predicates LIKE '%"'||IC.COLUMN_NAME||'"='||SM.NAME||'%'  or P.filter_predicates LIKE '%"'||IC.COLUMN_NAME||'"='||SM.NAME||'%'
   OR P.access_predicates LIKE '%"'||IC.COLUMN_NAME||'"<='||SM.NAME||'%' or P.filter_predicates LIKE '%"'||IC.COLUMN_NAME||'"<='||SM.NAME||'%'
   OR P.access_predicates LIKE '%"'||IC.COLUMN_NAME||'">='||SM.NAME||'%' or P.filter_predicates LIKE '%"'||IC.COLUMN_NAME||'">='||SM.NAME||'%'
   OR P.access_predicates LIKE '%"'||IC.COLUMN_NAME||'"=TO_NUMBER('||SM.NAME||'%' or P.filter_predicates LIKE '%"'||IC.COLUMN_NAME||'"=TO_NUMBER('||SM.NAME||'%'
   OR P.access_predicates LIKE '%"'||IC.COLUMN_NAME||'"<=TO_NUMBER('||SM.NAME||'%' or P.filter_predicates LIKE '%"'||IC.COLUMN_NAME||'"<=TO_NUMBER('||SM.NAME||'%'
   OR P.access_predicates LIKE '%"'||IC.COLUMN_NAME||'">=TO_NUMBER('||SM.NAME||'%' or P.filter_predicates LIKE '%"'||IC.COLUMN_NAME||'">=TO_NUMBER('||SM.NAME||'%'
   OR P.access_predicates LIKE '%"'||IC.COLUMN_NAME||'" LIKE '||SM.NAME||'%' or P.filter_predicates LIKE '%"'||IC.COLUMN_NAME||'" LIKE '||SM.NAME||'%'
   )
--ORDER BY P.ID, IC.INDEX_NAME, IC.COLUMN_POSITION
)
ORDER BY INST_ID, CHILD_NUMBER, PLAN_HASH_VALUE,  ID, INDEX_NAME, CP
)
/

pro </tbody>
pro  </table>


pro <table>
pro <tbody><tr>
pro <th>INST_ID</th>
pro <th>PLAN_HASH_VALUE</th>
pro <th>CHILD<br>NUMBER</th>
pro <th>ID</th>
pro <th>ACCESS_PREDICATES</th>
pro <th>FILTER_PREDICATES</th>
pro <th>PEEKED<br>BIND_VALUE</th>
pro <th>LOW_VALUE</th>
pro <th>HIGH_VALUE</th>
pro <th>TABLE_OWNER</th>
pro <th>TABLE_NAME</th>
pro <th>BP</th>
pro <th>COLUMN_NAME</th>
pro <th>BIND_NAME</th>
pro <th>BIND<br>DTYPE</th>
pro <th>COL<br>DTYPE</th>
pro <th>OPERATION</th>
pro <th>OPTIONS</th>
pro <th>COST</th>
pro <th>CARDINALITY</th>
pro <th>SEARCH<br>COLUMNS</th>
pro <th>NUM<br>DISTINCT</th>
pro <th>NUM<br>NULLS</th>
pro <th>NUM<br>ROWS</th>
pro <th>LAST_LOAD_TIME</th>
pro <th>SAVTIME</th>
pro </tr>

select  CHR(10)||'<tr>'||CHR(10)
     ||'<td class="r">'||INST_ID||'</td>'||CHR(10)
     ||'<td class="r">'||PLAN_HASH_VALUE||'</td>'||CHR(10)
     ||'<td class="r">'||CHILD_NUMBER||'</td>'||CHR(10)
     ||'<td class="r">'||ID||'</td>'||CHR(10)
     ||'<td class="r">'||access_predicates||'</td>'||CHR(10)
     ||'<td class="r">'||filter_predicates||'</td>'||CHR(10)
     ||'<td class="r">'||PEEKED_BIND_VALUE||'</td>'||CHR(10)
     ||'<td class="r">'||LOW_VALUE||'</td>'||CHR(10)
     ||'<td class="r">'||HIGH_VALUE||'</td>'||CHR(10)
     ||'<td class="r">'||TABLE_OWNER||'</td>'||CHR(10)
     ||'<td class="r">'||TABLE_NAME||'</td>'||CHR(10)
     ||'<td class="r">'||BP||'</td>'||CHR(10)
     ||'<td class="r">'||COLUMN_NAME||'</td>'||CHR(10)
     ||'<td class="r">'||BIND_NAME||'</td>'||CHR(10)
     ||'<td class="r">'||decode(BIND_DTYPE,COL_DTYPE,BIND_DTYPE,'<RED>'||BIND_DTYPE||'</RED>')||'</td>'||CHR(10)
     ||'<td class="r">'||COL_DTYPE||'</td>'||CHR(10)
     ||'<td class="r">'||OPERATION||'</td>'||CHR(10)
     ||'<td class="r">'||OPTIONS||'</td>'||CHR(10)
     ||'<td class="r">'||COST||'</td>'||CHR(10)
     ||'<td class="r">'||CARDINALITY||'</td>'||CHR(10)
     ||'<td class="r">'||SEARCH_COLUMNS||'</td>'||CHR(10)
     ||'<td class="r">'||NUM_DISTINCT||'</td>'||CHR(10)
     ||'<td class="r">'||NUM_NULLS||'</td>'||CHR(10)
     ||'<td class="r">'||NUM_ROWS||'</td>'||CHR(10)
     ||'<td class="r">'||LAST_LOAD_TIME||'</td>'||CHR(10)
     ||'<td class="r">'||SAVTIME||'</td>'||CHR(10)
     ||'</TR>'
from (
WITH /* TABLEH */ PT AS (
SELECT P.ID,
REPLACE(REPLACE( REGEXP_REPLACE(P.ACCESS_PREDICATES,':PSR\S+',
':'||SUBSTR(regexp_substr(P.ACCESS_PREDICATES,':PSR\S+',1),INSTR(regexp_substr(P.ACCESS_PREDICATES,':PSR\S+',1),'__')+2,LENGTH(regexp_substr(P.ACCESS_PREDICATES,':PSR\S+',1)))
  ),'TO_NUMBER(:', ':'),'TO_CHAR(:', ':') ACCESS_PREDICATES,
 SUBSTR(P.ACCESS_PREDICATES, INSTR(P.ACCESS_PREDICATES,':PSR')+4, INSTR(P.ACCESS_PREDICATES,'__')-INSTR(P.ACCESS_PREDICATES,':PSR')-4 )-1 APOSITION,
REPLACE(REPLACE( REGEXP_REPLACE(P.FILTER_PREDICATES,':PSR\S+',
':'||SUBSTR(regexp_substr(P.FILTER_PREDICATES,':PSR\S+',1),INSTR(regexp_substr(P.FILTER_PREDICATES,':PSR\S+',1),'__')+2,LENGTH(regexp_substr(P.FILTER_PREDICATES,':PSR\S+',1)))
  ),'TO_NUMBER(:', ':'),'TO_CHAR(:', ':') FILTER_PREDICATES,
 SUBSTR(P.FILTER_PREDICATES, INSTR(P.FILTER_PREDICATES,':PSR')+4, INSTR(P.FILTER_PREDICATES,'__')-INSTR(P.FILTER_PREDICATES,':PSR')-4 )-1 FPOSITION
FROM PLAN_TABLE  P
WHERE P.STATEMENT_ID = 'SMA_PSR'    AND  :L_DYN_BIND = 'Y'
AND ( P.ACCESS_PREDICATES LIKE '%:PSR%' OR P.FILTER_PREDICATES LIKE '%:PSR%' ) ),
 SM AS  (
SELECT /*+ materialize */ c.INST_ID, c.sql_id, c.plan_hash_value,  LAST_LOAD_TIME, c.CHILD_NUMBER,
         to_number(extractValue(value(d), '/bind/@pos')) position,
         extractValue(value(d), '/bind/@nam') NAME,
         extractValue(value(d), '/bind') value  ,
         --to_number(extractValue(value(d), '/bind/@ppo')) dup_pos,
         DECODE(extractValue(value(d), '/bind/@ dty'),1,'VARCHAR2',2,'NUMBER',12,'DATE',180,'TIMESTAMP',181,'TIMESTAMP', NULL ) dtype
         --to_number(extractValue(value(d), '/bind/@mxl')) max_length
    FROM   (
            select  inst_id, sql_id, plan_hash_value, LAST_LOAD_TIME, child_number
            from gv$sql
            where (inst_id, sql_id, plan_hash_value, LAST_LOAD_TIME) in
                 (select inst_id, sql_id, plan_hash_value, max(LAST_LOAD_TIME) LAST_LOAD_TIME
                  from gv$sql
                  where SQL_ID = :L_SQL_ID --AND :L_DYN_BIND = 'N'
                  group by inst_id, sql_id, plan_hash_value )
            and  SQL_ID = :L_SQL_ID ) s
         ,  gv$sql_plan c
         , TABLE(XMLSEQUENCE(EXTRACT(XMLTYPE(c.other_xml ), '/*/peeked_binds/bind'))) D
   where c.other_xml is not null and extractValue(value(d), '/bind') is not null
   AND C.SQL_ID = :L_SQL_ID
   and s.sql_id = c.sql_id and s.inst_id = c.inst_id and s.plan_hash_value = c.plan_hash_value and s.child_number = c.child_number
   )
SELECT INST_ID, PLAN_HASH_VALUE,CHILD_NUMBER, id,
--FULL_ACCESS_PREDICATES,
ACCESS_PREDICATES,
FILTER_PREDICATES,
--2021/05/27
substr(BIND_VALUE,1,length(BIND_VALUE)/3+1)||rpad('***********************************', length(BIND_VALUE)*2/3) PEEKED_BIND_VALUE,
(case when BIND_DTYPE = 'NUMBER' and COL_DTYPE = 'NUMBER'
           and to_number(BIND_VALUE) < LOW_VALUE  then '<RED>'||substr(LOW_VALUE,1,length(LOW_VALUE)/3+1)||rpad('***********************************', length(LOW_VALUE)*2/3)||'</RED>'
      when BIND_DTYPE = 'VARCHAR2' AND COL_DTYPE = 'VARCHAR2'
           and BIND_VALUE < LOW_VALUE  then '<RED>'||substr(LOW_VALUE,1,length(LOW_VALUE)/3+1)||rpad('***********************************', length(LOW_VALUE)*2/3)||'</RED>'
     ELSE  substr(LOW_VALUE,1,length(LOW_VALUE)/3+1)||rpad('***********************************', length(LOW_VALUE)*2/3)  end ) LOW_VALUE ,
(case when BIND_DTYPE = 'NUMBER' and COL_DTYPE = 'NUMBER'
           and to_number(BIND_VALUE) > HIGH_VALUE  then '<RED>'||substr(HIGH_VALUE,1,length(HIGH_VALUE)/3+1)||rpad('***********************************', length(HIGH_VALUE)*2/3)||'</RED>'
      when BIND_DTYPE = 'VARCHAR2' AND COL_DTYPE = 'VARCHAR2'
           and BIND_VALUE > HIGH_VALUE  then '<RED>'||substr(HIGH_VALUE,1,length(HIGH_VALUE)/3+1)||rpad('***********************************', length(HIGH_VALUE)*2/3)||'</RED>'
     ELSE  substr(HIGH_VALUE,1,length(HIGH_VALUE)/3+1)||rpad('***********************************', length(HIGH_VALUE)*2/3) end ) HIGH_VALUE ,
BP,
COLUMN_NAME,
TABLE_OWNER, TABLE_NAME,
BIND_NAME,
/*
 ( case
   when BIND_DTYPE = 'NUMBER' and to_number(BIND_VALUE) between to_number(low_value) and to_number(high_value)  then 'IN'
   when BIND_DTYPE = 'VARCHAR2' and to_char(BIND_VALUE) between to_char(low_value) and to_char(high_value)  then 'IN'
   when BIND_DTYPE = 'DATE' and to_date(BIND_VALUE) between to_date(low_value) and to_date(high_value)  then 'IN'
   when BIND_DTYPE = 'TIMESTAMP' and to_TIMESTAMP(BIND_VALUE) between to_TIMESTAMP(low_value) and to_TIMESTAMP(high_value)  then 'IN'
   ELSE 'OUT' END) WITHIN,
*/
BIND_DTYPE BIND_DTYPE,
/*
decode(:L_DYN_BIND,'Y',NULL,BIND_DTYPE) BIND_DTYPE,
*/
COL_DTYPE,
--HISTOGRAM,
substr(OPERATION,1,20) OPERATION, substr(OPTIONS,1,20) OPTIONS, COST, CARDINALITY, SEARCH_COLUMNS
, NUM_DISTINCT,  NUM_NULLS,  NUM_ROWS
, LAST_LOAD_TIME, SAVTIME
FROM (
select /*+ LEADING(PT SM P IC T T1 C) */ --P.INST_ID, , P.sql_id, P.plan_hash_value, P.object_type,
DISTINCT p.INST_ID, P.plan_hash_value, P.CHILD_NUMBER, P.id,
P.access_predicates FULL_ACCESS_PREDICATES,
DECODE(SIGN(INSTR( P.access_predicates, '"'||C.NAME||'"='||SM.NAME,1)),1,
 SUBSTR(P.access_predicates,INSTR( P.access_predicates, '"'||C.NAME||'"='||SM.NAME,1),LENGTH( '"'||C.NAME||'"='||SM.NAME))
 ,DECODE(SIGN(INSTR( P.access_predicates, '"'||C.NAME||'">='||SM.NAME,1)),1,
   SUBSTR(P.access_predicates,INSTR( P.access_predicates, '"'||C.NAME||'">='||SM.NAME,1),LENGTH( '"'||C.NAME||'">='||SM.NAME))
   ,DECODE(SIGN(INSTR( P.access_predicates, '"'||C.NAME||'"<='||SM.NAME,1)),1,
     SUBSTR(P.access_predicates,INSTR( P.access_predicates, '"'||C.NAME||'"<='||SM.NAME,1),LENGTH( '"'||C.NAME||'"<='||SM.NAME))
     ,DECODE(SIGN(INSTR( P.access_predicates, '"'||C.NAME||'"=TO_NUMBER('||SM.NAME,1)),1,
       SUBSTR(P.access_predicates,INSTR( P.access_predicates, '"'||C.NAME||'"=TO_NUMBER('||SM.NAME,1),LENGTH( '"'||C.NAME||'"=TO_NUMBER('||SM.NAME)+1)
       ,DECODE(SIGN(INSTR( P.access_predicates, '"'||C.NAME||'"<=TO_NUMBER('||SM.NAME,1)),1,
        SUBSTR(P.access_predicates,INSTR( P.access_predicates, '"'||C.NAME||'"<=TO_NUMBER('||SM.NAME,1),LENGTH( '"'||C.NAME||'"<=TO_NUMBER('||SM.NAME)+1)
        ,DECODE(SIGN(INSTR( P.access_predicates, '"'||C.NAME||'">=TO_NUMBER('||SM.NAME,1)),1,
         SUBSTR(P.access_predicates,INSTR( P.access_predicates, '"'||C.NAME||'">=TO_NUMBER('||SM.NAME,1),LENGTH( '"'||C.NAME||'">=TO_NUMBER('||SM.NAME)+1)
        ,DECODE(SIGN(INSTR( P.access_predicates, '"'||C.NAME||'" LIKE '||SM.NAME,1)),1,
         SUBSTR(P.access_predicates,INSTR( P.access_predicates, '"'||C.NAME||'" LIKE '||SM.NAME,1),LENGTH( '"'||C.NAME||'" LIKE '||SM.NAME)+1)
))))))) access_predicates,
--P.filter_predicates FULL_FILTER_PREDICATES,
DECODE(SIGN(INSTR( P.filter_predicates, '"'||C.NAME||'"='||SM.NAME,1)),1,
 SUBSTR(P.filter_predicates,INSTR( P.filter_predicates, '"'||C.NAME||'"='||SM.NAME,1),LENGTH( '"'||C.NAME||'"='||SM.NAME))
 ,DECODE(SIGN(INSTR( P.filter_predicates, '"'||C.NAME||'">='||SM.NAME,1)),1,
   SUBSTR(P.filter_predicates,INSTR( P.filter_predicates, '"'||C.NAME||'">='||SM.NAME,1),LENGTH( '"'||C.NAME||'">='||SM.NAME))
   ,DECODE(SIGN(INSTR( P.filter_predicates, '"'||C.NAME||'"<='||SM.NAME,1)),1,
     SUBSTR(P.filter_predicates,INSTR( P.filter_predicates, '"'||C.NAME||'"<='||SM.NAME,1),LENGTH( '"'||C.NAME||'"<='||SM.NAME))
     ,DECODE(SIGN(INSTR( P.filter_predicates, '"'||C.NAME||'"=TO_NUMBER('||SM.NAME,1)),1,
       SUBSTR(P.filter_predicates,INSTR( P.filter_predicates, '"'||C.NAME||'"=TO_NUMBER('||SM.NAME,1),LENGTH( '"'||C.NAME||'"=TO_NUMBER('||SM.NAME)+1)
       ,DECODE(SIGN(INSTR( P.filter_predicates, '"'||C.NAME||'"<=TO_NUMBER('||SM.NAME,1)),1,
        SUBSTR(P.filter_predicates,INSTR( P.filter_predicates, '"'||C.NAME||'"<=TO_NUMBER('||SM.NAME,1),LENGTH( '"'||C.NAME||'"<=TO_NUMBER('||SM.NAME)+1)
        ,DECODE(SIGN(INSTR( P.filter_predicates, '"'||C.NAME||'">=TO_NUMBER('||SM.NAME,1)),1,
         SUBSTR(P.filter_predicates,INSTR( P.access_predicates, '"'||C.NAME||'">=TO_NUMBER('||SM.NAME,1),LENGTH( '"'||C.NAME||'">=TO_NUMBER('||SM.NAME)+1)
         ,DECODE(SIGN(INSTR( P.filter_predicates, '"'||C.NAME||'" LIKE '||SM.NAME,1)),1,
          SUBSTR(P.filter_predicates,INSTR( P.access_predicates, '"'||C.NAME||'" LIKE '||SM.NAME,1),LENGTH( '"'||C.NAME||'" LIKE '||SM.NAME)+1)
))))))) filter_predicates,
--IC.INDEX_NAME,
SM.POSITION BP, C.NAME COLUMN_NAME,
t.owner table_owner, t.table_name,
       ( SELECT  substr(
         decode(c.type#
          ,2       ,to_char(utl_raw.cast_to_number(CSH.LOWVAL)) ||''
          ,1     ,to_char(utl_raw.cast_to_varchar2(CSH.LOWVAL)) ||''
          ,287    ,to_char(utl_raw.cast_to_nvarchar2(CSH.LOWVAL)) ||''
          ,101    ,to_char(utl_raw.cast_to_binary_double(CSH.LOWVAL)) ||''
          ,100    ,to_char(utl_raw.cast_to_binary_float(CSH.LOWVAL)) ||''
          ,12         ,decode(CSH.LOWVAL, NULL, NULL, rtrim(
                                to_char(100*(to_number(substr(CSH.LOWVAL,1,2),'XX')-100)
                                       + (to_number(substr(CSH.LOWVAL,3,2),'XX')-100),'fm0000')||'-'||
                                to_char(to_number(substr(CSH.LOWVAL,5,2),'XX'),'fm00')||'-'||
                                to_char(to_number(substr(CSH.LOWVAL,7,2),'XX'),'fm00')||' '||
                                to_char(to_number(substr(CSH.LOWVAL,9,2),'XX')-1,'fm00')||':'||
                                to_char(to_number(substr(CSH.LOWVAL,11,2),'XX')-1,'fm00')||':'||
                                to_char(to_number(substr(CSH.LOWVAL,13,2),'XX')-1,'fm00'))) ||''
          ,187    ,decode(CSH.LOWVAL, NULL, NULL, rtrim(
                           to_char(100*(to_number(substr(CSH.LOWVAL,1,2),'XX')-100)
                                  + (to_number(substr(CSH.LOWVAL,3,2),'XX')-100),'fm0000')||'-'||
                           to_char(to_number(substr(CSH.LOWVAL,5,2),'XX'),'fm00')||'-'||
                           to_char(to_number(substr(CSH.LOWVAL,7,2),'XX'),'fm00')||' '||
                           to_char(to_number(substr(CSH.LOWVAL,9,2),'XX')-1,'fm00')||':'||
                           to_char(to_number(substr(CSH.LOWVAL,11,2),'XX')-1,'fm00')||':'||
                           to_char(to_number(substr(CSH.LOWVAL,13,2),'XX')-1,'fm00')
                          ||'.'||to_number(substr(CSH.LOWVAL,15,8),'XXXXXXXX')  )) ||''
          , CSH.LOWVAL
        ),1,30) low_value
        FROM SYS.WRI$_OPTSTAT_HISTHEAD_HISTORY CSH
        WHERE CSH.OBJ#       = T1.OBJECT_ID
        AND   CSH.INTCOL#    = C.INTCOL#
        AND   to_DATE(to_CHAR(CSH.SAVTIME,'yyyy-mm-dd hh24:mi:ss'),'yyyy-mm-dd hh24:mi:ss') < SM.last_load_time
--        AND   to_DATE(to_CHAR(CSH.SAVTIME,'yyyy-mm-dd hh24:mi:ss'),'yyyy-mm-dd hh24:mi:ss') < SM.last_load_time
        order by to_DATE(to_CHAR(CSH.SAVTIME,'yyyy-mm-dd hh24:mi:ss'),'yyyy-mm-dd hh24:mi:ss') desc FETCH FIRST 1 ROW ONLY ) LOW_VALUE,
       ( SELECT  substr(
         decode(c.type# -- as there are several timestamp types
          ,2       ,to_char(utl_raw.cast_to_number(CSH.HIVAL)) ||''
          ,1     ,to_char(utl_raw.cast_to_varchar2(CSH.HIVAL)) ||''
          ,287    ,to_char(utl_raw.cast_to_nvarchar2(CSH.HIVAL)) ||''
          ,101    ,to_char(utl_raw.cast_to_binary_double(CSH.HIVAL)) ||''
          ,100    ,to_char(utl_raw.cast_to_binary_float(CSH.HIVAL)) ||''
          ,12         ,decode(CSH.HIVAL, NULL, NULL, rtrim(
                                to_char(100*(to_number(substr(CSH.HIVAL,1,2),'XX')-100)
                                       + (to_number(substr(CSH.HIVAL,3,2),'XX')-100),'fm0000')||'-'||
                                to_char(to_number(substr(CSH.HIVAL,5,2),'XX'),'fm00')||'-'||
                                to_char(to_number(substr(CSH.HIVAL,7,2),'XX'),'fm00')||' '||
                                to_char(to_number(substr(CSH.HIVAL,9,2),'XX')-1,'fm00')||':'||
                                to_char(to_number(substr(CSH.HIVAL,11,2),'XX')-1,'fm00')||':'||
                                to_char(to_number(substr(CSH.HIVAL,13,2),'XX')-1,'fm00'))) ||''
          ,187    ,decode(CSH.HIVAL, NULL, NULL, rtrim(
                           to_char(100*(to_number(substr(CSH.HIVAL,1,2),'XX')-100)
                                  + (to_number(substr(CSH.HIVAL,3,2),'XX')-100),'fm0000')||'-'||
                           to_char(to_number(substr(CSH.HIVAL,5,2),'XX'),'fm00')||'-'||
                           to_char(to_number(substr(CSH.HIVAL,7,2),'XX'),'fm00')||' '||
                           to_char(to_number(substr(CSH.HIVAL,9,2),'XX')-1,'fm00')||':'||
                           to_char(to_number(substr(CSH.HIVAL,11,2),'XX')-1,'fm00')||':'||
                           to_char(to_number(substr(CSH.HIVAL,13,2),'XX')-1,'fm00')
                          ||'.'||to_number(substr(CSH.HIVAL,15,8),'XXXXXXXX')  )) ||''
          , CSH.HIVAL
        ),1,30) HIGH_VALUE
        FROM SYS.WRI$_OPTSTAT_HISTHEAD_HISTORY CSH
        WHERE CSH.OBJ#       = T1.OBJECT_ID
        AND   CSH.INTCOL#    = C.INTCOL#
        AND   to_DATE(to_CHAR(CSH.SAVTIME,'yyyy-mm-dd hh24:mi:ss'),'yyyy-mm-dd hh24:mi:ss') < SM.last_load_time
--        AND   to_DATE(to_CHAR(CSH.SAVTIME,'yyyy-mm-dd hh24:mi:ss'),'yyyy-mm-dd hh24:mi:ss') < SM.last_load_time
        order by to_DATE(to_CHAR(CSH.SAVTIME,'yyyy-mm-dd hh24:mi:ss'),'yyyy-mm-dd hh24:mi:ss') desc FETCH FIRST 1 ROW ONLY ) HIGH_VALUE,
        SM.NAME BIND_NAME,
        substr(
        decode( SUBSTR(SM.dtype,1,9)
          ,'NUMBER'       ,to_char(utl_raw.cast_to_number(SM.VALUE)) ||''
          ,'VARCHAR2'     ,to_char(utl_raw.cast_to_varchar2(SM.VALUE)) ||''
          ,'NVARCHAR2'    ,to_char(utl_raw.cast_to_nvarchar2(SM.VALUE)) ||''
          ,'BINARY_DO'    ,to_char(utl_raw.cast_to_binary_double(SM.VALUE)) ||''
          ,'DATE'         ,decode(SM.VALUE, NULL, NULL, rtrim(
                                to_char(100*(to_number(substr(SM.VALUE,1,2),'XX')-100)
                                       + (to_number(substr(SM.VALUE,3,2),'XX')-100),'fm0000')||'-'||
                                to_char(to_number(substr(SM.VALUE,5,2),'XX'),'fm00')||'-'||
                                to_char(to_number(substr(SM.VALUE,7,2),'XX'),'fm00')||' '||
                                to_char(to_number(substr(SM.VALUE,9,2),'XX')-1,'fm00')||':'||
                                to_char(to_number(substr(SM.VALUE,11,2),'XX')-1,'fm00')||':'||
                                to_char(to_number(substr(SM.VALUE,13,2),'XX')-1,'fm00'))) ||''
          ,'TIMESTAMP'    ,decode(SM.VALUE, NULL, NULL, rtrim(
                           to_char(100*(to_number(substr(SM.VALUE,1,2),'XX')-100)
                                  + (to_number(substr(SM.VALUE,3,2),'XX')-100),'fm0000')||'-'||
                           to_char(to_number(substr(SM.VALUE,5,2),'XX'),'fm00')||'-'||
                           to_char(to_number(substr(SM.VALUE,7,2),'XX'),'fm00')||' '||
                           to_char(to_number(substr(SM.VALUE,9,2),'XX')-1,'fm00')||':'||
                           to_char(to_number(substr(SM.VALUE,11,2),'XX')-1,'fm00')||':'||
                           to_char(to_number(substr(SM.VALUE,13,2),'XX')-1,'fm00')
                          ||'.'||to_char(to_number(substr(SM.VALUE,15,8),'XXXXXXXX')))) ||''
          , SM.VALUE
       ),1,30) BIND_VALUE,
       --( case when SM.VALUE between CSH.LOWVAL and M.high_value then 'IN' ELSE 'OUT' END) WITHIN,
       SM.DTYPE BIND_DTYPE,
--       M.DATA_TYPE COL_DTYPE, m.HISTOGRAM,
DECODE(c.type#, 1,'VARCHAR2',2,'NUMBER',12,'DATE',180,'TIMESTAMP',181,'TIMESTAMP', C.TYPE#)  COL_DTYPE,
       p.OPERATION, p.OPTIONS, p.SEARCH_COLUMNS, P.COST, P.CARDINALITY,
--       , M.NUM_DISTINCT,  M.NUM_NULLS, T.NUM_ROWS - M.NUM_NULLS NUM_ROWS
       ( SELECT  CSH.DISTCNT  NUM_DISTINCT
        FROM SYS.WRI$_OPTSTAT_HISTHEAD_HISTORY CSH
        WHERE CSH.OBJ#       = T1.OBJECT_ID
        AND   CSH.INTCOL#    = C.INTCOL#
        AND   to_DATE(to_CHAR(CSH.SAVTIME,'yyyy-mm-dd hh24:mi:ss'),'yyyy-mm-dd hh24:mi:ss') < SM.last_load_time
--        AND   to_DATE(to_CHAR(CSH.SAVTIME,'yyyy-mm-dd hh24:mi:ss'),'yyyy-mm-dd hh24:mi:ss') < SM.last_load_time
        order by to_DATE(to_CHAR(CSH.SAVTIME,'yyyy-mm-dd hh24:mi:ss'),'yyyy-mm-dd hh24:mi:ss') desc FETCH FIRST 1 ROW ONLY ) NUM_DISTINCT,
       ( SELECT  CSH.NULL_CNT  NUM_NULLS
        FROM SYS.WRI$_OPTSTAT_HISTHEAD_HISTORY CSH
        WHERE CSH.OBJ#       = T1.OBJECT_ID
        AND   CSH.INTCOL#    = C.INTCOL#
        AND   to_DATE(to_CHAR(CSH.SAVTIME,'yyyy-mm-dd hh24:mi:ss'),'yyyy-mm-dd hh24:mi:ss') < SM.last_load_time
--        AND   to_DATE(to_CHAR(CSH.SAVTIME,'yyyy-mm-dd hh24:mi:ss'),'yyyy-mm-dd hh24:mi:ss') < SM.last_load_time
        order by to_DATE(to_CHAR(CSH.SAVTIME,'yyyy-mm-dd hh24:mi:ss'),'yyyy-mm-dd hh24:mi:ss') desc FETCH FIRST 1 ROW ONLY ) NUM_NULLS,
       ( SELECT  CSH.SAMPLE_SIZE SAMPLE_SIZE
        FROM SYS.WRI$_OPTSTAT_HISTHEAD_HISTORY CSH
        WHERE CSH.OBJ#       = T1.OBJECT_ID
        AND   CSH.INTCOL#    = C.INTCOL#
        AND   to_DATE(to_CHAR(CSH.SAVTIME,'yyyy-mm-dd hh24:mi:ss'),'yyyy-mm-dd hh24:mi:ss') < SM.last_load_time
--        AND   to_DATE(to_CHAR(CSH.SAVTIME,'yyyy-mm-dd hh24:mi:ss'),'yyyy-mm-dd hh24:mi:ss') < SM.last_load_time
        order by to_DATE(to_CHAR(CSH.SAVTIME,'yyyy-mm-dd hh24:mi:ss'),'yyyy-mm-dd hh24:mi:ss') desc FETCH FIRST 1 ROW ONLY ) NUM_ROWS,
      sm.LAST_LOAD_TIME,
      ( SELECT  to_char(TIMESTAMP#,'yyyy-mm-dd hh24:mi:ss')||' - '||to_CHAR(CSH.SAVTIME,'yyyy-mm-dd hh24:mi:ss') SAVTIME
        FROM SYS.WRI$_OPTSTAT_HISTHEAD_HISTORY CSH
        WHERE CSH.OBJ#       = T1.OBJECT_ID
        AND   CSH.INTCOL#    = C.INTCOL#
        AND   to_DATE(to_CHAR(CSH.SAVTIME,'yyyy-mm-dd hh24:mi:ss'),'yyyy-mm-dd hh24:mi:ss') < SM.last_load_time
--        AND   to_DATE(to_CHAR(CSH.SAVTIME,'yyyy-mm-dd hh24:mi:ss'),'yyyy-mm-dd hh24:mi:ss') < SM.last_load_time
        order by to_DATE(to_CHAR(CSH.SAVTIME,'yyyy-mm-dd hh24:mi:ss'),'yyyy-mm-dd hh24:mi:ss') desc FETCH FIRST 1 ROW ONLY ) SAVTIME
from PT, SM, gv$sql_plan P,
--DBA_IND_COLUMNS IC,
DBA_TABLES T,
SYS.COL$ C,
--DBA_OBJECTS T1
( SELECT  O.OBJ# OBJECT_ID, O.NAME OBJECT_NAME, U.NAME OWNER,  'TABLE' OBJECT_TYPE
  FROM SYS.OBJ$ O, SYS.USER$ U WHERE O.OWNER# = U.USER#  AND O.TYPE# = 2) T1
where ( ( PT.APOSITION = SM.POSITION AND  PT.ACCESS_PREDICATES LIKE  '%"'||C.NAME||'"%'||SM.NAME||'%' )
     OR ( PT.FPOSITION = SM.POSITION AND  PT.FILTER_PREDICATES LIKE  '%"'||C.NAME||'"%'||SM.NAME||'%' ) )
/*
AND ( SUBSTR( PT.ACCESS_PREDICATES,INSTR(PT.ACCESS_PREDICATES,':')-4,7)
      = SUBSTR(P.ACCESS_PREDICATES,INSTR(P.ACCESS_PREDICATES,':')-4,7)
  OR  SUBSTR( PT.FILTER_PREDICATES,INSTR(PT.FILTER_PREDICATES,':')-4,7)
      LIKE SUBSTR(P.FILTER_PREDICATES,INSTR(P.FILTER_PREDICATES,':')-4,6)||')'
  OR  SUBSTR( PT.ACCESS_PREDICATES,INSTR(PT.ACCESS_PREDICATES,':')-4,7)
      = SUBSTR(P.ACCESS_PREDICATES,INSTR(P.ACCESS_PREDICATES,':')-4,7)
  OR  SUBSTR( PT.FILTER_PREDICATES,INSTR(PT.FILTER_PREDICATES,':')-4,7)
      LIKE SUBSTR(P.FILTER_PREDICATES,INSTR(P.FILTER_PREDICATES,':')-4,6)||')'  )
*/
AND  T1.OBJECT_NAME = T.TABLE_NAME   AND T1.OWNER = T.OWNER  AND T1.OBJECT_TYPE = 'TABLE'
AND C.OBJ# = T1.OBJECT_ID   --AND C.NAME = IC.NAME
AND ( P.access_predicates like '%=:%'  or P.filter_predicates like '%=:%'
OR P.access_predicates like '%<=:%'  or P.filter_predicates like '%<=:%'
OR P.access_predicates like '%>=:%'  or P.filter_predicates like '%>=:%'
OR P.access_predicates like '%=TO_NUMBER(:%'  or P.filter_predicates like '%=TO_NUMBER(:%'
OR P.access_predicates like '%<=TO_NUMBER(:%'  or P.filter_predicates like '%<=TO_NUMBER(:%'
OR P.access_predicates like '%>=TO_NUMBER(:%'  or P.filter_predicates like '%>=TO_NUMBER(:%'
OR P.access_predicates like '% LIKE :%'  or P.filter_predicates like '% LIKE :%'
)
--and ( P.access_predicates not like '%"SESSION_ROLE_SET_KEY"="FND_GLOBAL"."SESSION_ROLE_SET_KEY"%'
--and    P.access_predicates not like '%"SANDBOX_ID"=SYS_CONTEXT(''FND_VPD_CTX''%'
--and    P.access_predicates not like '%"USER_GUID"="FND_GLOBAL"."USER_GUID"()%'
--and    P.access_predicates not like '%"ENTERPRISE_ID"=%"FUNCTION_ID"=%' )
and  P.object_type LIKE '%TABLE%'
and T.TABLE_NAME   = P.OBJECT_NAME
AND T.OWNER        = P.OBJECT_OWNER
and P.SQL_ID = :L_SQL_ID
AND ( P.access_predicates LIKE '%"'||C.NAME||'"=:%'   or P.filter_predicates LIKE '%"'||C.NAME||'"=:%'
   OR P.access_predicates LIKE '%"'||C.NAME||'"<=:%'  or P.filter_predicates LIKE '%"'||C.NAME||'"<=:%'
   OR P.access_predicates LIKE '%"'||C.NAME||'">=:%'  or P.filter_predicates LIKE '%"'||C.NAME||'">=:%'
   OR P.access_predicates LIKE '%"'||C.NAME||'"=TO_NUMBER(:%'   or P.filter_predicates LIKE '%"'||C.NAME||'"=TO_NUMBER(:%'
   OR P.access_predicates LIKE '%"'||C.NAME||'"<=TO_NUMBER(:%'  or P.filter_predicates LIKE '%"'||C.NAME||'"<=TO_NUMBER(:%'
   OR P.access_predicates LIKE '%"'||C.NAME||'">=TO_NUMBER(:%'  or P.filter_predicates LIKE '%"'||C.NAME||'">=TO_NUMBER(:%'
   OR P.access_predicates LIKE '%"'||C.NAME||'" LIKE :%'  or P.filter_predicates LIKE '%"'||C.NAME||'" LIKE :%'
   )
AND P.OPTIONS NOT IN ('FAST FULL SCAN','SAMPLE FAST FULL SCAN')
--AND M.OWNER       = IC.TABLE_OWNER
--AND M.TABLE_NAME  = IC.TABLE_NAME
--AND M.COLUMN_NAME = C.NAME
--------------
AND P.INST_ID          = SM.INST_ID
AND P.SQL_ID           = SM.SQL_ID
AND P.CHILD_NUMBER     = SM.CHILD_NUMBER
AND P.PLAN_HASH_VALUE  = SM.PLAN_HASH_VALUE
--------------
AND ( P.access_predicates LIKE '%"'||C.NAME||'"='||SM.NAME||'%'  or P.filter_predicates LIKE '%"'||C.NAME||'"='||SM.NAME||'%'
   OR P.access_predicates LIKE '%"'||C.NAME||'"<='||SM.NAME||'%' or P.filter_predicates LIKE '%"'||C.NAME||'"<='||SM.NAME||'%'
   OR P.access_predicates LIKE '%"'||C.NAME||'">='||SM.NAME||'%' or P.filter_predicates LIKE '%"'||C.NAME||'">='||SM.NAME||'%'
   OR P.access_predicates LIKE '%"'||C.NAME||'"=TO_NUMBER('||SM.NAME||'%' or P.filter_predicates LIKE '%"'||C.NAME||'"=TO_NUMBER('||SM.NAME||'%'
   OR P.access_predicates LIKE '%"'||C.NAME||'"<=TO_NUMBER('||SM.NAME||'%' or P.filter_predicates LIKE '%"'||C.NAME||'"<=TO_NUMBER('||SM.NAME||'%'
   OR P.access_predicates LIKE '%"'||C.NAME||'">=TO_NUMBER('||SM.NAME||'%' or P.filter_predicates LIKE '%"'||C.NAME||'">=TO_NUMBER('||SM.NAME||'%' 
   OR P.access_predicates LIKE '%"'||C.NAME||'" LIKE '||SM.NAME||'%' or P.filter_predicates LIKE '%"'||C.NAME||'" LIKE '||SM.NAME||'%'
   )
--ORDER BY P.ID, IC.INDEX_NAME, IC.COLUMN_POSITION
)
union all
SELECT INST_ID, PLAN_HASH_VALUE,CHILD_NUMBER, id,
--FULL_ACCESS_PREDICATES,
ACCESS_PREDICATES,
FILTER_PREDICATES,
--2021/05/27
substr(BIND_VALUE,1,length(BIND_VALUE)/3+1)||rpad('***********************************', length(BIND_VALUE)*2/3) PEEKED_BIND_VALUE,
(case when BIND_DTYPE = 'NUMBER' and COL_DTYPE = 'NUMBER'
           and to_number(BIND_VALUE) < LOW_VALUE  then '<RED>'||substr(LOW_VALUE,1,length(LOW_VALUE)/3+1)||rpad('***********************************', length(LOW_VALUE)*2/3)||'</RED>'
      when BIND_DTYPE = 'VARCHAR2' AND COL_DTYPE = 'VARCHAR2'
           and BIND_VALUE < LOW_VALUE  then '<RED>'||substr(LOW_VALUE,1,length(LOW_VALUE)/3+1)||rpad('***********************************', length(LOW_VALUE)*2/3)||'</RED>'
     ELSE  substr(LOW_VALUE,1,length(LOW_VALUE)/3+1)||rpad('***********************************', length(LOW_VALUE)*2/3)  end ) LOW_VALUE ,
(case when BIND_DTYPE = 'NUMBER' and COL_DTYPE = 'NUMBER'
           and to_number(BIND_VALUE) > HIGH_VALUE  then '<RED>'||substr(HIGH_VALUE,1,length(HIGH_VALUE)/3+1)||rpad('***********************************', length(HIGH_VALUE)*2/3)||'</RED>'
      when BIND_DTYPE = 'VARCHAR2' AND COL_DTYPE = 'VARCHAR2'
           and BIND_VALUE > HIGH_VALUE  then '<RED>'||substr(HIGH_VALUE,1,length(HIGH_VALUE)/3+1)||rpad('***********************************', length(HIGH_VALUE)*2/3)||'</RED>'
     ELSE  substr(HIGH_VALUE,1,length(HIGH_VALUE)/3+1)||rpad('***********************************', length(HIGH_VALUE)*2/3) end ) HIGH_VALUE ,
BP,
COLUMN_NAME,
TABLE_OWNER, TABLE_NAME,
BIND_NAME,
/*
 ( case
   when BIND_DTYPE = 'NUMBER' and to_number(BIND_VALUE) between to_number(low_value) and to_number(high_value)  then 'IN'
   when BIND_DTYPE = 'VARCHAR2' and to_char(BIND_VALUE) between to_char(low_value) and to_char(high_value)  then 'IN'
   when BIND_DTYPE = 'DATE' and to_date(BIND_VALUE) between to_date(low_value) and to_date(high_value)  then 'IN'
   when BIND_DTYPE = 'TIMESTAMP' and to_TIMESTAMP(BIND_VALUE) between to_TIMESTAMP(low_value) and to_TIMESTAMP(high_value)  then 'IN'
   ELSE 'OUT' END) WITHIN,
*/
BIND_DTYPE BIND_DTYPE,
/*
decode(:L_DYN_BIND,'Y',NULL,BIND_DTYPE) BIND_DTYPE,
*/
COL_DTYPE,
--HISTOGRAM,
substr(OPERATION,1,20) OPERATION, substr(OPTIONS,1,20) OPTIONS, COST, CARDINALITY, SEARCH_COLUMNS
, NUM_DISTINCT,  NUM_NULLS,  NUM_ROWS
, LAST_LOAD_TIME, SAVTIME
FROM (
select /*+ LEADING(PT SM P IC T T1 C) */ --P.INST_ID, , P.sql_id, P.plan_hash_value, P.object_type,
DISTINCT p.INST_ID, P.plan_hash_value, P.CHILD_NUMBER, P.id,
P.access_predicates FULL_ACCESS_PREDICATES,
DECODE(SIGN(INSTR( P.access_predicates, '"'||C.NAME||'"='||SM.NAME,1)),1,
 SUBSTR(P.access_predicates,INSTR( P.access_predicates, '"'||C.NAME||'"='||SM.NAME,1),LENGTH( '"'||C.NAME||'"='||SM.NAME))
 ,DECODE(SIGN(INSTR( P.access_predicates, '"'||C.NAME||'">='||SM.NAME,1)),1,
   SUBSTR(P.access_predicates,INSTR( P.access_predicates, '"'||C.NAME||'">='||SM.NAME,1),LENGTH( '"'||C.NAME||'">='||SM.NAME))
   ,DECODE(SIGN(INSTR( P.access_predicates, '"'||C.NAME||'"<='||SM.NAME,1)),1,
     SUBSTR(P.access_predicates,INSTR( P.access_predicates, '"'||C.NAME||'"<='||SM.NAME,1),LENGTH( '"'||C.NAME||'"<='||SM.NAME))
     ,DECODE(SIGN(INSTR( P.access_predicates, '"'||C.NAME||'"=TO_NUMBER('||SM.NAME,1)),1,
       SUBSTR(P.access_predicates,INSTR( P.access_predicates, '"'||C.NAME||'"=TO_NUMBER('||SM.NAME,1),LENGTH( '"'||C.NAME||'"=TO_NUMBER('||SM.NAME)+1)
       ,DECODE(SIGN(INSTR( P.access_predicates, '"'||C.NAME||'"<=TO_NUMBER('||SM.NAME,1)),1,
        SUBSTR(P.access_predicates,INSTR( P.access_predicates, '"'||C.NAME||'"<=TO_NUMBER('||SM.NAME,1),LENGTH( '"'||C.NAME||'"<=TO_NUMBER('||SM.NAME)+1)
        ,DECODE(SIGN(INSTR( P.access_predicates, '"'||C.NAME||'">=TO_NUMBER('||SM.NAME,1)),1,
         SUBSTR(P.access_predicates,INSTR( P.access_predicates, '"'||C.NAME||'">=TO_NUMBER('||SM.NAME,1),LENGTH( '"'||C.NAME||'">=TO_NUMBER('||SM.NAME)+1)
        ,DECODE(SIGN(INSTR( P.access_predicates, '"'||C.NAME||'" LIKE '||SM.NAME,1)),1,
         SUBSTR(P.access_predicates,INSTR( P.access_predicates, '"'||C.NAME||'" LIKE '||SM.NAME,1),LENGTH( '"'||C.NAME||'" LIKE '||SM.NAME)+1)
))))))) access_predicates,
--P.filter_predicates FULL_FILTER_PREDICATES,
DECODE(SIGN(INSTR( P.filter_predicates, '"'||C.NAME||'"='||SM.NAME,1)),1,
 SUBSTR(P.filter_predicates,INSTR( P.filter_predicates, '"'||C.NAME||'"='||SM.NAME,1),LENGTH( '"'||C.NAME||'"='||SM.NAME))
 ,DECODE(SIGN(INSTR( P.filter_predicates, '"'||C.NAME||'">='||SM.NAME,1)),1,
   SUBSTR(P.filter_predicates,INSTR( P.filter_predicates, '"'||C.NAME||'">='||SM.NAME,1),LENGTH( '"'||C.NAME||'">='||SM.NAME))
   ,DECODE(SIGN(INSTR( P.filter_predicates, '"'||C.NAME||'"<='||SM.NAME,1)),1,
     SUBSTR(P.filter_predicates,INSTR( P.filter_predicates, '"'||C.NAME||'"<='||SM.NAME,1),LENGTH( '"'||C.NAME||'"<='||SM.NAME))
     ,DECODE(SIGN(INSTR( P.filter_predicates, '"'||C.NAME||'"=TO_NUMBER('||SM.NAME,1)),1,
       SUBSTR(P.filter_predicates,INSTR( P.filter_predicates, '"'||C.NAME||'"=TO_NUMBER('||SM.NAME,1),LENGTH( '"'||C.NAME||'"=TO_NUMBER('||SM.NAME)+1)
       ,DECODE(SIGN(INSTR( P.filter_predicates, '"'||C.NAME||'"<=TO_NUMBER('||SM.NAME,1)),1,
        SUBSTR(P.filter_predicates,INSTR( P.filter_predicates, '"'||C.NAME||'"<=TO_NUMBER('||SM.NAME,1),LENGTH( '"'||C.NAME||'"<=TO_NUMBER('||SM.NAME)+1)
        ,DECODE(SIGN(INSTR( P.filter_predicates, '"'||C.NAME||'">=TO_NUMBER('||SM.NAME,1)),1,
         SUBSTR(P.filter_predicates,INSTR( P.access_predicates, '"'||C.NAME||'">=TO_NUMBER('||SM.NAME,1),LENGTH( '"'||C.NAME||'">=TO_NUMBER('||SM.NAME)+1)
         ,DECODE(SIGN(INSTR( P.filter_predicates, '"'||C.NAME||'" LIKE '||SM.NAME,1)),1,
          SUBSTR(P.filter_predicates,INSTR( P.access_predicates, '"'||C.NAME||'" LIKE '||SM.NAME,1),LENGTH( '"'||C.NAME||'" LIKE '||SM.NAME)+1)
))))))) filter_predicates,
--IC.INDEX_NAME,
SM.POSITION BP, C.NAME COLUMN_NAME,
t.owner table_owner, t.table_name,
       ( SELECT  substr(
         decode(c.type#
          ,2       ,to_char(utl_raw.cast_to_number(CSH.LOWVAL)) ||''
          ,1     ,to_char(utl_raw.cast_to_varchar2(CSH.LOWVAL)) ||''
          ,287    ,to_char(utl_raw.cast_to_nvarchar2(CSH.LOWVAL)) ||''
          ,101    ,to_char(utl_raw.cast_to_binary_double(CSH.LOWVAL)) ||''
          ,100    ,to_char(utl_raw.cast_to_binary_float(CSH.LOWVAL)) ||''
          ,12         ,decode(CSH.LOWVAL, NULL, NULL, rtrim(
                                to_char(100*(to_number(substr(CSH.LOWVAL,1,2),'XX')-100)
                                       + (to_number(substr(CSH.LOWVAL,3,2),'XX')-100),'fm0000')||'-'||
                                to_char(to_number(substr(CSH.LOWVAL,5,2),'XX'),'fm00')||'-'||
                                to_char(to_number(substr(CSH.LOWVAL,7,2),'XX'),'fm00')||' '||
                                to_char(to_number(substr(CSH.LOWVAL,9,2),'XX')-1,'fm00')||':'||
                                to_char(to_number(substr(CSH.LOWVAL,11,2),'XX')-1,'fm00')||':'||
                                to_char(to_number(substr(CSH.LOWVAL,13,2),'XX')-1,'fm00'))) ||''
          ,187    ,decode(CSH.LOWVAL, NULL, NULL, rtrim(
                           to_char(100*(to_number(substr(CSH.LOWVAL,1,2),'XX')-100)
                                  + (to_number(substr(CSH.LOWVAL,3,2),'XX')-100),'fm0000')||'-'||
                           to_char(to_number(substr(CSH.LOWVAL,5,2),'XX'),'fm00')||'-'||
                           to_char(to_number(substr(CSH.LOWVAL,7,2),'XX'),'fm00')||' '||
                           to_char(to_number(substr(CSH.LOWVAL,9,2),'XX')-1,'fm00')||':'||
                           to_char(to_number(substr(CSH.LOWVAL,11,2),'XX')-1,'fm00')||':'||
                           to_char(to_number(substr(CSH.LOWVAL,13,2),'XX')-1,'fm00')
                          ||'.'||to_number(substr(CSH.LOWVAL,15,8),'XXXXXXXX')  )) ||''
          , CSH.LOWVAL
        ),1,30) low_value
        FROM SYS.WRI$_OPTSTAT_HISTHEAD_HISTORY CSH
        WHERE CSH.OBJ#       = T1.OBJECT_ID
        AND   CSH.INTCOL#    = C.INTCOL#
        AND   to_DATE(to_CHAR(CSH.SAVTIME,'yyyy-mm-dd hh24:mi:ss'),'yyyy-mm-dd hh24:mi:ss') < SM.last_load_time
--        AND   to_DATE(to_CHAR(CSH.SAVTIME,'yyyy-mm-dd hh24:mi:ss'),'yyyy-mm-dd hh24:mi:ss') < SM.last_load_time
        order by to_DATE(to_CHAR(CSH.SAVTIME,'yyyy-mm-dd hh24:mi:ss'),'yyyy-mm-dd hh24:mi:ss') desc FETCH FIRST 1 ROW ONLY ) LOW_VALUE,
       ( SELECT  substr(
         decode(c.type# -- as there are several timestamp types
          ,2       ,to_char(utl_raw.cast_to_number(CSH.HIVAL)) ||''
          ,1     ,to_char(utl_raw.cast_to_varchar2(CSH.HIVAL)) ||''
          ,287    ,to_char(utl_raw.cast_to_nvarchar2(CSH.HIVAL)) ||''
          ,101    ,to_char(utl_raw.cast_to_binary_double(CSH.HIVAL)) ||''
          ,100    ,to_char(utl_raw.cast_to_binary_float(CSH.HIVAL)) ||''
          ,12         ,decode(CSH.HIVAL, NULL, NULL, rtrim(
                                to_char(100*(to_number(substr(CSH.HIVAL,1,2),'XX')-100)
                                       + (to_number(substr(CSH.HIVAL,3,2),'XX')-100),'fm0000')||'-'||
                                to_char(to_number(substr(CSH.HIVAL,5,2),'XX'),'fm00')||'-'||
                                to_char(to_number(substr(CSH.HIVAL,7,2),'XX'),'fm00')||' '||
                                to_char(to_number(substr(CSH.HIVAL,9,2),'XX')-1,'fm00')||':'||
                                to_char(to_number(substr(CSH.HIVAL,11,2),'XX')-1,'fm00')||':'||
                                to_char(to_number(substr(CSH.HIVAL,13,2),'XX')-1,'fm00'))) ||''
          ,187    ,decode(CSH.HIVAL, NULL, NULL, rtrim(
                           to_char(100*(to_number(substr(CSH.HIVAL,1,2),'XX')-100)
                                  + (to_number(substr(CSH.HIVAL,3,2),'XX')-100),'fm0000')||'-'||
                           to_char(to_number(substr(CSH.HIVAL,5,2),'XX'),'fm00')||'-'||
                           to_char(to_number(substr(CSH.HIVAL,7,2),'XX'),'fm00')||' '||
                           to_char(to_number(substr(CSH.HIVAL,9,2),'XX')-1,'fm00')||':'||
                           to_char(to_number(substr(CSH.HIVAL,11,2),'XX')-1,'fm00')||':'||
                           to_char(to_number(substr(CSH.HIVAL,13,2),'XX')-1,'fm00')
                          ||'.'||to_number(substr(CSH.HIVAL,15,8),'XXXXXXXX')  )) ||''
          , CSH.HIVAL
        ),1,30) HIGH_VALUE
        FROM SYS.WRI$_OPTSTAT_HISTHEAD_HISTORY CSH
        WHERE CSH.OBJ#       = T1.OBJECT_ID
        AND   CSH.INTCOL#    = C.INTCOL#
        AND   to_DATE(to_CHAR(CSH.SAVTIME,'yyyy-mm-dd hh24:mi:ss'),'yyyy-mm-dd hh24:mi:ss') < SM.last_load_time
--        AND   to_DATE(to_CHAR(CSH.SAVTIME,'yyyy-mm-dd hh24:mi:ss'),'yyyy-mm-dd hh24:mi:ss') < SM.last_load_time
        order by to_DATE(to_CHAR(CSH.SAVTIME,'yyyy-mm-dd hh24:mi:ss'),'yyyy-mm-dd hh24:mi:ss') desc FETCH FIRST 1 ROW ONLY ) HIGH_VALUE,
        SM.NAME BIND_NAME,
        substr(
        decode( SUBSTR(SM.dtype,1,9)
          ,'NUMBER'       ,to_char(utl_raw.cast_to_number(SM.VALUE)) ||''
          ,'VARCHAR2'     ,to_char(utl_raw.cast_to_varchar2(SM.VALUE)) ||''
          ,'NVARCHAR2'    ,to_char(utl_raw.cast_to_nvarchar2(SM.VALUE)) ||''
          ,'BINARY_DO'    ,to_char(utl_raw.cast_to_binary_double(SM.VALUE)) ||''
          ,'DATE'         ,decode(SM.VALUE, NULL, NULL, rtrim(
                                to_char(100*(to_number(substr(SM.VALUE,1,2),'XX')-100)
                                       + (to_number(substr(SM.VALUE,3,2),'XX')-100),'fm0000')||'-'||
                                to_char(to_number(substr(SM.VALUE,5,2),'XX'),'fm00')||'-'||
                                to_char(to_number(substr(SM.VALUE,7,2),'XX'),'fm00')||' '||
                                to_char(to_number(substr(SM.VALUE,9,2),'XX')-1,'fm00')||':'||
                                to_char(to_number(substr(SM.VALUE,11,2),'XX')-1,'fm00')||':'||
                                to_char(to_number(substr(SM.VALUE,13,2),'XX')-1,'fm00'))) ||''
          ,'TIMESTAMP'    ,decode(SM.VALUE, NULL, NULL, rtrim(
                           to_char(100*(to_number(substr(SM.VALUE,1,2),'XX')-100)
                                  + (to_number(substr(SM.VALUE,3,2),'XX')-100),'fm0000')||'-'||
                           to_char(to_number(substr(SM.VALUE,5,2),'XX'),'fm00')||'-'||
                           to_char(to_number(substr(SM.VALUE,7,2),'XX'),'fm00')||' '||
                           to_char(to_number(substr(SM.VALUE,9,2),'XX')-1,'fm00')||':'||
                           to_char(to_number(substr(SM.VALUE,11,2),'XX')-1,'fm00')||':'||
                           to_char(to_number(substr(SM.VALUE,13,2),'XX')-1,'fm00')
                          ||'.'||to_char(to_number(substr(SM.VALUE,15,8),'XXXXXXXX')))) ||''
          , SM.VALUE
       ),1,30) BIND_VALUE,
       --( case when SM.VALUE between CSH.LOWVAL and M.high_value then 'IN' ELSE 'OUT' END) WITHIN,
       SM.DTYPE BIND_DTYPE,
--       M.DATA_TYPE COL_DTYPE, m.HISTOGRAM,
DECODE(c.type#, 1,'VARCHAR2',2,'NUMBER',12,'DATE',180,'TIMESTAMP',181,'TIMESTAMP', C.TYPE#)  COL_DTYPE,
       p.OPERATION, p.OPTIONS, p.SEARCH_COLUMNS, P.COST, P.CARDINALITY,
--       , M.NUM_DISTINCT,  M.NUM_NULLS, T.NUM_ROWS - M.NUM_NULLS NUM_ROWS
       ( SELECT  CSH.DISTCNT  NUM_DISTINCT
        FROM SYS.WRI$_OPTSTAT_HISTHEAD_HISTORY CSH
        WHERE CSH.OBJ#       = T1.OBJECT_ID
        AND   CSH.INTCOL#    = C.INTCOL#
        AND   to_DATE(to_CHAR(CSH.SAVTIME,'yyyy-mm-dd hh24:mi:ss'),'yyyy-mm-dd hh24:mi:ss') < SM.last_load_time
--        AND   to_DATE(to_CHAR(CSH.SAVTIME,'yyyy-mm-dd hh24:mi:ss'),'yyyy-mm-dd hh24:mi:ss') < SM.last_load_time
        order by to_DATE(to_CHAR(CSH.SAVTIME,'yyyy-mm-dd hh24:mi:ss'),'yyyy-mm-dd hh24:mi:ss') desc FETCH FIRST 1 ROW ONLY ) NUM_DISTINCT,
       ( SELECT  CSH.NULL_CNT  NUM_NULLS
        FROM SYS.WRI$_OPTSTAT_HISTHEAD_HISTORY CSH
        WHERE CSH.OBJ#       = T1.OBJECT_ID
        AND   CSH.INTCOL#    = C.INTCOL#
        AND   to_DATE(to_CHAR(CSH.SAVTIME,'yyyy-mm-dd hh24:mi:ss'),'yyyy-mm-dd hh24:mi:ss') < SM.last_load_time
--        AND   to_DATE(to_CHAR(CSH.SAVTIME,'yyyy-mm-dd hh24:mi:ss'),'yyyy-mm-dd hh24:mi:ss') < SM.last_load_time
        order by to_DATE(to_CHAR(CSH.SAVTIME,'yyyy-mm-dd hh24:mi:ss'),'yyyy-mm-dd hh24:mi:ss') desc FETCH FIRST 1 ROW ONLY ) NUM_NULLS,
       ( SELECT  CSH.SAMPLE_SIZE SAMPLE_SIZE
        FROM SYS.WRI$_OPTSTAT_HISTHEAD_HISTORY CSH
        WHERE CSH.OBJ#       = T1.OBJECT_ID
        AND   CSH.INTCOL#    = C.INTCOL#
        AND   to_DATE(to_CHAR(CSH.SAVTIME,'yyyy-mm-dd hh24:mi:ss'),'yyyy-mm-dd hh24:mi:ss') < SM.last_load_time
--        AND   to_DATE(to_CHAR(CSH.SAVTIME,'yyyy-mm-dd hh24:mi:ss'),'yyyy-mm-dd hh24:mi:ss') < SM.last_load_time
        order by to_DATE(to_CHAR(CSH.SAVTIME,'yyyy-mm-dd hh24:mi:ss'),'yyyy-mm-dd hh24:mi:ss') desc FETCH FIRST 1 ROW ONLY ) NUM_ROWS,
      sm.LAST_LOAD_TIME,
      ( SELECT  to_char(TIMESTAMP#,'yyyy-mm-dd hh24:mi:ss')||' - '||to_CHAR(CSH.SAVTIME,'yyyy-mm-dd hh24:mi:ss') SAVTIME
        FROM SYS.WRI$_OPTSTAT_HISTHEAD_HISTORY CSH
        WHERE CSH.OBJ#       = T1.OBJECT_ID
        AND   CSH.INTCOL#    = C.INTCOL#
        AND   to_DATE(to_CHAR(CSH.SAVTIME,'yyyy-mm-dd hh24:mi:ss'),'yyyy-mm-dd hh24:mi:ss') < SM.last_load_time
--        AND   to_DATE(to_CHAR(CSH.SAVTIME,'yyyy-mm-dd hh24:mi:ss'),'yyyy-mm-dd hh24:mi:ss') < SM.last_load_time
        order by to_DATE(to_CHAR(CSH.SAVTIME,'yyyy-mm-dd hh24:mi:ss'),'yyyy-mm-dd hh24:mi:ss') desc FETCH FIRST 1 ROW ONLY ) SAVTIME
from SM, gv$sql_plan P,
--DBA_IND_COLUMNS IC,
DBA_TABLES T,
SYS.COL$ C,
--DBA_OBJECTS T1
( SELECT  O.OBJ# OBJECT_ID, O.NAME OBJECT_NAME, U.NAME OWNER,  'TABLE' OBJECT_TYPE
  FROM SYS.OBJ$ O, SYS.USER$ U WHERE O.OWNER# = U.USER#  AND O.TYPE# = 2) T1
where :L_DYN_BIND = 'N'
/*
AND ( SUBSTR( PT.ACCESS_PREDICATES,INSTR(PT.ACCESS_PREDICATES,':')-4,7)
      = SUBSTR(P.ACCESS_PREDICATES,INSTR(P.ACCESS_PREDICATES,':')-4,7)
  OR  SUBSTR( PT.FILTER_PREDICATES,INSTR(PT.FILTER_PREDICATES,':')-4,7)
      LIKE SUBSTR(P.FILTER_PREDICATES,INSTR(P.FILTER_PREDICATES,':')-4,6)||')'
  OR  SUBSTR( PT.ACCESS_PREDICATES,INSTR(PT.ACCESS_PREDICATES,':')-4,7)
      = SUBSTR(P.ACCESS_PREDICATES,INSTR(P.ACCESS_PREDICATES,':')-4,7)
  OR  SUBSTR( PT.FILTER_PREDICATES,INSTR(PT.FILTER_PREDICATES,':')-4,7)
      LIKE SUBSTR(P.FILTER_PREDICATES,INSTR(P.FILTER_PREDICATES,':')-4,6)||')'  )
*/
AND  T1.OBJECT_NAME = T.TABLE_NAME   AND T1.OWNER = T.OWNER  AND T1.OBJECT_TYPE = 'TABLE'
AND C.OBJ# = T1.OBJECT_ID   --AND C.NAME = IC.NAME
AND ( P.access_predicates like '%=:%'  or P.filter_predicates like '%=:%'
OR P.access_predicates like '%<=:%'  or P.filter_predicates like '%<=:%'
OR P.access_predicates like '%>=:%'  or P.filter_predicates like '%>=:%'
OR P.access_predicates like '%=TO_NUMBER(:%'  or P.filter_predicates like '%=TO_NUMBER(:%'
OR P.access_predicates like '%<=TO_NUMBER(:%'  or P.filter_predicates like '%<=TO_NUMBER(:%'
OR P.access_predicates like '%>=TO_NUMBER(:%'  or P.filter_predicates like '%>=TO_NUMBER(:%'
OR P.access_predicates like '% LIKE :%'  or P.filter_predicates like '% LIKE :%'
)
--and ( P.access_predicates not like '%"SESSION_ROLE_SET_KEY"="FND_GLOBAL"."SESSION_ROLE_SET_KEY"%'
--and    P.access_predicates not like '%"SANDBOX_ID"=SYS_CONTEXT(''FND_VPD_CTX''%'
--and    P.access_predicates not like '%"USER_GUID"="FND_GLOBAL"."USER_GUID"()%'
--and    P.access_predicates not like '%"ENTERPRISE_ID"=%"FUNCTION_ID"=%' )
and  P.object_type LIKE '%TABLE%'
and T.TABLE_NAME   = P.OBJECT_NAME
AND T.OWNER        = P.OBJECT_OWNER
and P.SQL_ID = :L_SQL_ID
AND ( P.access_predicates LIKE '%"'||C.NAME||'"=:%'   or P.filter_predicates LIKE '%"'||C.NAME||'"=:%'
   OR P.access_predicates LIKE '%"'||C.NAME||'"<=:%'  or P.filter_predicates LIKE '%"'||C.NAME||'"<=:%'
   OR P.access_predicates LIKE '%"'||C.NAME||'">=:%'  or P.filter_predicates LIKE '%"'||C.NAME||'">=:%'
   OR P.access_predicates LIKE '%"'||C.NAME||'"=TO_NUMBER(:%'   or P.filter_predicates LIKE '%"'||C.NAME||'"=TO_NUMBER(:%'
   OR P.access_predicates LIKE '%"'||C.NAME||'"<=TO_NUMBER(:%'  or P.filter_predicates LIKE '%"'||C.NAME||'"<=TO_NUMBER(:%'
   OR P.access_predicates LIKE '%"'||C.NAME||'">=TO_NUMBER(:%'  or P.filter_predicates LIKE '%"'||C.NAME||'">=TO_NUMBER(:%'
   OR P.access_predicates LIKE '%"'||C.NAME||'" LIKE :%'  or P.filter_predicates LIKE '%"'||C.NAME||'" LIKE :%'
   )
AND P.OPTIONS NOT IN ('FAST FULL SCAN','SAMPLE FAST FULL SCAN')
--AND M.OWNER       = IC.TABLE_OWNER
--AND M.TABLE_NAME  = IC.TABLE_NAME
--AND M.COLUMN_NAME = C.NAME
--------------
AND P.INST_ID          = SM.INST_ID
AND P.SQL_ID           = SM.SQL_ID
AND P.CHILD_NUMBER     = SM.CHILD_NUMBER
AND P.PLAN_HASH_VALUE  = SM.PLAN_HASH_VALUE
--------------
AND ( P.access_predicates LIKE '%"'||C.NAME||'"='||SM.NAME||'%'  or P.filter_predicates LIKE '%"'||C.NAME||'"='||SM.NAME||'%'
   OR P.access_predicates LIKE '%"'||C.NAME||'"<='||SM.NAME||'%' or P.filter_predicates LIKE '%"'||C.NAME||'"<='||SM.NAME||'%'
   OR P.access_predicates LIKE '%"'||C.NAME||'">='||SM.NAME||'%' or P.filter_predicates LIKE '%"'||C.NAME||'">='||SM.NAME||'%'
   OR P.access_predicates LIKE '%"'||C.NAME||'"=TO_NUMBER('||SM.NAME||'%' or P.filter_predicates LIKE '%"'||C.NAME||'"=TO_NUMBER('||SM.NAME||'%'
   OR P.access_predicates LIKE '%"'||C.NAME||'"<=TO_NUMBER('||SM.NAME||'%' or P.filter_predicates LIKE '%"'||C.NAME||'"<=TO_NUMBER('||SM.NAME||'%'
   OR P.access_predicates LIKE '%"'||C.NAME||'">=TO_NUMBER('||SM.NAME||'%' or P.filter_predicates LIKE '%"'||C.NAME||'">=TO_NUMBER('||SM.NAME||'%' 
   OR P.access_predicates LIKE '%"'||C.NAME||'" LIKE '||SM.NAME||'%' or P.filter_predicates LIKE '%"'||C.NAME||'" LIKE '||SM.NAME||'%'
   )
--ORDER BY P.ID, IC.INDEX_NAME, IC.COLUMN_POSITION
)
ORDER BY INST_ID, CHILD_NUMBER, PLAN_HASH_VALUE,  ID, TABLE_NAME, BP
)
/

pro </tbody>
pro  </table>

--COL SQL_TEXT FORMAT A300
--select :sql_text SQL_TEXT from dual ;

set heading off LINESIZE 300 pagesize 0

pro </details>

-- smabv.sql end

--  tsp start : prefs, delete histogram, drop extended stats by spd and drop spd.

pro
pro   <a name="MISSINGTABLE"></a>
pro <details>
pro   <summary><blue>MISSING TABLE STATS PREFS, UNNECESSARY HISTOGRAM/EXTENDED STATS/SPD</blue></summary>

/***************************************************************************************/
--pro <blue>FIX COMMAND</blue>


VAR L_EXISTS           VARCHAR2(3)
VAR L_EBR              varchar2(3)

EXEC DBMS_SPD.flush_sql_plan_directive;

BEGIN
  :L_EXISTS := 'NO';
  FOR I IN (     SELECT INST_ID, PLAN_HASH_VALUE, CHILD_NUMBER
                 FROM   GV$SQL_PLAN
                 where  SQL_ID = :L_SQL_ID AND ROWNUM = 1
            )
  LOOP
        :L_INST_ID         := I.INST_ID;
        :L_PLAN_HASH_VALUE := I.PLAN_HASH_VALUE;
        :L_CHILD_NUMBER    := I.CHILD_NUMBER;
        :L_EXISTS          := 'MEM';
  END LOOP;
  EXCEPTION
  WHEN OTHERS THEN
    :L_EXISTS := 'NO';
END ;
/
BEGIN
  IF ( :L_EXISTS = 'NO' )
  THEN
     FOR I IN (
              SELECT PLAN_HASH_VALUE, DBID
              FROM   DBA_HIST_SQL_PLAN
              WHERE  SQL_ID = :L_SQL_ID
              AND    DBID = (SELECT DBID FROM V$DATABASE)
              AND    ROWNUM = 1 )
     LOOP
        :L_PLAN_HASH_VALUE := I.PLAN_HASH_VALUE;
        :L_DBID :=  I.DBID;
        :L_EXISTS := 'AWR';
     END LOOP;
  END IF;
  EXCEPTION
  WHEN OTHERS THEN
        :L_EXISTS := 'NO';
END ;
/

BEGIN
  SELECT NVL( ( SELECT 'YES' FROM DBA_TABLES
  WHERE TABLE_NAME = 'fre_ebr_programs' and OWNER ='LCM_SUPER_ADMIN'), 'NO' )
  INTO :L_EBR FROM DUAL;
END ;
/

DECLARE
 LINE_NO NUMBER;
BEGIN
 LINE_NO := 0 ;

 IF (  :L_EXISTS <> 'NO' ) THEN
  FOR I IN (
   WITH SQLPLAN AS
    (
    SELECT P.OBJECT_OWNER,
           P.OBJECT_NAME
    FROM   GV$SQL_PLAN P
    WHERE  P.INST_ID = :L_INST_ID
    AND    P.SQL_ID = :L_SQL_ID
    AND    p.OPERATION LIKE 'TABLE%'
    AND    P.PLAN_HASH_VALUE = :L_PLAN_HASH_VALUE
    AND    P.CHILD_NUMBER = :L_CHILD_NUMBER
    AND    :L_EXISTS = 'MEM'
    UNION
    SELECT I.TABLE_owner OBJECT_OWNER,
           I.TABLE_name  OBJECT_NAME
    FROM   GV$SQL_PLAN P, DBA_INDEXES I
    WHERE  P.INST_ID = :L_INST_ID
    AND    P.SQL_ID = :L_SQL_ID
    AND    P.OPERATION LIKE 'INDEX%'
    AND    P.OBJECT_OWNER = I.OWNER
    AND    P.OBJECT_NAME  = I.INDEX_NAME
    AND    P.CHILD_NUMBER = :L_CHILD_NUMBER
    AND    P.PLAN_HASH_VALUE = :L_PLAN_HASH_VALUE
    AND    :L_EXISTS = 'MEM'
    UNION
    SELECT P.OBJECT_OWNER,
           P.OBJECT_NAME
    FROM   DBA_HIST_SQL_PLAN P
    WHERE  P.SQL_ID = :L_SQL_ID
    AND    P.operation LIKE 'TABLE%'
    AND    P.DBID = :L_DBID
    AND    P.PLAN_HASH_VALUE = :L_PLAN_HASH_VALUE
    AND    :L_EXISTS = 'AWR'
    UNION
    SELECT I.TABLE_OWNER OBJECT_OWNER,
           I.TABLE_NAME  OBJECT_NAME
    FROM   DBA_HIST_SQL_PLAN P, DBA_INDEXES I
    where  P.SQL_ID = :L_SQL_ID
    AND    P.operation LIKE 'INDEX%'
    AND    P.OBJECT_OWNER = I.OWNER
    AND    P.OBJECT_NAME  = I.INDEX_NAME
    AND    P.DBID = :L_DBID
    AND    P.PLAN_HASH_VALUE = :L_PLAN_HASH_VALUE
    AND    :L_EXISTS = 'AWR'
    ),
    PREFS AS (
    select /*+ LEADING(P) */ P.OBJECT_OWNER, P.OBJECT_NAME
    from SQLPLAN P
    where not exists
        ( select 1 from DBA_TAB_STAT_PREFS A
          where A.table_name = P.object_name
          AND   A.owner      = p.object_owner
          AND   A.PREFERENCE_NAME = 'METHOD_OPT' )
    order by 1,2
    )  /* set table prefs */
    SELECT 'exec FND_STATS_SEED.seed_table_prefs('''||DECODE(OBJECT_NAME,LOWER(OBJECT_NAME),'"'||OBJECT_NAME||'"',OBJECT_NAME)||''''||');' CMD
    FROM PREFS P
    WHERE EXISTS ( SELECT 1 FROM DBA_IND_COLUMNS IC WHERE IC.TABLE_OWNER = P.OBJECT_OWNER AND IC.TABLE_NAME = P.OBJECT_NAME AND IC.COLUMN_NAME LIKE '%ID' )
    UNION ALL /* delete histogram */
    SELECT 'exec DBMS_STATS.delete_column_stats(''FUSION'','''||DECODE(P.OBJECT_NAME,LOWER(P.OBJECT_NAME),'"'||P.OBJECT_NAME||'"',P.OBJECT_NAME)
    ||''''||', column_name=> '||''''||c.column_name||''''||',col_stat_type=>'||'''HISTOGRAM'''||');'  CMD
    FROM PREFS P, DBA_TAB_COLUMNS C
    WHERE P.OBJECT_OWNER = C.OWNER
    AND   P.OBJECT_NAME  = C.TABLE_NAME
    AND   C.COLUMN_NAME LIKE '%_ID'
    AND   C.NUM_DISTINCT > 256
    AND   C.HISTOGRAM <> 'NONE'
    UNION ALL  /* drop extended stats */
    SELECT  'exec DBMS_STATS.drop_extended_stats('''||e.owner||''','''||
        DECODE(T.OBJECT_NAME,LOWER(T.OBJECT_NAME),'"'||T.OBJECT_NAME||'"',T.OBJECT_NAME)
        ||''','''||to_char(e.extension)||''''||');'
        cmd
    FROM SQLPLAN t, dba_stat_extensions e
    WHERE t.object_name = e.table_name
    and   t.object_owner =e.owner
    and   DROPPABLE = 'Y'
    and   EXTENSION_NAME like 'SYS_ST%'
    UNION ALL  /* spd off */
    SELECT '/* '||t.object_name||' */'||' exec DBMS_SPD.drop_sql_plan_directive( directive_id => '||spdo.DIRECTIVE_ID||' );' CMD
    FROM SQLPLAN t, dba_sql_plan_dir_objects spdo
    WHERE spdo.owner = t.object_owner
    AND spdo.object_name = t.object_name
    AND :L_SHORT_DB_VERSION LIKE '12%'
  )
  LOOP
        IF ( LINE_NO = 0 AND :L_PDB <> 'NOPDB' ) THEN
           DBMS_OUTPUT.PUT_LINE('<blue>FIX COMMAND</blue>');
           DBMS_OUTPUT.PUT_LINE(:L_PDB);
        END IF;
        DBMS_OUTPUT.PUT_LINE(I.CMD);
        LINE_NO := 1;
  END LOOP;
 END IF;
 EXCEPTION
 WHEN OTHERS THEN
    DBMS_OUTPUT.PUT_LINE('PROMPT NO ACTION NEEDED');
END ;
/

pro </details>
--  tsp end : prefs, delete histogram, drop extended stats by spd and drop spd.


pro   <a name="OBJECTDDL"></a>
pro <details>
pro   <summary><blue>OBJECT DDL TIME WITHIN RECENT 30 DAYS</blue></summary>

--sma19c 20191219

pro <table>
pro <tbody><tr>
pro <th>OWNER</th>
pro <th>OBJECT_NAME</th>
pro <th>OBJECT_TYPE</th>
pro <th>LAST_DDL_TIME</th>
pro <th>STATUS</th>
pro </tr>

--20201010 need to fix
SET HEAD OFF
WITH DRV AS (
select /*+ no_parallel opt_param('parallel_execution_enabled', 'false') */ inst_id, address, hash_value
      from gv$sql
      where sql_id =  :L_SQL_ID
      and   inst_id = :L_INST_ID
      and   rownum = 1 ) ,
     OBJ_DRV AS (
     SELECT /*+ LEADING(DRV, D) */ DISTINCT d.to_owner, d.to_name
     from DRV, gv$object_dependency d
     where d.inst_id  = DRV.inst_id
     AND d.from_address = DRV.address
     AND d.from_hash  = DRV.hash_value )
SELECT  CHR(10)||'<tr>'||CHR(10)
     ||'<td class="r">'||OWNER||'</td>'||CHR(10)
     ||'<td class="r">'||OBJECT_NAME||'</td>'||CHR(10)
     ||'<td class="r">'||OBJECT_TYPE||'</td>'||CHR(10)
     ||'<td class="r">'||LAST_DDL_TIME||'</td>'||CHR(10)
     ||'<td class="r">'||STATUS||'</td>'||CHR(10)
     ||'</TR>'
FROM
(select /*+ LEADING(OBJ_DRV,o) use_nl(o) */
       O.OWNER , o.object_name , O.OBJECT_TYPE, to_char(o.LAST_DDL_TIME,'dd-Mon-yyyy hh24:mm:ss') LAST_DDL_TIME  ,
       o.STATUS
 from OBJ_DRV, dba_objects o
 where OBJ_DRV.to_owner = o.owner
 and OBJ_DRV.to_name = o.object_name
 and o.LAST_DDL_TIME > sysdate -30
 AND   :L_SQLHC_MIN_FLAG < 15  /* limits */
 ORDER BY 1,2,3)
/
--select O.OWNER ||'.'|| o.object_name object_name, O.OBJECT_TYPE, to_char(o.LAST_DDL_TIME,'dd-Mon-yyyy hh24:mm:ss') LAST_DDL_TIME

pro </tbody>
pro </table>
pro </details>
SET HEAD ON

-- autoIndex report

pro   <a name="AUTOINDEX"></a>
pro <details>
pro   <summary><blue>AUTO INDEX VERIFICATIONS</blue></summary>

--sma19c 2020017

pro <table>
pro <tbody><tr>
pro <th>EXECUTION_NAME</th>
pro <th>SQL_ID</th>
pro <th>ORIGINAL_PLAN_HASH_VALUE</th>
pro <th>AUTO_INDEX_PLAN_HASH_VALUE</th>
pro <th>ORIGINAL_BUFFER_GETS</th>
pro <th>AUTO_INDEX_BUFFER_GETS</th>
pro <th>STATUS</th>
pro </tr>


DECLARE

   L_EXECUTION_NAME                VARCHAR2(128);
   L_SQL_ID                        VARCHAR2(52);
   L_ORIGINAL_PLAN_HASH_VALUE      NUMBER;
   L_AUTO_INDEX_PLAN_HASH_VALUE    NUMBER;
   L_ORIGINAL_BUFFER_GETS          NUMBER;
   L_AUTO_INDEX_BUFFER_GETS        NUMBER;
   L_STATUS                        VARCHAR2(9);

   AIR_SQL varchar2(1000);

   TYPE LAIR_CURSOR IS REF CURSOR;
   AIR_SQL_CURSOR   LAIR_CURSOR;

BEGIN
  IF ( :L_SHORT_DB_VERSION LIKE '19%' or :L_SHORT_DB_VERSION LIKE '2%') THEN
        AIR_SQL := 'SELECT EXECUTION_NAME, SQL_ID, ORIGINAL_PLAN_HASH_VALUE, AUTO_INDEX_PLAN_HASH_VALUE,
                                   round(ORIGINAL_BUFFER_GETS), round(AUTO_INDEX_BUFFER_GETS), STATUS
                            FROM DBA_AUTO_INDEX_VERIFICATIONS
                            WHERE SQL_ID = :B1 ORDER BY EXECUTION_NAME ' ;

        OPEN AIR_SQL_CURSOR FOR AIR_SQL USING :L_SQL_ID;
	LOOP
            FETCH AIR_SQL_CURSOR INTO
                L_EXECUTION_NAME,
                L_SQL_ID        ,
                L_ORIGINAL_PLAN_HASH_VALUE,
                L_AUTO_INDEX_PLAN_HASH_VALUE,
                L_ORIGINAL_BUFFER_GETS,
                L_AUTO_INDEX_BUFFER_GETS,
                L_STATUS                 ;
            EXIT WHEN AIR_SQL_CURSOR%NOTFOUND;
	    DBMS_OUTPUT.PUT_LINE(
 		   CHR(10)||'<tr>'||CHR(10)
			  ||'<td class="r">'||L_EXECUTION_NAME            ||'</td>'||CHR(10)
			  ||'<td class="r">'||L_SQL_ID                    ||'</td>'||CHR(10)
			  ||'<td class="r">'||L_ORIGINAL_PLAN_HASH_VALUE  ||'</td>'||CHR(10)
			  ||'<td class="r">'||L_AUTO_INDEX_PLAN_HASH_VALUE||'</td>'||CHR(10)
			  ||'<td class="r">'||L_ORIGINAL_BUFFER_GETS      ||'</td>'||CHR(10)
			  ||'<td class="r">'||L_AUTO_INDEX_BUFFER_GETS    ||'</td>'||CHR(10)
			  ||'<td class="r">'||L_STATUS                    ||'</td>'||CHR(10)
			  ||'</tr>'	);
	END LOOP;
	CLOSE AIR_SQL_CURSOR;
	dbms_output.put(CHR(10));
  END IF;
END;
/

pro </tbody>
pro </table>
pro </details>
-- sma19c-20200423


SET HEAD ON

-- ECID report start
--sma19c-20200423

pro   <a name="GVASHHEADER"></a>
pro <details>
pro   <summary><blue>GV$ASH BY ECID/SQL_EXEC_ID</blue></summary>


pro <table>
pro <tbody><tr>
--pro <th>ECID<br>or<br>SQL_ID</th>
pro <th>ECID<br>or<br>SQL_EXEC_ID</th>
pro <th>PHV1</th>
pro <th>PHV2</th>
pro <th>FIRST<BR>SAMPLE_TIME</th>
pro <th>LAST<BR>SAMPLE_TIME</th>
pro <th>ELAPSED<BR>TIME</th>
pro <th>ASH Sample<br>Count</th>
pro <th>NofDistict<br>SQL</th>
pro <th>TOTAL<BR>EXECUTIONS</th>
pro <th>NofDistinct<br>PLAN<br>HashValue</th>
pro <th>TOTAL<BR>HARD PARSING</th>
pro <th>SESSIONS</th>
pro </tr>

SET HEAD OFF
var  L_ECID varchar2(300)
exec :L_ECID := null;
VAR  L_MIN_ID  NUMBER
VAR  L_MAX_ID  NUMBER
VAR  L_AVG_CNT NUMBER
VAR  L_GRP_BY  NUMBER
var  L_ECID2 varchar2(300)
exec :L_ECID2 := null;
VAR  L_MIN_ID2  NUMBER
VAR  L_MAX_ID2  NUMBER

BEGIN
     SELECT MAX(CONSUMER_GROUP_ID) INTO :L_SQL_GROUP_ID
     FROM DBA_RSRC_CONSUMER_GROUPS CR
     WHERE CR.CONSUMER_GROUP = 'FUSIONAPPS_ONLINE_GROUP' AND ROWNUM = 1 ;

     FOR SM IN ( with drv as ( select distinct nvl(ecid, sql_id) lecid  from   gv$active_session_history
                               where sql_id = :L_SQL_ID
                               --and :L_SQL_GROUP = 'FUSIONAPPS_ONLINE_GROUP'  AND CONSUMER_GROUP_ID = :L_SQL_GROUP_ID
                               )
               select rownum ROW_NUM, ecid, GRP_BY, phv1, DECODE(PHV2,PHV1,NULL,PHV2) phv2, MIN_ID, MAX_ID, ecid_start, ecid_end, ecid_time, ash_cnt, nd_sql, ROUND(ASH_CNT/greatest(ND_SQL,4)) AVG_CNT,
               executions, nd_phv, TOT_HP, sessions
               from
               ( select  ecid, GRP_BY, phv1, phv2, MIN_ID, MAX_ID, ecid_start, ecid_end, ecid_time, ash_cnt, nd_sql, executions, nd_phv, TOT_HP, sessions
                 from
                 ( select * from
                  ( select /*+ leading(drv) */  ecid, 1 GRP_BY,
                  min(SQL_PLAN_HASH_VALUE) phv1, max(SQL_PLAN_HASH_VALUE) phv2,
                    min(sample_id) min_id, max(sample_id) max_id,
                    min(sample_time) ecid_start, max(sample_time) ecid_end, max(sample_time) - min(sample_time) ECID_TIME,
                    count(*) ash_cnt, count(distinct sql_id) nd_sql, count(distinct sql_exec_id) executions,
                    count(distinct SQL_PLAN_HASH_VALUE) nd_phv,
                    SUM(DECODE(IN_HARD_PARSE     ,     'Y',1)) tot_hp,
                    count(distinct INST_ID||'-'||SESSION_ID||'-'||SESSION_SERIAL#) sessions
                    --from ( select /*+ leading(drv) */ ecid, sample_time, sql_id, sql_exec_id
                    from   gv$active_session_history, drv
                    where  ecid = lecid  and lecid <> :l_sql_id
                    group by ecid
                    union all
             --       select   sql_id ecid, INST_ID||SQL_EXEC_ID sql_exec_id,
                    select /*+ leading(drv) */  INST_ID||'-'||SQL_EXEC_ID ecid, 2 GRP_BY,
                  min(SQL_PLAN_HASH_VALUE) phv1, max(SQL_PLAN_HASH_VALUE) phv2,
                    min(sample_id) min_id, max(sample_id) max_id,
                    min(sample_time) ecid_start, max(sample_time) ecid_end, max(sample_time) - min(sample_time) ECID_TIME,
                    count(*) ash_cnt, count(distinct sql_id) nd_sql, count(distinct sql_exec_id) executions,
                    count(distinct SQL_PLAN_HASH_VALUE) nd_phv,
                    SUM(DECODE(IN_HARD_PARSE     ,     'Y',1)) tot_hp,
                    count(distinct INST_ID||'-'||SESSION_ID||'-'||SESSION_SERIAL#) sessions
                    --from ( select /*+ leading(drv) */ ecid, sample_time, sql_id, sql_exec_id
                    from   gv$active_session_history, drv
                    where  sql_id = lecid  and lecid = :l_sql_id
                    group by sql_id, INST_ID||'-'||SQL_EXEC_ID )
                    order by ash_cnt desc )
                 where rownum <= 5 )  )
     LOOP
            IF( SM.ROW_NUM = 1 ) THEN
                   :L_ECID    := SM.ECID;
                   :L_MIN_ID  := SM.MIN_ID;
                   :L_MAX_ID  := SM.MAX_ID;
                   :L_AVG_CNT := SM.AVG_CNT;
                   :L_GRP_BY  := SM.GRP_BY;
      	           DBMS_OUTPUT.PUT_LINE(
 		   CHR(10)||'<tr>'||CHR(10)
			  ||'<td class="r"><RED>'||SM.ECID                ||'</RED></td>'||CHR(10)
			  ||'<td class="r">'||SM.PHV1                     ||'</td>'||CHR(10)
			  ||'<td class="r">'||SM.PHV2                     ||'</td>'||CHR(10)
			  ||'<td class="r">'||SM.ECID_START               ||'</td>'||CHR(10)
			  ||'<td class="r">'||SM.ECID_END                 ||'</td>'||CHR(10)
			  ||'<td class="r">'||SM.ECID_TIME                ||'</td>'||CHR(10)
			  ||'<td class="r">'||SM.ASH_CNT                  ||'</td>'||CHR(10)
			  ||'<td class="r">'||SM.ND_SQL                   ||'</td>'||CHR(10)
			  ||'<td class="r">'||SM.EXECUTIONS               ||'</td>'||CHR(10)
			  ||'<td class="r">'||SM.ND_PHV                   ||'</td>'||CHR(10)
			  ||'<td class="r">'||SM.TOT_HP                   ||'</td>'||CHR(10)
			  ||'<td class="r">'||SM.SESSIONS                 ||'</td>'||CHR(10)
			  ||'</tr>'	);
            ELSE
	           DBMS_OUTPUT.PUT_LINE(
 		   CHR(10)||'<tr>'||CHR(10)
			  ||'<td class="r">'||SM.ECID                     ||'</td>'||CHR(10)
			  ||'<td class="r">'||SM.PHV1                     ||'</td>'||CHR(10)
			  ||'<td class="r">'||SM.PHV2                     ||'</td>'||CHR(10)
			  ||'<td class="r">'||SM.ECID_START               ||'</td>'||CHR(10)
			  ||'<td class="r">'||SM.ECID_END                 ||'</td>'||CHR(10)
			  ||'<td class="r">'||SM.ECID_TIME                ||'</td>'||CHR(10)
			  ||'<td class="r">'||SM.ASH_CNT                  ||'</td>'||CHR(10)
			  ||'<td class="r">'||SM.ND_SQL                   ||'</td>'||CHR(10)
			  ||'<td class="r">'||SM.EXECUTIONS               ||'</td>'||CHR(10)
			  ||'<td class="r">'||SM.ND_PHV                   ||'</td>'||CHR(10)
			  ||'<td class="r">'||SM.TOT_HP                   ||'</td>'||CHR(10)
			  ||'<td class="r">'||SM.SESSIONS                 ||'</td>'||CHR(10)
			  ||'</tr>'	);
            END IF;
            IF( SM.ROW_NUM = 2 AND SM.GRP_BY = 2 ) THEN
                   :L_ECID2    := SM.ECID;
                   :L_MIN_ID2  := SM.MIN_ID;
                   :L_MAX_ID2  := SM.MAX_ID;
            END IF;
     END LOOP ;
     EXCEPTION
        WHEN OTHERS THEN
         :L_EXISTS := 'L_ECID';
END ;
/

pro </tbody>
pro </table>
pro </details>



SET HEAD ON
pro   <a name="GVASHDETAIL"></a>
pro <details>

SET HEAD OFF
SELECT DECODE(:L_GRP_BY, 1, '<summary><blue>GV$ASH DETAILS BY ECID</blue>(<RED>'||:l_ecid||'</RED>)</summary>',
                         2, '<summary><blue>GV$ASH DETAILS BY SQL_EXEC_ID</blue>(<RED>'||:l_ecid||'</RED>)</summary>' )
FROM DUAL ;
--select '<summary><blue>GV$ASH DETAILS BY ECID</blue>(<RED>'||:l_ecid||'</RED>)</summary>' from dual where :l_ecid <>:l_sql_id
--union all
--select '<summary><blue>GV$ASH DETAILS BY SQL_EXEC_ID</blue>(<RED>'||:l_sql_id||'</RED>)</summary>' from dual where :l_ecid = :l_sql_id;
SET HEAD ON

-- ECID report
--sma19c-20200423

pro <table>
pro <tbody><tr>
pro <th>MODULE</th>
pro <th>SQL_ID</th>
pro <th>SQL<br>OPNAME</th>
--pro <th>PLAN_HASH_VALUE</th>
--pro <th>LINE_ID</th>
--pro <th>OBJ_NAME</th>
--pro <th>EVENT</th>
--pro <th>PHASE</th>
pro <th>SAMPLES</th>
pro <th>PCT</th>
pro <th>TOTAL<br>EXECS</th>
pro <th>WAIT</th>
pro <th>IO</th>
pro <th>CPU</th>
pro <th>EVENT<br>control</th>
pro <th>EVENT<br>cursor</th>
pro <th>EVENT<br>cell</th>
pro <th>EVENT<br>db_file</th>
pro <th>EVENT<br>direct</th>
pro <th>EVENT<br>enq</th>
pro <th>EVENT<br>gc</th>
pro <th>EVENT<br>latch</th>
pro <th>EVENT<br>library</th>
pro <th>EVENT<br>log</th>
pro <th>EVENT<br>PX</th>
pro <th>EVENT<br>resmgr</th>
pro <th>EVENT<br>row<br>cache</th>
pro <th>EVENT<br>SQL<br>Net</th>
pro <th>EVENT<br>utl<br>file</th>
pro <th>DBOP</th>
pro <th>PGA_M</th>
pro <th>TEMP_M</th>
pro <th>PHASE<br>CONNECTION<br>MGMT</th>
pro <th>PHASE<br>PARSE</th>
pro <th>PHASE<br>HARD<br>PARSE</th>
pro <th>PHASE<br>SQL<br>EXEC</th>
pro <th>PHASE<br>PLSQL<br>EXEC</th>
pro <th>PHASE<br>PLSQL<br>RPC</th>
pro <th>PHASE<br>PLSQL<br>COMPILE</th>
pro <th>PHASE<br>JAVA<br>EXEC</th>
pro <th>PHASE<br>BIND</th>
pro <th>PHASE<br>CURSOR<br>CLOSE</th>
pro <th>PHASE<br>SEQUENCE<br>LOAD</th>
pro <th>BLOCK<br>SESSs</th>
pro <th>FISRT<br>SAMPLES</th>
pro <th>LAST<br>SAMPLES</th>
pro <th>ELAPSED<br>TIME</th>
pro </tr>
set head off

BEGIN
     FOR SM IN (
       select module, CASE WHEN SQL_ID = :L_SQL_ID THEN '<RED>'||SQL_ID||'</RED>' ELSE SQL_ID END SQL_ID, sql_opname,
------------- L_AVG_CNT
          CASE WHEN samples > :L_AVG_CNT THEN '<RED>'||samples||'</RED>' ELSE to_char(samples) END samples,
-------------        ------
          CASE WHEN PCT > :L_AVG_CNT THEN '<RED>'||PCT||'</RED>' ELSE to_char(PCT) END PCT,
-------------        ------
          CASE WHEN EXECS > :L_AVG_CNT THEN '<RED>'||EXECS||'</RED>' ELSE to_char(EXECS) END EXECS,
--          EXECS,        EXECS,
          CASE WHEN WAIT > :L_AVG_CNT THEN '<RED>'||WAIT||'</RED>' ELSE to_char(WAIT) END WAIT,
--          WAIT,         WAIT,
          CASE WHEN IO > :L_AVG_CNT THEN '<RED>'||IO||'</RED>' ELSE to_char(IO) END IO,
--          IO,           IO,
          CASE WHEN CPU > :L_AVG_CNT THEN '<RED>'||CPU||'</RED>' ELSE to_char(CPU) END CPU,
--          CPU,          CPU,
          CASE WHEN CONTROL > :L_AVG_CNT THEN '<RED>'||CONTROL||'</RED>' ELSE to_char(CONTROL) END CONTROL,
--         control,      control,
          CASE WHEN CURSOR > :L_AVG_CNT THEN '<RED>'||CURSOR||'</RED>' ELSE to_char(CURSOR) END CURSOR,
--         cursor,       cursor,
          CASE WHEN CELL > :L_AVG_CNT THEN '<RED>'||CELL||'</RED>' ELSE to_char(CELL) END CELL,
--        cell,         cell,
          CASE WHEN DB_FILE > :L_AVG_CNT THEN '<RED>'||DB_FILE||'</RED>' ELSE to_char(DB_FILE) END DB_FILE,
--        db_file,      db_file,
          CASE WHEN DIRECT > :L_AVG_CNT THEN '<RED>'||DIRECT||'</RED>' ELSE to_char(DIRECT) END DIRECT,
--        direct,       direct,
          CASE WHEN ENQ > :L_AVG_CNT THEN '<RED>'||ENQ||'</RED>' ELSE to_char(ENQ) END ENQ,
--        enq,          enq,
          CASE WHEN GC > :L_AVG_CNT THEN '<RED>'||GC||'</RED>' ELSE to_char(GC) END GC,
--        gc,           gc,
          CASE WHEN LATCH > :L_AVG_CNT THEN '<RED>'||LATCH||'</RED>' ELSE to_char(LATCH) END LATCH,
--        latch,        latch,
          CASE WHEN LIBRARY > :L_AVG_CNT THEN '<RED>'||LIBRARY||'</RED>' ELSE to_char(LIBRARY) END LIBRARY,
--        library,      library,
          CASE WHEN LOG > :L_AVG_CNT THEN '<RED>'||LOG||'</RED>' ELSE to_char(LOG) END LOG,
--        log,          log,
          CASE WHEN PX > :L_AVG_CNT THEN '<RED>'||PX||'</RED>' ELSE to_char(PX) END PX,
--        PX,           PX,
          CASE WHEN RESMGR > :L_AVG_CNT THEN '<RED>'||RESMGR||'</RED>' ELSE to_char(RESMGR) END RESMGR,
--        resmgr,       resmgr,
          CASE WHEN ROW_CACHE > :L_AVG_CNT THEN '<RED>'||ROW_CACHE||'</RED>' ELSE to_char(ROW_CACHE) END ROW_CACHE,
--        row_cache,    row_cache,
          CASE WHEN SQL_NET > :L_AVG_CNT THEN '<RED>'||SQL_NET||'</RED>' ELSE to_char(SQL_NET) END SQL_NET,
          CASE WHEN UTL_FILE > :L_AVG_CNT THEN '<RED>'||UTL_FILE||'</RED>' ELSE to_char(UTL_FILE) END UTL_FILE,
          CASE WHEN DBOP > :L_AVG_CNT THEN '<RED>'||DBOP||'</RED>' ELSE to_char(DBOP) END DBOP,
-------------
           PGA_M,
          TEMP_M,
-------------
          CASE WHEN CONNECTION_MGMT > :L_AVG_CNT THEN '<RED>'||CONNECTION_MGMT||'</RED>' ELSE to_char(CONNECTION_MGMT) END CONNECTION_MGMT,
--          CONNECTION_MGMT,
          CASE WHEN PARSE > :L_AVG_CNT THEN '<RED>'||PARSE||'</RED>' ELSE to_char(PARSE) END PARSE,
--          PARSE,
          CASE WHEN HARD_PARSE > :L_AVG_CNT THEN '<RED>'||HARD_PARSE||'</RED>' ELSE to_char(HARD_PARSE) END HARD_PARSE,
--          HARD_PARSE,
          CASE WHEN SQL_EXECUTION > :L_AVG_CNT THEN '<RED>'||SQL_EXECUTION||'</RED>' ELSE to_char(SQL_EXECUTION) END SQL_EXECUTION,
--          SQL_EXECUTION,
          CASE WHEN PLSQL_EXECUTION > :L_AVG_CNT THEN '<RED>'||PLSQL_EXECUTION||'</RED>' ELSE to_char(PLSQL_EXECUTION) END PLSQL_EXECUTION,
--          PLSQL_EXECUTION,
          CASE WHEN PLSQL_RPC > :L_AVG_CNT THEN '<RED>'||PLSQL_RPC||'</RED>' ELSE to_char(PLSQL_RPC) END PLSQL_RPC,
--          PLSQL_RPC,
          CASE WHEN PLSQL_COMPILATION > :L_AVG_CNT THEN '<RED>'||PLSQL_COMPILATION||'</RED>' ELSE to_char(PLSQL_COMPILATION) END PLSQL_COMPILATION,
--          PLSQL_COMPILATION,
          CASE WHEN JAVA_EXECUTION > :L_AVG_CNT THEN '<RED>'||JAVA_EXECUTION||'</RED>' ELSE to_char(JAVA_EXECUTION) END JAVA_EXECUTION,
--          JAVA_EXECUTION,
          CASE WHEN BIND > :L_AVG_CNT THEN '<RED>'||BIND||'</RED>' ELSE to_char(BIND) END BIND,
--          BIND,
          CASE WHEN CURSOR_CLOSE > :L_AVG_CNT THEN '<RED>'||CURSOR_CLOSE||'</RED>' ELSE to_char(CURSOR_CLOSE) END CURSOR_CLOSE,
--          CURSOR_CLOSE,
          CASE WHEN SEQUENCE_LOAD > :L_AVG_CNT THEN '<RED>'||SEQUENCE_LOAD||'</RED>' ELSE to_char(SEQUENCE_LOAD) END SEQUENCE_LOAD,
--          SEQUENCE_LOAD,
-------------
          BLK_SIDS,
          first_sample,
          last_sample,
          elapsed_time
   FROM (
     select * from (
     select module, SQL_ID, sql_opname,
     -- sql_plan_hash_value PLAN_HASH_VALUE,
     -- sql_plan_line_id LINE_ID,
     --(SELECT obj.owner||'.'||obj.object_name||NVL2(obj.subobject_name, '.'||obj.subobject_name, NULL)
     --         FROM dba_objects obj WHERE obj.object_id = current_obj#) OBJ_NAME,
              --current_obj#,
         --     event,
         count(*) samples,
         ROUND((RATIO_TO_REPORT(COUNT(*)) over(partition by ecid))*100, 2) PCT,
         COUNT(DISTINCT SQL_EXEC_ID)  EXECS,
         sum(decode(session_state,'WAITING',1,0)) - sum(decode(session_state,'WAITING', decode(wait_class, 'User I/O',1,0),0)) as WAIT,
         sum(decode(session_state,'WAITING', decode(wait_class, 'User I/O',1,0),0)) as IO,
         SUM(DECODE(SESSION_STATE,'ON CPU',1,0))    CPU,
-------------
       SUM( case when event like 'control%' then 1 end ) control,
       SUM( case when event like 'cursor%' then 1 end ) cursor,
       SUM( case when event like 'cell%' then 1 end ) cell,
       SUM( case when event like 'db file%' then 1 end ) db_file,
       SUM( case when event like 'direct%' then 1 end ) direct,
       SUM( case when event like 'enq%' then 1 end ) enq,
       SUM( case when event like 'gc c%' then 1 end ) gc,
       SUM( case when event like 'latch%' then 1 end ) latch,
       SUM( case when event like 'library%' then 1 end ) library,
       SUM( case when event like 'log%' then 1 end ) log,
       SUM( case when event like 'PX%' then 1 end ) PX,
       SUM( case when event like 'resmgr%' then 1 end ) resmgr,
       SUM( case when event like 'row cache%' then 1 end ) row_cache,
       SUM( case when event like 'SQL*Net%' then 1 end ) sql_net ,
       SUM( case when event like 'utl_file%' then 1 end ) utl_file,
-------------
         SUM(DECODE(DBOP_EXEC_ID,'Y',1))   DBOP,
         ROUND(MAX(PGA_ALLOCATED)/1000000,2)  PGA_M,
         ROUND(MAX(TEMP_SPACE_ALLOCATED)/1000000,2) TEMP_M,
-------------
         SUM(DECODE(IN_CONNECTION_MGMT,'Y',1))      CONNECTION_MGMT,
         SUM(DECODE(IN_PARSE          ,     'Y',1)) PARSE,
         SUM(DECODE(IN_HARD_PARSE     ,     'Y',1)) HARD_PARSE,
         SUM(DECODE(IN_SQL_EXECUTION  ,     'Y',1)) SQL_EXECUTION,
         SUM(DECODE(IN_PLSQL_EXECUTION,     'Y',1)) PLSQL_EXECUTION,
         SUM(DECODE(IN_PLSQL_RPC      ,     'Y',1)) PLSQL_RPC,
         SUM(DECODE(IN_PLSQL_COMPILATION,   'Y',1)) PLSQL_COMPILATION,
         SUM(DECODE(IN_JAVA_EXECUTION   ,   'Y',1)) JAVA_EXECUTION,
         SUM(DECODE(IN_BIND             ,   'Y',1)) BIND,
         SUM(DECODE(IN_CURSOR_CLOSE     ,   'Y',1)) CURSOR_CLOSE,
         SUM(DECODE(IN_SEQUENCE_LOAD    ,   'Y',1)) SEQUENCE_LOAD,
         COUNT(DISTINCT BLOCKING_INST_ID||BLOCKING_SESSION||BLOCKING_SESSION_SERIAL#) BLK_SIDS,
         min(ash.sample_time) first_sample,
         max(ash.sample_time) last_sample,
         max(ash.sample_time)-min(ash.sample_time) elapsed_time
     from gv$ACTIVE_SESSion_HISTORY ASH
     where ( ecid = :l_ecid  AND :L_GRP_BY = 1
     and   :l_ecid is not null  AND SAMPLE_ID >= :L_MIN_ID  AND   SAMPLE_ID <= :L_MAX_ID )
     group by ecid, module, sql_id, sql_opname
     union all
          select INST_ID||'-'||SQL_EXEC_ID||'-'||module module, SQL_ID, sql_opname,
     -- sql_plan_hash_value PLAN_HASH_VALUE,
     -- sql_plan_line_id LINE_ID,
     --(SELECT obj.owner||'.'||obj.object_name||NVL2(obj.subobject_name, '.'||obj.subobject_name, NULL)
     --         FROM dba_objects obj WHERE obj.object_id = current_obj#) OBJ_NAME,
              --current_obj#,
         --     event,
         count(*) samples,
         ROUND((RATIO_TO_REPORT(COUNT(*)) over(partition by INST_ID||'-'||SQL_EXEC_ID))*100, 2) PCT,
         COUNT(DISTINCT SQL_EXEC_ID)  EXECS,
         sum(decode(session_state,'WAITING',1,0)) - sum(decode(session_state,'WAITING', decode(wait_class, 'User I/O',1,0),0)) as WAIT,
         sum(decode(session_state,'WAITING', decode(wait_class, 'User I/O',1,0),0)) as IO,
         SUM(DECODE(SESSION_STATE,'ON CPU',1,0))    CPU,
-------------
       SUM( case when event like 'control%' then 1 end ) control,
       SUM( case when event like 'cursor%' then 1 end ) cursor,
       SUM( case when event like 'cell%' then 1 end ) cell,
       SUM( case when event like 'db file%' then 1 end ) db_file,
       SUM( case when event like 'direct%' then 1 end ) direct,
       SUM( case when event like 'enq%' then 1 end ) enq,
       SUM( case when event like 'gc c%' then 1 end ) gc,
       SUM( case when event like 'latch%' then 1 end ) latch,
       SUM( case when event like 'library%' then 1 end ) library,
       SUM( case when event like 'log%' then 1 end ) log,
       SUM( case when event like 'PX%' then 1 end ) PX,
       SUM( case when event like 'resmgr%' then 1 end ) resmgr,
       SUM( case when event like 'row cache%' then 1 end ) row_cache,
       SUM( case when event like 'SQL*Net%' then 1 end ) sql_net ,
       SUM( case when event like 'utl_file%' then 1 end ) utl_file,
-------------
         SUM(DECODE(DBOP_EXEC_ID,'Y',1))   DBOP,
         ROUND(MAX(PGA_ALLOCATED)/1000000,2)  PGA_M,
         ROUND(MAX(TEMP_SPACE_ALLOCATED)/1000000,2) TEMP_M,
-------------
         SUM(DECODE(IN_CONNECTION_MGMT,'Y',1))      CONNECTION_MGMT,
         SUM(DECODE(IN_PARSE          ,     'Y',1)) PARSE,
         SUM(DECODE(IN_HARD_PARSE     ,     'Y',1)) HARD_PARSE,
         SUM(DECODE(IN_SQL_EXECUTION  ,     'Y',1)) SQL_EXECUTION,
         SUM(DECODE(IN_PLSQL_EXECUTION,     'Y',1)) PLSQL_EXECUTION,
         SUM(DECODE(IN_PLSQL_RPC      ,     'Y',1)) PLSQL_RPC,
         SUM(DECODE(IN_PLSQL_COMPILATION,   'Y',1)) PLSQL_COMPILATION,
         SUM(DECODE(IN_JAVA_EXECUTION   ,   'Y',1)) JAVA_EXECUTION,
         SUM(DECODE(IN_BIND             ,   'Y',1)) BIND,
         SUM(DECODE(IN_CURSOR_CLOSE     ,   'Y',1)) CURSOR_CLOSE,
         SUM(DECODE(IN_SEQUENCE_LOAD    ,   'Y',1)) SEQUENCE_LOAD,
         COUNT(DISTINCT BLOCKING_INST_ID||BLOCKING_SESSION||BLOCKING_SESSION_SERIAL#) BLK_SIDS,
         min(ash.sample_time) first_sample,
         max(ash.sample_time) last_sample,
         max(ash.sample_time)-min(ash.sample_time) elapsed_time
     from gv$ACTIVE_SESSion_HISTORY ASH
     where sql_id = :L_SQL_ID  and   :L_GRP_BY = 2
     AND ( ( INST_ID||'-'||SQL_EXEC_ID = :l_ecid   AND :l_ecid  is not null  AND SAMPLE_ID >= :L_MIN_ID  AND SAMPLE_ID <= :L_MAX_ID )
        OR ( INST_ID||'-'||SQL_EXEC_ID = :l_ecid2  AND :l_ecid2 is not null  AND SAMPLE_ID >= :L_MIN_ID2 AND SAMPLE_ID <= :L_MAX_ID2 ) )
     group by INST_ID||'-'||SQL_EXEC_ID, module, sql_id, sql_opname )
     order by to_number(samples) desc, MODULE )
   WHERE SAMPLES > :L_AVG_CNT - 1 OR SQL_ID = :L_SQL_ID OR ROWNUM < 11 )
     LOOP
	    DBMS_OUTPUT.PUT_LINE(
 		   CHR(10)||'<tr>'||CHR(10)
			  ||'<td class="r">'||SM.MODULE                     ||'</td>'||CHR(10)
			  ||'<td class="r">'||SM.SQL_ID                     ||'</td>'||CHR(10)
			  ||'<td class="r">'||SM.SQL_OPNAME                 ||'</td>'||CHR(10)
--			  ||'<td class="r">'||SM.PLAN_HASH_VALUE            ||'</td>'||CHR(10)
--			  ||'<td class="r">'||SM.LINE_ID                    ||'</td>'||CHR(10)
--			  ||'<td class="r">'||SM.OBJ_NAME                   ||'</td>'||CHR(10)
--			  ||'<td class="r">'||SM.EVENT                      ||'</td>'||CHR(10)
			  ||'<td class="r">'||SM.SAMPLES                    ||'</td>'||CHR(10)
			  ||'<td class="r">'||SM.PCT                        ||'</td>'||CHR(10)
			  ||'<td class="r">'||  SM.EXECS               ||'</td>'||CHR(10)
			  ||'<td class="r">'||  SM.WAIT                  ||'</td>'||CHR(10)
			  ||'<td class="r">'||  SM.IO                    ||'</td>'||CHR(10)
			  ||'<td class="r">'||  SM.CPU                   ||'</td>'||CHR(10)
-----
			  ||'<td class="r">'||  SM.control                   ||'</td>'||CHR(10)
			  ||'<td class="r">'||  SM.cursor                   ||'</td>'||CHR(10)
			  ||'<td class="r">'||  SM.cell                   ||'</td>'||CHR(10)
			  ||'<td class="r">'||  SM.db_file                   ||'</td>'||CHR(10)
			  ||'<td class="r">'||  SM.direct                   ||'</td>'||CHR(10)
			  ||'<td class="r">'||  SM.enq                   ||'</td>'||CHR(10)
			  ||'<td class="r">'||  SM.gc                   ||'</td>'||CHR(10)
			  ||'<td class="r">'||  SM.latch                  ||'</td>'||CHR(10)
			  ||'<td class="r">'||  SM.library                   ||'</td>'||CHR(10)
			  ||'<td class="r">'||  SM.log                   ||'</td>'||CHR(10)
			  ||'<td class="r">'||  SM.px                   ||'</td>'||CHR(10)
			  ||'<td class="r">'||  SM.resmgr                  ||'</td>'||CHR(10)
			  ||'<td class="r">'||  SM.row_cache                  ||'</td>'||CHR(10)
			  ||'<td class="r">'||  SM.sql_net                  ||'</td>'||CHR(10)
			  ||'<td class="r">'||  SM.utl_file                  ||'</td>'||CHR(10)
			  ||'<td class="r">'||  SM.DBOP                  ||'</td>'||CHR(10)
			  ||'<td class="r">'||  SM.pga_M                  ||'</td>'||CHR(10)
			  ||'<td class="r">'||  SM.temp_m                  ||'</td>'||CHR(10)
------
			  ||'<td class="r">'||  SM.CONNECTION_MGMT          ||'</td>'||CHR(10)
			  ||'<td class="r">'||  SM.PARSE                    ||'</td>'||CHR(10)
			  ||'<td class="r">'||  SM.HARD_PARSE               ||'</td>'||CHR(10)
			  ||'<td class="r">'||  SM.SQL_EXECUTION            ||'</td>'||CHR(10)
			  ||'<td class="r">'||  SM.PLSQL_EXECUTION          ||'</td>'||CHR(10)
			  ||'<td class="r">'||  SM.PLSQL_RPC                ||'</td>'||CHR(10)
			  ||'<td class="r">'||  SM.PLSQL_COMPILATION         ||'</td>'||CHR(10)
			  ||'<td class="r">'||  SM.JAVA_EXECUTION           ||'</td>'||CHR(10)
			  ||'<td class="r">'||  SM.BIND                     ||'</td>'||CHR(10)
			  ||'<td class="r">'||  SM.CURSOR_CLOSE             ||'</td>'||CHR(10)
			  ||'<td class="r">'||  SM.SEQUENCE_LOAD            ||'</td>'||CHR(10)
			  ||'<td class="r">'||  SM.BLK_SIDS                 ||'</td>'||CHR(10)
			  ||'<td class="r">'||SM.FIRST_SAMPLE               ||'</td>'||CHR(10)
			  ||'<td class="r">'||SM.LAST_SAMPLE                ||'</td>'||CHR(10)
			  ||'<td class="r">'||SM.ELAPSED_TIME               ||'</td>'||CHR(10)
			  ||'</tr>'	);
     END LOOP ;
     EXCEPTION
        WHEN OTHERS THEN
         :L_EXISTS := 'L_ECID_PHASE';
END ;
/

pro </tbody>
pro </table>
pro </details>

rem if :L_ecid is null then goto dba_hist_ash


SET HEAD ON

-- ECID report
--sma19c-20200423

pro   <a name="DBAASHHEADER"></a>
pro <details>
pro   <summary><blue>DBA_ASH BY ECID/SQL_EXEC_ID</blue></summary>


pro <table>
pro <tbody><tr>
pro <th>ECID<br>or<br>SQL_EXEC_ID</th>
pro <th>PHV1</th>
pro <th>PHV2</th>
pro <th>FIRST<BR>SAMPLE_TIME</th>
pro <th>LAST<BR>SAMPLE_TIME</th>
pro <th>ELAPSED<BR>TIME</th>
pro <th>ASH Sample<br>Count</th>
pro <th>NofDistict<br>SQL</th>
pro <th>TOTAL<BR>EXECUTIONS</th>
pro <th>NofDistinct<br>PLAN<br>HashValue</th>
pro <th>TOTAL<BR>HARD PARSING</th>
pro <th>SESSIONS</th>
pro </tr>

SET HEAD OFF

BEGIN

     FOR SM IN ( with drv as ( select distinct nvl(ecid, sql_id) lecid  from   DBA_HIST_active_sess_history
                               where sql_id = :L_SQL_ID  
                               --AND :L_ECID IS NULL
                               AND  DBID = :L_DBID
                               AND   :L_SQLHC_MIN_FLAG < 15
                               --2020922
                               AND SNAP_ID BETWEEN :L_SNAP_ID - 720 AND :L_SNAP_ID
                               --and :L_SQL_GROUP = 'FUSIONAPPS_ONLINE_GROUP'  AND CONSUMER_GROUP_ID = :L_SQL_GROUP_ID
                               )
               select rownum ROW_NUM, ecid, GRP_BY, PHV1, DECODE(PHV2,PHV1,NULL,PHV2) PHV2, MIN_ID, MAX_ID, ecid_start, ecid_end, ecid_time, ash_cnt, nd_sql, ROUND(ASH_CNT/greatest(ND_SQL,4)) AVG_CNT,
               executions, nd_phv, TOT_HP, SESSIONS
               from
               ( select  ecid, GRP_BY, PHV1, PHV2, MIN_ID, MAX_ID, ecid_start, ecid_end, ecid_time, ash_cnt, nd_sql, executions, nd_phv, TOT_HP, sessions from
                 ( select * from
                  ( select /*+ leading(drv) */  ecid, 1 GRP_BY,
                    MIN(SQL_PLAN_HASH_VALUE) PHV1, MAX(SQL_PLAN_HASH_VALUE) PHV2,
                    min(sample_id) min_id, max(sample_id) max_id,
                    min(sample_time) ecid_start, max(sample_time) ecid_end, max(sample_time) - min(sample_time) ECID_TIME,
                    count(*) ash_cnt, count(distinct sql_id) nd_sql, count(distinct sql_exec_id) executions,
                    count(distinct SQL_PLAN_HASH_VALUE) nd_phv,
                    SUM(DECODE(IN_HARD_PARSE     ,     'Y',1)) tot_hp,
                    COUNT(DISTINCT INSTANCE_NUMBER||'-'||SESSION_ID||'-'||SESSION_SERIAL#) SESSIONS
                    --from ( select /*+ leading(drv) */ ecid, sample_time, sql_id, sql_exec_id
                    from   DBA_HIST_active_sess_history, drv
                    where  ecid = lecid  and lecid <> :l_sql_id
                    --2020922
                    AND SNAP_ID BETWEEN :L_SNAP_ID - 720 AND :L_SNAP_ID
                    AND  DBID = :L_DBID
                    AND   :L_SQLHC_MIN_FLAG < 15
                    group by ecid
                    union all
                    select /*+ leading(drv) */  INSTANCE_NUMBER||'-'||SQL_EXEC_ID ECID, 2 GRP_BY,
                    MIN(SQL_PLAN_HASH_VALUE) PHV1, MAX(SQL_PLAN_HASH_VALUE) PHV2,
                    min(sample_id) min_id, max(sample_id) max_id,
                    min(sample_time) ecid_start, max(sample_time) ecid_end, max(sample_time) - min(sample_time) ECID_TIME,
                    count(*) ash_cnt, count(distinct sql_id) nd_sql, count(distinct sql_exec_id) executions,
                    count(distinct SQL_PLAN_HASH_VALUE) nd_phv,
                    SUM(DECODE(IN_HARD_PARSE     ,     'Y',1)) tot_hp,
                    COUNT(DISTINCT INSTANCE_NUMBER||'-'||SESSION_ID||'-'||SESSION_SERIAL#) SESSIONS
                    from   DBA_HIST_active_sess_history, drv
                    where  sql_id = lecid  and lecid = :l_sql_id
                    --2020922
                    AND SNAP_ID BETWEEN :L_SNAP_ID - 720 AND :L_SNAP_ID
                    AND  DBID = :L_DBID
                    AND   :L_SQLHC_MIN_FLAG < 15
                    group by sql_id, INSTANCE_NUMBER||'-'||SQL_EXEC_ID )
                    order by ash_cnt desc )
                 where rownum <= 5 )  )
     LOOP
            IF( SM.ROW_NUM = 1 ) THEN
                   :L_ECID    := SM.ECID;
                   :L_MIN_ID  := SM.MIN_ID;
                   :L_MAX_ID  := SM.MAX_ID;
                   :L_AVG_CNT := SM.AVG_CNT;
                   :L_GRP_BY  := SM.GRP_BY;
      	           DBMS_OUTPUT.PUT_LINE(
 		   CHR(10)||'<tr>'||CHR(10)
			  ||'<td class="r"><RED>'||SM.ECID                ||'</RED></td>'||CHR(10)
			  ||'<td class="r">'||SM.PHV1                     ||'</td>'||CHR(10)
			  ||'<td class="r">'||SM.PHV2                     ||'</td>'||CHR(10)
			  ||'<td class="r">'||SM.ECID_START               ||'</td>'||CHR(10)
			  ||'<td class="r">'||SM.ECID_END                 ||'</td>'||CHR(10)
			  ||'<td class="r">'||SM.ECID_TIME                ||'</td>'||CHR(10)
			  ||'<td class="r">'||SM.ASH_CNT                  ||'</td>'||CHR(10)
			  ||'<td class="r">'||SM.ND_SQL                   ||'</td>'||CHR(10)
			  ||'<td class="r">'||SM.EXECUTIONS               ||'</td>'||CHR(10)
			  ||'<td class="r">'||SM.ND_PHV                   ||'</td>'||CHR(10)
			  ||'<td class="r">'||SM.TOT_HP                   ||'</td>'||CHR(10)
			  ||'<td class="r">'||SM.SESSIONS                 ||'</td>'||CHR(10)
			  ||'</tr>'	);
            ELSE
	           DBMS_OUTPUT.PUT_LINE(
 		   CHR(10)||'<tr>'||CHR(10)
			  ||'<td class="r">'||SM.ECID                     ||'</td>'||CHR(10)
			  ||'<td class="r">'||SM.PHV1                     ||'</td>'||CHR(10)
			  ||'<td class="r">'||SM.PHV2                     ||'</td>'||CHR(10)
			  ||'<td class="r">'||SM.ECID_START               ||'</td>'||CHR(10)
			  ||'<td class="r">'||SM.ECID_END                 ||'</td>'||CHR(10)
			  ||'<td class="r">'||SM.ECID_TIME                 ||'</td>'||CHR(10)
			  ||'<td class="r">'||SM.ASH_CNT                  ||'</td>'||CHR(10)
			  ||'<td class="r">'||SM.ND_SQL                   ||'</td>'||CHR(10)
			  ||'<td class="r">'||SM.EXECUTIONS               ||'</td>'||CHR(10)
			  ||'<td class="r">'||SM.ND_PHV                   ||'</td>'||CHR(10)
			  ||'<td class="r">'||SM.TOT_HP                   ||'</td>'||CHR(10)
			  ||'<td class="r">'||SM.SESSIONS                 ||'</td>'||CHR(10)
			  ||'</tr>'	);
            END IF;
            IF( SM.ROW_NUM = 2 AND SM.GRP_BY = 2 ) THEN
                   :L_ECID2    := SM.ECID;
                   :L_MIN_ID2  := SM.MIN_ID;
                   :L_MAX_ID2  := SM.MAX_ID;
            END IF;
     END LOOP ;
     EXCEPTION
        WHEN OTHERS THEN
         :L_EXISTS := 'L_ECID_AWR';
END ;
/

pro </tbody>
pro </table>
pro </details>

SET HEAD ON
pro   <a name="DBAASHDETAIL"></a>
pro <details>

SET HEAD OFF
SELECT DECODE(:L_GRP_BY, 1, '<summary><blue>DBA_ASH DETAILS BY ECID</blue>(<RED>'||:l_ecid||'</RED>)</summary>',
                         2, '<summary><blue>DBA_ASH DETAILS BY SQL_EXEC_ID</blue>(<RED>'||:l_ecid||'</RED>)</summary>' )
FROM DUAL ;
--select '<summary><blue>DBA_ASH DETAILS BY ECID</blue>(<RED>'||:l_ecid||'</RED>)</summary>' from dual where :l_ecid <>:l_sql_id
--union all
--select '<summary><blue>DBA_ASH DETAILS BY SQL_ID</blue>(<RED>'||:l_sql_id||'</RED>)</summary>' from dual where :l_ecid = :l_sql_id;
SET HEAD ON

-- ECID report
--sma19c-20200423

pro <table>
pro <tbody><tr>
pro <th>MODULE</th>
pro <th>SQL_ID</th>
pro <th>SQL<br>OPNAME</th>
--pro <th>PLAN_HASH_VALUE</th>
--pro <th>LINE_ID</th>
--pro <th>OBJ_NAME</th>
--pro <th>EVENT</th>
--pro <th>PHASE</th>
pro <th>SAMPLES</th>
pro <th>PCT</th>
pro <th>TOTAL<br>EXECS</th>
pro <th>WAIT</th>
pro <th>IO</th>
pro <th>CPU</th>
pro <th>EVENT<br>control</th>
pro <th>EVENT<br>cursor</th>
pro <th>EVENT<br>cell</th>
pro <th>EVENT<br>db_file</th>
pro <th>EVENT<br>direct</th>
pro <th>EVENT<br>enq</th>
pro <th>EVENT<br>gc</th>
pro <th>EVENT<br>latch</th>
pro <th>EVENT<br>library</th>
pro <th>EVENT<br>log</th>
pro <th>EVENT<br>PX</th>
pro <th>EVENT<br>resmgr</th>
pro <th>EVENT<br>row<br>cache</th>
pro <th>EVENT<br>SQL<br>Net</th>
pro <th>EVENT<br>utl<br>file</th>
pro <th>DBOP</th>
pro <th>PGA_M</th>
pro <th>TEMP_M</th>
pro <th>PHASE<br>CONNECTION<br>MGMT</th>
pro <th>PHASE<br>PARSE</th>
pro <th>PHASE<br>HARD<br>PARSE</th>
pro <th>PHASE<br>SQL<br>EXEC</th>
pro <th>PHASE<br>PLSQL<br>EXEC</th>
pro <th>PHASE<br>PLSQL<br>RPC</th>
pro <th>PHASE<br>PLSQL<br>COMPILE</th>
pro <th>PHASE<br>JAVA<br>EXEC</th>
pro <th>PHASE<br>BIND</th>
pro <th>PHASE<br>CURSOR<br>CLOSE</th>
pro <th>PHASE<br>SEQUENCE<br>LOAD</th>
pro <th>BLOCK<br>SESSs</th>
pro <th>FISRT<br>SAMPLES</th>
pro <th>LAST<br>SAMPLES</th>
pro <th>ELAPSED<br>TIME</th>
pro </tr>
set head off

BEGIN
     FOR SM IN (
       select module, CASE WHEN SQL_ID = :L_SQL_ID THEN '<RED>'||SQL_ID||'</RED>' ELSE SQL_ID END SQL_ID, sql_opname,
------------- L_AVG_CNT
          CASE WHEN samples > :L_AVG_CNT THEN '<RED>'||samples||'</RED>' ELSE to_char(samples) END samples,
-------------        ------
          CASE WHEN PCT > :L_AVG_CNT THEN '<RED>'||PCT||'</RED>' ELSE to_char(PCT) END PCT,
-------------        ------
          CASE WHEN EXECS > :L_AVG_CNT THEN '<RED>'||EXECS||'</RED>' ELSE to_char(EXECS) END EXECS,
--          EXECS,        EXECS,
          CASE WHEN WAIT > :L_AVG_CNT THEN '<RED>'||WAIT||'</RED>' ELSE to_char(WAIT) END WAIT,
--          WAIT,         WAIT,
          CASE WHEN IO > :L_AVG_CNT THEN '<RED>'||IO||'</RED>' ELSE to_char(IO) END IO,
--          IO,           IO,
          CASE WHEN CPU > :L_AVG_CNT THEN '<RED>'||CPU||'</RED>' ELSE to_char(CPU) END CPU,
--          CPU,          CPU,
          CASE WHEN CONTROL > :L_AVG_CNT THEN '<RED>'||CONTROL||'</RED>' ELSE to_char(CONTROL) END CONTROL,
--         control,      control,
          CASE WHEN CURSOR > :L_AVG_CNT THEN '<RED>'||CURSOR||'</RED>' ELSE to_char(CURSOR) END CURSOR,
--         cursor,       cursor,
          CASE WHEN CELL > :L_AVG_CNT THEN '<RED>'||CELL||'</RED>' ELSE to_char(CELL) END CELL,
--        cell,         cell,
          CASE WHEN DB_FILE > :L_AVG_CNT THEN '<RED>'||DB_FILE||'</RED>' ELSE to_char(DB_FILE) END DB_FILE,
--        db_file,      db_file,
          CASE WHEN DIRECT > :L_AVG_CNT THEN '<RED>'||DIRECT||'</RED>' ELSE to_char(DIRECT) END DIRECT,
--        direct,       direct,
          CASE WHEN ENQ > :L_AVG_CNT THEN '<RED>'||ENQ||'</RED>' ELSE to_char(ENQ) END ENQ,
--        enq,          enq,
          CASE WHEN GC > :L_AVG_CNT THEN '<RED>'||GC||'</RED>' ELSE to_char(GC) END GC,
--        gc,           gc,
          CASE WHEN LATCH > :L_AVG_CNT THEN '<RED>'||LATCH||'</RED>' ELSE to_char(LATCH) END LATCH,
--        latch,        latch,
          CASE WHEN LIBRARY > :L_AVG_CNT THEN '<RED>'||LIBRARY||'</RED>' ELSE to_char(LIBRARY) END LIBRARY,
--        library,      library,
          CASE WHEN LOG > :L_AVG_CNT THEN '<RED>'||LOG||'</RED>' ELSE to_char(LOG) END LOG,
--        log,          log,
          CASE WHEN PX > :L_AVG_CNT THEN '<RED>'||PX||'</RED>' ELSE to_char(PX) END PX,
--        PX,           PX,
          CASE WHEN RESMGR > :L_AVG_CNT THEN '<RED>'||RESMGR||'</RED>' ELSE to_char(RESMGR) END RESMGR,
--        resmgr,       resmgr,
          CASE WHEN ROW_CACHE > :L_AVG_CNT THEN '<RED>'||ROW_CACHE||'</RED>' ELSE to_char(ROW_CACHE) END ROW_CACHE,
--        row_cache,    row_cache,
          CASE WHEN SQL_NET > :L_AVG_CNT THEN '<RED>'||SQL_NET||'</RED>' ELSE to_char(SQL_NET) END SQL_NET,
          CASE WHEN UTL_FILE > :L_AVG_CNT THEN '<RED>'||UTL_FILE||'</RED>' ELSE to_char(UTL_FILE) END UTL_FILE,
          CASE WHEN DBOP > :L_AVG_CNT THEN '<RED>'||DBOP||'</RED>' ELSE to_char(DBOP) END DBOP,
-------------
           PGA_M,
          TEMP_M,
-------------
          CASE WHEN CONNECTION_MGMT > :L_AVG_CNT THEN '<RED>'||CONNECTION_MGMT||'</RED>' ELSE to_char(CONNECTION_MGMT) END CONNECTION_MGMT,
--          CONNECTION_MGMT,
          CASE WHEN PARSE > :L_AVG_CNT THEN '<RED>'||PARSE||'</RED>' ELSE to_char(PARSE) END PARSE,
--          PARSE,
          CASE WHEN HARD_PARSE > :L_AVG_CNT THEN '<RED>'||HARD_PARSE||'</RED>' ELSE to_char(HARD_PARSE) END HARD_PARSE,
--          HARD_PARSE,
          CASE WHEN SQL_EXECUTION > :L_AVG_CNT THEN '<RED>'||SQL_EXECUTION||'</RED>' ELSE to_char(SQL_EXECUTION) END SQL_EXECUTION,
--          SQL_EXECUTION,
          CASE WHEN PLSQL_EXECUTION > :L_AVG_CNT THEN '<RED>'||PLSQL_EXECUTION||'</RED>' ELSE to_char(PLSQL_EXECUTION) END PLSQL_EXECUTION,
--          PLSQL_EXECUTION,
          CASE WHEN PLSQL_RPC > :L_AVG_CNT THEN '<RED>'||PLSQL_RPC||'</RED>' ELSE to_char(PLSQL_RPC) END PLSQL_RPC,
--          PLSQL_RPC,
          CASE WHEN PLSQL_COMPILATION > :L_AVG_CNT THEN '<RED>'||PLSQL_COMPILATION||'</RED>' ELSE to_char(PLSQL_COMPILATION) END PLSQL_COMPILATION,
--          PLSQL_COMPILATION,
          CASE WHEN JAVA_EXECUTION > :L_AVG_CNT THEN '<RED>'||JAVA_EXECUTION||'</RED>' ELSE to_char(JAVA_EXECUTION) END JAVA_EXECUTION,
--          JAVA_EXECUTION,
          CASE WHEN BIND > :L_AVG_CNT THEN '<RED>'||BIND||'</RED>' ELSE to_char(BIND) END BIND,
--          BIND,
          CASE WHEN CURSOR_CLOSE > :L_AVG_CNT THEN '<RED>'||CURSOR_CLOSE||'</RED>' ELSE to_char(CURSOR_CLOSE) END CURSOR_CLOSE,
--          CURSOR_CLOSE,
          CASE WHEN SEQUENCE_LOAD > :L_AVG_CNT THEN '<RED>'||SEQUENCE_LOAD||'</RED>' ELSE to_char(SEQUENCE_LOAD) END SEQUENCE_LOAD,
--          SEQUENCE_LOAD,
-------------
          BLK_SIDS,
          first_sample,
          last_sample,
          elapsed_time
   FROM (
     SELECT * FROM (
     select module, SQL_ID, sql_opname,
     -- sql_plan_hash_value PLAN_HASH_VALUE,
     -- sql_plan_line_id LINE_ID,
     --(SELECT obj.owner||'.'||obj.object_name||NVL2(obj.subobject_name, '.'||obj.subobject_name, NULL)
     --         FROM dba_objects obj WHERE obj.object_id = current_obj#) OBJ_NAME,
              --current_obj#,
         --     event,
         count(*) samples,
         ROUND((RATIO_TO_REPORT(COUNT(*)) over(partition by ecid))*100, 2) PCT,
         COUNT(DISTINCT SQL_EXEC_ID)  EXECS,
         sum(decode(session_state,'WAITING',1,0)) - sum(decode(session_state,'WAITING', decode(wait_class, 'User I/O',1,0),0)) as WAIT,
         sum(decode(session_state,'WAITING', decode(wait_class, 'User I/O',1,0),0)) as IO,
         SUM(DECODE(SESSION_STATE,'ON CPU',1,0))    CPU,
-------------
       SUM( case when event like 'control%' then 1 end ) control,
       SUM( case when event like 'cursor%' then 1 end ) cursor,
       SUM( case when event like 'cell%' then 1 end ) cell,
       SUM( case when event like 'db file%' then 1 end ) db_file,
       SUM( case when event like 'direct%' then 1 end ) direct,
       SUM( case when event like 'enq%' then 1 end ) enq,
       SUM( case when event like 'gc c%' then 1 end ) gc,
       SUM( case when event like 'latch%' then 1 end ) latch,
       SUM( case when event like 'library%' then 1 end ) library,
       SUM( case when event like 'log%' then 1 end ) log,
       SUM( case when event like 'PX%' then 1 end ) PX,
       SUM( case when event like 'resmgr%' then 1 end ) resmgr,
       SUM( case when event like 'row cache%' then 1 end ) row_cache,
       SUM( case when event like 'SQL*Net%' then 1 end ) sql_net ,
       SUM( case when event like 'utl_file%' then 1 end ) utl_file,
-------------
         SUM(DECODE(DBOP_EXEC_ID,'Y',1))   DBOP,
         ROUND(MAX(PGA_ALLOCATED)/1000000,2)  PGA_M,
         ROUND(MAX(TEMP_SPACE_ALLOCATED)/1000000,2) TEMP_M,
-------------
         SUM(DECODE(IN_CONNECTION_MGMT,'Y',1))      CONNECTION_MGMT,
         SUM(DECODE(IN_PARSE          ,     'Y',1)) PARSE,
         SUM(DECODE(IN_HARD_PARSE     ,     'Y',1)) HARD_PARSE,
         SUM(DECODE(IN_SQL_EXECUTION  ,     'Y',1)) SQL_EXECUTION,
         SUM(DECODE(IN_PLSQL_EXECUTION,     'Y',1)) PLSQL_EXECUTION,
         SUM(DECODE(IN_PLSQL_RPC      ,     'Y',1)) PLSQL_RPC,
         SUM(DECODE(IN_PLSQL_COMPILATION,   'Y',1)) PLSQL_COMPILATION,
         SUM(DECODE(IN_JAVA_EXECUTION   ,   'Y',1)) JAVA_EXECUTION,
         SUM(DECODE(IN_BIND             ,   'Y',1)) BIND,
         SUM(DECODE(IN_CURSOR_CLOSE     ,   'Y',1)) CURSOR_CLOSE,
         SUM(DECODE(IN_SEQUENCE_LOAD    ,   'Y',1)) SEQUENCE_LOAD,
         COUNT(DISTINCT BLOCKING_INST_ID||BLOCKING_SESSION||BLOCKING_SESSION_SERIAL#) BLK_SIDS,
         min(ash.sample_time) first_sample,
         max(ash.sample_time) last_sample,
         max(ash.sample_time)-min(ash.sample_time) elapsed_time
     from dba_hist_ACTIVE_SESS_HISTORY ASH
     where ( ECID = :L_ECID    AND   :L_ECID IS NOT NULL
     AND   DBID = :L_DBID  AND :L_GRP_BY = 1
     AND   :L_SQLHC_MIN_FLAG < 15
     --2020922
     AND SNAP_ID BETWEEN :L_SNAP_ID - 720 AND :L_SNAP_ID
     AND   SAMPLE_ID >= :L_MIN_ID  AND   SAMPLE_ID <= :L_MAX_ID )
     group by ecid, module, sql_id, sql_opname
     union all
     select INSTANCE_NUMBER||'-'||SQL_EXEC_ID||'-'||module MODULE, SQL_ID, sql_opname,
     -- sql_plan_hash_value PLAN_HASH_VALUE,
     -- sql_plan_line_id LINE_ID,
     --(SELECT obj.owner||'.'||obj.object_name||NVL2(obj.subobject_name, '.'||obj.subobject_name, NULL)
     --         FROM dba_objects obj WHERE obj.object_id = current_obj#) OBJ_NAME,
              --current_obj#,
         --     event,
         count(*) samples,
         ROUND((RATIO_TO_REPORT(COUNT(*)) over(partition by INSTANCE_NUMBER||'-'||SQL_EXEC_ID))*100, 2) PCT,
         COUNT(DISTINCT SQL_EXEC_ID)  EXECS,
         sum(decode(session_state,'WAITING',1,0)) - sum(decode(session_state,'WAITING', decode(wait_class, 'User I/O',1,0),0)) as WAIT,
         sum(decode(session_state,'WAITING', decode(wait_class, 'User I/O',1,0),0)) as IO,
         SUM(DECODE(SESSION_STATE,'ON CPU',1,0))    CPU,
-------------
       SUM( case when event like 'control%' then 1 end ) control,
       SUM( case when event like 'cursor%' then 1 end ) cursor,
       SUM( case when event like 'cell%' then 1 end ) cell,
       SUM( case when event like 'db file%' then 1 end ) db_file,
       SUM( case when event like 'direct%' then 1 end ) direct,
       SUM( case when event like 'enq%' then 1 end ) enq,
       SUM( case when event like 'gc c%' then 1 end ) gc,
       SUM( case when event like 'latch%' then 1 end ) latch,
       SUM( case when event like 'library%' then 1 end ) library,
       SUM( case when event like 'log%' then 1 end ) log,
       SUM( case when event like 'PX%' then 1 end ) PX,
       SUM( case when event like 'resmgr%' then 1 end ) resmgr,
       SUM( case when event like 'row cache%' then 1 end ) row_cache,
       SUM( case when event like 'SQL*Net%' then 1 end ) sql_net ,
       SUM( case when event like 'utl_file%' then 1 end ) utl_file,
-------------
         SUM(DECODE(DBOP_EXEC_ID,'Y',1))   DBOP,
         ROUND(MAX(PGA_ALLOCATED)/1000000,2)  PGA_M,
         ROUND(MAX(TEMP_SPACE_ALLOCATED)/1000000,2) TEMP_M,
-------------
         SUM(DECODE(IN_CONNECTION_MGMT,'Y',1))      CONNECTION_MGMT,
         SUM(DECODE(IN_PARSE          ,     'Y',1)) PARSE,
         SUM(DECODE(IN_HARD_PARSE     ,     'Y',1)) HARD_PARSE,
         SUM(DECODE(IN_SQL_EXECUTION  ,     'Y',1)) SQL_EXECUTION,
         SUM(DECODE(IN_PLSQL_EXECUTION,     'Y',1)) PLSQL_EXECUTION,
         SUM(DECODE(IN_PLSQL_RPC      ,     'Y',1)) PLSQL_RPC,
         SUM(DECODE(IN_PLSQL_COMPILATION,   'Y',1)) PLSQL_COMPILATION,
         SUM(DECODE(IN_JAVA_EXECUTION   ,   'Y',1)) JAVA_EXECUTION,
         SUM(DECODE(IN_BIND             ,   'Y',1)) BIND,
         SUM(DECODE(IN_CURSOR_CLOSE     ,   'Y',1)) CURSOR_CLOSE,
         SUM(DECODE(IN_SEQUENCE_LOAD    ,   'Y',1)) SEQUENCE_LOAD,
         COUNT(DISTINCT BLOCKING_INST_ID||BLOCKING_SESSION||BLOCKING_SESSION_SERIAL#) BLK_SIDS,
         min(ash.sample_time) first_sample,
         max(ash.sample_time) last_sample,
         max(ash.sample_time)-min(ash.sample_time) elapsed_time
     from dba_hist_ACTIVE_SESS_HISTORY ASH
     where    DBID = :L_DBID  AND :L_GRP_BY = 2 AND  SQL_ID = :L_SQL_ID
     AND   :L_SQLHC_MIN_FLAG < 15
     --2020922
     AND SNAP_ID BETWEEN :L_SNAP_ID - 720 AND :L_SNAP_ID
     AND ( (  INSTANCE_NUMBER||'-'||SQL_EXEC_ID = :L_ECID
        AND   :L_ECID IS NOT NULL    AND   SAMPLE_ID >= :L_MIN_ID AND   SAMPLE_ID <= :L_MAX_ID  )
      OR (   INSTANCE_NUMBER||'-'||SQL_EXEC_ID = :L_ECID2
        AND   :L_ECID2 IS NOT NULL  AND   SAMPLE_ID >= :L_MIN_ID2 AND   SAMPLE_ID <= :L_MAX_ID2 ) )
     group by INSTANCE_NUMBER||'-'||SQL_EXEC_ID, module, sql_id, sql_opname )
     order by to_number(samples) desc, MODULE
       )
   WHERE SAMPLES > :L_AVG_CNT - 1 OR SQL_ID = :L_SQL_ID OR ROWNUM < 11 )
     LOOP
	    DBMS_OUTPUT.PUT_LINE(
 		   CHR(10)||'<tr>'||CHR(10)
			  ||'<td class="r">'||SM.MODULE                     ||'</td>'||CHR(10)
			  ||'<td class="r">'||SM.SQL_ID                     ||'</td>'||CHR(10)
			  ||'<td class="r">'||SM.SQL_OPNAME                 ||'</td>'||CHR(10)
--			  ||'<td class="r">'||SM.PLAN_HASH_VALUE            ||'</td>'||CHR(10)
--			  ||'<td class="r">'||SM.LINE_ID                    ||'</td>'||CHR(10)
--			  ||'<td class="r">'||SM.OBJ_NAME                   ||'</td>'||CHR(10)
--			  ||'<td class="r">'||SM.EVENT                      ||'</td>'||CHR(10)
			  ||'<td class="r">'||SM.SAMPLES                    ||'</td>'||CHR(10)
			  ||'<td class="r">'||SM.PCT                        ||'</td>'||CHR(10)
			  ||'<td class="r">'||  SM.EXECS               ||'</td>'||CHR(10)
			  ||'<td class="r">'||  SM.WAIT                  ||'</td>'||CHR(10)
			  ||'<td class="r">'||  SM.IO                    ||'</td>'||CHR(10)
			  ||'<td class="r">'||  SM.CPU                   ||'</td>'||CHR(10)
-----
			  ||'<td class="r">'||  SM.control                   ||'</td>'||CHR(10)
			  ||'<td class="r">'||  SM.cursor                   ||'</td>'||CHR(10)
			  ||'<td class="r">'||  SM.cell                   ||'</td>'||CHR(10)
			  ||'<td class="r">'||  SM.db_file                   ||'</td>'||CHR(10)
			  ||'<td class="r">'||  SM.direct                   ||'</td>'||CHR(10)
			  ||'<td class="r">'||  SM.enq                   ||'</td>'||CHR(10)
			  ||'<td class="r">'||  SM.gc                   ||'</td>'||CHR(10)
			  ||'<td class="r">'||  SM.latch                  ||'</td>'||CHR(10)
			  ||'<td class="r">'||  SM.library                   ||'</td>'||CHR(10)
			  ||'<td class="r">'||  SM.log                   ||'</td>'||CHR(10)
			  ||'<td class="r">'||  SM.px                   ||'</td>'||CHR(10)
			  ||'<td class="r">'||  SM.resmgr                  ||'</td>'||CHR(10)
			  ||'<td class="r">'||  SM.row_cache                  ||'</td>'||CHR(10)
			  ||'<td class="r">'||  SM.sql_net                  ||'</td>'||CHR(10)
			  ||'<td class="r">'||  SM.utl_file                  ||'</td>'||CHR(10)
			  ||'<td class="r">'||  SM.DBOP                  ||'</td>'||CHR(10)
			  ||'<td class="r">'||  SM.pga_M                  ||'</td>'||CHR(10)
			  ||'<td class="r">'||  SM.temp_m                  ||'</td>'||CHR(10)
------
			  ||'<td class="r">'||  SM.CONNECTION_MGMT          ||'</td>'||CHR(10)
			  ||'<td class="r">'||  SM.PARSE                    ||'</td>'||CHR(10)
			  ||'<td class="r">'||  SM.HARD_PARSE               ||'</td>'||CHR(10)
			  ||'<td class="r">'||  SM.SQL_EXECUTION            ||'</td>'||CHR(10)
			  ||'<td class="r">'||  SM.PLSQL_EXECUTION          ||'</td>'||CHR(10)
			  ||'<td class="r">'||  SM.PLSQL_RPC                ||'</td>'||CHR(10)
			  ||'<td class="r">'||  SM.PLSQL_COMPILATION         ||'</td>'||CHR(10)
			  ||'<td class="r">'||  SM.JAVA_EXECUTION           ||'</td>'||CHR(10)
			  ||'<td class="r">'||  SM.BIND                     ||'</td>'||CHR(10)
			  ||'<td class="r">'||  SM.CURSOR_CLOSE             ||'</td>'||CHR(10)
			  ||'<td class="r">'||  SM.SEQUENCE_LOAD            ||'</td>'||CHR(10)
			  ||'<td class="r">'||  SM.BLK_SIDS                 ||'</td>'||CHR(10)
			  ||'<td class="r">'||SM.FIRST_SAMPLE               ||'</td>'||CHR(10)
			  ||'<td class="r">'||SM.LAST_SAMPLE                ||'</td>'||CHR(10)
			  ||'<td class="r">'||SM.ELAPSED_TIME               ||'</td>'||CHR(10)
			  ||'</tr>'	);
     END LOOP ;
     EXCEPTION
        WHEN OTHERS THEN
         :L_EXISTS := 'L_ECID_PHASE';
END ;
/

pro </tbody>
pro </table>
pro </details>


--select O.OWNER ||'.'|| o.object_name object_name, O.OBJECT_TYPE, to_char(o.LAST_DDL_TIME,'dd-Mon-yyyy hh24:mm:ss') LAST_DDL_TIME

-- ecid report end

------------------


SET HEAD ON

-- ECID report start
--sma19c-20200423

pro   <a name="19C_GV$SQL_INVALID"></a>
pro <details>
pro   <summary><blue>19C_GV$SQL_INVALID</blue></summary>


pro <table>
pro <tbody><tr>
pro <th>INST_ID</th>
pro <th>SQL_ID</th>
pro <th>CHILD<BR>NUMBER</th>
pro <th>PLAN_HASH_VALUE</th>
pro <th>DDL<BR>NO<BR>INVALIDATE</th>
pro <th>IS<BR>ROLLING<BR>INVALID</th>
pro <th>IS<BR>ROLLING<BR>REFRESH<BR>INVALID</th>
pro <th>INVALIDATIONS</th>
pro <th>PARSE<br>CALLS</th>
pro <th>EXECUTIONS</th>
pro <th>LAST_LOAD_TIME</th>
pro <th>LAST_ACTIVE_TIME</th>
pro </tr>

SET HEAD OFF

DECLARE
  QUERY VARCHAR2(4000);
  TYPE    CurTyp IS REF CURSOR;
  SM_CV   CurTyp;
  QR_INST_ID                        VARCHAR2(50);
  QR_SQL_ID                         VARCHAR2(50);
  QR_CHILD_NUMBER                   VARCHAR2(50);
  QR_PLAN_HASH_VALUE                VARCHAR2(50);
  QR_DDL_NO_INVALIDATE              VARCHAR2(50);
  QR_IS_ROLLING_INVALID             VARCHAR2(50);
  QR_IS_ROLLING_REFRESH_INVALID     VARCHAR2(50);
  QR_INVALIDATIONS                  VARCHAR2(50);
  QR_PARSE_CALLS                    VARCHAR2(50);
  QR_EXECUTIONS                     VARCHAR2(50);
  QR_LAST_LOAD_TIME                 VARCHAR2(80);
  QR_LAST_ACTIVE_TIME               VARCHAR2(80);
BEGIN

     IF ( :SQL_FROM_MEM = 1 AND (:L_SHORT_DB_VERSION LIKE '19%' OR :L_SHORT_DB_VERSION LIKE '2%') ) THEN
       QUERY := 'SELECT INST_ID, SQL_ID, CHILD_NUMBER, PLAN_HASH_VALUE, DDL_NO_INVALIDATE,  IS_ROLLING_INVALID, IS_ROLLING_REFRESH_INVALID, INVALIDATIONS, PARSE_CALLS,EXECUTIONS, LAST_LOAD_TIME, LAST_ACTIVE_TIME '
             ||' FROM GV$SQL WHERE SQL_ID = '''||:L_SQL_ID||''' ORDER BY 1,2,3';
       OPEN SM_CV FOR QUERY ;
       LOOP
          FETCH SM_CV INTO QR_INST_ID, QR_SQL_ID, QR_CHILD_NUMBER, QR_PLAN_HASH_VALUE, QR_DDL_NO_INVALIDATE, QR_IS_ROLLING_INVALID, QR_IS_ROLLING_REFRESH_INVALID, QR_INVALIDATIONS, 
          QR_PARSE_CALLS, QR_EXECUTIONS, QR_LAST_LOAD_TIME, QR_LAST_ACTIVE_TIME ;
          EXIT WHEN SM_CV%NOTFOUND;

          IF( QR_DDL_NO_INVALIDATE  = 'Y' ) THEN QR_DDL_NO_INVALIDATE  := '<RED>'||QR_DDL_NO_INVALIDATE ||'</RED>'; END IF ;
          IF( QR_IS_ROLLING_INVALID = 'Y' ) THEN QR_IS_ROLLING_INVALID := '<RED>'||QR_IS_ROLLING_INVALID||'</RED>'; END IF ;
          IF( QR_IS_ROLLING_REFRESH_INVALID = 'Y' ) THEN QR_IS_ROLLING_REFRESH_INVALID := '<RED>'||QR_IS_ROLLING_REFRESH_INVALID||'</RED>'; END IF ;
          IF( QR_INVALIDATIONS  <> 0 ) THEN QR_INVALIDATIONS := '<RED>'||QR_INVALIDATIONS||'</RED>'; END IF ;

          DBMS_OUTPUT.PUT_LINE(
 		   CHR(10)||'<tr>'||CHR(10)
			  ||'<td class="r">'||QR_INST_ID                          ||'</td>'||CHR(10)
			  ||'<td class="r">'||QR_SQL_ID                           ||'</td>'||CHR(10)
			  ||'<td class="r">'||QR_CHILD_NUMBER                     ||'</td>'||CHR(10)
			  ||'<td class="r">'||QR_PLAN_HASH_VALUE                  ||'</td>'||CHR(10)
			  ||'<td class="r">'||QR_DDL_NO_INVALIDATE                ||'</td>'||CHR(10)
			  ||'<td class="r">'||QR_IS_ROLLING_INVALID               ||'</td>'||CHR(10)
			  ||'<td class="r">'||QR_IS_ROLLING_REFRESH_INVALID       ||'</td>'||CHR(10)
			  ||'<td class="r">'||QR_INVALIDATIONS                    ||'</td>'||CHR(10)
			  ||'<td class="r">'||QR_PARSE_CALLS                      ||'</td>'||CHR(10)
			  ||'<td class="r">'||QR_EXECUTIONS                       ||'</td>'||CHR(10)
			  ||'<td class="r">'||QR_LAST_LOAD_TIME                   ||'</td>'||CHR(10)
			  ||'<td class="r">'||QR_LAST_ACTIVE_TIME                 ||'</td>'||CHR(10)
			  ||'</tr>'	);
       END LOOP;
       CLOSE SM_CV;
     END IF;
     EXCEPTION
     WHEN OTHERS THEN
       NULL;
       -- :L_POD_SIZE := NULL;
END;
/

pro </tbody>
pro </table>
pro </details>

SET HEAD ON

---20201223
-- sqlset start

pro   <a name="SQLSET_SQL_STATS"></a>
pro <details>
pro   <summary><blue>SQLSET_SQL_STATS</blue></summary>

--20210125
BEGIN
     DBMS_OUTPUT.PUT_LINE('<a href="http://100.100.123.145:8080/apex/f?p=101:2002:::NO::P2002_SQL_ID:'||:l_sql_id||'" target="_blank">PSR SQL REP search with the SQL_ID, <blue>'||:l_sql_id||'</blue></a>');
     DBMS_OUTPUT.PUT_LINE('+');
END;
/
pro <table>
pro <tbody><tr>
pro <th>SQL_ID</th>
pro <th>PLAN_HASH_VALUE</th>
pro <th>SQLSET_ID</th>
pro <th>SQLSET_NAME</th>
pro <th>LAST_MODIFIED</th>
pro <th>AVG_BUFFER_GETS</th>
pro <th>AVG_ET_SEC</th>
pro <th>AVG_CPU_SEC</th>
pro <th>AVG_ROWS</th>
pro <th>TOTAL_EXEC</th>
pro <th>NOTES</th>
pro </tr>

SET HEAD OFF

SELECT  		   CHR(10)||'<tr>'||CHR(10)
			  ||'<td class="r">'||SQL_ID            ||'</td>'||CHR(10)
			  ||'<td class="r">'||PLAN_HASH_VALUE   ||'</td>'||CHR(10)
			  ||'<td class="r">'||SQLSET_ID         ||'</td>'||CHR(10)
			  ||'<td class="r">'||SQLSET_NAME       ||'</td>'||CHR(10)
			  ||'<td class="r">'||LAST_MODIFIED     ||'</td>'||CHR(10)
			  ||'<td class="r">'||AVG_BUFFER_GETS   ||'</td>'||CHR(10)
			  ||'<td class="r">'||AVG_ET_SEC        ||'</td>'||CHR(10)
			  ||'<td class="r">'||AVG_CPU_SEC       ||'</td>'||CHR(10)
			  ||'<td class="r">'||AVG_ROWS          ||'</td>'||CHR(10)
			  ||'<td class="r">'||TOTAL_EXEC        ||'</td>'||CHR(10)
			  ||'<td class="r">'||NOTES             ||'</td>'||CHR(10)
			  ||'</tr>'
FROM (
SELECT  SQL_ID, PLAN_HASH_VALUE, SQLSET_ID, LAST_MODIFIED, substr(SQLSET_NAME,1,50) SQLSET_NAME,
              CASE WHEN buffer_gets >= 1e18 THEN ROUND(buffer_gets /1e18,1) || 'E'
                   WHEN buffer_gets >= 1e15 THEN ROUND(buffer_gets /1e15,1) || 'P'
                   WHEN buffer_gets >= 1e12 THEN ROUND(buffer_gets /1e12,1) || 'T'
                   WHEN buffer_gets >= 1e9  THEN ROUND(buffer_gets / 1e9,1) || 'G'
                   WHEN buffer_gets >= 1e6  THEN ROUND(buffer_gets / 1e6,1) || 'M'
                   WHEN buffer_gets >= 1e3  THEN ROUND(buffer_gets / 1e3,1) || 'K'
                   ELSE to_char(round(buffer_gets)) END  AVG_BUFFER_GETS,
              CASE WHEN ET_SEC >= 1e18  THEN ROUND(ET_SEC / 1e18,1) || 'E'
                   WHEN ET_SEC >= 1e15  THEN ROUND(ET_SEC / 1e15,1) || 'P'
                   WHEN ET_SEC >= 1e12  THEN ROUND(ET_SEC / 1e12,1) || 'T'
                   WHEN ET_SEC >= 1e9  THEN ROUND(ET_SEC / 1e9,1) || 'G'
                   WHEN ET_SEC >= 1e6 THEN ROUND(ET_SEC / 1e6,1) || 'M'
                   WHEN ET_SEC >= 1e3 THEN ROUND(ET_SEC / 1e3,1) || 'K'
                   ELSE to_char(round(ET_SEC,3)) END  AVG_ET_SEC,
              CASE WHEN ET_SEC >= 1e18  THEN ROUND(CPU_SEC / 1e18,1) || 'E'
                   WHEN ET_SEC >= 1e15  THEN ROUND(CPU_SEC / 1e15,1) || 'P'
                   WHEN ET_SEC >= 1e12  THEN ROUND(CPU_SEC / 1e12,1) || 'T'
                   WHEN ET_SEC >= 1e9  THEN ROUND(CPU_SEC / 1e9,1) || 'G'
                   WHEN ET_SEC >= 1e6 THEN ROUND(CPU_SEC / 1e6,1) || 'M'
                   WHEN ET_SEC >= 1e3 THEN ROUND(CPU_SEC / 1e3,1) || 'K'
                   ELSE to_char(round(CPU_SEC,3)) END  AVG_CPU_SEC,
              CASE WHEN rows_processed >= 1e18  THEN ROUND(rows_processed / 1e18,1) || 'E'
                   WHEN rows_processed >= 1e15  THEN ROUND(rows_processed / 1e15,1) || 'P'
                   WHEN rows_processed >= 1e12  THEN ROUND(rows_processed / 1e12,1) || 'T'
                   WHEN rows_processed >= 1e9  THEN ROUND(rows_processed / 1e9,1) || 'G'
                   WHEN rows_processed >= 1e6 THEN ROUND(rows_processed / 1e6,1) || 'M'
                   WHEN rows_processed >= 1e3 THEN ROUND(rows_processed / 1e3,1) || 'K'
                   ELSE to_char(round(rows_processed)) END  AVG_ROWS,
              CASE WHEN executions >= 1e18  THEN ROUND(executions / 1e18,1) || 'E'
                   WHEN executions >= 1e15  THEN ROUND(executions / 1e15,1) || 'P'
                   WHEN executions >= 1e12  THEN ROUND(executions / 1e12,1) || 'T'
                   WHEN executions >= 1e9  THEN ROUND(executions / 1e9,1) || 'G'
                   WHEN executions >= 1e6 THEN ROUND(executions / 1e6,1) || 'M'
                   WHEN executions >= 1e3 THEN ROUND(executions / 1e3,1) || 'K'
                   ELSE to_char(round(executions)) END  TOTAL_EXEC,
              replace(replace(replace(replace(replace(notes,'CardFB:,',''),'SQL_PROFILE:,',''),'SQL_PATCH:,',''),'SQL_BSL:,',''),'ADPTV_PLAN:,','') NOTES
FROM (
SELECT SQL_ID, PLAN_HASH_VALUE, SQLSET_ID, SQLSET_NAME,  LAST_MODIFIED, ROUND(buffer_gets/GREATEST(executions,1)) buffer_gets,
       ROUND(ET_SEC/GREATEST(executions,1)/1E6,3) ET_SEC,
       ROUND(CPU_SEC/GREATEST(executions,1)/1E6,3) CPU_SEC,
       ROUND(rows_processed/GREATEST(executions,1)) rows_processed, executions,
   (    select
         'DB VER:'||extractValue(value(d), '/other_xml/info[@type="db_version"]')
       ||',PARS_S:'||extractValue(value(d), '/other_xml/info[@type="parse_schema"]')
       ||',CardFB:'||extractValue(value(d), '/other_xml/info[@type="cardinality_feedback"]')
       ||',SQL_PROFILE:'||extractValue(value(d), '/other_xml/info[@type="sql_profile"]')
       ||',SQL_PATCH:'||extractValue(value(d), '/other_xml/info[@type="sql_patch"]')
       ||',SQL_BSL:'||extractValue(value(d), '/other_xml/info[@type="baseline"]')
       ||',ADPTV_PLAN:'||extractValue(value(d), '/other_xml/info[@type="adaptive_plan"]')
       ||','  etc
       from  sys.WRI$_SQLSET_PLAN_LINES c,
             TABLE(XMLSEQUENCE(EXTRACT(XMLTYPE(c.other_xml), '/other_xml'))) D
       where STMT_ID =  h.stmt_id
       and   plan_hash_value = h.plan_hash_value
       and   other_xml is not null  )  notes
FROM (
select MAX(s.id) stmt_id, MAX(s.sqlset_id) sqlset_id, MAX(d.name) sqlset_NAME, max(d.LAST_MODIFIED) LAST_MODIFIED, s.sql_id, c.plan_hash_value,
       SUM(executions) executions, SUM(buffer_gets) buffer_gets, SUM(elapsed_time) et_sec,  SUM(CPU_time) CPU_sec, sum(rows_processed) rows_processed
from sys.WRI$_SQLSET_STATEMENTS s, sys.WRI$_SQLSET_DEFINITIONS d, sys.WRI$_SQLSET_STATISTICS c
where sql_id = :L_SQL_ID and d.id = s.sqlset_id
AND s.id = c.stmt_id
AND s.con_dbid = c.con_dbid
AND d.last_modified > to_date('31-MAY-2019','DD-MON-YYYY')
GROUP BY s.sql_id, c.plan_hash_value ) h
ORDER BY 6 ) ) ;

pro </tbody>
pro </table>
pro </details>
-- sqlset end

SET HEAD ON

-- 20210104 sqlset plan details start

pro   <a name="SQLSET_PLAN_DETAILS"></a>
pro <details>
pro   <summary><blue>SQLSET_PLAN_DETAILS</blue></summary>

begin
    for l_sqlset in (
               select  *
               from (
               select MAX(s.id) stmt_id, MAX(s.sqlset_id) sqlset_id, MAX(d.name) sqlset_NAME, s.sql_id, c.plan_hash_value,
               SUM(executions) executions, SUM(buffer_gets) buffer_gets, SUM(elapsed_time)/greatest(1,SUM(executions)) et_sec,  SUM(CPU_time) CPU_sec, sum(rows_processed) rows_processed
               from sys.WRI$_SQLSET_STATEMENTS s, sys.WRI$_SQLSET_DEFINITIONS d, sys.WRI$_SQLSET_STATISTICS c
               where sql_id = :L_SQL_ID and d.id = s.sqlset_id
               AND s.id = c.stmt_id
               AND s.con_dbid = c.con_dbid
               AND d.last_modified > to_date('31-MAY-2019','DD-MON-YYYY')
               GROUP BY s.sql_id, c.plan_hash_value order by 8 )
               -- 20210111
               where rownum <  decode(:L_SQLHC_MIN_FLAG,16,6,11)
               )
    loop
       for l_sqlset_plan  in (
         select
         id,
         SQLSET_ID||'--'||
	 LPAD('    ',4-LENGTH(ID))||ID||':'||
	 lpad('        ', 10-length(NVL(COST,0)))||NVL(TO_CHAR(COST),' ')||':'||
	 lpad('        ', 11-length(nvl(CARDINALITY,0)))||NVL(TO_CHAR(CARDINALITY),' ')||':'||
	 substr(lpad('...............................', 1*(DEPTH-1)) 	||
	 operation ||' '|| options ||' '||object_name,1,400)||' '||
--20210127
        (CASE WHEN operation like 'INDEX%'
                   THEN ' INDEX'||DECODE(object_name,NULL,NULL,'(@"'||qblock_name||'" "'||replace( replace(object_alias,'"',''),'@','"@"' )||'" "'||object_name||'")')
	 END )
         operation
         from ( select sqlset_id, id,
              CASE WHEN COST >= 1e18 THEN ROUND(COST /1e18,1) || 'E'
                   WHEN COST >= 1e15 THEN ROUND(COST /1e15,1) || 'P'
                   WHEN COST >= 1e12 THEN ROUND(COST /1e12,1) || 'T'
                   WHEN COST >= 1e9  THEN ROUND(COST / 1e9,1) || 'G'
                   WHEN COST >= 1e6  THEN ROUND(COST / 1e6,1) || 'M'
                   WHEN COST >= 1e3  THEN ROUND(COST / 1e3,1) || 'K'
                   ELSE to_char(round(COST,2)) END  cost,
              CASE WHEN CARDINALITY >= 1e18  THEN ROUND(CARDINALITY / 1e18,1) || 'E'
                   WHEN CARDINALITY >= 1e15  THEN ROUND(CARDINALITY / 1e15,1) || 'P'
                   WHEN CARDINALITY >= 1e12  THEN ROUND(CARDINALITY / 1e12,1) || 'T'
                   WHEN CARDINALITY >= 1e9  THEN ROUND(CARDINALITY / 1e9,1) || 'G'
                   WHEN CARDINALITY >= 1e6 THEN ROUND(CARDINALITY / 1e6,1) || 'M'
                   WHEN CARDINALITY >= 1e3 THEN ROUND(CARDINALITY / 1e3,1) || 'K'
                   ELSE to_char(round(CARDINALITY,2)) END  cardinality,
              depth, operation, options, object_name, qblock_name, object_alias
        from DBA_SQLSET_PLANS
        WHERE sql_id = :l_sql_id
        and   plan_hash_value = l_sqlset.plan_hash_value
        and   SQLSET_ID = l_sqlset.sqlset_id
        )
        ORDER BY SQLSET_ID, ID
        )
      loop
         if ( l_sqlset_plan.id = 0 ) then 
            DBMS_OUTPUT.PUT_LINE('*');
            DBMS_OUTPUT.PUT_LINE('-------------------------------------------------------------------------------------');
            DBMS_OUTPUT.PUT_LINE('SET_ID: ID:     COST :Cardinality: Operation (PHV : '||l_sqlset.plan_hash_value||')');
            DBMS_OUTPUT.PUT_LINE('-------------------------------------------------------------------------------------');
         end if ;
         DBMS_OUTPUT.PUT_LINE( l_sqlset_plan.operation );
      end loop;
--20210127--LEADING HINT--
       for l_sqlset_hint  in (
         SELECT rownum rm, sqlset_id, OUTLINE_DATA
         FROM (
               SELECT /*+ leading(drv) opt_param('parallel_execution_enabled', 'false') */
                     drv.SQLSET_ID,  SUBSTR(EXTRACTVALUE(VALUE(d), '/hint'), 1, 4000) OUTLINE_DATA
               FROM ( select SQLSET_ID, other_xml
                      from  DBA_SQLSET_PLANS
                      WHERE sql_id = :l_sql_id
                      and   plan_hash_value = l_sqlset.plan_hash_value
                      and   SQLSET_ID = l_sqlset.sqlset_id
                      and   other_xml is not null ) drv,
                     TABLE(XMLSEQUENCE(EXTRACT(XMLTYPE(other_xml), '/*/outline_data/hint'))) d
               )
         WHERE OUTLINE_DATA LIKE 'LEADING%'
        )
        loop
          if ( l_sqlset_hint.rm = 1 ) then
            DBMS_OUTPUT.PUT_LINE('*');
            DBMS_OUTPUT.PUT_LINE('-------------------------------------------------------------------------------------');
            DBMS_OUTPUT.PUT_LINE('SET_ID: '||l_sqlset_hint.sqlset_id||' (PHV : '||l_sqlset.plan_hash_value||') : Leading hint only');
            DBMS_OUTPUT.PUT_LINE('-------------------------------------------------------------------------------------');
          end if;
            DBMS_OUTPUT.PUT_LINE( l_sqlset_hint.OUTLINE_DATA );
        end loop;
    end loop;
end;
/
pro </details>
-- 20210104 sqlset plan details end

pro
pro <details>
pro   <summary>More Reference Information</summary>
pro
Pro   <a href="https://confluence.oraclecorp.com/confluence/display/~jinsoo.eo@oracle.com/FusionApps+SQL+Tuning+Automation">FusionApps SQL Tuning Automation</a>
set head off
SELECT 'Start: ' || to_timestamp(:L_smastart, 'YYYY-MM-DD HH24:MI:SS:FF') from dual;
SELECT 'End  : ' || to_timestamp(to_char(systimestamp, 'YYYY-MM-DD HH24:MI:SS:FF'), 'YYYY-MM-DD HH24:MI:SS:FF') from dual;
SELECT 'The sma took ' || (to_timestamp(to_char(systimestamp, 'YYYY-MM-DD HH24:MI:SS:FF'), 'YYYY-MM-DD HH24:MI:SS:FF') - to_timestamp(:L_smastart, 'YYYY-MM-DD HH24:MI:SS:FF')) as sqlhc_runtime from dual;
SELECT 'SQLHC took '||:L_SQLHC_MIN||' mins' FROM DUAL ;

set head on
pro </details>

pro </pre>
pro <a href="#top">Back to top</a><pre>

PRO </body>
PRO </html>
spool off

-- rem sma_summary_&&files_prefix..html moved here. 20200708

SPOOL sma_summary_&&files_prefix..html;

pro </pre><a name="SQL_LEVEL_Observations"></a><h2>SQL level Observations</h2><pre>
begin

     IF ( :SQL_FROM_SPM = 0 ) THEN
           DBMS_OUTPUT.PUT_LINE('SQL_ID: <blue>'||:L_SQL_ID||'</blue> was available in GV$SQL_MONITOR : <RED>NO</RED>');
           DBMS_OUTPUT.PUT_LINE('=> <B>SMA(SQL Monitor Analyzer) could <RED>not</RED> perform the analysis.</B>');
     END IF;
     IF ( :SQL_FROM_SPM = 1 ) THEN
           DBMS_OUTPUT.PUT_LINE('SQL_ID: <blue>'||:L_SQL_ID||'</blue> was available in GV$SQL_MONITOR : <blue>YES</blue>');
     END IF;
     IF ( :L_SQL_GROUP IS NOT NULL ) THEN
           DBMS_OUTPUT.PUT_LINE('SQL CONSUMER GROUP1 : <blue>'||:L_SQL_GROUP||'</blue>');
     END IF;
     IF ( :L_SQL_GROUP1 IS NOT NULL ) THEN
           DBMS_OUTPUT.PUT_LINE('SQL CONSUMER GROUP2 : <blue>'||:L_SQL_GROUP1||'</blue>');
     END IF;
     IF ( :L_HPT > 1 and 'FUSIONAPPS_ONLINE_GROUP' IN (:L_SQL_GROUP ,:L_SQL_GROUP1)  ) THEN
           DBMS_OUTPUT.PUT_LINE('AVG HARD PARSING TIME(S) : <RED>'||:L_HPT||'</RED> Seconds and SHARABLE_MEMORY : <RED>'||:L_SHARABLE_MEM||'</RED>');
     END IF;
     IF ( :L_VPD_CNT > 3 ) THEN
           DBMS_OUTPUT.PUT_LINE('PII VPD Usage count : <RED>'||:L_VPD_CNT||'</RED>');
     END IF;
     IF ( :L_SQL_PROFILE IS NOT NULL ) THEN
       DBMS_OUTPUT.PUT_LINE('SQL PROFILE : <RED>YES</RED> (NAME: <blue>'||:L_SQL_PROFILE||'</blue>, PHV: <blue>'||:L_PLAN_HASH_VALUE_PROFILE||'</blue>)');
     END IF;
     IF ( :L_SQL_PATCH IS NOT NULL ) THEN
       DBMS_OUTPUT.PUT_LINE('SQL PATCH : <RED>YES</RED> (<blue>'||:L_SQL_PATCH||'</blue>)');
     END IF;
     IF ( :L_SQL_PLAN_BASELINE IS NOT NULL ) THEN
       DBMS_OUTPUT.PUT_LINE('SQL BASELINE : <RED>YES</RED> (<blue>'||:L_SQL_PLAN_BASELINE||'</blue>)');
     END IF;
     IF ( 1 in (:issue_blind_input ,:issue_blind_query ,:issue_inac_card_estim ,:issue_cbo ,:issue_error ,
                :issue_improper_index ,:issue_MJ_CP ,:issue_blind_condition ,:issue_stats ,:issue_throw_away ) ) then
        --  DBMS_OUTPUT.PUT_LINE('<a href="#PHV_ANALYSIS">PHV level Analysis</a> section has more <blue>detail information</blue> for the following category.');
            DBMS_OUTPUT.PUT_LINE('.');
            DBMS_OUTPUT.PUT_LINE('The following category can have more detail information in <a href="#PHV_ANALYSIS"><blue>PHV level Analysis</blue></a>');
     end if;
     IF ( :ISSUE_HEAVY_OPERATION = 1) THEN
            DBMS_OUTPUT.PUT_LINE('.');
            DBMS_OUTPUT.PUT_LINE('<blue>* </blue>Heavy operation : <RED>YES</RED>');
            DBMS_OUTPUT.PUT_LINE('<blue>Action Item : DEVELOPMENT TEAM</BLUE>');
            DBMS_OUTPUT.PUT_LINE('=> Suggestion : Review the operation requiring heavy Waits or CPU in SMA report');
     END IF;
/* blind query */
     IF (:issue_blind_query = 1
/*v3*/  and :issue_improper_index = 0 and :issue_throw_away = 0 and :issue_inac_card_estim = 0 and :issue_cbo = 0
        and :issue_blind_input = 0    --and :issue_blind_condition = 0
         ) then
            DBMS_OUTPUT.PUT_LINE('.');
            DBMS_OUTPUT.PUT_LINE('<blue>* </blue>Blind operation : <RED>YES</RED>');
            DBMS_OUTPUT.PUT_LINE('<blue>Action Item : DEVELOPMENT TEAM</BLUE>');
            DBMS_OUTPUT.PUT_LINE('=> Suggestion : Add selective criteria to the SQL');
     end if;
     IF (:issue_blind_input = 1 ) then
            DBMS_OUTPUT.PUT_LINE('.');
            DBMS_OUTPUT.PUT_LINE('<blue>* </blue>Blind input or unselective input : <RED>YES</RED>');
            DBMS_OUTPUT.PUT_LINE('<blue>Action Item : DEVELOPMENT TEAM/SUPPORT TEAM</BLUE>');
            DBMS_OUTPUT.PUT_LINE('=> Suggestion : Use selective input');
     end if;
     IF (:issue_blind_condition = 1 and :issue_blind_query = 0 ) then
            DBMS_OUTPUT.PUT_LINE('.');
            DBMS_OUTPUT.PUT_LINE('<blue>* </blue>Unselective condition or input : <RED>YES</RED>');
            DBMS_OUTPUT.PUT_LINE('<blue>Action Item : DEVELOPMENT TEAM/SUPPORT TEAM</BLUE>');
            DBMS_OUTPUT.PUT_LINE('=> Suggestion : Use selective criteria or input');
     end if;
/* missing join */
     IF (:issue_MJ_CP = 1 ) then
            DBMS_OUTPUT.PUT_LINE('.');
            DBMS_OUTPUT.PUT_LINE('<blue>* </blue>Merge Join with Suspicious missing join : <RED>YES</RED>');
            DBMS_OUTPUT.PUT_LINE('<blue>Action Item : DEVELOPMENT TEAM</BLUE>');
            DBMS_OUTPUT.PUT_LINE('=> Suggestion : Refer to PHV level Analysis');
--20200626
            DBMS_OUTPUT.PUT_LINE('<a href="https://apex.oraclecorp.com/pls/apex/f?p=28906" target="_blank"><blue>Please use SQL PARSER to find Missing-Join</blue></a>');
     end if;
/* improper index */
     IF (:issue_improper_index = 1 ) then
            DBMS_OUTPUT.PUT_LINE('.');
            DBMS_OUTPUT.PUT_LINE('<blue>* </blue>Improper Index and Column Condition : <RED>YES</RED>');
            DBMS_OUTPUT.PUT_LINE('<blue>Action Item : DEVELOPMENT TEAM</BLUE>');
            DBMS_OUTPUT.PUT_LINE('=> Suggestion : Refer to PHV level Analysis');
     end if;
/* only when no error 20200529 */
     IF (:issue_throw_away = 1 ) then
            DBMS_OUTPUT.PUT_LINE('.');
            DBMS_OUTPUT.PUT_LINE('<blue>* </blue>Improper Index with Throw-away : <RED>YES</RED>');
            DBMS_OUTPUT.PUT_LINE('<blue>Action Item : DEVELOPMENT TEAM</BLUE>');
            DBMS_OUTPUT.PUT_LINE('=> Suggestion : Modify/create the index or change the join order');
            DBMS_OUTPUT.PUT_LINE('=> Refer to PHV level Analysis for more details');
            if (:issue_error = 1) then
              DBMS_OUTPUT.PUT_LINE('=>Note: Since the sql met the error, the throw-away issue might not be correct.');
            end if;
     end if;
/* stale stats */
     IF (:issue_stats = 1 ) then
            DBMS_OUTPUT.PUT_LINE('.');
            DBMS_OUTPUT.PUT_LINE('<blue>* </blue>Stats Issue : <RED>YES</RED>');
            DBMS_OUTPUT.PUT_LINE('<blue>Action Item : DEVELOPMENT TEAM/CLOUD OPEARTION TEAM</BLUE>');
            DBMS_OUTPUT.PUT_LINE('=> Suggestion : Refer to PHV level Analysis');
     end if;
/* wrong cardinality estimation */
     IF (:issue_inac_card_estim = 1 ) then
            DBMS_OUTPUT.PUT_LINE('.');
            DBMS_OUTPUT.PUT_LINE('<blue>* </blue>Inaccurate Cardinality estimation : <RED>YES</RED>');
            DBMS_OUTPUT.PUT_LINE('<blue>Action Item : DEVELOPMENT TEAM/CLOUD OPEARTION TEAM/PSR</BLUE>');
            DBMS_OUTPUT.PUT_LINE('=> Suggestion : Refer to PHV level Analysis with PSR');
     end if;
/* jppd issue */
     IF (:issue_cbo = 1 ) then
            DBMS_OUTPUT.PUT_LINE('.');
            DBMS_OUTPUT.PUT_LINE('<blue>* </blue>Suspicious CBO issue : <RED>YES</RED>');
            DBMS_OUTPUT.PUT_LINE('<blue>Action Item : DEVELOPMENT TEAM/CLOUD OPEARTION TEAM/PSR</BLUE>');
            DBMS_OUTPUT.PUT_LINE('=> Suggestion : Refer to PHV level Analysis with PSR');

     end if;
/* errorstale stats */
     IF (:issue_error = 1 ) then
            DBMS_OUTPUT.PUT_LINE('.');
            DBMS_OUTPUT.PUT_LINE('<blue>* </blue>Error : <RED>YES</RED>');
            DBMS_OUTPUT.PUT_LINE('<blue>Action Item : DEVELOPMENT TEAM/CLOUD OPEARTION TEAM/PSR</BLUE>');
            DBMS_OUTPUT.PUT_LINE('=> Suggestion : Refer to PHV level Analysis');
     end if;
/* v3 */
     SELECT NVL(
      (WITH DRV AS (SELECT MAX(SNAP_ID) MSNAP_ID FROM DBA_HIST_SNAPSHOT WHERE DBID = :L_DBID
                    --2020922
                    AND SNAP_ID BETWEEN :L_SNAP_ID - 720 AND :L_SNAP_ID)
       SELECT COUNT(DISTINCT SQL_ID)
       FROM (
          SELECT SQL_ID
          FROM GV$SQLAREA
          WHERE FORCE_MATCHING_SIGNATURE = :L_FORCE_MATCHING_SIGNATURE and :L_FORCE_MATCHING_SIGNATURE <> 0
          AND SQL_ID <> :L_SQL_ID  AND :SQL_FROM_MEM = 1
          --AND PLAN_HASH_VALUE = :L_PLAN_HASH_VALUE
          UNION ALL
          SELECT SQL_ID
          FROM DBA_HIST_SQLSTAT, DRV
          WHERE FORCE_MATCHING_SIGNATURE = :L_FORCE_MATCHING_SIGNATURE and :L_FORCE_MATCHING_SIGNATURE <> 0
          --2020922
          AND SNAP_ID BETWEEN :L_SNAP_ID - 720 AND :L_SNAP_ID
          AND   DBID = :L_DBID  AND SQL_ID <> :L_SQL_ID AND ( :SQL_FROM_AWR = 1 OR :SQL_FROM_MEM = 1 )
          --AND PLAN_HASH_VALUE = :L_PLAN_HASH_VALUE
          AND   SNAP_ID  >= DRV.MSNAP_ID  - 24*7 )), 0 ) INTO :L_LITERAL_SQL
      FROM DUAL ;
     IF ( :L_LITERAL_SQL > 1 ) THEN
            DBMS_OUTPUT.PUT_LINE('.');
            DBMS_OUTPUT.PUT_LINE('Dynamic SQL with different literal (found '||:L_LITERAL_SQL||' SQLs): <RED>YES</RED>');
            DBMS_OUTPUT.PUT_LINE('<blue>Action Item : DEVELOPMENT TEAM</BLUE>');
            DBMS_OUTPUT.PUT_LINE('=> Suggestion : Replace the literal with bind variable');
     END IF;
/* 20200722 repeated predicates start */
     IF ( :ISSUE_REPEATED_PREDICATES > 0 ) THEN
            DBMS_OUTPUT.PUT_LINE('.');
            DBMS_OUTPUT.PUT_LINE('<blue>* </blue>Repeated Predicates : <RED>YES</RED>');
            DBMS_OUTPUT.PUT_LINE('<blue>Action Item : DEVELOPMENT TEAM</BLUE>');
            DBMS_OUTPUT.PUT_LINE('=> Suggestion : Review PREPEATED PREDICATES (MEM) under SMA report');
     END IF;
/* 20200722 repeated predicates end */
end;
/
--20210317
BEGIN
  IF( :L_CURRENT_BEST IS NOT NULL AND :L_CURRENT_BEST <> -1 AND :L_COUNT >= 2 AND :L_SQL_PROFILE IS NULL AND :L_CURRENT_BEST_TIME*2 < :L_CURRENT_WORST1_TIME
       and :L_CURRENT_BEST_BFG < :L_CURRENT_WORST1_BFG AND :L_VPD_CNT = 0 ) THEN
    DBMS_OUTPUT.PUT_LINE('.');
    DBMS_OUTPUT.PUT_LINE('<blue>Action Item : DEVELOPMENT TEAM/OPERATION TEAM</BLUE>');
    DBMS_OUTPUT.PUT_LINE('Better Plan is available : <blue>YES</blue>');
    DBMS_OUTPUT.PUT_LINE('=> If the sql is using VPD, do not setup the sql profile.');
    DBMS_OUTPUT.PUT_LINE('=> How to set the sql profile with current better plan');
    DBMS_OUTPUT.PUT_LINE('$<blue>sqlplus / as sysdba</blue>');
    IF ( :L_PDB <> 'NOPDB' ) THEN
      DBMS_OUTPUT.PUT_LINE('SQL><blue>'||:L_PDB||'</blue>');
    END IF;
    DBMS_OUTPUT.PUT_LINE('SQL><blue>start coe_xfr_sql_profile.sql '||:L_SQL_ID||' '||:L_CURRENT_BEST||'</blue>');
    DBMS_OUTPUT.PUT_LINE('SQL><blue>start coe_xfr_sql_profile_'||:L_SQL_ID||'_'||:L_CURRENT_BEST||'.sql</blue>');
    --DBMS_OUTPUT.PUT_LINE('is under <a href="https://stbeehive.oracle.com/teamcollab/library/st/PSR+DB+Team/Public+Documents/Tools">https://stbeehive.oracle.com/teamcollab/library/st/PSR+DB+Team/Public+Documents/Tools</blue></a>');
--20200706
    DBMS_OUTPUT.PUT_LINE('<blue>The file, coe_xfr_sql_profile.sql is under <a href="https://oradocs-corp.documents.us2.oraclecloud.com/documents/folder/FA310826A083983F8A71E262F6C3FF17C1177A968060/_Tools" target="_blank">PSR/Tools</blue></a>');
    DBMS_OUTPUT.PUT_LINE('<blue>For the detail instruction, refer <a href="https://confluence.oraclecorp.com/confluence/display/PSR/Create+a+SQL+Profile" target="_blank">PSR/Create_a_SQL_Profile</blue></a>');
  END IF;

/* V3 bugdb searching */
     DBMS_OUTPUT.PUT_LINE('+');
--20200706
     DBMS_OUTPUT.PUT_LINE('<a href="https://bug.oraclecorp.com/pls/bug/webbug_reports.km_search?p_search='||:l_sql_id||'" target="_blank">Bug DB search with the SQL_ID, <blue>'||:l_sql_id||'</blue></a>');
--   DBMS_OUTPUT.PUT_LINE('https://bug.oraclecorp.com/pls/bug/webbug_reports.km_search?p_search='||:l_sql_id);
--20210125
     DBMS_OUTPUT.PUT_LINE('+');
     DBMS_OUTPUT.PUT_LINE('<a href="http://100.100.123.145:8080/apex/f?p=101:2002:::NO::P2002_SQL_ID:'||:l_sql_id||'" target="_blank">PSR SQL REP search with the SQL_ID, <blue>'||:l_sql_id||'</blue></a>');

END;
/

-- 19C
DECLARE
    QUARANTINE_NAME VARCHAR2(60);
BEGIN
IF ( :L_SHORT_DB_VERSION LIKE '19%' or :L_SHORT_DB_VERSION LIKE '2%') THEN
-- SMA19C
 IF ( :L_CURRENT_WORST1 <> -1 ) THEN
    DBMS_OUTPUT.PUT_LINE('.');
    DBMS_OUTPUT.PUT_LINE('<blue>DB 19C only</BLUE>');
    DBMS_OUTPUT.PUT_LINE('<blue>Action Item : DEVELOPMENT TEAM/OPERATION TEAM</BLUE>');
    DBMS_OUTPUT.PUT_LINE('Worst Plan is available : <blue>YES</blue>');
    DBMS_OUTPUT.PUT_LINE('=> How to set the sql quarantine with current worst plan');
    DBMS_OUTPUT.PUT_LINE('$<blue>sqlplus / as sysdba</blue>');
    IF ( :L_PDB <> 'NOPDB' ) THEN
      DBMS_OUTPUT.PUT_LINE('SQL><blue>'||:L_PDB||'</blue>');
    END IF;
    DBMS_OUTPUT.PUT_LINE('SQL><BLUE>SELECT DBMS_SQLQ.CREATE_QUARANTINE_BY_SQL_ID(SQL_ID => '''||:L_SQL_ID||''', PLAN_HASH_VALUE => '||:L_CURRENT_WORST1||' ) QUARANTINE_NAME FROM DUAL;</BLUE>');
 END IF;
 IF ( :L_CURRENT_WORST2 <> -1 ) THEN
    DBMS_OUTPUT.PUT_LINE('SQL><BLUE>SELECT DBMS_SQLQ.CREATE_QUARANTINE_BY_SQL_ID(SQL_ID => '''||:L_SQL_ID||''', PLAN_HASH_VALUE => '||:L_CURRENT_WORST2||' ) QUARANTINE_NAME FROM DUAL;</BLUE>');
 END IF;
 IF ( :L_CURRENT_WORST3 <> -1 ) THEN
    DBMS_OUTPUT.PUT_LINE('SQL><BLUE>SELECT DBMS_SQLQ.CREATE_QUARANTINE_BY_SQL_ID(SQL_ID => '''||:L_SQL_ID||''', PLAN_HASH_VALUE => '||:L_CURRENT_WORST3||' ) QUARANTINE_NAME FROM DUAL;</BLUE>');
 END IF;
 IF ( :L_CURRENT_WORST4 <> -1 ) THEN
    DBMS_OUTPUT.PUT_LINE('SQL><BLUE>SELECT DBMS_SQLQ.CREATE_QUARANTINE_BY_SQL_ID(SQL_ID => '''||:L_SQL_ID||''', PLAN_HASH_VALUE => '||:L_CURRENT_WORST4||' ) QUARANTINE_NAME FROM DUAL;</BLUE>');
 END IF;
 IF ( :L_CURRENT_WORST5 <> -1 ) THEN
    DBMS_OUTPUT.PUT_LINE('SQL><BLUE>SELECT DBMS_SQLQ.CREATE_QUARANTINE_BY_SQL_ID(SQL_ID => '''||:L_SQL_ID||''', PLAN_HASH_VALUE => '||:L_CURRENT_WORST5||' ) QUARANTINE_NAME FROM DUAL;</BLUE>');
 END IF;
END IF;
END;
/

-- FOR SMA AND SQLHC
spool off



REM FOR SMA and sqlhc
/* rem for linux (cat:rm) and windows (copy:del) */
--20200705 start
--HOS cat sma_&&files_prefix..sql1 sma_&&files_prefix..sql2 sma_&&files_prefix..sql3 sma_ep_&&files_prefix..output sma_ep1_&&files_prefix..output sma_&&files_prefix..sql4 > sma_&&files_prefix..html
--HOS copy /Y sma_&&files_prefix..sql1 + sma_&&files_prefix..sql2 + sma_&&files_prefix..sql3 + sma_ep_&&files_prefix..output + sma_ep1_&&files_prefix..output + sma_&&files_prefix..sql4 sma_&&files_prefix..html
--HOS rm  -f sma_&&files_prefix..sql1 sma_&&files_prefix..sql2 sma_&&files_prefix..sql3 sma_&&files_prefix..sql4
--HOS del -f sma_&&files_prefix..sql1 sma_&&files_prefix..sql2 sma_&&files_prefix..sql3 sma_&&files_prefix..sql4

HOS cat sma_&&files_prefix..sql1 sma_summary_&&files_prefix..html sma_&&files_prefix..sql3 sma_ep_&&files_prefix..output sma_ep1_&&files_prefix..output sma_&&files_prefix..sql4 > sma_&&files_prefix..html
HOS copy /Y sma_&&files_prefix..sql1 + sma_summary_&&files_prefix..html + sma_&&files_prefix..sql3 + sma_ep_&&files_prefix..output + sma_ep1_&&files_prefix..output + sma_&&files_prefix..sql4 sma_&&files_prefix..html
HOS rm  -f sma_&&files_prefix..sql1 sma_&&files_prefix..sql3 sma_&&files_prefix..sql4
HOS del -f sma_&&files_prefix..sql1 sma_&&files_prefix..sql3 sma_&&files_prefix..sql4
--20200705 end

HOS rm  -f sma_ep_&&files_prefix..output sma_ep1_&&files_prefix..output
HOS del -f sma_ep_&&files_prefix..output sma_ep1_&&files_prefix..output

HOS rm  -f sma_exp_&&files_prefix..sql sma_exp1_&&files_prefix..sql
HOS del -f sma_exp_&&files_prefix..sql sma_exp1_&&files_prefix..sql

REM For SQLHC for no zipping of sma
--HOS zip -m sma_&&files_prefix..zip  sma_&&files_prefix..html
--20200705 start
--HOS zip -m sma_&&files_prefix..zip  sma_summary_&&files_prefix..html
--20200705 end



REM FOR SQLHC additionally
--HOS zip -m &&files_prefix..zip  sma_&&files_prefix..zip
HOS zip -m &&files_prefix..zip  sma_&&files_prefix..html
HOS zip -m &&files_prefix..zip  sma_summary_&&files_prefix..html


--20200630

REM GET EXPANDED SQL TEXT
set long 1000000 longc 10000000 trims on trim on head off term off feed off pagesize 50000
var expanded_sql_text clob;
col expanded_sql_text form A120 wor
exec DBMS_UTILITY.expand_sql_text(input_sql_text => :sql_text, output_sql_text => :expanded_sql_text);
spool expanded_sql_text_&&files_prefix..sql
print expanded_sql_text
spool off
--20200706
set head on term on trims off  trim off long 80 longc 80
--PRO ;;
--SPO sqlhc.log APP;

REM PUSH THE expanded text file in the SQLHC zip
--rem for sma
--HOS zip -m sma_&&files_prefix..zip expanded_sql_text_&&files_prefix..sql
rem for sqlhc
HOS zip -m &&files_prefix..zip expanded_sql_text_&&files_prefix..sql


--exec :l_sql_id := null;
--exec :sql_text := null;
UNDEF 1 2 PLAN_PRINT
set echo on  FEED On verify on heading on LINESIZE 100 pagesize 100
EXEC DBMS_APPLICATION_INFO.SET_MODULE(module_name => NULL, action_name => NULL);

/*
sma ends
*/

PRO
PRO &&files_prefix..zip has been created.
PRO
SET TERM OFF;
/* Pushkar - Release the lock so that other SQLHCs can run */
DECLARE
   l_release_retval number;
   l_str varchar2(200);
BEGIN
    l_str := q'[begin :1 := dbms_lock.release(lockhandle => :2); end;]';
    execute immediate l_str using OUT l_release_retval, IN :lockhandle;

EXCEPTION
    WHEN OTHERS THEN
       NULL;
END;
/
-- end
EXEC DBMS_APPLICATION_INFO.SET_MODULE(module_name => NULL, action_name => NULL);
--Uday EXEC DBMS_APPLICATION_INFO.SET_CLIENT_INFO(client_info => '^^sqldx_prefix.');
--Uday @@sqldx.sql ^^license. ^^sqldx_output. ^^sql_id.
SET TERM ON ECHO OFF FEED 6 VER ON SHOW OFF HEA ON LIN 80 NEWP 1 PAGES 14 LONG 80 LONGC 80 SQLC MIX TAB ON TRIMS OFF TI OFF TIMI OFF ARRAY 15 NUMF "" SQLP SQL> SUF sql BLO . RECSEP WR APPI OFF SERVEROUT OFF AUTOT OFF;
PRO
SET DEF ON;
--Uday HOS zip -m &&files_prefix..zip &&sqldx_prefix.*
PRO
--Uday PRO SQLDX files have been added to &&files_prefix..zip
PRO
HOS unzip -l &&files_prefix..zip
CL COL;
UNDEF 1 2 method script mos_doc doc_ver doc_date doc_link bug_link input_parameter input_sql_id input_license unique_id sql_id signature signaturef license udump_path sqldx_prefix sqldx_output ebr_date;




